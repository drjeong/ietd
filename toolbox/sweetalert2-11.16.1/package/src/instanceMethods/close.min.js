import globalState,{restoreActiveElement}from"../globalState.js";import{removeKeydownHandler}from"../keydown-handler.js";import privateMethods from"../privateMethods.js";import privateProps from"../privateProps.js";import{unsetAriaHidden}from"../utils/aria.js";import{swalClasses}from"../utils/classes.js";import*as dom from"../utils/dom/index.js";import{undoIOSfix}from"../utils/iosFix.js";import{undoReplaceScrollbarWithPadding}from"../utils/scrollbar.js";import{isSafariOrIOS}from"../utils/iosFix.js";function removePopupAndResetState(instance,container,returnFocus,didClose){if(dom.isToast()){triggerDidCloseAndDispose(instance,didClose)}else{restoreActiveElement(returnFocus).then(()=>triggerDidCloseAndDispose(instance,didClose));removeKeydownHandler(globalState)}if(isSafariOrIOS){container.setAttribute("style","display:none !important");container.removeAttribute("class");container.innerHTML=""}else{container.remove()}if(dom.isModal()){undoReplaceScrollbarWithPadding();undoIOSfix();unsetAriaHidden()}removeBodyClasses()}function removeBodyClasses(){dom.removeClass([document.documentElement,document.body],[swalClasses.shown,swalClasses["height-auto"],swalClasses["no-backdrop"],swalClasses["toast-shown"]])}export function close(resolveValue){resolveValue=prepareResolveValue(resolveValue);const swalPromiseResolve=privateMethods.swalPromiseResolve.get(this);const didClose=triggerClosePopup(this);if(this.isAwaitingPromise){if(!resolveValue.isDismissed){handleAwaitingPromise(this);swalPromiseResolve(resolveValue)}}else if(didClose){swalPromiseResolve(resolveValue)}}const triggerClosePopup=instance=>{const popup=dom.getPopup();if(!popup){return false}const innerParams=privateProps.innerParams.get(instance);if(!innerParams||dom.hasClass(popup,innerParams.hideClass.popup)){return false}dom.removeClass(popup,innerParams.showClass.popup);dom.addClass(popup,innerParams.hideClass.popup);const backdrop=dom.getContainer();dom.removeClass(backdrop,innerParams.showClass.backdrop);dom.addClass(backdrop,innerParams.hideClass.backdrop);handlePopupAnimation(instance,popup,innerParams);return true};export function rejectPromise(error){const rejectPromise=privateMethods.swalPromiseReject.get(this);handleAwaitingPromise(this);if(rejectPromise){rejectPromise(error)}}export const handleAwaitingPromise=instance=>{if(instance.isAwaitingPromise){delete instance.isAwaitingPromise;if(!privateProps.innerParams.get(instance)){instance._destroy()}}};const prepareResolveValue=resolveValue=>{if(typeof resolveValue==="undefined"){return{isConfirmed:false,isDenied:false,isDismissed:true}}return Object.assign({isConfirmed:false,isDenied:false,isDismissed:false},resolveValue)};const handlePopupAnimation=(instance,popup,innerParams)=>{const container=dom.getContainer();const animationIsSupported=dom.hasCssAnimation(popup);if(typeof innerParams.willClose==="function"){innerParams.willClose(popup)}globalState.eventEmitter?.emit("willClose",popup);if(animationIsSupported){animatePopup(instance,popup,container,innerParams.returnFocus,innerParams.didClose)}else{removePopupAndResetState(instance,container,innerParams.returnFocus,innerParams.didClose)}};const animatePopup=(instance,popup,container,returnFocus,didClose)=>{globalState.swalCloseEventFinishedCallback=removePopupAndResetState.bind(null,instance,container,returnFocus,didClose);const swalCloseAnimationFinished=function(e){if(e.target===popup){globalState.swalCloseEventFinishedCallback?.();delete globalState.swalCloseEventFinishedCallback;popup.removeEventListener("animationend",swalCloseAnimationFinished);popup.removeEventListener("transitionend",swalCloseAnimationFinished)}};popup.addEventListener("animationend",swalCloseAnimationFinished);popup.addEventListener("transitionend",swalCloseAnimationFinished)};const triggerDidCloseAndDispose=(instance,didClose)=>{setTimeout(()=>{if(typeof didClose==="function"){didClose.bind(instance.params)()}globalState.eventEmitter?.emit("didClose");if(instance._destroy){instance._destroy()}})};export{close as closePopup,close as closeModal,close as closeToast};