(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")root["_Highcharts"]=factory(),module.exports=root["_Highcharts"];else if(typeof define==="function"&&define.amd)define("highcharts/highcharts",[],factory);else if(typeof exports==="object")root["_Highcharts"]=factory(),exports["highcharts"]=root["_Highcharts"];else root["Highcharts"]&&root["Highcharts"].error(16,true),root["Highcharts"]=factory()})(typeof window==="undefined"?this:window,()=>{return(()=>{"use strict";var __webpack_require__={};(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>standalone_navigator_src});var Globals;(function(Globals){Globals.SVG_NS="http://www.w3.org/2000/svg",Globals.product="Highcharts",Globals.version="12.0.2",Globals.win=typeof window!=="undefined"?window:{},Globals.doc=Globals.win.document,Globals.svg=Globals.doc&&Globals.doc.createElementNS&&!!Globals.doc.createElementNS(Globals.SVG_NS,"svg").createSVGRect,Globals.userAgent=Globals.win.navigator&&Globals.win.navigator.userAgent||"",Globals.isChrome=Globals.win.chrome,Globals.isFirefox=Globals.userAgent.indexOf("Firefox")!==-1,Globals.isMS=/(edge|msie|trident)/i.test(Globals.userAgent)&&!Globals.win.opera,Globals.isSafari=!Globals.isChrome&&Globals.userAgent.indexOf("Safari")!==-1,Globals.isTouchDevice=/(Mobile|Android|Windows Phone)/.test(Globals.userAgent),Globals.isWebKit=Globals.userAgent.indexOf("AppleWebKit")!==-1,Globals.deg2rad=Math.PI*2/360,Globals.marginNames=["plotTop","marginRight","marginBottom","plotLeft"],Globals.noop=function(){},Globals.supportsPassiveEvents=function(){let supportsPassive=false;if(!Globals.isMS){const opts=Object.defineProperty({},"passive",{get:function(){supportsPassive=true}});if(Globals.win.addEventListener&&Globals.win.removeEventListener){Globals.win.addEventListener("testPassive",Globals.noop,opts);Globals.win.removeEventListener("testPassive",Globals.noop,opts)}}return supportsPassive}();Globals.charts=[];Globals.composed=[];Globals.dateFormats={};Globals.seriesTypes={};Globals.symbolSizes={};Globals.chartCount=0})(Globals||(Globals={}));const Core_Globals=Globals;"";const{charts,doc,win}=Core_Globals;function error(code,stop,chart,params){const severity=stop?"Highcharts error":"Highcharts warning";if(code===32){code=`${severity}: Deprecated member`}const isCode=isNumber(code);let message=isCode?`${severity} #${code}: www.highcharts.com/errors/${code}/`:code.toString();const defaultHandler=function(){if(stop){throw new Error(message)}if(win.console&&error.messages.indexOf(message)===-1){console.warn(message)}};if(typeof params!=="undefined"){let additionalMessages="";if(isCode){message+="?"}objectEach(params,function(value,key){additionalMessages+=`\n - ${key}: ${value}`;if(isCode){message+=encodeURI(key)+"="+encodeURI(value)}});message+=additionalMessages}fireEvent(Core_Globals,"displayError",{chart:chart,code:code,message:message,params:params},defaultHandler);error.messages.push(message)}(function(error){error.messages=[]})(error||(error={}));function merge(extendOrSource,...sources){let i,args=[extendOrSource,...sources],ret={};const doCopy=function(copy,original){if(typeof copy!=="object"){copy={}}objectEach(original,function(value,key){if(key==="__proto__"||key==="constructor"){return}if(isObject(value,true)&&!isClass(value)&&!isDOMElement(value)){copy[key]=doCopy(copy[key]||{},value)}else{copy[key]=original[key]}});return copy};if(extendOrSource===true){ret=args[1];args=Array.prototype.slice.call(args,2)}const len=args.length;for(i=0;i<len;i++){ret=doCopy(ret,args[i])}return ret}function clamp(value,min,max){return value>min?value<max?value:max:min}function crisp(value,lineWidth=0,inverted){const mod=lineWidth%2/2,inverter=inverted?-1:1;return(Math.round(value*inverter-mod)+mod)*inverter}function diffObjects(newer,older,keepOlder,collectionsWithUpdate){const ret={};function diff(newer,older,ret,depth){const keeper=keepOlder?older:newer;objectEach(newer,function(newerVal,key){if(!depth&&collectionsWithUpdate&&collectionsWithUpdate.indexOf(key)>-1&&older[key]){newerVal=splat(newerVal);ret[key]=[];for(let i=0;i<Math.max(newerVal.length,older[key].length);i++){if(older[key][i]){if(newerVal[i]===void 0){ret[key][i]=older[key][i]}else{ret[key][i]={};diff(newerVal[i],older[key][i],ret[key][i],depth+1)}}}}else if(isObject(newerVal,true)&&!newerVal.nodeType){ret[key]=isArray(newerVal)?[]:{};diff(newerVal,older[key]||{},ret[key],depth+1);if(Object.keys(ret[key]).length===0&&!(key==="colorAxis"&&depth===0)){delete ret[key]}}else if(newer[key]!==older[key]||key in newer&&!(key in older)){if(key!=="__proto__"&&key!=="constructor"){ret[key]=keeper[key]}}})}diff(newer,older,ret,0);return ret}function pInt(s,mag){return parseInt(s,mag||10)}function isString(s){return typeof s==="string"}function isArray(obj){const str=Object.prototype.toString.call(obj);return str==="[object Array]"||str==="[object Array Iterator]"}function isObject(obj,strict){return!!obj&&typeof obj==="object"&&(!strict||!isArray(obj))}function isDOMElement(obj){return isObject(obj)&&typeof obj.nodeType==="number"}function isClass(obj){const c=obj&&obj.constructor;return!!(isObject(obj,true)&&!isDOMElement(obj)&&(c&&c.name&&c.name!=="Object"))}function isNumber(n){return typeof n==="number"&&!isNaN(n)&&n<Infinity&&n>-Infinity}function erase(arr,item){let i=arr.length;while(i--){if(arr[i]===item){arr.splice(i,1);break}}}function insertItem(item,collection){const indexOption=item.options.index,length=collection.length;let i;for(i=item.options.isInternal?length:0;i<length+1;i++){if(!collection[i]||isNumber(indexOption)&&indexOption<pick(collection[i].options.index,collection[i]._i)||collection[i].options.isInternal){collection.splice(i,0,item);break}}return i}function pushUnique(array,item){return array.indexOf(item)<0&&!!array.push(item)}function defined(obj){return typeof obj!=="undefined"&&obj!==null}function attr(elem,keyOrAttribs,value){const isGetter=isString(keyOrAttribs)&&!defined(value);let ret;const attrSingle=(value,key)=>{if(defined(value)){elem.setAttribute(key,value)}else if(isGetter){ret=elem.getAttribute(key);if(!ret&&key==="class"){ret=elem.getAttribute(key+"Name")}}else{elem.removeAttribute(key)}};if(isString(keyOrAttribs)){attrSingle(value,keyOrAttribs)}else{objectEach(keyOrAttribs,attrSingle)}return ret}function splat(obj){return isArray(obj)?obj:[obj]}function syncTimeout(fn,delay,context){if(delay>0){return setTimeout(fn,delay,context)}fn.call(0,context);return-1}function internalClearTimeout(id){if(defined(id)){clearTimeout(id)}}function extend(a,b){let n;if(!a){a={}}for(n in b){a[n]=b[n]}return a}function pick(){const args=arguments;const length=args.length;for(let i=0;i<length;i++){const arg=args[i];if(typeof arg!=="undefined"&&arg!==null){return arg}}}function css(el,styles){extend(el.style,styles)}function createElement(tag,attribs,styles,parent,nopad){const el=doc.createElement(tag);if(attribs){extend(el,attribs)}if(nopad){css(el,{padding:"0",border:"none",margin:"0"})}if(styles){css(el,styles)}if(parent){parent.appendChild(el)}return el}function extendClass(parent,members){const obj=function(){};obj.prototype=new parent;extend(obj.prototype,members);return obj}function pad(number,length,padder){return new Array((length||2)+1-String(number).replace("-","").length).join(padder||"0")+number}function relativeLength(value,base,offset){return/%$/.test(value)?base*parseFloat(value)/100+(offset||0):parseFloat(value)}function replaceNested(text,...replacements){let previous,replacement;do{previous=text;for(replacement of replacements){text=text.replace(replacement[0],replacement[1])}}while(text!==previous);return text}function wrap(obj,method,func){const proceed=obj[method];obj[method]=function(){const outerArgs=arguments,scope=this;return func.apply(this,[function(){return proceed.apply(scope,arguments.length?arguments:outerArgs)}].concat([].slice.call(arguments)))}}function getMagnitude(num){return Math.pow(10,Math.floor(Math.log(num)/Math.LN10))}function normalizeTickInterval(interval,multiples,magnitude,allowDecimals,hasTickAmount){let i,retInterval=interval;magnitude=pick(magnitude,getMagnitude(interval));const normalized=interval/magnitude;if(!multiples){multiples=hasTickAmount?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10];if(allowDecimals===false){if(magnitude===1){multiples=multiples.filter(function(num){return num%1===0})}else if(magnitude<=.1){multiples=[1/magnitude]}}}for(i=0;i<multiples.length;i++){retInterval=multiples[i];if(hasTickAmount&&retInterval*magnitude>=interval||!hasTickAmount&&normalized<=(multiples[i]+(multiples[i+1]||multiples[i]))/2){break}}retInterval=correctFloat(retInterval*magnitude,-Math.round(Math.log(.001)/Math.LN10));return retInterval}function stableSort(arr,sortFunction){const length=arr.length;let sortValue,i;for(i=0;i<length;i++){arr[i].safeI=i}arr.sort(function(a,b){sortValue=sortFunction(a,b);return sortValue===0?a.safeI-b.safeI:sortValue});for(i=0;i<length;i++){delete arr[i].safeI}}function arrayMin(data){let i=data.length,min=data[0];while(i--){if(data[i]<min){min=data[i]}}return min}function arrayMax(data){let i=data.length,max=data[0];while(i--){if(data[i]>max){max=data[i]}}return max}function destroyObjectProperties(obj,except,destructablesOnly){objectEach(obj,function(val,n){if(val!==except&&val?.destroy){val.destroy()}if(val?.destroy||!destructablesOnly){delete obj[n]}})}function discardElement(element){if(element&&element.parentElement){element.parentElement.removeChild(element)}}function correctFloat(num,prec){return num>1e14?num:parseFloat(num.toPrecision(prec||14))}const timeUnits={millisecond:1,second:1e3,minute:6e4,hour:36e5,day:24*36e5,week:7*24*36e5,month:28*24*36e5,year:364*24*36e5};Math.easeInOutSine=function(pos){return-.5*(Math.cos(Math.PI*pos)-1)};const getAlignFactor=(align="")=>({center:.5,right:1,middle:.5,bottom:1})[align]||0;function getClosestDistance(arrays,onError){const allowNegative=!onError;let closest,loopLength,distance,i;arrays.forEach(xData=>{if(xData.length>1){loopLength=xData.length-1;for(i=loopLength;i>0;i--){distance=xData[i]-xData[i-1];if(distance<0&&!allowNegative){onError?.();onError=void 0}else if(distance&&(typeof closest==="undefined"||distance<closest)){closest=distance}}}});return closest}function getNestedProperty(path,parent){const pathElements=path.split(".");while(pathElements.length&&defined(parent)){const pathElement=pathElements.shift();if(typeof pathElement==="undefined"||pathElement==="__proto__"){return}if(pathElement==="this"){let thisProp;if(isObject(parent)){thisProp=parent["@this"]}return thisProp??parent}const child=parent[pathElement];if(!defined(child)||typeof child==="function"||typeof child.nodeType==="number"||child===win){return}parent=child}return parent}function getStyle(el,prop,toInt){let style;if(prop==="width"){let offsetWidth=Math.min(el.offsetWidth,el.scrollWidth);const boundingClientRectWidth=el.getBoundingClientRect&&el.getBoundingClientRect().width;if(boundingClientRectWidth<offsetWidth&&boundingClientRectWidth>=offsetWidth-1){offsetWidth=Math.floor(boundingClientRectWidth)}return Math.max(0,offsetWidth-(getStyle(el,"padding-left",true)||0)-(getStyle(el,"padding-right",true)||0))}if(prop==="height"){return Math.max(0,Math.min(el.offsetHeight,el.scrollHeight)-(getStyle(el,"padding-top",true)||0)-(getStyle(el,"padding-bottom",true)||0))}const css=win.getComputedStyle(el,void 0);if(css){style=css.getPropertyValue(prop);if(pick(toInt,prop!=="opacity")){style=pInt(style)}}return style}const find=Array.prototype.find?function(arr,callback){return arr.find(callback)}:function(arr,callback){let i;const length=arr.length;for(i=0;i<length;i++){if(callback(arr[i],i)){return arr[i]}}};function offset(el){const docElem=doc.documentElement,box=el.parentElement||el.parentNode?el.getBoundingClientRect():{top:0,left:0,width:0,height:0};return{top:box.top+(win.pageYOffset||docElem.scrollTop)-(docElem.clientTop||0),left:box.left+(win.pageXOffset||docElem.scrollLeft)-(docElem.clientLeft||0),width:box.width,height:box.height}}function objectEach(obj,fn,ctx){for(const key in obj){if(Object.hasOwnProperty.call(obj,key)){fn.call(ctx||obj[key],obj[key],key,obj)}}}function addEvent(el,type,fn,options={}){const owner=typeof el==="function"&&el.prototype||el;if(!Object.hasOwnProperty.call(owner,"hcEvents")){owner.hcEvents={}}const events=owner.hcEvents;if(Core_Globals.Point&&el instanceof Core_Globals.Point&&el.series&&el.series.chart){el.series.chart.runTrackerClick=true}const addEventListener=el.addEventListener;if(addEventListener){addEventListener.call(el,type,fn,Core_Globals.supportsPassiveEvents?{passive:options.passive===void 0?type.indexOf("touch")!==-1:options.passive,capture:false}:false)}if(!events[type]){events[type]=[]}const eventObject={fn:fn,order:typeof options.order==="number"?options.order:Infinity};events[type].push(eventObject);events[type].sort((a,b)=>a.order-b.order);return function(){removeEvent(el,type,fn)}}function removeEvent(el,type,fn){function removeOneEvent(type,fn){const removeEventListener=el.removeEventListener;if(removeEventListener){removeEventListener.call(el,type,fn,false)}}function removeAllEvents(eventCollection){let types,len;if(!el.nodeName){return}if(type){types={};types[type]=true}else{types=eventCollection}objectEach(types,function(_val,n){if(eventCollection[n]){len=eventCollection[n].length;while(len--){removeOneEvent(n,eventCollection[n][len].fn)}}})}const owner=typeof el==="function"&&el.prototype||el;if(Object.hasOwnProperty.call(owner,"hcEvents")){const events=owner.hcEvents;if(type){const typeEvents=events[type]||[];if(fn){events[type]=typeEvents.filter(function(obj){return fn!==obj.fn});removeOneEvent(type,fn)}else{removeAllEvents(events);events[type]=[]}}else{removeAllEvents(events);delete owner.hcEvents}}}function fireEvent(el,type,eventArguments,defaultFunction){eventArguments=eventArguments||{};if(doc.createEvent&&(el.dispatchEvent||el.fireEvent&&el!==Core_Globals)){const e=doc.createEvent("Events");e.initEvent(type,true,true);eventArguments=extend(e,eventArguments);if(el.dispatchEvent){el.dispatchEvent(eventArguments)}else{el.fireEvent(type,eventArguments)}}else if(el.hcEvents){if(!eventArguments.target){extend(eventArguments,{preventDefault:function(){eventArguments.defaultPrevented=true},target:el,type:type})}const events=[];let object=el;let multilevel=false;while(object.hcEvents){if(Object.hasOwnProperty.call(object,"hcEvents")&&object.hcEvents[type]){if(events.length){multilevel=true}events.unshift.apply(events,object.hcEvents[type])}object=Object.getPrototypeOf(object)}if(multilevel){events.sort((a,b)=>a.order-b.order)}events.forEach(obj=>{if(obj.fn.call(el,eventArguments)===false){eventArguments.preventDefault()}})}if(defaultFunction&&!eventArguments.defaultPrevented){defaultFunction.call(el,eventArguments)}}let serialMode;const uniqueKey=function(){const hash=Math.random().toString(36).substring(2,9)+"-";let id=0;return function(){return"highcharts-"+(serialMode?"":hash)+id++}}();function useSerialIds(mode){return serialMode=pick(mode,serialMode)}function isFunction(obj){return typeof obj==="function"}function ucfirst(s){return isString(s)?s.substring(0,1).toUpperCase()+s.substring(1):String(s)}if(win.jQuery){win.jQuery.fn.highcharts=function(){const args=[].slice.call(arguments);if(this[0]){if(args[0]){new Core_Globals[isString(args[0])?args.shift():"Chart"](this[0],args[0],args[1]);return this}return charts[attr(this[0],"data-highcharts-chart")]}}}const Utilities={addEvent:addEvent,arrayMax:arrayMax,arrayMin:arrayMin,attr:attr,clamp:clamp,clearTimeout:internalClearTimeout,correctFloat:correctFloat,createElement:createElement,crisp:crisp,css:css,defined:defined,destroyObjectProperties:destroyObjectProperties,diffObjects:diffObjects,discardElement:discardElement,erase:erase,error:error,extend:extend,extendClass:extendClass,find:find,fireEvent:fireEvent,getAlignFactor:getAlignFactor,getClosestDistance:getClosestDistance,getMagnitude:getMagnitude,getNestedProperty:getNestedProperty,getStyle:getStyle,insertItem:insertItem,isArray:isArray,isClass:isClass,isDOMElement:isDOMElement,isFunction:isFunction,isNumber:isNumber,isObject:isObject,isString:isString,merge:merge,normalizeTickInterval:normalizeTickInterval,objectEach:objectEach,offset:offset,pad:pad,pick:pick,pInt:pInt,pushUnique:pushUnique,relativeLength:relativeLength,removeEvent:removeEvent,replaceNested:replaceNested,splat:splat,stableSort:stableSort,syncTimeout:syncTimeout,timeUnits:timeUnits,ucfirst:ucfirst,uniqueKey:uniqueKey,useSerialIds:useSerialIds,wrap:wrap};const Core_Utilities=Utilities;"";const ChartDefaults={alignThresholds:false,panning:{enabled:false,type:"x"},styledMode:false,borderRadius:0,colorCount:10,allowMutatingData:true,ignoreHiddenSeries:true,spacing:[10,10,15,10],resetZoomButton:{theme:{},position:{}},reflow:true,type:"line",zooming:{singleTouch:false,resetButton:{theme:{zIndex:6},position:{align:"right",x:-10,y:10}}},width:null,height:null,borderColor:"#334eff",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"};const Chart_ChartDefaults=ChartDefaults;const SeriesPalettes={colors:["#2caffe","#544fc5","#00e272","#fe6a35","#6b8abc","#d568fb","#2ee0ca","#fa4b42","#feb56a","#91e8e1"]};const Palettes=SeriesPalettes;const{win:Time_win}=Core_Globals;const{defined:Time_defined,error:Time_error,extend:Time_extend,isNumber:Time_isNumber,isObject:Time_isObject,isString:Time_isString,merge:Time_merge,objectEach:Time_objectEach,pad:Time_pad,splat:Time_splat,timeUnits:Time_timeUnits,ucfirst:Time_ucfirst}=Core_Utilities;const hasOldSafariBug=Core_Globals.isSafari&&Time_win.Intl&&!Time_win.Intl.DateTimeFormat.prototype.formatRange;const isDateTimeFormatOptions=obj=>obj.main===void 0;const spanishWeekdayIndex=weekday=>["D","L","M","X","J","V","S"].indexOf(weekday);class Time{constructor(options){this.options={};this.variableTimezone=false;this.Date=Time_win.Date;this.update(options)}update(options={}){let timezone=options.timezone??"UTC";this.dTLCache={};this.options=options=Time_merge(true,this.options,options);const{timezoneOffset,useUTC}=options;this.Date=options.Date||Time_win.Date||Date;if(Time_defined(useUTC)){timezone=useUTC?"UTC":void 0}if(timezoneOffset&&timezoneOffset%60===0){timezone="Etc/GMT"+(timezoneOffset>0?"+":"")+timezoneOffset/60}this.variableTimezone=timezone!=="UTC"&&timezone?.indexOf("Etc/GMT")!==0;this.timezone=timezone;["months","shortMonths","weekdays","shortWeekdays"].forEach(name=>{const isMonth=/months/i.test(name),isShort=/short/.test(name),options={timeZone:"UTC"};options[isMonth?"month":"weekday"]=isShort?"short":"long";this[name]=(isMonth?[0,1,2,3,4,5,6,7,8,9,10,11]:[3,4,5,6,7,8,9]).map(position=>this.dateFormat(options,(isMonth?31:1)*24*36e5*position))})}toParts(timestamp){const[weekday,dayOfMonth,month,year,hours,minutes,seconds]=this.dateTimeFormat({weekday:"narrow",day:"numeric",month:"numeric",year:"numeric",hour:"numeric",minute:"numeric",second:"numeric"},timestamp,"es").split(/(?:, |\/|:)/g);return[year,+month-1,dayOfMonth,hours,minutes,seconds,Math.floor(Number(timestamp)||0)%1e3,spanishWeekdayIndex(weekday)].map(Number)}dateTimeFormat(options,timestamp,locale=this.options.locale){const cacheKey=JSON.stringify(options)+locale;if(Time_isString(options)){options=this.str2dtf(options)}let dTL=this.dTLCache[cacheKey];if(!dTL){options.timeZone??(options.timeZone=this.timezone);try{dTL=new Intl.DateTimeFormat(locale,options)}catch(e){if(/Invalid time zone/i.test(e.message)){Time_error(34);options.timeZone="UTC";dTL=new Intl.DateTimeFormat(locale,options)}else{Time_error(e.message,false)}}}this.dTLCache[cacheKey]=dTL;return dTL?.format(timestamp)||""}str2dtf(s,dtf={}){const mapping={L:{fractionalSecondDigits:3},S:{second:"2-digit"},M:{minute:"numeric"},H:{hour:"2-digit"},k:{hour:"numeric"},E:{weekday:"narrow"},a:{weekday:"short"},A:{weekday:"long"},d:{day:"2-digit"},e:{day:"numeric"},b:{month:"short"},B:{month:"long"},m:{month:"2-digit"},o:{month:"numeric"},y:{year:"2-digit"},Y:{year:"numeric"}};Object.keys(mapping).forEach(key=>{if(s.indexOf(key)!==-1){Time_extend(dtf,mapping[key])}});return dtf}makeTime(year,month,date=1,hours=0,minutes,seconds,milliseconds){let d=this.Date.UTC(year,month,date,hours,minutes||0,seconds||0,milliseconds||0);if(this.timezone!=="UTC"){const offset=this.getTimezoneOffset(d);d+=offset;if([2,3,8,9,10,11].indexOf(month)!==-1&&(hours<5||hours>20)){const newOffset=this.getTimezoneOffset(d);if(offset!==newOffset){d+=newOffset-offset}else if(offset-36e5===this.getTimezoneOffset(d-36e5)&&!hasOldSafariBug){d-=36e5}}}return d}parse(s){if(!Time_isString(s)){return s??void 0}s=s.replace(/\//g,"-").replace(/(GMT|UTC)/,"");const hasTimezone=s.indexOf("Z")>-1||/([+-][0-9]{2}):?[0-9]{2}$/.test(s),isYYYYMMDD=/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(s);if(!hasTimezone&&!isYYYYMMDD){s+="Z"}const ts=Date.parse(s);if(Time_isNumber(ts)){return ts+(!hasTimezone||isYYYYMMDD?this.getTimezoneOffset(ts):0)}}getTimezoneOffset(timestamp){if(this.timezone!=="UTC"){const[date,gmt,hours,colon,minutes=0]=this.dateTimeFormat({timeZoneName:"shortOffset"},timestamp,"en").split(/(GMT|:)/).map(Number),offset=-(hours+minutes/60)*60*6e4;if(Time_isNumber(offset)){return offset}}return 0}dateFormat(format,timestamp,upperCaseFirst){const lang=Core_Globals.defaultOptions?.lang;if(!Time_defined(timestamp)||isNaN(timestamp)){return lang?.invalidDate||""}format=format??"%Y-%m-%d %H:%M:%S";if(Time_isString(format)){const localeAwareRegex=/%\[([a-zA-Z]+)\]/g;let match;while(match=localeAwareRegex.exec(format)){format=format.replace(match[0],this.dateTimeFormat(match[1],timestamp))}}if(Time_isString(format)&&format.indexOf("%")!==-1){const time=this,[fullYear,month,dayOfMonth,hours,minutes,seconds,milliseconds,weekday]=this.toParts(timestamp),langWeekdays=lang?.weekdays||this.weekdays,shortWeekdays=lang?.shortWeekdays||this.shortWeekdays,months=lang?.months||this.months,shortMonths=lang?.shortMonths||this.shortMonths,replacements=Time_extend({a:shortWeekdays?shortWeekdays[weekday]:langWeekdays[weekday].substr(0,3),A:langWeekdays[weekday],d:Time_pad(dayOfMonth),e:Time_pad(dayOfMonth,2," "),w:weekday,b:shortMonths[month],B:months[month],m:Time_pad(month+1),o:month+1,y:fullYear.toString().substr(2,2),Y:fullYear,H:Time_pad(hours),k:hours,I:Time_pad(hours%12||12),l:hours%12||12,M:Time_pad(minutes),p:hours<12?"AM":"PM",P:hours<12?"am":"pm",S:Time_pad(seconds),L:Time_pad(milliseconds,3)},Core_Globals.dateFormats);Time_objectEach(replacements,function(val,key){if(Time_isString(format)){while(format.indexOf("%"+key)!==-1){format=format.replace("%"+key,typeof val==="function"?val.call(time,timestamp):val)}}})}else if(Time_isObject(format)){const tzHours=(this.getTimezoneOffset(timestamp)||0)/(6e4*60),timeZone=this.options.timezone||"Etc/GMT"+(tzHours>=0?"+":"")+tzHours,{prefix="",suffix=""}=format;format=prefix+this.dateTimeFormat(Time_extend({timeZone:timeZone},format),timestamp)+suffix}return upperCaseFirst?Time_ucfirst(format):format}resolveDTLFormat(f){if(!Time_isObject(f,true)){f=Time_splat(f);return{main:f[0],from:f[1],to:f[2]}}if(Time_isObject(f,true)&&isDateTimeFormatOptions(f)){return{main:f}}return f}getTimeTicks(normalizedInterval,min,max,startOfWeek){const time=this,tickPositions=[],higherRanks={},{count=1,unitRange}=normalizedInterval;let[year,month,dayOfMonth,hours,minutes,seconds]=time.toParts(min),milliseconds=(min||0)%1e3,variableDayLength;startOfWeek??(startOfWeek=1);if(Time_defined(min)){milliseconds=unitRange>=Time_timeUnits.second?0:count*Math.floor(milliseconds/count);if(unitRange>=Time_timeUnits.second){seconds=unitRange>=Time_timeUnits.minute?0:count*Math.floor(seconds/count)}if(unitRange>=Time_timeUnits.minute){minutes=unitRange>=Time_timeUnits.hour?0:count*Math.floor(minutes/count)}if(unitRange>=Time_timeUnits.hour){hours=unitRange>=Time_timeUnits.day?0:count*Math.floor(hours/count)}if(unitRange>=Time_timeUnits.day){dayOfMonth=unitRange>=Time_timeUnits.month?1:Math.max(1,count*Math.floor(dayOfMonth/count))}if(unitRange>=Time_timeUnits.month){month=unitRange>=Time_timeUnits.year?0:count*Math.floor(month/count)}if(unitRange>=Time_timeUnits.year){year-=year%count}if(unitRange===Time_timeUnits.week){if(count){min=time.makeTime(year,month,dayOfMonth,hours,minutes,seconds,milliseconds)}const weekday=this.dateTimeFormat({timeZone:this.timezone,weekday:"narrow"},min,"es"),weekdayNo=spanishWeekdayIndex(weekday);dayOfMonth+=-weekdayNo+startOfWeek+(weekdayNo<startOfWeek?-7:0)}min=time.makeTime(year,month,dayOfMonth,hours,minutes,seconds,milliseconds);if(time.variableTimezone&&Time_defined(max)){variableDayLength=max-min>4*Time_timeUnits.month||time.getTimezoneOffset(min)!==time.getTimezoneOffset(max)}let t=min,i=1;while(t<max){tickPositions.push(t);if(unitRange===Time_timeUnits.year){t=time.makeTime(year+i*count,0)}else if(unitRange===Time_timeUnits.month){t=time.makeTime(year,month+i*count)}else if(variableDayLength&&(unitRange===Time_timeUnits.day||unitRange===Time_timeUnits.week)){t=time.makeTime(year,month,dayOfMonth+i*count*(unitRange===Time_timeUnits.day?1:7))}else if(variableDayLength&&unitRange===Time_timeUnits.hour&&count>1){t=time.makeTime(year,month,dayOfMonth,hours+i*count)}else{t+=unitRange*count}i++}tickPositions.push(t);if(unitRange<=Time_timeUnits.hour&&tickPositions.length<1e4){tickPositions.forEach(t=>{if(t%18e5===0&&time.dateFormat("%H%M%S%L",t)==="000000000"){higherRanks[t]="day"}})}}tickPositions.info=Time_extend(normalizedInterval,{higherRanks:higherRanks,totalRange:unitRange*count});return tickPositions}getDateFormat(range,timestamp,startOfWeek,dateTimeLabelFormats){const dateStr=this.dateFormat("%m-%d %H:%M:%S.%L",timestamp),blank="01-01 00:00:00.000",strpos={millisecond:15,second:12,minute:9,hour:6,day:3};let n="millisecond",lastN=n;for(n in Time_timeUnits){if(range===Time_timeUnits.week&&+this.dateFormat("%w",timestamp)===startOfWeek&&dateStr.substr(6)===blank.substr(6)){n="week";break}if(Time_timeUnits[n]>range){n=lastN;break}if(strpos[n]&&dateStr.substr(strpos[n])!==blank.substr(strpos[n])){break}if(n!=="week"){lastN=n}}return this.resolveDTLFormat(dateTimeLabelFormats[n]).main}}const Core_Time=Time;"";const{isTouchDevice}=Core_Globals;const{fireEvent:Defaults_fireEvent,merge:Defaults_merge}=Core_Utilities;const defaultOptions={colors:Palettes.colors,symbols:["circle","diamond","square","triangle","triangle-down"],lang:{locale:void 0,loading:"Loading...",months:void 0,shortMonths:void 0,weekdays:void 0,numericSymbols:["k","M","G","T","P","E"],resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1"},global:{buttonTheme:{fill:"#f7f7f7",padding:8,r:2,stroke:"#cccccc","stroke-width":1,style:{color:"#333333",cursor:"pointer",fontSize:"0.8em",fontWeight:"normal"},states:{hover:{fill:"#e6e6e6"},select:{fill:"#e6e9ff",style:{color:"#000000",fontWeight:"bold"}},disabled:{style:{color:"#cccccc"}}}}},time:{Date:void 0,timezone:"UTC",timezoneOffset:0,useUTC:void 0},chart:Chart_ChartDefaults,title:{style:{color:"#333333",fontWeight:"bold"},text:"Chart title",margin:15,minScale:.67},subtitle:{style:{color:"#666666",fontSize:"0.8em"},text:""},caption:{margin:15,style:{color:"#666666",fontSize:"0.8em"},text:"",align:"left",verticalAlign:"bottom"},plotOptions:{},legend:{enabled:true,align:"center",alignColumns:true,className:"highcharts-no-tooltip",events:{},layout:"horizontal",itemMarginBottom:2,itemMarginTop:2,labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{style:{fontSize:"0.8em"},activeColor:"#0022ff",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",cursor:"pointer",fontSize:"0.8em",textDecoration:"none",textOverflow:"ellipsis"},itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#666666",textDecoration:"line-through"},shadow:false,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:true,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontSize:"0.8em",fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:true,animation:{duration:300,easing:x=>Math.sqrt(1-Math.pow(x-1,2))},borderRadius:3,dateTimeLabelFormats:{millisecond:"%[AebHMSL]",second:"%[AebHMS]",minute:"%[AebHM]",hour:"%[AebHM]",day:"%[AebY]",week:"Week from %[AebY]",month:"%[BY]",year:"%Y"},footerFormat:"",headerShape:"callout",hideDelay:500,padding:8,shape:"callout",shared:false,snap:isTouchDevice?25:10,headerFormat:'<span style="font-size: 0.8em">{ucfirst point.key}</span><br/>',pointFormat:'<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',backgroundColor:"#ffffff",borderWidth:void 0,shadow:true,stickOnContact:false,style:{color:"#333333",cursor:"default",fontSize:"0.8em"},useHTML:false},credits:{enabled:true,href:"https://www.highcharts.com?credits",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"0.6em"},text:"Highcharts.com"}};defaultOptions.chart.styledMode=true;defaultOptions.chart.styledMode=false;"";const defaultTime=new Core_Time(defaultOptions.time);function getOptions(){return defaultOptions}function setOptions(options){Defaults_fireEvent(Core_Globals,"setOptions",{options:options});Defaults_merge(true,defaultOptions,options);if(options.time){defaultTime.update(defaultOptions.time)}if(options.lang&&"locale"in options.lang){defaultTime.update({locale:options.lang.locale})}return defaultOptions}const DefaultOptions={defaultOptions:defaultOptions,defaultTime:defaultTime,getOptions:getOptions,setOptions:setOptions};const Defaults=DefaultOptions;"";const{isNumber:Color_isNumber,merge:Color_merge,pInt:Color_pInt,defined:Color_defined}=Core_Utilities;class Color{static parse(input){return input?new Color(input):Color.None}constructor(input){this.rgba=[NaN,NaN,NaN,NaN];this.input=input;const GlobalColor=Core_Globals.Color;if(GlobalColor&&GlobalColor!==Color){return new GlobalColor(input)}let result,rgba,i,parser;if(typeof input==="object"&&typeof input.stops!=="undefined"){this.stops=input.stops.map(stop=>new Color(stop[1]))}else if(typeof input==="string"){this.input=input=Color.names[input.toLowerCase()]||input;i=Color.parsers.length;while(i--&&!rgba){parser=Color.parsers[i];result=parser.regex.exec(input);if(result){rgba=parser.parse(result)}}}if(rgba){this.rgba=rgba}}get(format){const input=this.input,rgba=this.rgba;if(typeof input==="object"&&typeof this.stops!=="undefined"){const ret=Color_merge(input);ret.stops=[].slice.call(ret.stops);this.stops.forEach((stop,i)=>{ret.stops[i]=[ret.stops[i][0],stop.get(format)]});return ret}if(rgba&&Color_isNumber(rgba[0])){if(format==="rgb"||!format&&rgba[3]===1){return"rgb("+rgba[0]+","+rgba[1]+","+rgba[2]+")"}if(format==="a"){return`${rgba[3]}`}return"rgba("+rgba.join(",")+")"}return input}brighten(alpha){const rgba=this.rgba;if(this.stops){this.stops.forEach(function(stop){stop.brighten(alpha)})}else if(Color_isNumber(alpha)&&alpha!==0){for(let i=0;i<3;i++){rgba[i]+=Color_pInt(alpha*255);if(rgba[i]<0){rgba[i]=0}if(rgba[i]>255){rgba[i]=255}}}return this}setOpacity(alpha){this.rgba[3]=alpha;return this}tweenTo(to,pos){const fromRgba=this.rgba,toRgba=to.rgba;if(!Color_isNumber(fromRgba[0])||!Color_isNumber(toRgba[0])){return to.input||"none"}const hasAlpha=toRgba[3]!==1||fromRgba[3]!==1;return(hasAlpha?"rgba(":"rgb(")+Math.round(toRgba[0]+(fromRgba[0]-toRgba[0])*(1-pos))+","+Math.round(toRgba[1]+(fromRgba[1]-toRgba[1])*(1-pos))+","+Math.round(toRgba[2]+(fromRgba[2]-toRgba[2])*(1-pos))+(hasAlpha?","+(toRgba[3]+(fromRgba[3]-toRgba[3])*(1-pos)):"")+")"}}Color.names={white:"#ffffff",black:"#000000"};Color.parsers=[{regex:/rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,parse:function(result){return[Color_pInt(result[1]),Color_pInt(result[2]),Color_pInt(result[3]),parseFloat(result[4],10)]}},{regex:/rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,parse:function(result){return[Color_pInt(result[1]),Color_pInt(result[2]),Color_pInt(result[3]),1]}},{regex:/^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i,parse:function(result){return[Color_pInt(result[1]+result[1],16),Color_pInt(result[2]+result[2],16),Color_pInt(result[3]+result[3],16),!Color_defined(result[4])?1:Color_pInt(result[4]+result[4],16)/255]}},{regex:/^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i,parse:function(result){return[Color_pInt(result[1],16),Color_pInt(result[2],16),Color_pInt(result[3],16),!Color_defined(result[4])?1:Color_pInt(result[4],16)/255]}}];Color.None=new Color("");const Color_Color=Color;"";const{parse:color}=Color_Color;const{win:Fx_win}=Core_Globals;const{isNumber:Fx_isNumber,objectEach:Fx_objectEach}=Core_Utilities;class Fx{constructor(elem,options,prop){this.pos=NaN;this.options=options;this.elem=elem;this.prop=prop}dSetter(){const paths=this.paths,start=paths&&paths[0],end=paths&&paths[1],now=this.now||0;let path=[];if(now===1||!start||!end){path=this.toD||[]}else if(start.length===end.length&&now<1){for(let i=0;i<end.length;i++){const startSeg=start[i];const endSeg=end[i];const tweenSeg=[];for(let j=0;j<endSeg.length;j++){const startItem=startSeg[j];const endItem=endSeg[j];if(Fx_isNumber(startItem)&&Fx_isNumber(endItem)&&!(endSeg[0]==="A"&&(j===4||j===5))){tweenSeg[j]=startItem+now*(endItem-startItem)}else{tweenSeg[j]=endItem}}path.push(tweenSeg)}}else{path=end}this.elem.attr("d",path,void 0,true)}update(){const elem=this.elem,prop=this.prop,now=this.now,step=this.options.step;if(this[prop+"Setter"]){this[prop+"Setter"]()}else if(elem.attr){if(elem.element){elem.attr(prop,now,null,true)}}else{elem.style[prop]=now+this.unit}if(step){step.call(elem,now,this)}}run(from,to,unit){const self=this,options=self.options,timer=function(gotoEnd){return timer.stopped?false:self.step(gotoEnd)},requestAnimationFrame=Fx_win.requestAnimationFrame||function(step){setTimeout(step,13)},step=function(){for(let i=0;i<Fx.timers.length;i++){if(!Fx.timers[i]()){Fx.timers.splice(i--,1)}}if(Fx.timers.length){requestAnimationFrame(step)}};if(from===to&&!this.elem["forceAnimate:"+this.prop]){delete options.curAnim[this.prop];if(options.complete&&Object.keys(options.curAnim).length===0){options.complete.call(this.elem)}}else{this.startTime=+new Date;this.start=from;this.end=to;this.unit=unit;this.now=this.start;this.pos=0;timer.elem=this.elem;timer.prop=this.prop;if(timer()&&Fx.timers.push(timer)===1){requestAnimationFrame(step)}}}step(gotoEnd){const t=+new Date,options=this.options,elem=this.elem,complete=options.complete,duration=options.duration,curAnim=options.curAnim;let ret,done;if(!!elem.attr&&!elem.element){ret=false}else if(gotoEnd||t>=duration+this.startTime){this.now=this.end;this.pos=1;this.update();curAnim[this.prop]=true;done=true;Fx_objectEach(curAnim,function(val){if(val!==true){done=false}});if(done&&complete){complete.call(elem)}ret=false}else{this.pos=options.easing((t-this.startTime)/duration);this.now=this.start+(this.end-this.start)*this.pos;this.update();ret=true}return ret}initPath(elem,fromD,toD){const startX=elem.startX,endX=elem.endX,end=toD.slice(),isArea=elem.isArea,positionFactor=isArea?2:1,disableAnimation=fromD&&toD.length>fromD.length&&toD.hasStackedCliffs;let shift,fullLength,i,reverse,start=fromD&&fromD.slice();if(!start||disableAnimation){return[end,end]}function prepend(arr,other){while(arr.length<fullLength){const moveSegment=arr[0],otherSegment=other[fullLength-arr.length];if(otherSegment&&moveSegment[0]==="M"){if(otherSegment[0]==="C"){arr[0]=["C",moveSegment[1],moveSegment[2],moveSegment[1],moveSegment[2],moveSegment[1],moveSegment[2]]}else{arr[0]=["L",moveSegment[1],moveSegment[2]]}}arr.unshift(moveSegment);if(isArea){const z=arr.pop();arr.push(arr[arr.length-1],z)}}}function append(arr){while(arr.length<fullLength){const segmentToAdd=arr[Math.floor(arr.length/positionFactor)-1].slice();if(segmentToAdd[0]==="C"){segmentToAdd[1]=segmentToAdd[5];segmentToAdd[2]=segmentToAdd[6]}if(!isArea){arr.push(segmentToAdd)}else{const lowerSegmentToAdd=arr[Math.floor(arr.length/positionFactor)].slice();arr.splice(arr.length/2,0,segmentToAdd,lowerSegmentToAdd)}}}if(startX&&endX&&endX.length){for(i=0;i<startX.length;i++){if(startX[i]===endX[0]){shift=i;break}else if(startX[0]===endX[endX.length-startX.length+i]){shift=i;reverse=true;break}else if(startX[startX.length-1]===endX[endX.length-startX.length+i]){shift=startX.length-i;break}}if(typeof shift==="undefined"){start=[]}}if(start.length&&Fx_isNumber(shift)){fullLength=end.length+shift*positionFactor;if(!reverse){prepend(end,start);append(start)}else{prepend(start,end);append(end)}}return[start,end]}fillSetter(){Fx.prototype.strokeSetter.apply(this,arguments)}strokeSetter(){this.elem.attr(this.prop,color(this.start).tweenTo(color(this.end),this.pos),void 0,true)}}Fx.timers=[];const Animation_Fx=Fx;const{defined:AnimationUtilities_defined,getStyle:AnimationUtilities_getStyle,isArray:AnimationUtilities_isArray,isNumber:AnimationUtilities_isNumber,isObject:AnimationUtilities_isObject,merge:AnimationUtilities_merge,objectEach:AnimationUtilities_objectEach,pick:AnimationUtilities_pick}=Core_Utilities;function setAnimation(animation,chart){chart.renderer.globalAnimation=AnimationUtilities_pick(animation,chart.options.chart.animation,true)}function animObject(animation){return AnimationUtilities_isObject(animation)?AnimationUtilities_merge({duration:500,defer:0},animation):{duration:animation?500:0,defer:0}}function getDeferredAnimation(chart,animation,series){const labelAnimation=animObject(animation),s=series?[series]:chart.series;let defer=0,duration=0;s.forEach(series=>{const seriesAnim=animObject(series.options.animation);defer=AnimationUtilities_isObject(animation)&&AnimationUtilities_defined(animation.defer)?labelAnimation.defer:Math.max(defer,seriesAnim.duration+seriesAnim.defer);duration=Math.min(labelAnimation.duration,seriesAnim.duration)});if(chart.renderer.forExport){defer=0}const anim={defer:Math.max(0,defer-duration),duration:Math.min(defer,duration)};return anim}function animate(el,params,opt){let start,unit="",end,fx,args;if(!AnimationUtilities_isObject(opt)){args=arguments;opt={duration:args[2],easing:args[3],complete:args[4]}}if(!AnimationUtilities_isNumber(opt.duration)){opt.duration=400}opt.easing=typeof opt.easing==="function"?opt.easing:Math[opt.easing]||Math.easeInOutSine;opt.curAnim=AnimationUtilities_merge(params);AnimationUtilities_objectEach(params,function(val,prop){stop(el,prop);fx=new Animation_Fx(el,opt,prop);end=void 0;if(prop==="d"&&AnimationUtilities_isArray(params.d)){fx.paths=fx.initPath(el,el.pathArray,params.d);fx.toD=params.d;start=0;end=1}else if(el.attr){start=el.attr(prop)}else{start=parseFloat(AnimationUtilities_getStyle(el,prop))||0;if(prop!=="opacity"){unit="px"}}if(!end){end=val}if(typeof end==="string"&&end.match("px")){end=end.replace(/px/g,"")}fx.run(start,end,unit)})}function stop(el,prop){let i=Animation_Fx.timers.length;while(i--){if(Animation_Fx.timers[i].elem===el&&(!prop||prop===Animation_Fx.timers[i].prop)){Animation_Fx.timers[i].stopped=true}}}const animationExports={animate:animate,animObject:animObject,getDeferredAnimation:getDeferredAnimation,setAnimation:setAnimation,stop:stop};const AnimationUtilities=animationExports;const{SVG_NS,win:AST_win}=Core_Globals;const{attr:AST_attr,createElement:AST_createElement,css:AST_css,error:AST_error,isFunction:AST_isFunction,isString:AST_isString,objectEach:AST_objectEach,splat:AST_splat}=Core_Utilities;const{trustedTypes}=AST_win;const trustedTypesPolicy=trustedTypes&&AST_isFunction(trustedTypes.createPolicy)&&trustedTypes.createPolicy("highcharts",{createHTML:s=>s});const emptyHTML=trustedTypesPolicy?trustedTypesPolicy.createHTML(""):"";class AST{static filterUserAttributes(attributes){AST_objectEach(attributes,(val,key)=>{let valid=true;if(AST.allowedAttributes.indexOf(key)===-1){valid=false}if(["background","dynsrc","href","lowsrc","src"].indexOf(key)!==-1){valid=AST_isString(val)&&AST.allowedReferences.some(ref=>val.indexOf(ref)===0)}if(!valid){AST_error(33,false,void 0,{"Invalid attribute in config":`${key}`});delete attributes[key]}if(AST_isString(val)&&attributes[key]){attributes[key]=val.replace(/</g,"&lt;")}});return attributes}static parseStyle(style){return style.split(";").reduce((styles,line)=>{const pair=line.split(":").map(s=>s.trim()),key=pair.shift();if(key&&pair.length){styles[key.replace(/-([a-z])/g,g=>g[1].toUpperCase())]=pair.join(":")}return styles},{})}static setElementHTML(el,html){el.innerHTML=AST.emptyHTML;if(html){const ast=new AST(html);ast.addToDOM(el)}}constructor(source){this.nodes=typeof source==="string"?this.parseMarkup(source):source}addToDOM(parent){function recurse(subtree,subParent){let ret;AST_splat(subtree).forEach(function(item){const tagName=item.tagName;const textNode=item.textContent?Core_Globals.doc.createTextNode(item.textContent):void 0;const bypassHTMLFiltering=AST.bypassHTMLFiltering;let node;if(tagName){if(tagName==="#text"){node=textNode}else if(AST.allowedTags.indexOf(tagName)!==-1||bypassHTMLFiltering){const NS=tagName==="svg"?SVG_NS:subParent.namespaceURI||SVG_NS;const element=Core_Globals.doc.createElementNS(NS,tagName);const attributes=item.attributes||{};AST_objectEach(item,function(val,key){if(key!=="tagName"&&key!=="attributes"&&key!=="children"&&key!=="style"&&key!=="textContent"){attributes[key]=val}});AST_attr(element,bypassHTMLFiltering?attributes:AST.filterUserAttributes(attributes));if(item.style){AST_css(element,item.style)}if(textNode){element.appendChild(textNode)}recurse(item.children||[],element);node=element}else{AST_error(33,false,void 0,{"Invalid tagName in config":tagName})}}if(node){subParent.appendChild(node)}ret=node});return ret}return recurse(this.nodes,parent)}parseMarkup(markup){const nodes=[];markup=markup.trim().replace(/ style=(["'])/g," data-style=$1");let doc;try{doc=(new DOMParser).parseFromString(trustedTypesPolicy?trustedTypesPolicy.createHTML(markup):markup,"text/html")}catch(e){}if(!doc){const body=AST_createElement("div");body.innerHTML=markup;doc={body:body}}const appendChildNodes=(node,addTo)=>{const tagName=node.nodeName.toLowerCase();const astNode={tagName:tagName};if(tagName==="#text"){astNode.textContent=node.textContent||""}const parsedAttributes=node.attributes;if(parsedAttributes){const attributes={};[].forEach.call(parsedAttributes,attrib=>{if(attrib.name==="data-style"){astNode.style=AST.parseStyle(attrib.value)}else{attributes[attrib.name]=attrib.value}});astNode.attributes=attributes}if(node.childNodes.length){const children=[];[].forEach.call(node.childNodes,childNode=>{appendChildNodes(childNode,children)});if(children.length){astNode.children=children}}addTo.push(astNode)};[].forEach.call(doc.body.childNodes,childNode=>appendChildNodes(childNode,nodes));return nodes}}AST.allowedAttributes=["alt","aria-controls","aria-describedby","aria-expanded","aria-haspopup","aria-hidden","aria-label","aria-labelledby","aria-live","aria-pressed","aria-readonly","aria-roledescription","aria-selected","class","clip-path","color","colspan","cx","cy","d","dx","dy","disabled","fill","filterUnits","flood-color","flood-opacity","height","href","id","in","in2","markerHeight","markerWidth","offset","opacity","operator","orient","padding","paddingLeft","paddingRight","patternUnits","r","radius","refX","refY","role","scope","slope","src","startOffset","stdDeviation","stroke","stroke-linecap","stroke-width","style","tableValues","result","rowspan","summary","target","tabindex","text-align","text-anchor","textAnchor","textLength","title","type","valign","width","x","x1","x2","xlink:href","y","y1","y2","zIndex"];AST.allowedReferences=["https://","http://","mailto:","/","../","./","#"];AST.allowedTags=["a","abbr","b","br","button","caption","circle","clipPath","code","dd","defs","div","dl","dt","em","feComponentTransfer","feComposite","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feMorphology","feOffset","feMerge","feMergeNode","filter","h1","h2","h3","h4","h5","h6","hr","i","img","li","linearGradient","marker","ol","p","path","pattern","pre","rect","small","span","stop","strong","style","sub","sup","svg","table","text","textPath","thead","title","tbody","tspan","td","th","tr","u","ul","#text"];AST.emptyHTML=emptyHTML;AST.bypassHTMLFiltering=false;const HTML_AST=AST;"";const{defaultOptions:Templating_defaultOptions,defaultTime:Templating_defaultTime}=Defaults;const{doc:Templating_doc}=Core_Globals;const{extend:Templating_extend,getNestedProperty:Templating_getNestedProperty,isArray:Templating_isArray,isNumber:Templating_isNumber,isObject:Templating_isObject,pick:Templating_pick,ucfirst:Templating_ucfirst}=Core_Utilities;const helpers={add:(a,b)=>a+b,divide:(a,b)=>b!==0?a/b:"",eq:(a,b)=>a==b,each:function(arr){const match=arguments[arguments.length-1];return Templating_isArray(arr)?arr.map((item,i)=>format(match.body,Templating_extend(Templating_isObject(item)?item:{"@this":item},{"@index":i,"@first":i===0,"@last":i===arr.length-1}))).join(""):false},ge:(a,b)=>a>=b,gt:(a,b)=>a>b,if:condition=>!!condition,le:(a,b)=>a<=b,lt:(a,b)=>a<b,multiply:(a,b)=>a*b,ne:(a,b)=>a!=b,subtract:(a,b)=>a-b,ucfirst:Templating_ucfirst,unless:condition=>!condition};const numberFormatCache={};function dateFormat(format,timestamp,upperCaseFirst){return Templating_defaultTime.dateFormat(format,timestamp,upperCaseFirst)}function format(str="",ctx,chart){const regex=/\{([\p{L}\d:\.,;\-\/<>\[\]%_@"'’= #\(\)]+)\}/gu,subRegex=/\(([\p{L}\d:\.,;\-\/<>\[\]%_@"'= ]+)\)/gu,matches=[],floatRegex=/f$/,decRegex=/\.(\d)/,lang=chart?.options.lang||Templating_defaultOptions.lang,time=chart&&chart.time||Templating_defaultTime,numberFormatter=chart&&chart.numberFormatter||numberFormat;const resolveProperty=(key="")=>{let n;if(key==="true"){return true}if(key==="false"){return false}if((n=Number(key)).toString()===key){return n}if(/^["'].+["']$/.test(key)){return key.slice(1,-1)}return Templating_getNestedProperty(key,ctx)};let match,currentMatch,depth=0,hasSub;while((match=regex.exec(str))!==null){const mainMatch=match,subMatch=subRegex.exec(match[1]);if(subMatch){match=subMatch;hasSub=true}if(!currentMatch||!currentMatch.isBlock){currentMatch={ctx:ctx,expression:match[1],find:match[0],isBlock:match[1].charAt(0)==="#",start:match.index,startInner:match.index+match[0].length,length:match[0].length}}const fn=(currentMatch.isBlock?mainMatch:match)[1].split(" ")[0].replace("#","");if(helpers[fn]){if(currentMatch.isBlock&&fn===currentMatch.fn){depth++}if(!currentMatch.fn){currentMatch.fn=fn}}const startingElseSection=match[1]==="else";if(currentMatch.isBlock&&currentMatch.fn&&(match[1]===`/${currentMatch.fn}`||startingElseSection)){if(!depth){const start=currentMatch.startInner,body=str.substr(start,match.index-start);if(currentMatch.body===void 0){currentMatch.body=body;currentMatch.startInner=match.index+match[0].length}else{currentMatch.elseBody=body}currentMatch.find+=body+match[0];if(!startingElseSection){matches.push(currentMatch);currentMatch=void 0}}else if(!startingElseSection){depth--}}else if(!currentMatch.isBlock){matches.push(currentMatch)}if(subMatch&&!currentMatch?.isBlock){break}}matches.forEach(match=>{const{body,elseBody,expression,fn}=match;let replacement,i;if(fn){const args=[match],parts=[],len=expression.length;let start=0,startChar;for(i=0;i<=len;i++){const char=expression.charAt(i);if(!startChar&&(char==='"'||char==="'")){startChar=char}else if(startChar===char){startChar=""}if(!startChar&&(char===" "||i===len)){parts.push(expression.substr(start,i-start));start=i+1}}i=helpers[fn].length;while(i--){args.unshift(resolveProperty(parts[i+1]))}replacement=helpers[fn].apply(ctx,args);if(match.isBlock&&typeof replacement==="boolean"){replacement=format(replacement?body:elseBody,ctx,chart)}}else{const valueAndFormat=expression.split(":");replacement=resolveProperty(valueAndFormat.shift()||"");if(valueAndFormat.length&&typeof replacement==="number"){const segment=valueAndFormat.join(":");if(floatRegex.test(segment)){const decimals=parseInt((segment.match(decRegex)||["","-1"])[1],10);if(replacement!==null){replacement=numberFormatter(replacement,decimals,lang.decimalPoint,segment.indexOf(",")>-1?lang.thousandsSep:"")}}else{replacement=time.dateFormat(segment,replacement);if(hasSub){replacement=`"${replacement}"`}}}}str=str.replace(match.find,Templating_pick(replacement,""))});return hasSub?format(str,ctx,chart):str}function numberFormat(number,decimals,decimalPoint,thousandsSep){number=+number||0;decimals=+decimals;let ret,fractionDigits,[mantissa,exp]=number.toString().split("e").map(Number);const lang=this?.options?.lang||Templating_defaultOptions.lang,origDec=(number.toString().split(".")[1]||"").split("e")[0].length,firstDecimals=decimals,options={};decimalPoint??(decimalPoint=lang.decimalPoint);thousandsSep??(thousandsSep=lang.thousandsSep);if(decimals===-1){decimals=Math.min(origDec,20)}else if(!Templating_isNumber(decimals)){decimals=2}else if(decimals&&exp<0){fractionDigits=decimals+exp;if(fractionDigits>=0){mantissa=+mantissa.toExponential(fractionDigits).split("e")[0];decimals=fractionDigits}else{mantissa=Math.floor(mantissa);if(decimals<20){number=+(mantissa*Math.pow(10,exp)).toFixed(decimals)}else{number=0}exp=0}}if(exp){decimals??(decimals=2);number=mantissa}if(Templating_isNumber(decimals)&&decimals>=0){options.minimumFractionDigits=decimals;options.maximumFractionDigits=decimals}if(thousandsSep===""){options.useGrouping=false}const hasSeparators=thousandsSep||decimalPoint,locale=hasSeparators?"en":this?.locale||lang.locale||Templating_doc.body.closest("[lang]")?.lang,cacheKey=JSON.stringify(options)+locale,nf=numberFormatCache[cacheKey]??(numberFormatCache[cacheKey]=new Intl.NumberFormat(locale,options));ret=nf.format(number);if(hasSeparators){ret=ret.replace(/\,/g,thousandsSep??",").replace(".",decimalPoint??".")}if(!decimals&&+ret===0||exp<0&&!firstDecimals){ret="0"}if(exp&&+ret!==0){ret+="e"+(exp<0?"":"+")+exp}return ret}const Templating={dateFormat:dateFormat,format:format,helpers:helpers,numberFormat:numberFormat};const Core_Templating=Templating;var RendererRegistry;(function(RendererRegistry){RendererRegistry.rendererTypes={};let defaultRenderer;function getRendererType(rendererType=defaultRenderer){return RendererRegistry.rendererTypes[rendererType]||RendererRegistry.rendererTypes[defaultRenderer]}RendererRegistry.getRendererType=getRendererType;function registerRendererType(rendererType,rendererClass,setAsDefault){RendererRegistry.rendererTypes[rendererType]=rendererClass;if(!defaultRenderer||setAsDefault){defaultRenderer=rendererType;Core_Globals.Renderer=rendererClass}}RendererRegistry.registerRendererType=registerRendererType})(RendererRegistry||(RendererRegistry={}));const Renderer_RendererRegistry=RendererRegistry;const{clamp:RendererUtilities_clamp,pick:RendererUtilities_pick,pushUnique:RendererUtilities_pushUnique,stableSort:RendererUtilities_stableSort}=Core_Utilities;var RendererUtilities;(function(RendererUtilities){function distribute(boxes,len,maxDistance){const origBoxes=boxes,reducedLen=origBoxes.reducedLen||len,sortByRank=(a,b)=>(b.rank||0)-(a.rank||0),sortByTarget=(a,b)=>a.target-b.target,restBoxes=[],boxesLength=boxes.length,forDeletion=[],push=restBoxes.push;let i,cursor,step,overlapping=true,box,target,total=0,equalRank;i=boxesLength;while(i--){total+=boxes[i].size}if(total>reducedLen){RendererUtilities_stableSort(boxes,sortByRank);equalRank=boxes[0].rank===boxes[boxes.length-1].rank;step=equalRank?boxesLength/2:-1;cursor=equalRank?step:boxesLength-1;while(step&&total>reducedLen){i=Math.floor(cursor);box=boxes[i];if(RendererUtilities_pushUnique(forDeletion,i)){total-=box.size}cursor+=step;if(equalRank&&cursor>=boxes.length){step/=2;cursor=step}}forDeletion.sort((a,b)=>b-a).forEach(i=>push.apply(restBoxes,boxes.splice(i,1)))}RendererUtilities_stableSort(boxes,sortByTarget);boxes=boxes.map(box=>({size:box.size,targets:[box.target],align:RendererUtilities_pick(box.align,.5)}));while(overlapping){i=boxes.length;while(i--){box=boxes[i];target=(Math.min.apply(0,box.targets)+Math.max.apply(0,box.targets))/2;box.pos=RendererUtilities_clamp(target-box.size*box.align,0,len-box.size)}i=boxes.length;overlapping=false;while(i--){if(i>0&&boxes[i-1].pos+boxes[i-1].size>boxes[i].pos){boxes[i-1].size+=boxes[i].size;boxes[i-1].targets=boxes[i-1].targets.concat(boxes[i].targets);boxes[i-1].align=.5;if(boxes[i-1].pos+boxes[i-1].size>len){boxes[i-1].pos=len-boxes[i-1].size}boxes.splice(i,1);overlapping=true}}}push.apply(origBoxes,restBoxes);i=0;boxes.some(box=>{let posInCompositeBox=0;return(box.targets||[]).some(()=>{origBoxes[i].pos=box.pos+posInCompositeBox;if(typeof maxDistance!=="undefined"&&Math.abs(origBoxes[i].pos-origBoxes[i].target)>maxDistance){origBoxes.slice(0,i+1).forEach(box=>delete box.pos);origBoxes.reducedLen=(origBoxes.reducedLen||len)-len*.1;if(origBoxes.reducedLen>len*.1){distribute(origBoxes,len,maxDistance)}return true}posInCompositeBox+=origBoxes[i].size;i++;return false})});RendererUtilities_stableSort(origBoxes,sortByTarget);return origBoxes}RendererUtilities.distribute=distribute})(RendererUtilities||(RendererUtilities={}));const Renderer_RendererUtilities=RendererUtilities;const{animate:SVGElement_animate,animObject:SVGElement_animObject,stop:SVGElement_stop}=AnimationUtilities;const{deg2rad,doc:SVGElement_doc,svg,SVG_NS:SVGElement_SVG_NS,win:SVGElement_win,isFirefox}=Core_Globals;const{addEvent:SVGElement_addEvent,attr:SVGElement_attr,createElement:SVGElement_createElement,crisp:SVGElement_crisp,css:SVGElement_css,defined:SVGElement_defined,erase:SVGElement_erase,extend:SVGElement_extend,fireEvent:SVGElement_fireEvent,getAlignFactor:SVGElement_getAlignFactor,isArray:SVGElement_isArray,isFunction:SVGElement_isFunction,isNumber:SVGElement_isNumber,isObject:SVGElement_isObject,isString:SVGElement_isString,merge:SVGElement_merge,objectEach:SVGElement_objectEach,pick:SVGElement_pick,pInt:SVGElement_pInt,pushUnique:SVGElement_pushUnique,replaceNested:SVGElement_replaceNested,syncTimeout:SVGElement_syncTimeout,uniqueKey:SVGElement_uniqueKey}=Core_Utilities;class SVGElement{_defaultGetter(key){let ret=SVGElement_pick(this[key+"Value"],this[key],this.element?this.element.getAttribute(key):null,0);if(/^-?[\d\.]+$/.test(ret)){ret=parseFloat(ret)}return ret}_defaultSetter(value,key,element){element.setAttribute(key,value)}add(parent){const renderer=this.renderer,element=this.element;let inserted;if(parent){this.parentGroup=parent}if(typeof this.textStr!=="undefined"&&this.element.nodeName==="text"){renderer.buildText(this)}this.added=true;if(!parent||parent.handleZ||this.zIndex){inserted=this.zIndexSetter()}if(!inserted){(parent?parent.element:renderer.box).appendChild(element)}if(this.onAdd){this.onAdd()}return this}addClass(className,replace){const currentClassName=replace?"":this.attr("class")||"";className=(className||"").split(/ /g).reduce(function(newClassName,name){if(currentClassName.indexOf(name)===-1){newClassName.push(name)}return newClassName},currentClassName?[currentClassName]:[]).join(" ");if(className!==currentClassName){this.attr("class",className)}return this}afterSetters(){if(this.doTransform){this.updateTransform();this.doTransform=false}}align(alignOptions,alignByTranslate,alignTo,redraw=true){const attribs={},renderer=this.renderer,alignedObjects=renderer.alignedObjects,initialAlignment=Boolean(alignOptions);if(alignOptions){this.alignOptions=alignOptions;this.alignByTranslate=alignByTranslate;this.alignTo=alignTo}else{alignOptions=this.alignOptions||{};alignByTranslate=this.alignByTranslate;alignTo=this.alignTo}const alignToKey=!alignTo||SVGElement_isString(alignTo)?alignTo||"renderer":void 0;if(alignToKey){if(initialAlignment){SVGElement_pushUnique(alignedObjects,this)}alignTo=void 0}const alignToBox=SVGElement_pick(alignTo,renderer[alignToKey],renderer),x=(alignToBox.x||0)+(alignOptions.x||0)+((alignToBox.width||0)-(alignOptions.width||0))*SVGElement_getAlignFactor(alignOptions.align),y=(alignToBox.y||0)+(alignOptions.y||0)+((alignToBox.height||0)-(alignOptions.height||0))*SVGElement_getAlignFactor(alignOptions.verticalAlign);attribs[alignByTranslate?"translateX":"x"]=Math.round(x);attribs[alignByTranslate?"translateY":"y"]=Math.round(y);if(redraw){this[this.placed?"animate":"attr"](attribs);this.placed=true}this.alignAttr=attribs;return this}alignSetter(value){const convert={left:"start",center:"middle",right:"end"};if(convert[value]){this.alignValue=value;this.element.setAttribute("text-anchor",convert[value])}}animate(params,options,complete){const animOptions=SVGElement_animObject(SVGElement_pick(options,this.renderer.globalAnimation,true)),deferTime=animOptions.defer;if(SVGElement_doc.hidden){animOptions.duration=0}if(animOptions.duration!==0){if(complete){animOptions.complete=complete}SVGElement_syncTimeout(()=>{if(this.element){SVGElement_animate(this,params,animOptions)}},deferTime)}else{this.attr(params,void 0,complete||animOptions.complete);SVGElement_objectEach(params,function(val,prop){if(animOptions.step){animOptions.step.call(this,val,{prop:prop,pos:1,elem:this})}},this)}return this}applyTextOutline(textOutline){const elem=this.element,hasContrast=textOutline.indexOf("contrast")!==-1,styles={};if(hasContrast){styles.textOutline=textOutline=textOutline.replace(/contrast/g,this.renderer.getContrast(elem.style.fill))}const parts=textOutline.split(" ");const color=parts[parts.length-1];let strokeWidth=parts[0];if(strokeWidth&&strokeWidth!=="none"&&Core_Globals.svg){this.fakeTS=true;strokeWidth=strokeWidth.replace(/(^[\d\.]+)(.*?)$/g,function(match,digit,unit){return 2*Number(digit)+unit});this.removeTextOutline();const outline=SVGElement_doc.createElementNS(SVGElement_SVG_NS,"tspan");SVGElement_attr(outline,{class:"highcharts-text-outline",fill:color,stroke:color,"stroke-width":strokeWidth,"stroke-linejoin":"round"});const parentElem=elem.querySelector("textPath")||elem;[].forEach.call(parentElem.childNodes,childNode=>{const clone=childNode.cloneNode(true);if(clone.removeAttribute){["fill","stroke","stroke-width","stroke"].forEach(prop=>clone.removeAttribute(prop))}outline.appendChild(clone)});let totalHeight=0;[].forEach.call(parentElem.querySelectorAll("text tspan"),element=>{totalHeight+=Number(element.getAttribute("dy"))});const br=SVGElement_doc.createElementNS(SVGElement_SVG_NS,"tspan");br.textContent="​";SVGElement_attr(br,{x:Number(elem.getAttribute("x")),dy:-totalHeight});outline.appendChild(br);parentElem.insertBefore(outline,parentElem.firstChild)}}attr(hash,val,complete,continueAnimation){const{element}=this,symbolCustomAttribs=SVGElement.symbolCustomAttribs;let key,hasSetSymbolSize,ret=this,skipAttr,setter;if(typeof hash==="string"&&typeof val!=="undefined"){key=hash;hash={};hash[key]=val}if(typeof hash==="string"){ret=(this[hash+"Getter"]||this._defaultGetter).call(this,hash,element)}else{SVGElement_objectEach(hash,function eachAttribute(val,key){skipAttr=false;if(!continueAnimation){SVGElement_stop(this,key)}if(this.symbolName&&symbolCustomAttribs.indexOf(key)!==-1){if(!hasSetSymbolSize){this.symbolAttr(hash);hasSetSymbolSize=true}skipAttr=true}if(this.rotation&&(key==="x"||key==="y")){this.doTransform=true}if(!skipAttr){setter=this[key+"Setter"]||this._defaultSetter;setter.call(this,val,key,element)}},this);this.afterSetters()}if(complete){complete.call(this)}return ret}clip(clipElem){if(clipElem&&!clipElem.clipPath){const id=SVGElement_uniqueKey()+"-",clipPath=this.renderer.createElement("clipPath").attr({id:id}).add(this.renderer.defs);SVGElement_extend(clipElem,{clipPath:clipPath,id:id,count:0});clipElem.add(clipPath)}return this.attr("clip-path",clipElem?`url(${this.renderer.url}#${clipElem.id})`:"none")}crisp(rect,strokeWidth){strokeWidth=Math.round(strokeWidth||rect.strokeWidth||0);const x1=rect.x||this.x||0,y1=rect.y||this.y||0,x2=(rect.width||this.width||0)+x1,y2=(rect.height||this.height||0)+y1,x=SVGElement_crisp(x1,strokeWidth),y=SVGElement_crisp(y1,strokeWidth),x2Crisp=SVGElement_crisp(x2,strokeWidth),y2Crisp=SVGElement_crisp(y2,strokeWidth);SVGElement_extend(rect,{x:x,y:y,width:x2Crisp-x,height:y2Crisp-y});if(SVGElement_defined(rect.strokeWidth)){rect.strokeWidth=strokeWidth}return rect}complexColor(colorOptions,prop,elem){const renderer=this.renderer;let colorObject,gradName,gradAttr,radAttr,gradients,stops,stopColor,stopOpacity,radialReference,id,key=[],value;SVGElement_fireEvent(this.renderer,"complexColor",{args:arguments},function(){if(colorOptions.radialGradient){gradName="radialGradient"}else if(colorOptions.linearGradient){gradName="linearGradient"}if(gradName){gradAttr=colorOptions[gradName];gradients=renderer.gradients;stops=colorOptions.stops;radialReference=elem.radialReference;if(SVGElement_isArray(gradAttr)){colorOptions[gradName]=gradAttr={x1:gradAttr[0],y1:gradAttr[1],x2:gradAttr[2],y2:gradAttr[3],gradientUnits:"userSpaceOnUse"}}if(gradName==="radialGradient"&&radialReference&&!SVGElement_defined(gradAttr.gradientUnits)){radAttr=gradAttr;gradAttr=SVGElement_merge(gradAttr,renderer.getRadialAttr(radialReference,radAttr),{gradientUnits:"userSpaceOnUse"})}SVGElement_objectEach(gradAttr,function(value,n){if(n!=="id"){key.push(n,value)}});SVGElement_objectEach(stops,function(val){key.push(val)});key=key.join(",");if(gradients[key]){id=gradients[key].attr("id")}else{gradAttr.id=id=SVGElement_uniqueKey();const gradientObject=gradients[key]=renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);gradientObject.radAttr=radAttr;gradientObject.stops=[];stops.forEach(function(stop){if(stop[1].indexOf("rgba")===0){colorObject=Color_Color.parse(stop[1]);stopColor=colorObject.get("rgb");stopOpacity=colorObject.get("a")}else{stopColor=stop[1];stopOpacity=1}const stopObject=renderer.createElement("stop").attr({offset:stop[0],"stop-color":stopColor,"stop-opacity":stopOpacity}).add(gradientObject);gradientObject.stops.push(stopObject)})}value="url("+renderer.url+"#"+id+")";elem.setAttribute(prop,value);elem.gradient=key;colorOptions.toString=function(){return value}}})}css(styles){const oldStyles=this.styles,newStyles={},elem=this.element;let textWidth,hasNew=!oldStyles;if(oldStyles){SVGElement_objectEach(styles,function(value,n){if(oldStyles&&oldStyles[n]!==value){newStyles[n]=value;hasNew=true}})}if(hasNew){if(oldStyles){styles=SVGElement_extend(oldStyles,newStyles)}if(styles.width===null||styles.width==="auto"){delete this.textWidth}else if(elem.nodeName.toLowerCase()==="text"&&styles.width){textWidth=this.textWidth=SVGElement_pInt(styles.width)}SVGElement_extend(this.styles,styles);if(textWidth&&(!svg&&this.renderer.forExport)){delete styles.width}const fontSize=isFirefox&&styles.fontSize||null;if(fontSize&&(SVGElement_isNumber(fontSize)||/^\d+$/.test(fontSize))){styles.fontSize+="px"}const stylesToApply=SVGElement_merge(styles);if(elem.namespaceURI===this.SVG_NS){["textOutline","textOverflow","whiteSpace","width"].forEach(key=>stylesToApply&&delete stylesToApply[key]);if(stylesToApply.color){stylesToApply.fill=stylesToApply.color}}SVGElement_css(elem,stylesToApply)}if(this.added){if(this.element.nodeName==="text"){this.renderer.buildText(this)}if(styles.textOutline){this.applyTextOutline(styles.textOutline)}}return this}dashstyleSetter(value){let i,strokeWidth=this["stroke-width"];if(strokeWidth==="inherit"){strokeWidth=1}value=value&&value.toLowerCase();if(value){const v=value.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");i=v.length;while(i--){v[i]=""+SVGElement_pInt(v[i])*SVGElement_pick(strokeWidth,NaN)}value=v.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",value)}}destroy(){const wrapper=this,element=wrapper.element||{},renderer=wrapper.renderer,ownerSVGElement=element.ownerSVGElement;let parentToClean=element.nodeName==="SPAN"&&wrapper.parentGroup||void 0,grandParent,i;element.onclick=element.onmouseout=element.onmouseover=element.onmousemove=element.point=null;SVGElement_stop(wrapper);if(wrapper.clipPath&&ownerSVGElement){const clipPath=wrapper.clipPath;[].forEach.call(ownerSVGElement.querySelectorAll("[clip-path],[CLIP-PATH]"),function(el){if(el.getAttribute("clip-path").indexOf(clipPath.element.id)>-1){el.removeAttribute("clip-path")}});wrapper.clipPath=clipPath.destroy()}wrapper.connector=wrapper.connector?.destroy();if(wrapper.stops){for(i=0;i<wrapper.stops.length;i++){wrapper.stops[i].destroy()}wrapper.stops.length=0;wrapper.stops=void 0}wrapper.safeRemoveChild(element);while(parentToClean&&parentToClean.div&&parentToClean.div.childNodes.length===0){grandParent=parentToClean.parentGroup;wrapper.safeRemoveChild(parentToClean.div);delete parentToClean.div;parentToClean=grandParent}if(wrapper.alignOptions){SVGElement_erase(renderer.alignedObjects,wrapper)}SVGElement_objectEach(wrapper,function(val,key){if(wrapper[key]&&wrapper[key].parentGroup===wrapper&&wrapper[key].destroy){wrapper[key].destroy()}delete wrapper[key]});return}dSetter(value,key,element){if(SVGElement_isArray(value)){if(typeof value[0]==="string"){value=this.renderer.pathToSegments(value)}this.pathArray=value;value=value.reduce((acc,seg,i)=>{if(!seg||!seg.join){return(seg||"").toString()}return(i?acc+" ":"")+seg.join(" ")},"")}if(/(NaN| {2}|^$)/.test(value)){value="M 0 0"}if(this[key]!==value){element.setAttribute(key,value);this[key]=value}}fillSetter(value,key,element){if(typeof value==="string"){element.setAttribute(key,value)}else if(value){this.complexColor(value,key,element)}}hrefSetter(value,key,element){element.setAttributeNS("http://www.w3.org/1999/xlink",key,value)}getBBox(reload,rot){const wrapper=this,{alignValue,element,renderer,styles,textStr}=wrapper,{cache,cacheKeys}=renderer,isSVG=element.namespaceURI===wrapper.SVG_NS,rotation=SVGElement_pick(rot,wrapper.rotation,0),fontSize=renderer.styledMode?element&&SVGElement.prototype.getStyle.call(element,"font-size"):styles.fontSize;let bBox,height,toggleTextShadowShim,cacheKey;if(SVGElement_defined(textStr)){cacheKey=textStr.toString();if(cacheKey.indexOf("<")===-1){cacheKey=cacheKey.replace(/\d/g,"0")}cacheKey+=["",renderer.rootFontSize,fontSize,rotation,wrapper.textWidth,alignValue,styles.lineClamp,styles.textOverflow,styles.fontWeight].join(",")}if(cacheKey&&!reload){bBox=cache[cacheKey]}if(!bBox||bBox.polygon){if(isSVG||renderer.forExport){try{toggleTextShadowShim=this.fakeTS&&function(display){const outline=element.querySelector(".highcharts-text-outline");if(outline){SVGElement_css(outline,{display:display})}};if(SVGElement_isFunction(toggleTextShadowShim)){toggleTextShadowShim("none")}bBox=element.getBBox?SVGElement_extend({},element.getBBox()):{width:element.offsetWidth,height:element.offsetHeight,x:0,y:0};if(SVGElement_isFunction(toggleTextShadowShim)){toggleTextShadowShim("")}}catch(e){""}if(!bBox||bBox.width<0){bBox={x:0,y:0,width:0,height:0}}}else{bBox=wrapper.htmlGetBBox()}height=bBox.height;if(isSVG){bBox.height=height={"11px,17":14,"13px,20":16}[`${fontSize||""},${Math.round(height)}`]||height}if(rotation){bBox=this.getRotatedBox(bBox,rotation)}const e={bBox:bBox};SVGElement_fireEvent(this,"afterGetBBox",e);bBox=e.bBox}if(cacheKey&&(textStr===""||bBox.height>0)){while(cacheKeys.length>250){delete cache[cacheKeys.shift()]}if(!cache[cacheKey]){cacheKeys.push(cacheKey)}cache[cacheKey]=bBox}return bBox}getRotatedBox(box,rotation){const{x:boxX,y:boxY,width,height}=box,{alignValue,translateY,rotationOriginX=0,rotationOriginY=0}=this,alignFactor=SVGElement_getAlignFactor(alignValue),baseline=Number(this.element.getAttribute("y")||0)-(translateY?0:boxY),rad=rotation*deg2rad,rad90=(rotation-90)*deg2rad,cosRad=Math.cos(rad),sinRad=Math.sin(rad),wCosRad=width*cosRad,wSinRad=width*sinRad,cosRad90=Math.cos(rad90),sinRad90=Math.sin(rad90),[[xOriginCosRad,xOriginSinRad],[yOriginCosRad,yOriginSinRad]]=[rotationOriginX,rotationOriginY].map(rotOrigin=>[rotOrigin-rotOrigin*cosRad,rotOrigin*sinRad]),pX=boxX+alignFactor*(width-wCosRad)+xOriginCosRad+yOriginSinRad,pY=boxY+baseline-alignFactor*wSinRad-xOriginSinRad+yOriginCosRad,aX=pX+baseline*cosRad90,bX=aX+wCosRad,cX=bX-height*cosRad90,dX=cX-wCosRad,aY=pY+baseline*sinRad90,bY=aY+wSinRad,cY=bY-height*sinRad90,dY=cY-wSinRad;const x=Math.min(aX,bX,cX,dX),y=Math.min(aY,bY,cY,dY),boxWidth=Math.max(aX,bX,cX,dX)-x,boxHeight=Math.max(aY,bY,cY,dY)-y;return{x:x,y:y,width:boxWidth,height:boxHeight,polygon:[[aX,aY],[bX,bY],[cX,cY],[dX,dY]]}}getStyle(prop){return SVGElement_win.getComputedStyle(this.element||this,"").getPropertyValue(prop)}hasClass(className){return(""+this.attr("class")).split(" ").indexOf(className)!==-1}hide(){return this.attr({visibility:"hidden"})}htmlGetBBox(){return{height:0,width:0,x:0,y:0}}constructor(renderer,nodeName){this.onEvents={};this.opacity=1;this.SVG_NS=SVGElement_SVG_NS;this.element=nodeName==="span"||nodeName==="body"?SVGElement_createElement(nodeName):SVGElement_doc.createElementNS(this.SVG_NS,nodeName);this.renderer=renderer;this.styles={};SVGElement_fireEvent(this,"afterInit")}on(eventType,handler){const{onEvents}=this;if(onEvents[eventType]){onEvents[eventType]()}onEvents[eventType]=SVGElement_addEvent(this.element,eventType,handler);return this}opacitySetter(value,key,element){const opacity=Number(Number(value).toFixed(3));this.opacity=opacity;element.setAttribute(key,opacity)}reAlign(){if(this.alignOptions?.width&&this.alignOptions.align!=="left"){this.alignOptions.width=this.getBBox().width;this.placed=false;this.align()}}removeClass(className){return this.attr("class",(""+this.attr("class")).replace(SVGElement_isString(className)?new RegExp(`(^| )${className}( |$)`):className," ").replace(/ +/g," ").trim())}removeTextOutline(){const outline=this.element.querySelector("tspan.highcharts-text-outline");if(outline){this.safeRemoveChild(outline)}}safeRemoveChild(element){const parentNode=element.parentNode;if(parentNode){parentNode.removeChild(element)}}setRadialReference(coordinates){const existingGradient=this.element.gradient&&this.renderer.gradients[this.element.gradient];this.element.radialReference=coordinates;if(existingGradient&&existingGradient.radAttr){existingGradient.animate(this.renderer.getRadialAttr(coordinates,existingGradient.radAttr))}return this}shadow(shadowOptions){const{renderer}=this,options=SVGElement_merge(this.parentGroup?.rotation===90?{offsetX:-1,offsetY:-1}:{},SVGElement_isObject(shadowOptions)?shadowOptions:{}),id=renderer.shadowDefinition(options);return this.attr({filter:shadowOptions?`url(${renderer.url}#${id})`:"none"})}show(inherit=true){return this.attr({visibility:inherit?"inherit":"visible"})}"stroke-widthSetter"(value,key,element){this[key]=value;element.setAttribute(key,value)}strokeWidth(){if(!this.renderer.styledMode){return this["stroke-width"]||0}const val=this.getStyle("stroke-width");let ret=0,tempElement;if(/px$/.test(val)){ret=SVGElement_pInt(val)}else if(val!==""){tempElement=SVGElement_doc.createElementNS(SVGElement_SVG_NS,"rect");SVGElement_attr(tempElement,{width:val,"stroke-width":0});this.element.parentNode.appendChild(tempElement);ret=tempElement.getBBox().width;tempElement.parentNode.removeChild(tempElement)}return ret}symbolAttr(hash){const wrapper=this;SVGElement.symbolCustomAttribs.forEach(function(key){wrapper[key]=SVGElement_pick(hash[key],wrapper[key])});wrapper.attr({d:wrapper.renderer.symbols[wrapper.symbolName](wrapper.x,wrapper.y,wrapper.width,wrapper.height,wrapper)})}textSetter(value){if(value!==this.textStr){delete this.textPxLength;this.textStr=value;if(this.added){this.renderer.buildText(this)}this.reAlign()}}titleSetter(value){const el=this.element;const titleNode=el.getElementsByTagName("title")[0]||SVGElement_doc.createElementNS(this.SVG_NS,"title");if(el.insertBefore){el.insertBefore(titleNode,el.firstChild)}else{el.appendChild(titleNode)}titleNode.textContent=SVGElement_replaceNested(SVGElement_pick(value,""),[/<[^>]*>/g,""]).replace(/&lt;/g,"<").replace(/&gt;/g,">")}toFront(){const element=this.element;element.parentNode.appendChild(element);return this}translate(x,y){return this.attr({translateX:x,translateY:y})}updateTransform(attrib="transform"){const{element,matrix,rotation=0,rotationOriginX,rotationOriginY,scaleX,scaleY,translateX=0,translateY=0}=this;const transform=["translate("+translateX+","+translateY+")"];if(SVGElement_defined(matrix)){transform.push("matrix("+matrix.join(",")+")")}if(rotation){transform.push("rotate("+rotation+" "+SVGElement_pick(rotationOriginX,element.getAttribute("x"),0)+" "+SVGElement_pick(rotationOriginY,element.getAttribute("y")||0)+")");if(this.text?.element.tagName==="SPAN"){this.text.attr({rotation:rotation,rotationOriginX:(rotationOriginX||0)-this.padding,rotationOriginY:(rotationOriginY||0)-this.padding})}}if(SVGElement_defined(scaleX)||SVGElement_defined(scaleY)){transform.push("scale("+SVGElement_pick(scaleX,1)+" "+SVGElement_pick(scaleY,1)+")")}if(transform.length&&!(this.text||this).textPath){element.setAttribute(attrib,transform.join(" "))}}visibilitySetter(value,key,element){if(value==="inherit"){element.removeAttribute(key)}else if(this[key]!==value){element.setAttribute(key,value)}this[key]=value}xGetter(key){if(this.element.nodeName==="circle"){if(key==="x"){key="cx"}else if(key==="y"){key="cy"}}return this._defaultGetter(key)}zIndexSetter(value,key){const renderer=this.renderer,parentGroup=this.parentGroup,parentWrapper=parentGroup||renderer,parentNode=parentWrapper.element||renderer.box,element=this.element,svgParent=parentNode===renderer.box;let childNodes,otherElement,otherZIndex,inserted=false,undefinedOtherZIndex,run=this.added,i;if(SVGElement_defined(value)){element.setAttribute("data-z-index",value);value=+value;if(this[key]===value){run=false}}else if(SVGElement_defined(this[key])){element.removeAttribute("data-z-index")}this[key]=value;if(run){value=this.zIndex;if(value&&parentGroup){parentGroup.handleZ=true}childNodes=parentNode.childNodes;for(i=childNodes.length-1;i>=0&&!inserted;i--){otherElement=childNodes[i];otherZIndex=otherElement.getAttribute("data-z-index");undefinedOtherZIndex=!SVGElement_defined(otherZIndex);if(otherElement!==element){if(value<0&&undefinedOtherZIndex&&!svgParent&&!i){parentNode.insertBefore(element,childNodes[i]);inserted=true}else if(SVGElement_pInt(otherZIndex)<=value||undefinedOtherZIndex&&(!SVGElement_defined(value)||value>=0)){parentNode.insertBefore(element,childNodes[i+1]);inserted=true}}}if(!inserted){parentNode.insertBefore(element,childNodes[svgParent?3:0]);inserted=true}}return inserted}}SVGElement.symbolCustomAttribs=["anchorX","anchorY","clockwise","end","height","innerR","r","start","width","x","y"];SVGElement.prototype.strokeSetter=SVGElement.prototype.fillSetter;SVGElement.prototype.yGetter=SVGElement.prototype.xGetter;SVGElement.prototype.matrixSetter=SVGElement.prototype.rotationOriginXSetter=SVGElement.prototype.rotationOriginYSetter=SVGElement.prototype.rotationSetter=SVGElement.prototype.scaleXSetter=SVGElement.prototype.scaleYSetter=SVGElement.prototype.translateXSetter=SVGElement.prototype.translateYSetter=SVGElement.prototype.verticalAlignSetter=function(value,key){this[key]=value;this.doTransform=true};const SVG_SVGElement=SVGElement;"";const{defined:SVGLabel_defined,extend:SVGLabel_extend,getAlignFactor:SVGLabel_getAlignFactor,isNumber:SVGLabel_isNumber,merge:SVGLabel_merge,pick:SVGLabel_pick,removeEvent:SVGLabel_removeEvent}=Core_Utilities;class SVGLabel extends SVG_SVGElement{constructor(renderer,str,x,y,shape,anchorX,anchorY,useHTML,baseline,className){super(renderer,"g");this.paddingLeftSetter=this.paddingSetter;this.paddingRightSetter=this.paddingSetter;this.doUpdate=false;this.textStr=str;this.x=x;this.y=y;this.anchorX=anchorX;this.anchorY=anchorY;this.baseline=baseline;this.className=className;this.addClass(className==="button"?"highcharts-no-tooltip":"highcharts-label");if(className){this.addClass("highcharts-"+className)}this.text=renderer.text(void 0,0,0,useHTML).attr({zIndex:1});let hasBGImage;if(typeof shape==="string"){hasBGImage=/^url\((.*?)\)$/.test(shape);if(hasBGImage||this.renderer.symbols[shape]){this.symbolKey=shape}}this.bBox=SVGLabel.emptyBBox;this.padding=3;this.baselineOffset=0;this.needsBox=renderer.styledMode||hasBGImage;this.deferredAttr={};this.alignFactor=0}alignSetter(value){const alignFactor=SVGLabel_getAlignFactor(value);if(alignFactor!==this.alignFactor){this.alignFactor=alignFactor;if(this.bBox&&SVGLabel_isNumber(this.xSetting)){this.attr({x:this.xSetting})}}}anchorXSetter(value,key){this.anchorX=value;this.boxAttr(key,Math.round(value)-this.getCrispAdjust()-this.xSetting)}anchorYSetter(value,key){this.anchorY=value;this.boxAttr(key,value-this.ySetting)}boxAttr(key,value){if(this.box){this.box.attr(key,value)}else{this.deferredAttr[key]=value}}css(styles){if(styles){const textStyles={};styles=SVGLabel_merge(styles);SVGLabel.textProps.forEach(prop=>{if(typeof styles[prop]!=="undefined"){textStyles[prop]=styles[prop];delete styles[prop]}});this.text.css(textStyles);if("fontSize"in textStyles||"fontWeight"in textStyles){this.updateTextPadding()}else if("width"in textStyles||"textOverflow"in textStyles){this.updateBoxSize()}}return SVG_SVGElement.prototype.css.call(this,styles)}destroy(){SVGLabel_removeEvent(this.element,"mouseenter");SVGLabel_removeEvent(this.element,"mouseleave");if(this.text){this.text.destroy()}if(this.box){this.box=this.box.destroy()}SVG_SVGElement.prototype.destroy.call(this);return void 0}fillSetter(value,key){if(value){this.needsBox=true}this.fill=value;this.boxAttr(key,value)}getBBox(reload,rot){if(this.textStr&&this.bBox.width===0&&this.bBox.height===0){this.updateBoxSize()}const{padding,height=0,translateX=0,translateY=0,width=0}=this,paddingLeft=SVGLabel_pick(this.paddingLeft,padding),rotation=rot??(this.rotation||0);let bBox={width:width,height:height,x:translateX+this.bBox.x-paddingLeft,y:translateY+this.bBox.y-padding+this.baselineOffset};if(rotation){bBox=this.getRotatedBox(bBox,rotation)}return bBox}getCrispAdjust(){return(this.renderer.styledMode&&this.box?this.box.strokeWidth():this["stroke-width"]?parseInt(this["stroke-width"],10):0)%2/2}heightSetter(value){this.heightSetting=value;this.doUpdate=true}afterSetters(){super.afterSetters();if(this.doUpdate){this.updateBoxSize();this.doUpdate=false}}onAdd(){this.text.add(this);this.attr({text:SVGLabel_pick(this.textStr,""),x:this.x||0,y:this.y||0});if(this.box&&SVGLabel_defined(this.anchorX)){this.attr({anchorX:this.anchorX,anchorY:this.anchorY})}}paddingSetter(value,key){if(!SVGLabel_isNumber(value)){this[key]=void 0}else if(value!==this[key]){this[key]=value;this.updateTextPadding()}}rSetter(value,key){this.boxAttr(key,value)}strokeSetter(value,key){this.stroke=value;this.boxAttr(key,value)}"stroke-widthSetter"(value,key){if(value){this.needsBox=true}this["stroke-width"]=value;this.boxAttr(key,value)}"text-alignSetter"(value){this.textAlign=value}textSetter(text){if(typeof text!=="undefined"){this.text.attr({text:text})}this.updateTextPadding();this.reAlign()}updateBoxSize(){const text=this.text,attribs={},padding=this.padding,bBox=this.bBox=(!SVGLabel_isNumber(this.widthSetting)||!SVGLabel_isNumber(this.heightSetting)||this.textAlign)&&SVGLabel_defined(text.textStr)?text.getBBox(void 0,0):SVGLabel.emptyBBox;let crispAdjust;this.width=this.getPaddedWidth();this.height=(this.heightSetting||bBox.height||0)+2*padding;const metrics=this.renderer.fontMetrics(text);this.baselineOffset=padding+Math.min((this.text.firstLineMetrics||metrics).b,bBox.height||Infinity);if(this.heightSetting){this.baselineOffset+=(this.heightSetting-metrics.h)/2}if(this.needsBox&&!text.textPath){if(!this.box){const box=this.box=this.symbolKey?this.renderer.symbol(this.symbolKey):this.renderer.rect();box.addClass((this.className==="button"?"":"highcharts-label-box")+(this.className?" highcharts-"+this.className+"-box":""));box.add(this)}crispAdjust=this.getCrispAdjust();attribs.x=crispAdjust;attribs.y=(this.baseline?-this.baselineOffset:0)+crispAdjust;attribs.width=Math.round(this.width);attribs.height=Math.round(this.height);this.box.attr(SVGLabel_extend(attribs,this.deferredAttr));this.deferredAttr={}}}updateTextPadding(){const text=this.text;if(!text.textPath){this.updateBoxSize();const textY=this.baseline?0:this.baselineOffset,textX=(this.paddingLeft??this.padding)+(SVGLabel_defined(this.widthSetting)&&this.bBox?SVGLabel_getAlignFactor(this.textAlign)*(this.widthSetting-this.bBox.width):0);if(textX!==text.x||textY!==text.y){text.attr("x",textX);if(text.hasBoxWidthChanged){this.bBox=text.getBBox(true)}if(typeof textY!=="undefined"){text.attr("y",textY)}}text.x=textX;text.y=textY}}widthSetter(value){this.widthSetting=SVGLabel_isNumber(value)?value:void 0;this.doUpdate=true}getPaddedWidth(){const padding=this.padding;const paddingLeft=SVGLabel_pick(this.paddingLeft,padding);const paddingRight=SVGLabel_pick(this.paddingRight,padding);return(this.widthSetting||this.bBox.width||0)+paddingLeft+paddingRight}xSetter(value){this.x=value;if(this.alignFactor){value-=this.alignFactor*this.getPaddedWidth();this["forceAnimate:x"]=true}this.xSetting=Math.round(value);this.attr("translateX",this.xSetting)}ySetter(value){this.ySetting=this.y=Math.round(value);this.attr("translateY",this.ySetting)}}SVGLabel.emptyBBox={width:0,height:0,x:0,y:0};SVGLabel.textProps=["color","direction","fontFamily","fontSize","fontStyle","fontWeight","lineClamp","lineHeight","textAlign","textDecoration","textOutline","textOverflow","whiteSpace","width"];const SVG_SVGLabel=SVGLabel;const{defined:Symbols_defined,isNumber:Symbols_isNumber,pick:Symbols_pick}=Core_Utilities;function arc(cx,cy,w,h,options){const arc=[];if(options){const start=options.start||0,rx=Symbols_pick(options.r,w),ry=Symbols_pick(options.r,h||w),proximity=2e-4/(options.borderRadius?1:Math.max(rx,1)),fullCircle=Math.abs((options.end||0)-start-2*Math.PI)<proximity,end=(options.end||0)-(fullCircle?proximity:0),innerRadius=options.innerR,open=Symbols_pick(options.open,fullCircle),cosStart=Math.cos(start),sinStart=Math.sin(start),cosEnd=Math.cos(end),sinEnd=Math.sin(end),longArc=Symbols_pick(options.longArc,end-start-Math.PI<proximity?0:1);let arcSegment=["A",rx,ry,0,longArc,Symbols_pick(options.clockwise,1),cx+rx*cosEnd,cy+ry*sinEnd];arcSegment.params={start:start,end:end,cx:cx,cy:cy};arc.push(["M",cx+rx*cosStart,cy+ry*sinStart],arcSegment);if(Symbols_defined(innerRadius)){arcSegment=["A",innerRadius,innerRadius,0,longArc,Symbols_defined(options.clockwise)?1-options.clockwise:0,cx+innerRadius*cosStart,cy+innerRadius*sinStart];arcSegment.params={start:end,end:start,cx:cx,cy:cy};arc.push(open?["M",cx+innerRadius*cosEnd,cy+innerRadius*sinEnd]:["L",cx+innerRadius*cosEnd,cy+innerRadius*sinEnd],arcSegment)}if(!open){arc.push(["Z"])}}return arc}function callout(x,y,w,h,options){const arrowLength=6,halfDistance=6,r=Math.min(options&&options.r||0,w,h),safeDistance=r+halfDistance,anchorX=options&&options.anchorX,anchorY=options&&options.anchorY||0;const path=roundedRect(x,y,w,h,{r:r});if(!Symbols_isNumber(anchorX)){return path}if(anchorX<w&&anchorX>0&&anchorY<h&&anchorY>0){return path}if(x+anchorX>w-safeDistance){if(anchorY>y+safeDistance&&anchorY<y+h-safeDistance){path.splice(3,1,["L",x+w,anchorY-halfDistance],["L",x+w+arrowLength,anchorY],["L",x+w,anchorY+halfDistance],["L",x+w,y+h-r])}else{if(anchorX<w){const isTopCorner=anchorY<y+safeDistance,cornerY=isTopCorner?y:y+h,sliceStart=isTopCorner?2:5;path.splice(sliceStart,0,["L",anchorX,anchorY],["L",x+w-r,cornerY])}else{path.splice(3,1,["L",x+w,h/2],["L",anchorX,anchorY],["L",x+w,h/2],["L",x+w,y+h-r])}}}else if(x+anchorX<safeDistance){if(anchorY>y+safeDistance&&anchorY<y+h-safeDistance){path.splice(7,1,["L",x,anchorY+halfDistance],["L",x-arrowLength,anchorY],["L",x,anchorY-halfDistance],["L",x,y+r])}else{if(anchorX>0){const isTopCorner=anchorY<y+safeDistance,cornerY=isTopCorner?y:y+h,sliceStart=isTopCorner?1:6;path.splice(sliceStart,0,["L",anchorX,anchorY],["L",x+r,cornerY])}else{path.splice(7,1,["L",x,h/2],["L",anchorX,anchorY],["L",x,h/2],["L",x,y+r])}}}else if(anchorY>h&&anchorX<w-safeDistance){path.splice(5,1,["L",anchorX+halfDistance,y+h],["L",anchorX,y+h+arrowLength],["L",anchorX-halfDistance,y+h],["L",x+r,y+h])}else if(anchorY<0&&anchorX>safeDistance){path.splice(1,1,["L",anchorX-halfDistance,y],["L",anchorX,y-arrowLength],["L",anchorX+halfDistance,y],["L",w-r,y])}return path}function circle(x,y,w,h){return arc(x+w/2,y+h/2,w/2,h/2,{start:Math.PI*.5,end:Math.PI*2.5,open:false})}function diamond(x,y,w,h){return[["M",x+w/2,y],["L",x+w,y+h/2],["L",x+w/2,y+h],["L",x,y+h/2],["Z"]]}function rect(x,y,w,h,options){if(options&&options.r){return roundedRect(x,y,w,h,options)}return[["M",x,y],["L",x+w,y],["L",x+w,y+h],["L",x,y+h],["Z"]]}function roundedRect(x,y,w,h,options){const r=options?.r||0;return[["M",x+r,y],["L",x+w-r,y],["A",r,r,0,0,1,x+w,y+r],["L",x+w,y+h-r],["A",r,r,0,0,1,x+w-r,y+h],["L",x+r,y+h],["A",r,r,0,0,1,x,y+h-r],["L",x,y+r],["A",r,r,0,0,1,x+r,y],["Z"]]}function triangle(x,y,w,h){return[["M",x+w/2,y],["L",x+w,y+h],["L",x,y+h],["Z"]]}function triangleDown(x,y,w,h){return[["M",x,y],["L",x+w,y],["L",x+w/2,y+h],["Z"]]}const Symbols={arc:arc,callout:callout,circle:circle,diamond:diamond,rect:rect,roundedRect:roundedRect,square:rect,triangle:triangle,"triangle-down":triangleDown};const SVG_Symbols=Symbols;const{doc:TextBuilder_doc,SVG_NS:TextBuilder_SVG_NS,win:TextBuilder_win}=Core_Globals;const{attr:TextBuilder_attr,extend:TextBuilder_extend,fireEvent:TextBuilder_fireEvent,isString:TextBuilder_isString,objectEach:TextBuilder_objectEach,pick:TextBuilder_pick}=Core_Utilities;const stringWithEllipsis=(text,currentIndex)=>text.substring(0,currentIndex)+"…";class TextBuilder{constructor(svgElement){const textStyles=svgElement.styles;this.renderer=svgElement.renderer;this.svgElement=svgElement;this.width=svgElement.textWidth;this.textLineHeight=textStyles&&textStyles.lineHeight;this.textOutline=textStyles&&textStyles.textOutline;this.ellipsis=Boolean(textStyles&&textStyles.textOverflow==="ellipsis");this.lineClamp=textStyles?.lineClamp;this.noWrap=Boolean(textStyles&&textStyles.whiteSpace==="nowrap")}buildSVG(){const wrapper=this.svgElement,textNode=wrapper.element,renderer=wrapper.renderer,textStr=TextBuilder_pick(wrapper.textStr,"").toString(),hasMarkup=textStr.indexOf("<")!==-1,childNodes=textNode.childNodes,tempParent=!wrapper.added&&renderer.box,regexMatchBreaks=/<br.*?>/g,textCache=[textStr,this.ellipsis,this.noWrap,this.textLineHeight,this.textOutline,wrapper.getStyle("font-size"),wrapper.styles.lineClamp,this.width].join(",");if(textCache===wrapper.textCache){return}wrapper.textCache=textCache;delete wrapper.actualWidth;for(let i=childNodes.length;i--;){textNode.removeChild(childNodes[i])}if(!hasMarkup&&!this.ellipsis&&!this.width&&!wrapper.textPath&&(textStr.indexOf(" ")===-1||this.noWrap&&!regexMatchBreaks.test(textStr))){textNode.appendChild(TextBuilder_doc.createTextNode(this.unescapeEntities(textStr)))}else if(textStr!==""){if(tempParent){tempParent.appendChild(textNode)}const ast=new HTML_AST(textStr);this.modifyTree(ast.nodes);ast.addToDOM(textNode);this.modifyDOM();if(this.ellipsis&&(textNode.textContent||"").indexOf("…")!==-1){wrapper.attr("title",this.unescapeEntities(wrapper.textStr||"",["&lt;","&gt;"]))}if(tempParent){tempParent.removeChild(textNode)}}if(TextBuilder_isString(this.textOutline)&&wrapper.applyTextOutline){wrapper.applyTextOutline(this.textOutline)}}modifyDOM(){const wrapper=this.svgElement;const x=TextBuilder_attr(wrapper.element,"x");wrapper.firstLineMetrics=void 0;let firstChild;while(firstChild=wrapper.element.firstChild){if(/^[\s\u200B]*$/.test(firstChild.textContent||" ")){wrapper.element.removeChild(firstChild)}else{break}}[].forEach.call(wrapper.element.querySelectorAll("tspan.highcharts-br"),(br,i)=>{if(br.nextSibling&&br.previousSibling){if(i===0&&br.previousSibling.nodeType===1){wrapper.firstLineMetrics=wrapper.renderer.fontMetrics(br.previousSibling)}TextBuilder_attr(br,{dy:this.getLineHeight(br.nextSibling),x:x})}});const width=this.width||0;if(!width){return}const modifyTextNode=(textNode,parentElement)=>{const text=textNode.textContent||"";const words=text.replace(/([^\^])-/g,"$1- ").split(" ");const hasWhiteSpace=!this.noWrap&&(words.length>1||wrapper.element.childNodes.length>1);const dy=this.getLineHeight(parentElement),ellipsisWidth=Math.max(0,width-.8*dy);let lineNo=0;let startAt=wrapper.actualWidth;if(hasWhiteSpace){const lines=[];const precedingSiblings=[];while(parentElement.firstChild&&parentElement.firstChild!==textNode){precedingSiblings.push(parentElement.firstChild);parentElement.removeChild(parentElement.firstChild)}while(words.length){if(words.length&&!this.noWrap&&lineNo>0){lines.push(textNode.textContent||"");textNode.textContent=words.join(" ").replace(/- /g,"-")}this.truncate(textNode,void 0,words,lineNo===0?startAt||0:0,width,ellipsisWidth,(t,currentIndex)=>words.slice(0,currentIndex).join(" ").replace(/- /g,"-"));startAt=wrapper.actualWidth;lineNo++;if(this.lineClamp&&lineNo>=this.lineClamp){if(words.length){this.truncate(textNode,textNode.textContent||"",void 0,0,width,ellipsisWidth,stringWithEllipsis);textNode.textContent=textNode.textContent?.replace("…","")+"…"}break}}precedingSiblings.forEach(childNode=>{parentElement.insertBefore(childNode,textNode)});lines.forEach(line=>{parentElement.insertBefore(TextBuilder_doc.createTextNode(line),textNode);const br=TextBuilder_doc.createElementNS(TextBuilder_SVG_NS,"tspan");br.textContent="​";TextBuilder_attr(br,{dy:dy,x:x});parentElement.insertBefore(br,textNode)})}else if(this.ellipsis){if(text){this.truncate(textNode,text,void 0,0,width,ellipsisWidth,stringWithEllipsis)}}};const modifyChildren=node=>{const childNodes=[].slice.call(node.childNodes);childNodes.forEach(childNode=>{if(childNode.nodeType===TextBuilder_win.Node.TEXT_NODE){modifyTextNode(childNode,node)}else{if(childNode.className.baseVal.indexOf("highcharts-br")!==-1){wrapper.actualWidth=0}modifyChildren(childNode)}})};modifyChildren(wrapper.element)}getLineHeight(node){const element=node.nodeType===TextBuilder_win.Node.TEXT_NODE?node.parentElement:node;return this.textLineHeight?parseInt(this.textLineHeight.toString(),10):this.renderer.fontMetrics(element||this.svgElement.element).h}modifyTree(nodes){const modifyChild=(node,i)=>{const{attributes={},children,style={},tagName}=node,styledMode=this.renderer.styledMode;if(tagName==="b"||tagName==="strong"){if(styledMode){attributes["class"]="highcharts-strong"}else{style.fontWeight="bold"}}else if(tagName==="i"||tagName==="em"){if(styledMode){attributes["class"]="highcharts-emphasized"}else{style.fontStyle="italic"}}if(style&&style.color){style.fill=style.color}if(tagName==="br"){attributes["class"]="highcharts-br";node.textContent="​";const nextNode=nodes[i+1];if(nextNode&&nextNode.textContent){nextNode.textContent=nextNode.textContent.replace(/^ +/gm,"")}}else if(tagName==="a"&&children&&children.some(child=>child.tagName==="#text")){node.children=[{children:children,tagName:"tspan"}]}if(tagName!=="#text"&&tagName!=="a"){node.tagName="tspan"}TextBuilder_extend(node,{attributes:attributes,style:style});if(children){children.filter(c=>c.tagName!=="#text").forEach(modifyChild)}};nodes.forEach(modifyChild);TextBuilder_fireEvent(this.svgElement,"afterModifyTree",{nodes:nodes})}truncate(textNode,text,words,startAt,width,ellipsisWidth,getString){const svgElement=this.svgElement;const{rotation}=svgElement;const lengths=[];let minIndex=words&&!startAt?1:0;let maxIndex=(text||words||"").length;let currentIndex=maxIndex;let str;let actualWidth;if(!words){width=ellipsisWidth}const getSubStringLength=function(charEnd,concatenatedEnd){const end=concatenatedEnd||charEnd;const parentNode=textNode.parentNode;if(parentNode&&typeof lengths[end]==="undefined"){if(parentNode.getSubStringLength){try{lengths[end]=startAt+parentNode.getSubStringLength(0,words?end+1:end)}catch(e){""}}}return lengths[end]};svgElement.rotation=0;actualWidth=getSubStringLength(textNode.textContent.length);if(startAt+actualWidth>width){while(minIndex<=maxIndex){currentIndex=Math.ceil((minIndex+maxIndex)/2);if(words){str=getString(words,currentIndex)}actualWidth=getSubStringLength(currentIndex,str&&str.length-1);if(minIndex===maxIndex){minIndex=maxIndex+1}else if(actualWidth>width){maxIndex=currentIndex-1}else{minIndex=currentIndex}}if(maxIndex===0){textNode.textContent=""}else if(!(text&&maxIndex===text.length-1)){textNode.textContent=str||getString(text||words,currentIndex)}if(this.ellipsis&&actualWidth>width){this.truncate(textNode,textNode.textContent||"",void 0,0,width,ellipsisWidth,stringWithEllipsis)}}if(words){words.splice(0,currentIndex)}svgElement.actualWidth=actualWidth;svgElement.rotation=rotation}unescapeEntities(inputStr,except){TextBuilder_objectEach(this.renderer.escapes,function(value,key){if(!except||except.indexOf(value)===-1){inputStr=inputStr.toString().replace(new RegExp(value,"g"),key)}});return inputStr}}const SVG_TextBuilder=TextBuilder;const{defaultOptions:SVGRenderer_defaultOptions}=Defaults;const{charts:SVGRenderer_charts,deg2rad:SVGRenderer_deg2rad,doc:SVGRenderer_doc,isFirefox:SVGRenderer_isFirefox,isMS,isWebKit,noop,SVG_NS:SVGRenderer_SVG_NS,symbolSizes,win:SVGRenderer_win}=Core_Globals;const{addEvent:SVGRenderer_addEvent,attr:SVGRenderer_attr,createElement:SVGRenderer_createElement,crisp:SVGRenderer_crisp,css:SVGRenderer_css,defined:SVGRenderer_defined,destroyObjectProperties:SVGRenderer_destroyObjectProperties,extend:SVGRenderer_extend,isArray:SVGRenderer_isArray,isNumber:SVGRenderer_isNumber,isObject:SVGRenderer_isObject,isString:SVGRenderer_isString,merge:SVGRenderer_merge,pick:SVGRenderer_pick,pInt:SVGRenderer_pInt,replaceNested:SVGRenderer_replaceNested,uniqueKey:SVGRenderer_uniqueKey}=Core_Utilities;let hasInternalReferenceBug;class SVGRenderer{constructor(container,width,height,style,forExport,allowHTML,styledMode){const renderer=this,boxWrapper=renderer.createElement("svg").attr({version:"1.1",class:"highcharts-root"}),element=boxWrapper.element;if(!styledMode){boxWrapper.css(this.getStyle(style||{}))}container.appendChild(element);SVGRenderer_attr(container,"dir","ltr");if(container.innerHTML.indexOf("xmlns")===-1){SVGRenderer_attr(element,"xmlns",this.SVG_NS)}this.box=element;this.boxWrapper=boxWrapper;this.alignedObjects=[];this.url=this.getReferenceURL();const desc=this.createElement("desc").add();desc.element.appendChild(SVGRenderer_doc.createTextNode("Created with Highcharts 12.0.2"));this.defs=this.createElement("defs").add();this.allowHTML=allowHTML;this.forExport=forExport;this.styledMode=styledMode;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.rootFontSize=boxWrapper.getStyle("font-size");renderer.setSize(width,height,false);let subPixelFix,rect;if(SVGRenderer_isFirefox&&container.getBoundingClientRect){subPixelFix=function(){SVGRenderer_css(container,{left:0,top:0});rect=container.getBoundingClientRect();SVGRenderer_css(container,{left:Math.ceil(rect.left)-rect.left+"px",top:Math.ceil(rect.top)-rect.top+"px"})};subPixelFix();renderer.unSubPixelFix=SVGRenderer_addEvent(SVGRenderer_win,"resize",subPixelFix)}}definition(def){const ast=new HTML_AST([def]);return ast.addToDOM(this.defs.element)}getReferenceURL(){if((SVGRenderer_isFirefox||isWebKit)&&SVGRenderer_doc.getElementsByTagName("base").length){if(!SVGRenderer_defined(hasInternalReferenceBug)){const id=SVGRenderer_uniqueKey();const ast=new HTML_AST([{tagName:"svg",attributes:{width:8,height:8},children:[{tagName:"defs",children:[{tagName:"clipPath",attributes:{id:id},children:[{tagName:"rect",attributes:{width:4,height:4}}]}]},{tagName:"rect",attributes:{id:"hitme",width:8,height:8,"clip-path":`url(#${id})`,fill:"rgba(0,0,0,0.001)"}}]}]);const svg=ast.addToDOM(SVGRenderer_doc.body);SVGRenderer_css(svg,{position:"fixed",top:0,left:0,zIndex:9e5});const hitElement=SVGRenderer_doc.elementFromPoint(6,6);hasInternalReferenceBug=(hitElement&&hitElement.id)==="hitme";SVGRenderer_doc.body.removeChild(svg)}if(hasInternalReferenceBug){return SVGRenderer_replaceNested(SVGRenderer_win.location.href.split("#")[0],[/<[^>]*>/g,""],[/([\('\)])/g,"\\$1"],[/ /g,"%20"])}}return""}getStyle(style){this.style=SVGRenderer_extend({fontFamily:'-apple-system, BlinkMacSystemFont, "Segoe UI", '+'Roboto, Helvetica, Arial, "Apple Color Emoji", '+'"Segoe UI Emoji", "Segoe UI Symbol", sans-serif',fontSize:"1rem"},style);return this.style}setStyle(style){this.boxWrapper.css(this.getStyle(style))}isHidden(){return!this.boxWrapper.getBBox().width}destroy(){const renderer=this,rendererDefs=renderer.defs;renderer.box=null;renderer.boxWrapper=renderer.boxWrapper.destroy();SVGRenderer_destroyObjectProperties(renderer.gradients||{});renderer.gradients=null;renderer.defs=rendererDefs.destroy();if(renderer.unSubPixelFix){renderer.unSubPixelFix()}renderer.alignedObjects=null;return null}createElement(nodeName){return new this.Element(this,nodeName)}getRadialAttr(radialReference,gradAttr){return{cx:radialReference[0]-radialReference[2]/2+(gradAttr.cx||0)*radialReference[2],cy:radialReference[1]-radialReference[2]/2+(gradAttr.cy||0)*radialReference[2],r:(gradAttr.r||0)*radialReference[2]}}shadowDefinition(shadowOptions){const id=[`highcharts-drop-shadow-${this.chartIndex}`,...Object.keys(shadowOptions).map(key=>`${key}-${shadowOptions[key]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g,""),options=SVGRenderer_merge({color:"#000000",offsetX:1,offsetY:1,opacity:.15,width:5},shadowOptions);if(!this.defs.element.querySelector(`#${id}`)){this.definition({tagName:"filter",attributes:{id:id,filterUnits:options.filterUnits},children:this.getShadowFilterContent(options)})}return id}getShadowFilterContent(options){return[{tagName:"feDropShadow",attributes:{dx:options.offsetX,dy:options.offsetY,"flood-color":options.color,"flood-opacity":Math.min(options.opacity*5,1),stdDeviation:options.width/2}}]}buildText(wrapper){new SVG_TextBuilder(wrapper).buildSVG()}getContrast(color){const rgba=Color_Color.parse(color).rgba.map(b8=>{const c=b8/255;return c<=.03928?c/12.92:Math.pow((c+.055)/1.055,2.4)});const l=.2126*rgba[0]+.7152*rgba[1]+.0722*rgba[2];return 1.05/(l+.05)>(l+.05)/.05?"#FFFFFF":"#000000"}button(text,x,y,callback,theme={},hoverState,selectState,disabledState,shape,useHTML){const label=this.label(text,x,y,shape,void 0,void 0,useHTML,void 0,"button"),styledMode=this.styledMode,args=arguments;let curState=0;theme=SVGRenderer_merge(SVGRenderer_defaultOptions.global.buttonTheme,theme);if(styledMode){delete theme.fill;delete theme.stroke;delete theme["stroke-width"]}const states=theme.states||{},normalStyle=theme.style||{};delete theme.states;delete theme.style;const stateAttribs=[HTML_AST.filterUserAttributes(theme)],stateStyles=[normalStyle];if(!styledMode){["hover","select","disabled"].forEach((stateName,i)=>{stateAttribs.push(SVGRenderer_merge(stateAttribs[0],HTML_AST.filterUserAttributes(args[i+5]||states[stateName]||{})));stateStyles.push(stateAttribs[i+1].style);delete stateAttribs[i+1].style})}SVGRenderer_addEvent(label.element,isMS?"mouseover":"mouseenter",function(){if(curState!==3){label.setState(1)}});SVGRenderer_addEvent(label.element,isMS?"mouseout":"mouseleave",function(){if(curState!==3){label.setState(curState)}});label.setState=(state=0)=>{if(state!==1){label.state=curState=state}label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed","disabled"][state]);if(!styledMode){label.attr(stateAttribs[state]);const css=stateStyles[state];if(SVGRenderer_isObject(css)){label.css(css)}}};label.attr(stateAttribs[0]);if(!styledMode){label.css(SVGRenderer_extend({cursor:"default"},normalStyle));if(useHTML){label.text.css({pointerEvents:"none"})}}return label.on("touchstart",e=>e.stopPropagation()).on("click",function(e){if(curState!==3){callback.call(label,e)}})}crispLine(points,width){const[start,end]=points;if(SVGRenderer_defined(start[1])&&start[1]===end[1]){start[1]=end[1]=SVGRenderer_crisp(start[1],width)}if(SVGRenderer_defined(start[2])&&start[2]===end[2]){start[2]=end[2]=SVGRenderer_crisp(start[2],width)}return points}path(path){const attribs=this.styledMode?{}:{fill:"none"};if(SVGRenderer_isArray(path)){attribs.d=path}else if(SVGRenderer_isObject(path)){SVGRenderer_extend(attribs,path)}return this.createElement("path").attr(attribs)}circle(x,y,r){const attribs=SVGRenderer_isObject(x)?x:typeof x==="undefined"?{}:{x:x,y:y,r:r},wrapper=this.createElement("circle");wrapper.xSetter=wrapper.ySetter=function(value,key,element){element.setAttribute("c"+key,value)};return wrapper.attr(attribs)}arc(x,y,r,innerR,start,end){let options;if(SVGRenderer_isObject(x)){options=x;y=options.y;r=options.r;innerR=options.innerR;start=options.start;end=options.end;x=options.x}else{options={innerR:innerR,start:start,end:end}}const arc=this.symbol("arc",x,y,r,r,options);arc.r=r;return arc}rect(x,y,width,height,r,strokeWidth){const attribs=SVGRenderer_isObject(x)?x:typeof x==="undefined"?{}:{x:x,y:y,r:r,width:Math.max(width||0,0),height:Math.max(height||0,0)},wrapper=this.createElement("rect");if(!this.styledMode){if(typeof strokeWidth!=="undefined"){attribs["stroke-width"]=strokeWidth;SVGRenderer_extend(attribs,wrapper.crisp(attribs))}attribs.fill="none"}wrapper.rSetter=function(value,_key,element){wrapper.r=value;SVGRenderer_attr(element,{rx:value,ry:value})};wrapper.rGetter=function(){return wrapper.r||0};return wrapper.attr(attribs)}roundedRect(attribs){return this.symbol("roundedRect").attr(attribs)}setSize(width,height,animate){const renderer=this;renderer.width=width;renderer.height=height;renderer.boxWrapper.animate({width:width,height:height},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")})},duration:SVGRenderer_pick(animate,true)?void 0:0});renderer.alignElements()}g(name){const elem=this.createElement("g");return name?elem.attr({class:"highcharts-"+name}):elem}image(href,x,y,width,height,onload){const attribs={preserveAspectRatio:"none"};if(SVGRenderer_isNumber(x)){attribs.x=x}if(SVGRenderer_isNumber(y)){attribs.y=y}if(SVGRenderer_isNumber(width)){attribs.width=width}if(SVGRenderer_isNumber(height)){attribs.height=height}const elemWrapper=this.createElement("image").attr(attribs),onDummyLoad=function(e){elemWrapper.attr({href:href});onload.call(elemWrapper,e)};if(onload){elemWrapper.attr({href:"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="});const dummy=new SVGRenderer_win.Image;SVGRenderer_addEvent(dummy,"load",onDummyLoad);dummy.src=href;if(dummy.complete){onDummyLoad({})}}else{elemWrapper.attr({href:href})}return elemWrapper}symbol(symbol,x,y,width,height,options){const ren=this,imageRegex=/^url\((.*?)\)$/,isImage=imageRegex.test(symbol),sym=!isImage&&(this.symbols[symbol]?symbol:"circle"),symbolFn=sym&&this.symbols[sym];let obj,path,imageSrc,centerImage;if(symbolFn){if(typeof x==="number"){path=symbolFn.call(this.symbols,x||0,y||0,width||0,height||0,options)}obj=this.path(path);if(!ren.styledMode){obj.attr("fill","none")}SVGRenderer_extend(obj,{symbolName:sym||void 0,x:x,y:y,width:width,height:height});if(options){SVGRenderer_extend(obj,options)}}else if(isImage){imageSrc=symbol.match(imageRegex)[1];const img=obj=this.image(imageSrc);img.imgwidth=SVGRenderer_pick(options&&options.width,symbolSizes[imageSrc]&&symbolSizes[imageSrc].width);img.imgheight=SVGRenderer_pick(options&&options.height,symbolSizes[imageSrc]&&symbolSizes[imageSrc].height);centerImage=obj=>obj.attr({width:obj.width,height:obj.height});["width","height"].forEach(key=>{img[`${key}Setter`]=function(value,key){this[key]=value;const{alignByTranslate,element,width,height,imgwidth,imgheight}=this,imgSize=key==="width"?imgwidth:imgheight;let scale=1;if(options&&options.backgroundSize==="within"&&width&&height&&imgwidth&&imgheight){scale=Math.min(width/imgwidth,height/imgheight);SVGRenderer_attr(element,{width:Math.round(imgwidth*scale),height:Math.round(imgheight*scale)})}else if(element&&imgSize){element.setAttribute(key,imgSize)}if(!alignByTranslate&&imgwidth&&imgheight){this.translate(((width||0)-imgwidth*scale)/2,((height||0)-imgheight*scale)/2)}}});if(SVGRenderer_defined(x)){img.attr({x:x,y:y})}img.isImg=true;img.symbolUrl=symbol;if(SVGRenderer_defined(img.imgwidth)&&SVGRenderer_defined(img.imgheight)){centerImage(img)}else{img.attr({width:0,height:0});SVGRenderer_createElement("img",{onload:function(){const chart=SVGRenderer_charts[ren.chartIndex];if(this.width===0){SVGRenderer_css(this,{position:"absolute",top:"-999em"});SVGRenderer_doc.body.appendChild(this)}symbolSizes[imageSrc]={width:this.width,height:this.height};img.imgwidth=this.width;img.imgheight=this.height;if(img.element){centerImage(img)}if(this.parentNode){this.parentNode.removeChild(this)}ren.imgCount--;if(!ren.imgCount&&chart&&!chart.hasLoaded){chart.onload()}},src:imageSrc});this.imgCount++}}return obj}clipRect(x,y,width,height){return this.rect(x,y,width,height,0)}text(str,x,y,useHTML){const renderer=this,attribs={};if(useHTML&&(renderer.allowHTML||!renderer.forExport)){return renderer.html(str,x,y)}attribs.x=Math.round(x||0);if(y){attribs.y=Math.round(y)}if(SVGRenderer_defined(str)){attribs.text=str}const wrapper=renderer.createElement("text").attr(attribs);if(!useHTML||renderer.forExport&&!renderer.allowHTML){wrapper.xSetter=function(value,key,element){const tspans=element.getElementsByTagName("tspan"),parentVal=element.getAttribute(key);for(let i=0,tspan;i<tspans.length;i++){tspan=tspans[i];if(tspan.getAttribute(key)===parentVal){tspan.setAttribute(key,value)}}element.setAttribute(key,value)}}return wrapper}fontMetrics(element){const f=SVGRenderer_pInt(SVG_SVGElement.prototype.getStyle.call(element,"font-size")||0);const h=f<24?f+3:Math.round(f*1.2),b=Math.round(h*.8);return{h:h,b:b,f:f}}rotCorr(baseline,rotation,alterY){let y=baseline;if(rotation&&alterY){y=Math.max(y*Math.cos(rotation*SVGRenderer_deg2rad),4)}return{x:-baseline/3*Math.sin(rotation*SVGRenderer_deg2rad),y:y}}pathToSegments(path){const ret=[];const segment=[];const commandLength={A:8,C:7,H:2,L:3,M:3,Q:5,S:5,T:3,V:2};for(let i=0;i<path.length;i++){if(SVGRenderer_isString(segment[0])&&SVGRenderer_isNumber(path[i])&&segment.length===commandLength[segment[0].toUpperCase()]){path.splice(i,0,segment[0].replace("M","L").replace("m","l"))}if(typeof path[i]==="string"){if(segment.length){ret.push(segment.slice(0))}segment.length=0}segment.push(path[i])}ret.push(segment.slice(0));return ret}label(str,x,y,shape,anchorX,anchorY,useHTML,baseline,className){return new SVG_SVGLabel(this,str,x,y,shape,anchorX,anchorY,useHTML,baseline,className)}alignElements(){this.alignedObjects.forEach(el=>el.align())}}SVGRenderer_extend(SVGRenderer.prototype,{Element:SVG_SVGElement,SVG_NS:SVGRenderer_SVG_NS,escapes:{"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},symbols:SVG_Symbols,draw:noop});Renderer_RendererRegistry.registerRendererType("svg",SVGRenderer,true);const SVG_SVGRenderer=SVGRenderer;"";const{composed}=Core_Globals;const{attr:HTMLElement_attr,css:HTMLElement_css,createElement:HTMLElement_createElement,defined:HTMLElement_defined,extend:HTMLElement_extend,getAlignFactor:HTMLElement_getAlignFactor,isNumber:HTMLElement_isNumber,pInt:HTMLElement_pInt,pushUnique:HTMLElement_pushUnique}=Core_Utilities;function commonSetter(value,key,elem){const style=this.div?.style||elem.style;SVG_SVGElement.prototype[`${key}Setter`].call(this,value,key,elem);if(style){style[key]=value}}const decorateSVGGroup=(g,container)=>{if(!g.div){const className=HTMLElement_attr(g.element,"class"),cssProto=g.css;const div=HTMLElement_createElement("div",className?{className:className}:void 0,{position:"absolute",left:`${g.translateX||0}px`,top:`${g.translateY||0}px`,...g.styles,display:g.display,opacity:g.opacity,visibility:g.visibility},g.parentGroup?.div||container);g.classSetter=(value,key,element)=>{element.setAttribute("class",value);div.className=value};g.translateXSetter=g.translateYSetter=(value,key)=>{g[key]=value;div.style[key==="translateX"?"left":"top"]=`${value}px`;g.doTransform=true};g.opacitySetter=g.visibilitySetter=commonSetter;g.css=styles=>{cssProto.call(g,styles);if(styles.cursor){div.style.cursor=styles.cursor}if(styles.pointerEvents){div.style.pointerEvents=styles.pointerEvents}return g};g.on=function(){SVG_SVGElement.prototype.on.apply({element:div,onEvents:g.onEvents},arguments);return g};g.div=div}return g.div};class HTMLElement extends SVG_SVGElement{static compose(SVGRendererClass){if(HTMLElement_pushUnique(composed,this.compose)){SVGRendererClass.prototype.html=function(str,x,y){return new HTMLElement(this,"span").attr({text:str,x:Math.round(x),y:Math.round(y)})}}}constructor(renderer,nodeName){super(renderer,nodeName);this.css({position:"absolute",...renderer.styledMode?{}:{fontFamily:renderer.style.fontFamily,fontSize:renderer.style.fontSize}})}getSpanCorrection(width,baseline,alignCorrection){this.xCorr=-width*alignCorrection;this.yCorr=-baseline}css(styles){const{element}=this,isSettingWidth=element.tagName==="SPAN"&&styles&&"width"in styles,textWidth=isSettingWidth&&styles.width;let doTransform;if(isSettingWidth){delete styles.width;this.textWidth=HTMLElement_pInt(textWidth)||void 0;doTransform=true}if(styles?.textOverflow==="ellipsis"){styles.overflow="hidden"}if(styles?.lineClamp){styles.display="-webkit-box";styles.WebkitLineClamp=styles.lineClamp;styles.WebkitBoxOrient="vertical";styles.overflow="hidden"}if(HTMLElement_isNumber(Number(styles?.fontSize))){styles.fontSize=styles.fontSize+"px"}HTMLElement_extend(this.styles,styles);HTMLElement_css(element,styles);if(doTransform){this.updateTransform()}return this}htmlGetBBox(){const{element}=this;return{x:element.offsetLeft,y:element.offsetTop,width:element.offsetWidth,height:element.offsetHeight}}updateTransform(){if(!this.added){this.alignOnAdd=true;return}const{element,renderer,rotation,rotationOriginX,rotationOriginY,scaleX,scaleY,styles,textAlign="left",textWidth,translateX=0,translateY=0,x=0,y=0}=this,{display="block",whiteSpace}=styles;const getTextPxLength=()=>{if(this.textPxLength){return this.textPxLength}HTMLElement_css(element,{width:"",whiteSpace:whiteSpace||"nowrap"});return element.offsetWidth};HTMLElement_css(element,{marginLeft:`${translateX}px`,marginTop:`${translateY}px`});if(element.tagName==="SPAN"){const currentTextTransform=[rotation,textAlign,element.innerHTML,textWidth,this.textAlign].join(","),parentPadding=this.parentGroup?.padding*-1||0;let baseline,hasBoxWidthChanged=false;if(textWidth!==this.oldTextWidth){const textPxLength=getTextPxLength(),textWidthNum=textWidth||0;if((textWidthNum>this.oldTextWidth||textPxLength>textWidthNum)&&(/[ \-]/.test(element.textContent||element.innerText)||element.style.textOverflow==="ellipsis")){HTMLElement_css(element,{width:textPxLength>textWidthNum||rotation||scaleX?textWidth+"px":"auto",display:display,whiteSpace:whiteSpace||"normal"});this.oldTextWidth=textWidth;hasBoxWidthChanged=true}}this.hasBoxWidthChanged=hasBoxWidthChanged;if(currentTextTransform!==this.cTT){baseline=renderer.fontMetrics(element).b;if(HTMLElement_defined(rotation)&&(rotation!==(this.oldRotation||0)||textAlign!==this.oldAlign)){this.setSpanRotation(rotation,parentPadding,parentPadding)}this.getSpanCorrection(!HTMLElement_defined(rotation)&&!this.textWidth&&this.textPxLength||element.offsetWidth,baseline,HTMLElement_getAlignFactor(textAlign))}const{xCorr=0,yCorr=0}=this,rotOriginX=(rotationOriginX??x)-xCorr-x-parentPadding,rotOriginY=(rotationOriginY??y)-yCorr-y-parentPadding,styles={left:`${x+xCorr}px`,top:`${y+yCorr}px`,textAlign:textAlign,transformOrigin:`${rotOriginX}px ${rotOriginY}px`};if(scaleX||scaleY){styles.transform=`scale(${scaleX??1},${scaleY??1})`}HTMLElement_css(element,styles);this.cTT=currentTextTransform;this.oldRotation=rotation;this.oldAlign=textAlign}}setSpanRotation(rotation,originX,originY){HTMLElement_css(this.element,{transform:`rotate(${rotation}deg)`,transformOrigin:`${originX}% ${originY}px`})}add(parentGroup){const container=this.renderer.box.parentNode,parents=[];let div;this.parentGroup=parentGroup;if(parentGroup){div=parentGroup.div;if(!div){let svgGroup=parentGroup;while(svgGroup){parents.push(svgGroup);svgGroup=svgGroup.parentGroup}for(const parentGroup of parents.reverse()){div=decorateSVGGroup(parentGroup,container)}}}(div||container).appendChild(this.element);this.added=true;if(this.alignOnAdd){this.updateTransform()}return this}textSetter(value){if(value!==this.textStr){delete this.bBox;delete this.oldTextWidth;HTML_AST.setElementHTML(this.element,value??"");this.textStr=value;this.doTransform=true}}alignSetter(value){this.alignValue=this.textAlign=value;this.doTransform=true}xSetter(value,key){this[key]=value;this.doTransform=true}}const proto=HTMLElement.prototype;proto.visibilitySetter=proto.opacitySetter=commonSetter;proto.ySetter=proto.rotationSetter=proto.rotationOriginXSetter=proto.rotationOriginYSetter=proto.xSetter;const HTML_HTMLElement=HTMLElement;var AxisDefaults;(function(AxisDefaults){AxisDefaults.xAxis={alignTicks:true,allowDecimals:void 0,panningEnabled:true,zIndex:2,zoomEnabled:true,dateTimeLabelFormats:{millisecond:{main:"%[HMSL]",range:false},second:{main:"%[HMS]",range:false},minute:{main:"%[HM]",range:false},hour:{main:"%[HM]",range:false},day:{main:"%[eb]"},week:{main:"%[eb]"},month:{main:"%[bY]"},year:{main:"%Y"}},endOnTick:false,gridLineDashStyle:"Solid",gridZIndex:1,labels:{autoRotationLimit:80,distance:15,enabled:true,indentation:10,overflow:"justify",reserveSpace:void 0,rotation:void 0,staggerLines:0,step:0,useHTML:false,zIndex:7,style:{color:"#333333",cursor:"default",fontSize:"0.8em",textOverflow:"ellipsis"}},maxPadding:.01,minorGridLineDashStyle:"Solid",minorTickLength:2,minorTickPosition:"outside",minorTicksPerMajor:5,minPadding:.01,offset:void 0,reversed:void 0,reversedStacks:false,showEmpty:true,showFirstLabel:true,showLastLabel:true,startOfWeek:1,startOnTick:false,tickLength:10,tickPixelInterval:100,tickmarkPlacement:"between",tickPosition:"outside",title:{align:"middle",useHTML:false,x:0,y:0,style:{color:"#666666",fontSize:"0.8em"}},visible:true,minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#333333",lineWidth:1,gridLineColor:"#e6e6e6",gridLineWidth:void 0,tickColor:"#333333"};AxisDefaults.yAxis={reversedStacks:true,endOnTick:true,maxPadding:.05,minPadding:.05,tickPixelInterval:72,showLastLabel:true,labels:{x:void 0},startOnTick:true,title:{text:"Values"},stackLabels:{animation:{},allowOverlap:false,enabled:false,crop:true,overflow:"justify",formatter:function(){const{numberFormatter}=this.axis.chart;return numberFormatter(this.total||0,-1)},style:{color:"#000000",fontSize:"0.7em",fontWeight:"bold",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0}})(AxisDefaults||(AxisDefaults={}));const Axis_AxisDefaults=AxisDefaults;const{addEvent:Foundation_addEvent,isFunction:Foundation_isFunction,objectEach:Foundation_objectEach,removeEvent:Foundation_removeEvent}=Core_Utilities;var Foundation;(function(Foundation){function registerEventOptions(component,options){component.eventOptions=component.eventOptions||{};Foundation_objectEach(options.events,function(event,eventType){if(component.eventOptions[eventType]!==event){if(component.eventOptions[eventType]){Foundation_removeEvent(component,eventType,component.eventOptions[eventType]);delete component.eventOptions[eventType]}if(Foundation_isFunction(event)){component.eventOptions[eventType]=event;Foundation_addEvent(component,eventType,event,{order:0})}}})}Foundation.registerEventOptions=registerEventOptions})(Foundation||(Foundation={}));const Core_Foundation=Foundation;const{deg2rad:Tick_deg2rad}=Core_Globals;const{clamp:Tick_clamp,correctFloat:Tick_correctFloat,defined:Tick_defined,destroyObjectProperties:Tick_destroyObjectProperties,extend:Tick_extend,fireEvent:Tick_fireEvent,getAlignFactor:Tick_getAlignFactor,isNumber:Tick_isNumber,merge:Tick_merge,objectEach:Tick_objectEach,pick:Tick_pick}=Core_Utilities;class Tick{constructor(axis,pos,type,noLabel,parameters){this.isNew=true;this.isNewLabel=true;this.axis=axis;this.pos=pos;this.type=type||"";this.parameters=parameters||{};this.tickmarkOffset=this.parameters.tickmarkOffset;this.options=this.parameters.options;Tick_fireEvent(this,"init");if(!type&&!noLabel){this.addLabel()}}addLabel(){const tick=this,axis=tick.axis,options=axis.options,chart=axis.chart,categories=axis.categories,log=axis.logarithmic,names=axis.names,pos=tick.pos,labelOptions=Tick_pick(tick.options&&tick.options.labels,options.labels),tickPositions=axis.tickPositions,isFirst=pos===tickPositions[0],isLast=pos===tickPositions[tickPositions.length-1],animateLabels=(!labelOptions.step||labelOptions.step===1)&&axis.tickInterval===1,tickPositionInfo=tickPositions.info;let label=tick.label,dateTimeLabelFormat,dateTimeLabelFormats,i;let value=this.parameters.category||(categories?Tick_pick(categories[pos],names[pos],pos):pos);if(log&&Tick_isNumber(value)){value=Tick_correctFloat(log.lin2log(value))}if(axis.dateTime){if(tickPositionInfo){dateTimeLabelFormats=chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid&&tickPositionInfo.higherRanks[pos]||tickPositionInfo.unitName]);dateTimeLabelFormat=dateTimeLabelFormats.main}else if(Tick_isNumber(value)){dateTimeLabelFormat=axis.dateTime.getXDateFormat(value,options.dateTimeLabelFormats||{})}}tick.isFirst=isFirst;tick.isLast=isLast;const ctx={axis:axis,chart:chart,dateTimeLabelFormat:dateTimeLabelFormat,isFirst:isFirst,isLast:isLast,pos:pos,tick:tick,tickPositionInfo:tickPositionInfo,value:value};Tick_fireEvent(this,"labelFormat",ctx);const labelFormatter=ctx=>{if(labelOptions.formatter){return labelOptions.formatter.call(ctx,ctx)}if(labelOptions.format){ctx.text=axis.defaultLabelFormatter.call(ctx);return Core_Templating.format(labelOptions.format,ctx,chart)}return axis.defaultLabelFormatter.call(ctx)};const str=labelFormatter.call(ctx,ctx);const list=dateTimeLabelFormats&&dateTimeLabelFormats.list;if(list){tick.shortenLabel=function(){for(i=0;i<list.length;i++){Tick_extend(ctx,{dateTimeLabelFormat:list[i]});label.attr({text:labelFormatter.call(ctx,ctx)});if(label.getBBox().width<axis.getSlotWidth(tick)-2*(labelOptions.padding||0)){return}}label.attr({text:""})}}else{tick.shortenLabel=void 0}if(animateLabels&&axis._addedPlotLB){tick.moveLabel(str,labelOptions)}if(!Tick_defined(label)&&!tick.movedLabel){tick.label=label=tick.createLabel(str,labelOptions);tick.rotation=0}else if(label&&label.textStr!==str&&!animateLabels){if(label.textWidth&&!labelOptions.style.width&&!label.styles.width){label.css({width:null})}label.attr({text:str});label.textPxLength=label.getBBox().width}}createLabel(str,labelOptions,xy){const axis=this.axis,{renderer,styledMode}=axis.chart,label=Tick_defined(str)&&labelOptions.enabled?renderer.text(str,xy?.x,xy?.y,labelOptions.useHTML).add(axis.labelGroup):void 0;if(label){const whiteSpace=labelOptions.style.whiteSpace||"normal";if(!styledMode){label.css(Tick_merge(labelOptions.style,{whiteSpace:"nowrap"}))}label.textPxLength=label.getBBox().width;if(!styledMode){label.css({whiteSpace:whiteSpace})}}return label}destroy(){Tick_destroyObjectProperties(this,this.axis)}getPosition(horiz,tickPos,tickmarkOffset,old){const axis=this.axis,chart=axis.chart,cHeight=old&&chart.oldChartHeight||chart.chartHeight,pos={x:horiz?Tick_correctFloat(axis.translate(tickPos+tickmarkOffset,void 0,void 0,old)+axis.transB):axis.left+axis.offset+(axis.opposite?(old&&chart.oldChartWidth||chart.chartWidth)-axis.right-axis.left:0),y:horiz?cHeight-axis.bottom+axis.offset-(axis.opposite?axis.height:0):Tick_correctFloat(cHeight-axis.translate(tickPos+tickmarkOffset,void 0,void 0,old)-axis.transB)};pos.y=Tick_clamp(pos.y,-1e9,1e9);Tick_fireEvent(this,"afterGetPosition",{pos:pos});return pos}getLabelPosition(x,y,label,horiz,labelOptions,tickmarkOffset,index,step){const axis=this.axis,transA=axis.transA,reversed=axis.isLinked&&axis.linkedParent?axis.linkedParent.reversed:axis.reversed,staggerLines=axis.staggerLines,rotCorr=axis.tickRotCorr||{x:0,y:0},labelOffsetCorrection=!horiz&&!axis.reserveSpaceDefault?-axis.labelOffset*(axis.labelAlign==="center"?.5:1):0,distance=labelOptions.distance,pos={};let yOffset,line;if(axis.side===0){yOffset=label.rotation?-distance:-label.getBBox().height}else if(axis.side===2){yOffset=rotCorr.y+distance}else{yOffset=Math.cos(label.rotation*Tick_deg2rad)*(rotCorr.y-label.getBBox(false,0).height/2)}if(Tick_defined(labelOptions.y)){yOffset=axis.side===0&&axis.horiz?labelOptions.y+yOffset:labelOptions.y}x=x+Tick_pick(labelOptions.x,[0,1,0,-1][axis.side]*distance)+labelOffsetCorrection+rotCorr.x-(tickmarkOffset&&horiz?tickmarkOffset*transA*(reversed?-1:1):0);y=y+yOffset-(tickmarkOffset&&!horiz?tickmarkOffset*transA*(reversed?1:-1):0);if(staggerLines){line=index/(step||1)%staggerLines;if(axis.opposite){line=staggerLines-line-1}y+=line*(axis.labelOffset/staggerLines)}pos.x=x;pos.y=Math.round(y);Tick_fireEvent(this,"afterGetLabelPosition",{pos:pos,tickmarkOffset:tickmarkOffset,index:index});return pos}getLabelSize(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0}getMarkPath(x,y,tickLength,tickWidth,horiz=false,renderer){return renderer.crispLine([["M",x,y],["L",x+(horiz?0:-tickLength),y+(horiz?tickLength:0)]],tickWidth)}handleOverflow(xy){const tick=this,axis=this.axis,labelOptions=axis.options.labels,pxPos=xy.x,chartWidth=axis.chart.chartWidth,spacing=axis.chart.spacing,leftBound=Tick_pick(axis.labelLeft,Math.min(axis.pos,spacing[3])),rightBound=Tick_pick(axis.labelRight,Math.max(!axis.isRadial?axis.pos+axis.len:0,chartWidth-spacing[1])),label=this.label,rotation=this.rotation,factor=Tick_getAlignFactor(axis.labelAlign||label.attr("align")),labelWidth=label.getBBox().width,slotWidth=axis.getSlotWidth(tick),xCorrection=factor,css={};let modifiedSlotWidth=slotWidth,goRight=1,leftPos,rightPos,textWidth;if(!rotation&&labelOptions.overflow==="justify"){leftPos=pxPos-factor*labelWidth;rightPos=pxPos+(1-factor)*labelWidth;if(leftPos<leftBound){modifiedSlotWidth=xy.x+modifiedSlotWidth*(1-factor)-leftBound}else if(rightPos>rightBound){modifiedSlotWidth=rightBound-xy.x+modifiedSlotWidth*factor;goRight=-1}modifiedSlotWidth=Math.min(slotWidth,modifiedSlotWidth);if(modifiedSlotWidth<slotWidth&&axis.labelAlign==="center"){xy.x+=goRight*(slotWidth-modifiedSlotWidth-xCorrection*(slotWidth-Math.min(labelWidth,modifiedSlotWidth)))}if(labelWidth>modifiedSlotWidth||axis.autoRotation&&(label.styles||{}).width){textWidth=modifiedSlotWidth}}else if(rotation<0&&pxPos-factor*labelWidth<leftBound){textWidth=Math.round(pxPos/Math.cos(rotation*Tick_deg2rad)-leftBound)}else if(rotation>0&&pxPos+factor*labelWidth>rightBound){textWidth=Math.round((chartWidth-pxPos)/Math.cos(rotation*Tick_deg2rad))}if(textWidth&&label){if(tick.shortenLabel){tick.shortenLabel()}else{label.css(Tick_extend(css,{width:Math.floor(textWidth)+"px",lineClamp:axis.isRadial?0:1}))}}}moveLabel(str,labelOptions){const tick=this,label=tick.label,axis=tick.axis;let moved=false,labelPos;if(label&&label.textStr===str){tick.movedLabel=label;moved=true;delete tick.label}else{Tick_objectEach(axis.ticks,function(currentTick){if(!moved&&!currentTick.isNew&&currentTick!==tick&&currentTick.label&&currentTick.label.textStr===str){tick.movedLabel=currentTick.label;moved=true;currentTick.labelPos=tick.movedLabel.xy;delete currentTick.label}})}if(!moved&&(tick.labelPos||label)){labelPos=tick.labelPos||label.xy;tick.movedLabel=tick.createLabel(str,labelOptions,labelPos);if(tick.movedLabel){tick.movedLabel.attr({opacity:0})}}}render(index,old,opacity){const tick=this,axis=tick.axis,horiz=axis.horiz,pos=tick.pos,tickmarkOffset=Tick_pick(tick.tickmarkOffset,axis.tickmarkOffset),xy=tick.getPosition(horiz,pos,tickmarkOffset,old),x=xy.x,y=xy.y,axisStart=axis.pos,axisEnd=axisStart+axis.len,pxPos=horiz?x:y;if(!axis.chart.polar&&tick.isNew&&(Tick_correctFloat(pxPos)<axisStart||pxPos>axisEnd)){opacity=0}const labelOpacity=Tick_pick(opacity,tick.label&&tick.label.newOpacity,1);opacity=Tick_pick(opacity,1);this.isActive=true;this.renderGridLine(old,opacity);this.renderMark(xy,opacity);this.renderLabel(xy,old,labelOpacity,index);tick.isNew=false;Tick_fireEvent(this,"afterRender")}renderGridLine(old,opacity){const tick=this,axis=tick.axis,options=axis.options,attribs={},pos=tick.pos,type=tick.type,tickmarkOffset=Tick_pick(tick.tickmarkOffset,axis.tickmarkOffset),renderer=axis.chart.renderer;let gridLine=tick.gridLine,gridLinePath,gridLineWidth=options.gridLineWidth,gridLineColor=options.gridLineColor,dashStyle=options.gridLineDashStyle;if(tick.type==="minor"){gridLineWidth=options.minorGridLineWidth;gridLineColor=options.minorGridLineColor;dashStyle=options.minorGridLineDashStyle}if(!gridLine){if(!axis.chart.styledMode){attribs.stroke=gridLineColor;attribs["stroke-width"]=gridLineWidth||0;attribs.dashstyle=dashStyle}if(!type){attribs.zIndex=1}if(old){opacity=0}tick.gridLine=gridLine=renderer.path().attr(attribs).addClass("highcharts-"+(type?type+"-":"")+"grid-line").add(axis.gridGroup)}if(gridLine){gridLinePath=axis.getPlotLinePath({value:pos+tickmarkOffset,lineWidth:gridLine.strokeWidth(),force:"pass",old:old,acrossPanes:false});if(gridLinePath){gridLine[old||tick.isNew?"attr":"animate"]({d:gridLinePath,opacity:opacity})}}}renderMark(xy,opacity){const tick=this,axis=tick.axis,options=axis.options,renderer=axis.chart.renderer,type=tick.type,tickSize=axis.tickSize(type?type+"Tick":"tick"),x=xy.x,y=xy.y,tickWidth=Tick_pick(options[type!=="minor"?"tickWidth":"minorTickWidth"],!type&&axis.isXAxis?1:0),tickColor=options[type!=="minor"?"tickColor":"minorTickColor"];let mark=tick.mark;const isNewMark=!mark;if(tickSize){if(axis.opposite){tickSize[0]=-tickSize[0]}if(!mark){tick.mark=mark=renderer.path().addClass("highcharts-"+(type?type+"-":"")+"tick").add(axis.axisGroup);if(!axis.chart.styledMode){mark.attr({stroke:tickColor,"stroke-width":tickWidth})}}mark[isNewMark?"attr":"animate"]({d:tick.getMarkPath(x,y,tickSize[0],mark.strokeWidth(),axis.horiz,renderer),opacity:opacity})}}renderLabel(xy,old,opacity,index){const tick=this,axis=tick.axis,horiz=axis.horiz,options=axis.options,label=tick.label,labelOptions=options.labels,step=labelOptions.step,tickmarkOffset=Tick_pick(tick.tickmarkOffset,axis.tickmarkOffset),x=xy.x,y=xy.y;let show=true;if(label&&Tick_isNumber(x)){label.xy=xy=tick.getLabelPosition(x,y,label,horiz,labelOptions,tickmarkOffset,index,step);if(tick.isFirst&&!tick.isLast&&!options.showFirstLabel||tick.isLast&&!tick.isFirst&&!options.showLastLabel){show=false}else if(horiz&&!labelOptions.step&&!labelOptions.rotation&&!old&&opacity!==0){tick.handleOverflow(xy)}if(step&&index%step){show=false}if(show&&Tick_isNumber(xy.y)){xy.opacity=opacity;label[tick.isNewLabel?"attr":"animate"](xy).show(true);tick.isNewLabel=false}else{label.hide();tick.isNewLabel=true}}}replaceMovedLabel(){const tick=this,label=tick.label,axis=tick.axis;if(label&&!tick.isNew){label.animate({opacity:0},void 0,label.destroy);delete tick.label}axis.isDirty=true;tick.label=tick.movedLabel;delete tick.movedLabel}}const Axis_Tick=Tick;"";const{animObject:Axis_animObject}=AnimationUtilities;const{xAxis,yAxis}=Axis_AxisDefaults;const{defaultOptions:Axis_defaultOptions}=Defaults;const{registerEventOptions}=Core_Foundation;const{deg2rad:Axis_deg2rad}=Core_Globals;const{arrayMax:Axis_arrayMax,arrayMin:Axis_arrayMin,clamp:Axis_clamp,correctFloat:Axis_correctFloat,defined:Axis_defined,destroyObjectProperties:Axis_destroyObjectProperties,erase:Axis_erase,error:Axis_error,extend:Axis_extend,fireEvent:Axis_fireEvent,getClosestDistance:Axis_getClosestDistance,insertItem:Axis_insertItem,isArray:Axis_isArray,isNumber:Axis_isNumber,isString:Axis_isString,merge:Axis_merge,normalizeTickInterval:Axis_normalizeTickInterval,objectEach:Axis_objectEach,pick:Axis_pick,relativeLength:Axis_relativeLength,removeEvent:Axis_removeEvent,splat:Axis_splat,syncTimeout:Axis_syncTimeout}=Core_Utilities;const getNormalizedTickInterval=(axis,tickInterval)=>Axis_normalizeTickInterval(tickInterval,void 0,void 0,Axis_pick(axis.options.allowDecimals,tickInterval<.5||axis.tickAmount!==void 0),!!axis.tickAmount);Axis_extend(Axis_defaultOptions,{xAxis:xAxis,yAxis:Axis_merge(xAxis,yAxis)});class Axis{constructor(chart,userOptions,coll){this.init(chart,userOptions,coll)}init(chart,userOptions,coll=this.coll){const isXAxis=coll==="xAxis",axis=this,horiz=axis.isZAxis||(chart.inverted?!isXAxis:isXAxis);axis.chart=chart;axis.horiz=horiz;axis.isXAxis=isXAxis;axis.coll=coll;Axis_fireEvent(this,"init",{userOptions:userOptions});axis.opposite=Axis_pick(userOptions.opposite,axis.opposite);axis.side=Axis_pick(userOptions.side,axis.side,horiz?axis.opposite?0:2:axis.opposite?1:3);axis.setOptions(userOptions);const options=axis.options,labelsOptions=options.labels;axis.type??(axis.type=options.type||"linear");axis.uniqueNames??(axis.uniqueNames=options.uniqueNames??true);Axis_fireEvent(axis,"afterSetType");axis.userOptions=userOptions;axis.minPixelPadding=0;axis.reversed=Axis_pick(options.reversed,axis.reversed);axis.visible=options.visible;axis.zoomEnabled=options.zoomEnabled;axis.hasNames=this.type==="category"||options.categories===true;axis.categories=Axis_isArray(options.categories)&&options.categories||(axis.hasNames?[]:void 0);if(!axis.names){axis.names=[];axis.names.keys={}}axis.plotLinesAndBandsGroups={};axis.positiveValuesOnly=!!axis.logarithmic;axis.isLinked=Axis_defined(options.linkedTo);axis.ticks={};axis.labelEdge=[];axis.minorTicks={};axis.plotLinesAndBands=[];axis.alternateBands={};axis.len??(axis.len=0);axis.minRange=axis.userMinRange=options.minRange||options.maxZoom;axis.range=options.range;axis.offset=options.offset||0;axis.max=void 0;axis.min=void 0;const crosshair=Axis_pick(options.crosshair,Axis_splat(chart.options.tooltip.crosshairs)[isXAxis?0:1]);axis.crosshair=crosshair===true?{}:crosshair;if(chart.axes.indexOf(axis)===-1){if(isXAxis){chart.axes.splice(chart.xAxis.length,0,axis)}else{chart.axes.push(axis)}Axis_insertItem(this,chart[this.coll])}chart.orderItems(axis.coll);axis.series=axis.series||[];if(chart.inverted&&!axis.isZAxis&&isXAxis&&!Axis_defined(axis.reversed)){axis.reversed=true}axis.labelRotation=Axis_isNumber(labelsOptions.rotation)?labelsOptions.rotation:void 0;registerEventOptions(axis,options);Axis_fireEvent(this,"afterInit")}setOptions(userOptions){const sideSpecific=this.horiz?{labels:{autoRotation:[-45],padding:3},margin:15}:{labels:{padding:1},title:{rotation:90*this.side}};this.options=Axis_merge(sideSpecific,Axis_defaultOptions[this.coll],userOptions);Axis_fireEvent(this,"afterSetOptions",{userOptions:userOptions})}defaultLabelFormatter(){const axis=this.axis,chart=this.chart,{numberFormatter}=chart,value=Axis_isNumber(this.value)?this.value:NaN,time=axis.chart.time,categories=axis.categories,dateTimeLabelFormat=this.dateTimeLabelFormat,lang=Axis_defaultOptions.lang,numericSymbols=lang.numericSymbols,numSymMagnitude=lang.numericSymbolMagnitude||1e3,numericSymbolDetector=axis.logarithmic?Math.abs(value):axis.tickInterval;let i=numericSymbols&&numericSymbols.length,multi,ret;if(categories){ret=`${this.value}`}else if(dateTimeLabelFormat){ret=time.dateFormat(dateTimeLabelFormat,value,true)}else if(i&&numericSymbols&&numericSymbolDetector>=1e3){while(i--&&typeof ret==="undefined"){multi=Math.pow(numSymMagnitude,i+1);if(numericSymbolDetector>=multi&&value*10%multi===0&&numericSymbols[i]!==null&&value!==0){ret=numberFormatter(value/multi,-1)+numericSymbols[i]}}}if(typeof ret==="undefined"){if(Math.abs(value)>=1e4){ret=numberFormatter(value,-1)}else{ret=numberFormatter(value,-1,void 0,"")}}return ret}getSeriesExtremes(){const axis=this;let xExtremes;Axis_fireEvent(this,"getSeriesExtremes",null,function(){axis.hasVisibleSeries=false;axis.dataMin=axis.dataMax=axis.threshold=void 0;axis.softThreshold=!axis.isXAxis;axis.series.forEach(series=>{if(series.reserveSpace()){const seriesOptions=series.options;let xData,threshold=seriesOptions.threshold,seriesDataMin,seriesDataMax;axis.hasVisibleSeries=true;if(axis.positiveValuesOnly&&(threshold||0)<=0){threshold=void 0}if(axis.isXAxis){xData=series.getColumn("x");if(xData.length){xData=axis.logarithmic?xData.filter(x=>x>0):xData;xExtremes=series.getXExtremes(xData);seriesDataMin=xExtremes.min;seriesDataMax=xExtremes.max;if(!Axis_isNumber(seriesDataMin)&&!(seriesDataMin instanceof Date)){xData=xData.filter(Axis_isNumber);xExtremes=series.getXExtremes(xData);seriesDataMin=xExtremes.min;seriesDataMax=xExtremes.max}if(xData.length){axis.dataMin=Math.min(Axis_pick(axis.dataMin,seriesDataMin),seriesDataMin);axis.dataMax=Math.max(Axis_pick(axis.dataMax,seriesDataMax),seriesDataMax)}}}else{const dataExtremes=series.applyExtremes();if(Axis_isNumber(dataExtremes.dataMin)){seriesDataMin=dataExtremes.dataMin;axis.dataMin=Math.min(Axis_pick(axis.dataMin,seriesDataMin),seriesDataMin)}if(Axis_isNumber(dataExtremes.dataMax)){seriesDataMax=dataExtremes.dataMax;axis.dataMax=Math.max(Axis_pick(axis.dataMax,seriesDataMax),seriesDataMax)}if(Axis_defined(threshold)){axis.threshold=threshold}if(!seriesOptions.softThreshold||axis.positiveValuesOnly){axis.softThreshold=false}}}})});Axis_fireEvent(this,"afterGetSeriesExtremes")}translate(val,backwards,cvsCoord,old,handleLog,pointPlacement){const axis=this.linkedParent||this,localMin=old&&axis.old?axis.old.min:axis.min;if(!Axis_isNumber(localMin)){return NaN}const minPixelPadding=axis.minPixelPadding,doPostTranslate=(axis.isOrdinal||axis.brokenAxis?.hasBreaks||axis.logarithmic&&handleLog)&&axis.lin2val;let sign=1,cvsOffset=0,localA=old&&axis.old?axis.old.transA:axis.transA,returnValue=0;if(!localA){localA=axis.transA}if(cvsCoord){sign*=-1;cvsOffset=axis.len}if(axis.reversed){sign*=-1;cvsOffset-=sign*(axis.sector||axis.len)}if(backwards){val=val*sign+cvsOffset;val-=minPixelPadding;returnValue=val/localA+localMin;if(doPostTranslate){returnValue=axis.lin2val(returnValue)}}else{if(doPostTranslate){val=axis.val2lin(val)}const value=sign*(val-localMin)*localA;returnValue=value+cvsOffset+sign*minPixelPadding+(Axis_isNumber(pointPlacement)?localA*pointPlacement:0);if(!axis.isRadial){returnValue=Axis_correctFloat(returnValue)}}return returnValue}toPixels(value,paneCoordinates){return this.translate(this.chart?.time.parse(value)??NaN,false,!this.horiz,void 0,true)+(paneCoordinates?0:this.pos)}toValue(pixel,paneCoordinates){return this.translate(pixel-(paneCoordinates?0:this.pos),true,!this.horiz,void 0,true)}getPlotLinePath(options){const axis=this,chart=axis.chart,axisLeft=axis.left,axisTop=axis.top,old=options.old,value=options.value,lineWidth=options.lineWidth,cHeight=old&&chart.oldChartHeight||chart.chartHeight,cWidth=old&&chart.oldChartWidth||chart.chartWidth,transB=axis.transB;let translatedValue=options.translatedValue,force=options.force,x1,y1,x2,y2,skip;function between(x,a,b){if(force!=="pass"&&(x<a||x>b)){if(force){x=Axis_clamp(x,a,b)}else{skip=true}}return x}const evt={value:value,lineWidth:lineWidth,old:old,force:force,acrossPanes:options.acrossPanes,translatedValue:translatedValue};Axis_fireEvent(this,"getPlotLinePath",evt,function(e){translatedValue=Axis_pick(translatedValue,axis.translate(value,void 0,void 0,old));translatedValue=Axis_clamp(translatedValue,-1e9,1e9);x1=x2=translatedValue+transB;y1=y2=cHeight-translatedValue-transB;if(!Axis_isNumber(translatedValue)){skip=true;force=false}else if(axis.horiz){y1=axisTop;y2=cHeight-axis.bottom+(axis.options.isInternal?0:chart.scrollablePixelsY||0);x1=x2=between(x1,axisLeft,axisLeft+axis.width)}else{x1=axisLeft;x2=cWidth-axis.right+(chart.scrollablePixelsX||0);y1=y2=between(y1,axisTop,axisTop+axis.height)}e.path=skip&&!force?void 0:chart.renderer.crispLine([["M",x1,y1],["L",x2,y2]],lineWidth||1)});return evt.path}getLinearTickPositions(tickInterval,min,max){const roundedMin=Axis_correctFloat(Math.floor(min/tickInterval)*tickInterval),roundedMax=Axis_correctFloat(Math.ceil(max/tickInterval)*tickInterval),tickPositions=[];let pos,lastPos,precision;if(Axis_correctFloat(roundedMin+tickInterval)===roundedMin){precision=20}if(this.single){return[min]}pos=roundedMin;while(pos<=roundedMax){tickPositions.push(pos);pos=Axis_correctFloat(pos+tickInterval,precision);if(pos===lastPos){break}lastPos=pos}return tickPositions}getMinorTickInterval(){const{minorTicks,minorTickInterval}=this.options;if(minorTicks===true){return Axis_pick(minorTickInterval,"auto")}if(minorTicks===false){return}return minorTickInterval}getMinorTickPositions(){const axis=this,options=axis.options,tickPositions=axis.tickPositions,minorTickInterval=axis.minorTickInterval,pointRangePadding=axis.pointRangePadding||0,min=(axis.min||0)-pointRangePadding,max=(axis.max||0)+pointRangePadding,range=axis.brokenAxis?.hasBreaks?axis.brokenAxis.unitLength:max-min;let minorTickPositions=[],pos;if(range&&range/minorTickInterval<axis.len/3){const logarithmic=axis.logarithmic;if(logarithmic){this.paddedTicks.forEach(function(_pos,i,paddedTicks){if(i){minorTickPositions.push.apply(minorTickPositions,logarithmic.getLogTickPositions(minorTickInterval,paddedTicks[i-1],paddedTicks[i],true))}})}else if(axis.dateTime&&this.getMinorTickInterval()==="auto"){minorTickPositions=minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval),min,max,options.startOfWeek))}else{for(pos=min+(tickPositions[0]-min)%minorTickInterval;pos<=max;pos+=minorTickInterval){if(pos===minorTickPositions[0]){break}minorTickPositions.push(pos)}}}if(minorTickPositions.length!==0){axis.trimTicks(minorTickPositions)}return minorTickPositions}adjustForMinRange(){const axis=this,options=axis.options,logarithmic=axis.logarithmic,time=axis.chart.time;let{max,min,minRange}=axis,zoomOffset,spaceAvailable,closestDataRange,minArgs,maxArgs;if(axis.isXAxis&&typeof minRange==="undefined"&&!logarithmic){if(Axis_defined(options.min)||Axis_defined(options.max)||Axis_defined(options.floor)||Axis_defined(options.ceiling)){minRange=null}else{closestDataRange=Axis_getClosestDistance(axis.series.map(s=>{const xData=s.getColumn("x");return s.xIncrement?xData.slice(0,2):xData}))||0;minRange=Math.min(closestDataRange*5,axis.dataMax-axis.dataMin)}}if(Axis_isNumber(max)&&Axis_isNumber(min)&&Axis_isNumber(minRange)&&max-min<minRange){spaceAvailable=axis.dataMax-axis.dataMin>=minRange;zoomOffset=(minRange-max+min)/2;minArgs=[min-zoomOffset,time.parse(options.min)??min-zoomOffset];if(spaceAvailable){minArgs[2]=logarithmic?logarithmic.log2lin(axis.dataMin):axis.dataMin}min=Axis_arrayMax(minArgs);maxArgs=[min+minRange,time.parse(options.max)??min+minRange];if(spaceAvailable){maxArgs[2]=logarithmic?logarithmic.log2lin(axis.dataMax):axis.dataMax}max=Axis_arrayMin(maxArgs);if(max-min<minRange){minArgs[0]=max-minRange;minArgs[1]=time.parse(options.min)??max-minRange;min=Axis_arrayMax(minArgs)}}axis.minRange=minRange;axis.min=min;axis.max=max}getClosest(){let closestSingleDistance,closestDistance;if(this.categories){closestDistance=1}else{const singleXs=[];this.series.forEach(function(series){const seriesClosest=series.closestPointRange,xData=series.getColumn("x");if(xData.length===1){singleXs.push(xData[0])}else if(series.sorted&&Axis_defined(seriesClosest)&&series.reserveSpace()){closestDistance=Axis_defined(closestDistance)?Math.min(closestDistance,seriesClosest):seriesClosest}});if(singleXs.length){singleXs.sort((a,b)=>a-b);closestSingleDistance=Axis_getClosestDistance([singleXs])}}if(closestSingleDistance&&closestDistance){return Math.min(closestSingleDistance,closestDistance)}return closestSingleDistance||closestDistance}nameToX(point){const explicitCategories=Axis_isArray(this.options.categories),names=explicitCategories?this.categories:this.names;let nameX=point.options.x,x;point.series.requireSorting=false;if(!Axis_defined(nameX)){nameX=this.uniqueNames&&names?explicitCategories?names.indexOf(point.name):Axis_pick(names.keys[point.name],-1):point.series.autoIncrement()}if(nameX===-1){if(!explicitCategories&&names){x=names.length}}else if(Axis_isNumber(nameX)){x=nameX}if(typeof x!=="undefined"){this.names[x]=point.name;this.names.keys[point.name]=x}else if(point.x){x=point.x}return x}updateNames(){const axis=this,names=this.names,i=names.length;if(i>0){Object.keys(names.keys).forEach(function(key){delete names.keys[key]});names.length=0;this.minRange=this.userMinRange;(this.series||[]).forEach(series=>{series.xIncrement=null;if(!series.points||series.isDirtyData){axis.max=Math.max(axis.max||0,series.dataTable.rowCount-1);series.processData();series.generatePoints()}const xData=series.getColumn("x").slice();series.data.forEach((point,i)=>{let x=xData[i];if(point?.options&&typeof point.name!=="undefined"){x=axis.nameToX(point);if(typeof x!=="undefined"&&x!==point.x){xData[i]=point.x=x}}});series.dataTable.setColumn("x",xData)})}}setAxisTranslation(){const axis=this,range=axis.max-axis.min,linkedParent=axis.linkedParent,hasCategories=!!axis.categories,isXAxis=axis.isXAxis;let pointRange=axis.axisPointRange||0,closestPointRange,minPointOffset=0,pointRangePadding=0,ordinalCorrection,transA=axis.transA;if(isXAxis||hasCategories||pointRange){closestPointRange=axis.getClosest();if(linkedParent){minPointOffset=linkedParent.minPointOffset;pointRangePadding=linkedParent.pointRangePadding}else{axis.series.forEach(function(series){const seriesPointRange=hasCategories?1:isXAxis?Axis_pick(series.options.pointRange,closestPointRange,0):axis.axisPointRange||0,pointPlacement=series.options.pointPlacement;pointRange=Math.max(pointRange,seriesPointRange);if(!axis.single||hasCategories){const isPointPlacementAxis=series.is("xrange")?!isXAxis:isXAxis;minPointOffset=Math.max(minPointOffset,isPointPlacementAxis&&Axis_isString(pointPlacement)?0:seriesPointRange/2);pointRangePadding=Math.max(pointRangePadding,isPointPlacementAxis&&pointPlacement==="on"?0:seriesPointRange)}})}ordinalCorrection=axis.ordinal&&axis.ordinal.slope&&closestPointRange?axis.ordinal.slope/closestPointRange:1;axis.minPointOffset=minPointOffset=minPointOffset*ordinalCorrection;axis.pointRangePadding=pointRangePadding=pointRangePadding*ordinalCorrection;axis.pointRange=Math.min(pointRange,axis.single&&hasCategories?1:range);if(isXAxis&&closestPointRange){axis.closestPointRange=closestPointRange}}axis.translationSlope=axis.transA=transA=axis.staticScale||axis.len/(range+pointRangePadding||1);axis.transB=axis.horiz?axis.left:axis.bottom;axis.minPixelPadding=transA*minPointOffset;Axis_fireEvent(this,"afterSetAxisTranslation")}minFromRange(){const{max,min}=this;return Axis_isNumber(max)&&Axis_isNumber(min)&&max-min||void 0}setTickInterval(secondPass){const axis=this,{categories,chart,dataMax,dataMin,dateTime,isXAxis,logarithmic,options,softThreshold}=axis,time=chart.time,threshold=Axis_isNumber(axis.threshold)?axis.threshold:void 0,minRange=axis.minRange||0,{ceiling,floor,linkedTo,softMax,softMin}=options,linkedParent=Axis_isNumber(linkedTo)&&chart[axis.coll]?.[linkedTo],tickPixelIntervalOption=options.tickPixelInterval;let maxPadding=options.maxPadding,minPadding=options.minPadding,range=0,linkedParentExtremes,tickIntervalOption=Axis_isNumber(options.tickInterval)&&options.tickInterval>=0?options.tickInterval:void 0,thresholdMin,thresholdMax,hardMin,hardMax;if(!dateTime&&!categories&&!linkedParent){this.getTickAmount()}hardMin=Axis_pick(axis.userMin,time.parse(options.min));hardMax=Axis_pick(axis.userMax,time.parse(options.max));if(linkedParent){axis.linkedParent=linkedParent;linkedParentExtremes=linkedParent.getExtremes();axis.min=Axis_pick(linkedParentExtremes.min,linkedParentExtremes.dataMin);axis.max=Axis_pick(linkedParentExtremes.max,linkedParentExtremes.dataMax);if(this.type!==linkedParent.type){Axis_error(11,true,chart)}}else{if(softThreshold&&Axis_defined(threshold)&&Axis_isNumber(dataMax)&&Axis_isNumber(dataMin)){if(dataMin>=threshold){thresholdMin=threshold;minPadding=0}else if(dataMax<=threshold){thresholdMax=threshold;maxPadding=0}}axis.min=Axis_pick(hardMin,thresholdMin,dataMin);axis.max=Axis_pick(hardMax,thresholdMax,dataMax)}if(Axis_isNumber(axis.max)&&Axis_isNumber(axis.min)){if(logarithmic){if(axis.positiveValuesOnly&&!secondPass&&Math.min(axis.min,Axis_pick(dataMin,axis.min))<=0){Axis_error(10,true,chart)}axis.min=Axis_correctFloat(logarithmic.log2lin(axis.min),16);axis.max=Axis_correctFloat(logarithmic.log2lin(axis.max),16)}if(axis.range&&Axis_isNumber(dataMin)){axis.userMin=axis.min=hardMin=Math.max(dataMin,axis.minFromRange()||0);axis.userMax=hardMax=axis.max;axis.range=void 0}}Axis_fireEvent(axis,"foundExtremes");axis.adjustForMinRange();if(Axis_isNumber(axis.min)&&Axis_isNumber(axis.max)){if(!Axis_isNumber(axis.userMin)&&Axis_isNumber(softMin)&&softMin<axis.min){axis.min=hardMin=softMin}if(!Axis_isNumber(axis.userMax)&&Axis_isNumber(softMax)&&softMax>axis.max){axis.max=hardMax=softMax}if(!categories&&!axis.axisPointRange&&!axis.stacking?.usePercentage&&!linkedParent){range=axis.max-axis.min;if(range){if(!Axis_defined(hardMin)&&minPadding){axis.min-=range*minPadding}if(!Axis_defined(hardMax)&&maxPadding){axis.max+=range*maxPadding}}}if(!Axis_isNumber(axis.userMin)&&Axis_isNumber(floor)){axis.min=Math.max(axis.min,floor)}if(!Axis_isNumber(axis.userMax)&&Axis_isNumber(ceiling)){axis.max=Math.min(axis.max,ceiling)}if(softThreshold&&Axis_isNumber(dataMin)&&Axis_isNumber(dataMax)){const numThreshold=threshold||0;if(!Axis_defined(hardMin)&&axis.min<numThreshold&&dataMin>=numThreshold){axis.min=options.minRange?Math.min(numThreshold,axis.max-minRange):numThreshold}else if(!Axis_defined(hardMax)&&axis.max>numThreshold&&dataMax<=numThreshold){axis.max=options.minRange?Math.max(numThreshold,axis.min+minRange):numThreshold}}if(!chart.polar&&axis.min>axis.max){if(Axis_defined(options.min)){axis.max=axis.min}else if(Axis_defined(options.max)){axis.min=axis.max}}range=axis.max-axis.min}if(axis.min===axis.max||!Axis_isNumber(axis.min)||!Axis_isNumber(axis.max)){axis.tickInterval=1}else if(linkedParent&&!tickIntervalOption&&tickPixelIntervalOption===linkedParent.options.tickPixelInterval){axis.tickInterval=tickIntervalOption=linkedParent.tickInterval}else{axis.tickInterval=Axis_pick(tickIntervalOption,this.tickAmount?range/Math.max(this.tickAmount-1,1):void 0,categories?1:range*tickPixelIntervalOption/Math.max(axis.len,tickPixelIntervalOption))}if(isXAxis&&!secondPass){const hasExtremesChanged=axis.min!==axis.old?.min||axis.max!==axis.old?.max;axis.series.forEach(function(series){series.forceCrop=series.forceCropping?.();series.processData(hasExtremesChanged)});Axis_fireEvent(this,"postProcessData",{hasExtremesChanged:hasExtremesChanged})}axis.setAxisTranslation();Axis_fireEvent(this,"initialAxisTranslation");if(axis.pointRange&&!tickIntervalOption){axis.tickInterval=Math.max(axis.pointRange,axis.tickInterval)}const minTickInterval=Axis_pick(options.minTickInterval,dateTime&&!axis.series.some(s=>!s.sorted)?axis.closestPointRange:0);if(!tickIntervalOption&&axis.tickInterval<minTickInterval){axis.tickInterval=minTickInterval}if(!dateTime&&!logarithmic&&!tickIntervalOption){axis.tickInterval=getNormalizedTickInterval(axis,axis.tickInterval)}if(!this.tickAmount){axis.tickInterval=axis.unsquish()}this.setTickPositions()}setTickPositions(){const axis=this,options=this.options,tickPositionsOption=options.tickPositions,tickPositioner=options.tickPositioner,minorTickIntervalOption=this.getMinorTickInterval(),allowEndOnTick=!this.isPanning,startOnTick=allowEndOnTick&&options.startOnTick,endOnTick=allowEndOnTick&&options.endOnTick;let tickPositions=[],tickPositionerResult;this.tickmarkOffset=this.categories&&options.tickmarkPlacement==="between"&&this.tickInterval===1?.5:0;this.single=this.min===this.max&&Axis_defined(this.min)&&!this.tickAmount&&(this.min%1===0||options.allowDecimals!==false);if(tickPositionsOption){tickPositions=tickPositionsOption.slice()}else if(Axis_isNumber(this.min)&&Axis_isNumber(this.max)){if(!axis.ordinal?.positions&&(this.max-this.min)/this.tickInterval>Math.max(2*this.len,200)){tickPositions=[this.min,this.max];Axis_error(19,false,this.chart)}else if(axis.dateTime){tickPositions=axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval,options.units),this.min,this.max,options.startOfWeek,axis.ordinal?.positions,this.closestPointRange,true)}else if(axis.logarithmic){tickPositions=axis.logarithmic.getLogTickPositions(this.tickInterval,this.min,this.max)}else{const startingTickInterval=this.tickInterval;let adjustedTickInterval=startingTickInterval;while(adjustedTickInterval<=startingTickInterval*2){tickPositions=this.getLinearTickPositions(this.tickInterval,this.min,this.max);if(this.tickAmount&&tickPositions.length>this.tickAmount){this.tickInterval=getNormalizedTickInterval(this,adjustedTickInterval*=1.1)}else{break}}}if(tickPositions.length>this.len){tickPositions=[tickPositions[0],tickPositions[tickPositions.length-1]];if(tickPositions[0]===tickPositions[1]){tickPositions.length=1}}if(tickPositioner){this.tickPositions=tickPositions;tickPositionerResult=tickPositioner.apply(axis,[this.min,this.max]);if(tickPositionerResult){tickPositions=tickPositionerResult}}}this.tickPositions=tickPositions;this.minorTickInterval=minorTickIntervalOption==="auto"&&this.tickInterval?this.tickInterval/options.minorTicksPerMajor:minorTickIntervalOption;this.paddedTicks=tickPositions.slice(0);this.trimTicks(tickPositions,startOnTick,endOnTick);if(!this.isLinked&&Axis_isNumber(this.min)&&Axis_isNumber(this.max)){if(this.single&&tickPositions.length<2&&!this.categories&&!this.series.some(s=>s.is("heatmap")&&s.options.pointPlacement==="between")){this.min-=.5;this.max+=.5}if(!tickPositionsOption&&!tickPositionerResult){this.adjustTickAmount()}}Axis_fireEvent(this,"afterSetTickPositions")}trimTicks(tickPositions,startOnTick,endOnTick){const roundedMin=tickPositions[0],roundedMax=tickPositions[tickPositions.length-1],minPointOffset=!this.isOrdinal&&this.minPointOffset||0;Axis_fireEvent(this,"trimTicks");if(!this.isLinked){if(startOnTick&&roundedMin!==-Infinity){this.min=roundedMin}else{while(this.min-minPointOffset>tickPositions[0]){tickPositions.shift()}}if(endOnTick){this.max=roundedMax}else{while(this.max+minPointOffset<tickPositions[tickPositions.length-1]){tickPositions.pop()}}if(tickPositions.length===0&&Axis_defined(roundedMin)&&!this.options.tickPositions){tickPositions.push((roundedMax+roundedMin)/2)}}}alignToOthers(){const axis=this,chart=axis.chart,alignedAxes=[this],options=axis.options,chartOptions=chart.options.chart,alignThresholds=this.coll==="yAxis"&&chartOptions.alignThresholds,thresholdAlignments=[];let hasOther;axis.thresholdAlignment=void 0;if((chartOptions.alignTicks!==false&&options.alignTicks||alignThresholds)&&options.startOnTick!==false&&options.endOnTick!==false&&!axis.logarithmic){const getKey=axis=>{const{horiz,options}=axis;return[horiz?options.left:options.top,options.width,options.height,options.pane].join(",")};const thisKey=getKey(this);chart[this.coll].forEach(function(otherAxis){const{series}=otherAxis;if(series.length&&series.some(s=>s.visible)&&otherAxis!==axis&&getKey(otherAxis)===thisKey){hasOther=true;alignedAxes.push(otherAxis)}})}if(hasOther&&alignThresholds){alignedAxes.forEach(otherAxis=>{const threshAlign=otherAxis.getThresholdAlignment(axis);if(Axis_isNumber(threshAlign)){thresholdAlignments.push(threshAlign)}});const thresholdAlignment=thresholdAlignments.length>1?thresholdAlignments.reduce((sum,n)=>sum+=n,0)/thresholdAlignments.length:void 0;alignedAxes.forEach(axis=>{axis.thresholdAlignment=thresholdAlignment})}return hasOther}getThresholdAlignment(callerAxis){if(!Axis_isNumber(this.dataMin)||this!==callerAxis&&this.series.some(s=>s.isDirty||s.isDirtyData)){this.getSeriesExtremes()}if(Axis_isNumber(this.threshold)){let thresholdAlignment=Axis_clamp((this.threshold-(this.dataMin||0))/((this.dataMax||0)-(this.dataMin||0)),0,1);if(this.options.reversed){thresholdAlignment=1-thresholdAlignment}return thresholdAlignment}}getTickAmount(){const axis=this,options=this.options,tickPixelInterval=options.tickPixelInterval;let tickAmount=options.tickAmount;if(!Axis_defined(options.tickInterval)&&!tickAmount&&this.len<tickPixelInterval&&!this.isRadial&&!axis.logarithmic&&options.startOnTick&&options.endOnTick){tickAmount=2}if(!tickAmount&&this.alignToOthers()){tickAmount=Math.ceil(this.len/tickPixelInterval)+1}if(tickAmount<4){this.finalTickAmt=tickAmount;tickAmount=5}this.tickAmount=tickAmount}adjustTickAmount(){const axis=this,{finalTickAmt,max,min,options,tickPositions,tickAmount,thresholdAlignment}=axis,currentTickAmount=tickPositions?.length,threshold=Axis_pick(axis.threshold,axis.softThreshold?0:null);let len,i,tickInterval=axis.tickInterval,thresholdTickIndex;const append=()=>tickPositions.push(Axis_correctFloat(tickPositions[tickPositions.length-1]+tickInterval)),prepend=()=>tickPositions.unshift(Axis_correctFloat(tickPositions[0]-tickInterval));if(Axis_isNumber(thresholdAlignment)){thresholdTickIndex=thresholdAlignment<.5?Math.ceil(thresholdAlignment*(tickAmount-1)):Math.floor(thresholdAlignment*(tickAmount-1));if(options.reversed){thresholdTickIndex=tickAmount-1-thresholdTickIndex}}if(axis.hasData()&&Axis_isNumber(min)&&Axis_isNumber(max)){const adjustExtremes=()=>{axis.transA*=(currentTickAmount-1)/(tickAmount-1);axis.min=options.startOnTick?tickPositions[0]:Math.min(min,tickPositions[0]);axis.max=options.endOnTick?tickPositions[tickPositions.length-1]:Math.max(max,tickPositions[tickPositions.length-1])};if(Axis_isNumber(thresholdTickIndex)&&Axis_isNumber(axis.threshold)){while(tickPositions[thresholdTickIndex]!==threshold||tickPositions.length!==tickAmount||tickPositions[0]>min||tickPositions[tickPositions.length-1]<max){tickPositions.length=0;tickPositions.push(axis.threshold);while(tickPositions.length<tickAmount){if(tickPositions[thresholdTickIndex]===void 0||tickPositions[thresholdTickIndex]>axis.threshold){prepend()}else{append()}}if(tickInterval>axis.tickInterval*8){break}tickInterval*=2}adjustExtremes()}else if(currentTickAmount<tickAmount){while(tickPositions.length<tickAmount){if(tickPositions.length%2||min===threshold){append()}else{prepend()}}adjustExtremes()}if(Axis_defined(finalTickAmt)){i=len=tickPositions.length;while(i--){if(finalTickAmt===3&&i%2===1||finalTickAmt<=2&&i>0&&i<len-1){tickPositions.splice(i,1)}}axis.finalTickAmt=void 0}}}setScale(){const axis=this,{coll,stacking}=axis;let isDirtyData=false,isXAxisDirty=false;axis.series.forEach(series=>{isDirtyData=isDirtyData||series.isDirtyData||series.isDirty;isXAxisDirty=isXAxisDirty||series.xAxis&&series.xAxis.isDirty||false});axis.setAxisSize();const isDirtyAxisLength=axis.len!==(axis.old&&axis.old.len);if(isDirtyAxisLength||isDirtyData||isXAxisDirty||axis.isLinked||axis.forceRedraw||axis.userMin!==(axis.old&&axis.old.userMin)||axis.userMax!==(axis.old&&axis.old.userMax)||axis.alignToOthers()){if(stacking&&coll==="yAxis"){stacking.buildStacks()}axis.forceRedraw=false;if(!axis.userMinRange){axis.minRange=void 0}axis.getSeriesExtremes();axis.setTickInterval();if(stacking&&coll==="xAxis"){stacking.buildStacks()}if(!axis.isDirty){axis.isDirty=isDirtyAxisLength||axis.min!==axis.old?.min||axis.max!==axis.old?.max}}else if(stacking){stacking.cleanStacks()}if(isDirtyData){delete axis.allExtremes}Axis_fireEvent(this,"afterSetScale")}setExtremes(min,max,redraw=true,animation,eventArguments){const chart=this.chart;this.series.forEach(serie=>{delete serie.kdTree});min=chart.time.parse(min);max=chart.time.parse(max);eventArguments=Axis_extend(eventArguments,{min:min,max:max});Axis_fireEvent(this,"setExtremes",eventArguments,e=>{this.userMin=e.min;this.userMax=e.max;this.eventArgs=e;if(redraw){chart.redraw(animation)}})}setAxisSize(){const chart=this.chart,options=this.options,offsets=options.offsets||[0,0,0,0],horiz=this.horiz,width=this.width=Math.round(Axis_relativeLength(Axis_pick(options.width,chart.plotWidth-offsets[3]+offsets[1]),chart.plotWidth)),height=this.height=Math.round(Axis_relativeLength(Axis_pick(options.height,chart.plotHeight-offsets[0]+offsets[2]),chart.plotHeight)),top=this.top=Math.round(Axis_relativeLength(Axis_pick(options.top,chart.plotTop+offsets[0]),chart.plotHeight,chart.plotTop)),left=this.left=Math.round(Axis_relativeLength(Axis_pick(options.left,chart.plotLeft+offsets[3]),chart.plotWidth,chart.plotLeft));this.bottom=chart.chartHeight-height-top;this.right=chart.chartWidth-width-left;this.len=Math.max(horiz?width:height,0);this.pos=horiz?left:top}getExtremes(){const axis=this,log=axis.logarithmic;return{min:log?Axis_correctFloat(log.lin2log(axis.min)):axis.min,max:log?Axis_correctFloat(log.lin2log(axis.max)):axis.max,dataMin:axis.dataMin,dataMax:axis.dataMax,userMin:axis.userMin,userMax:axis.userMax}}getThreshold(threshold){const axis=this,log=axis.logarithmic,realMin=log?log.lin2log(axis.min):axis.min,realMax=log?log.lin2log(axis.max):axis.max;if(threshold===null||threshold===-Infinity){threshold=realMin}else if(threshold===Infinity){threshold=realMax}else if(realMin>threshold){threshold=realMin}else if(realMax<threshold){threshold=realMax}return axis.translate(threshold,0,1,0,1)}autoLabelAlign(rotation){const angle=(Axis_pick(rotation,0)-this.side*90+720)%360,evt={align:"center"};Axis_fireEvent(this,"autoLabelAlign",evt,function(e){if(angle>15&&angle<165){e.align="right"}else if(angle>195&&angle<345){e.align="left"}});return evt.align}tickSize(prefix){const options=this.options,tickWidth=Axis_pick(options[prefix==="tick"?"tickWidth":"minorTickWidth"],prefix==="tick"&&this.isXAxis&&!this.categories?1:0);let tickLength=options[prefix==="tick"?"tickLength":"minorTickLength"],tickSize;if(tickWidth&&tickLength){if(options[prefix+"Position"]==="inside"){tickLength=-tickLength}tickSize=[tickLength,tickWidth]}const e={tickSize:tickSize};Axis_fireEvent(this,"afterTickSize",e);return e.tickSize}labelMetrics(){const renderer=this.chart.renderer,ticks=this.ticks,tick=ticks[Object.keys(ticks)[0]]||{};return this.chart.renderer.fontMetrics(tick.label||tick.movedLabel||renderer.box)}unsquish(){const labelOptions=this.options.labels,padding=labelOptions.padding||0,horiz=this.horiz,tickInterval=this.tickInterval,slotSize=this.len/(((this.categories?1:0)+this.max-this.min)/tickInterval),rotationOption=labelOptions.rotation,lineHeight=Axis_correctFloat(this.labelMetrics().h*.8),range=Math.max(this.max-this.min,0),getStep=function(spaceNeeded){let step=(spaceNeeded+2*padding)/(slotSize||1);step=step>1?Math.ceil(step):1;if(step*tickInterval>range&&spaceNeeded!==Infinity&&slotSize!==Infinity&&range){step=Math.ceil(range/tickInterval)}return Axis_correctFloat(step*tickInterval)};let newTickInterval=tickInterval,rotation,bestScore=Number.MAX_VALUE,autoRotation;if(horiz){if(!labelOptions.staggerLines){if(Axis_isNumber(rotationOption)){autoRotation=[rotationOption]}else if(slotSize<labelOptions.autoRotationLimit){autoRotation=labelOptions.autoRotation}}if(autoRotation){let step,score;for(const rot of autoRotation){if(rot===rotationOption||rot&&rot>=-90&&rot<=90){step=getStep(Math.abs(lineHeight/Math.sin(Axis_deg2rad*rot)));score=step+Math.abs(rot/360);if(score<bestScore){bestScore=score;rotation=rot;newTickInterval=step}}}}}else{newTickInterval=getStep(lineHeight*.75)}this.autoRotation=autoRotation;this.labelRotation=Axis_pick(rotation,Axis_isNumber(rotationOption)?rotationOption:0);return labelOptions.step?tickInterval:newTickInterval}getSlotWidth(tick){const chart=this.chart,horiz=this.horiz,labelOptions=this.options.labels,slotCount=Math.max(this.tickPositions.length-(this.categories?0:1),1),marginLeft=chart.margin[3];if(tick&&Axis_isNumber(tick.slotWidth)){return tick.slotWidth}if(horiz&&labelOptions.step<2&&!this.isRadial){if(labelOptions.rotation){return 0}return(this.staggerLines||1)*this.len/slotCount}if(!horiz){const cssWidth=labelOptions.style.width;if(cssWidth!==void 0){return parseInt(String(cssWidth),10)}if(marginLeft){return marginLeft-chart.spacing[3]}}return chart.chartWidth*.33}renderUnsquish(){const chart=this.chart,renderer=chart.renderer,tickPositions=this.tickPositions,ticks=this.ticks,labelOptions=this.options.labels,labelStyleOptions=labelOptions.style,horiz=this.horiz,slotWidth=this.getSlotWidth(),innerWidth=Math.max(1,Math.round(slotWidth-(horiz?2*(labelOptions.padding||0):labelOptions.distance||0))),attr={},labelMetrics=this.labelMetrics(),lineClampOption=labelStyleOptions.lineClamp;let commonWidth,lineClamp=lineClampOption??(Math.floor(this.len/(tickPositions.length*labelMetrics.h))||1),maxLabelLength=0;if(!Axis_isString(labelOptions.rotation)){attr.rotation=labelOptions.rotation||0}tickPositions.forEach(function(tickPosition){const tick=ticks[tickPosition];if(tick.movedLabel){tick.replaceMovedLabel()}const textPxLength=tick.label?.textPxLength||0;if(textPxLength>maxLabelLength){maxLabelLength=textPxLength}});this.maxLabelLength=maxLabelLength;if(this.autoRotation){if(maxLabelLength>innerWidth&&maxLabelLength>labelMetrics.h){attr.rotation=this.labelRotation}else{this.labelRotation=0}}else if(slotWidth){commonWidth=innerWidth}if(attr.rotation){commonWidth=maxLabelLength>chart.chartHeight*.5?chart.chartHeight*.33:maxLabelLength;if(!lineClampOption){lineClamp=1}}this.labelAlign=labelOptions.align||this.autoLabelAlign(this.labelRotation);if(this.labelAlign){attr.align=this.labelAlign}tickPositions.forEach(function(pos){const tick=ticks[pos],label=tick&&tick.label,widthOption=labelStyleOptions.width,css={};if(label){label.attr(attr);if(tick.shortenLabel){tick.shortenLabel()}else if(commonWidth&&!widthOption&&labelStyleOptions.whiteSpace!=="nowrap"&&(commonWidth<(label.textPxLength||0)||label.element.tagName==="SPAN")){label.css(Axis_extend(css,{width:`${commonWidth}px`,lineClamp:lineClamp}))}else if(label.styles.width&&!css.width&&!widthOption){label.css({width:"auto"})}tick.rotation=attr.rotation}},this);this.tickRotCorr=renderer.rotCorr(labelMetrics.b,this.labelRotation||0,this.side!==0)}hasData(){return this.series.some(function(s){return s.hasData()})||this.options.showEmpty&&Axis_defined(this.min)&&Axis_defined(this.max)}addTitle(display){const axis=this,renderer=axis.chart.renderer,horiz=axis.horiz,opposite=axis.opposite,options=axis.options,axisTitleOptions=options.title,styledMode=axis.chart.styledMode;let textAlign;if(!axis.axisTitle){textAlign=axisTitleOptions.textAlign;if(!textAlign){textAlign=(horiz?{low:"left",middle:"center",high:"right"}:{low:opposite?"right":"left",middle:"center",high:opposite?"left":"right"})[axisTitleOptions.align]}axis.axisTitle=renderer.text(axisTitleOptions.text||"",0,0,axisTitleOptions.useHTML).attr({zIndex:7,rotation:axisTitleOptions.rotation||0,align:textAlign}).addClass("highcharts-axis-title");if(!styledMode){axis.axisTitle.css(Axis_merge(axisTitleOptions.style))}axis.axisTitle.add(axis.axisGroup);axis.axisTitle.isNew=true}if(!styledMode&&!axisTitleOptions.style.width&&!axis.isRadial){axis.axisTitle.css({width:axis.len+"px"})}axis.axisTitle[display?"show":"hide"](display)}generateTick(pos){const axis=this,ticks=axis.ticks;if(!ticks[pos]){ticks[pos]=new Axis_Tick(axis,pos)}else{ticks[pos].addLabel()}}createGroups(){const{axisParent,chart,coll,options}=this,renderer=chart.renderer;const createGroup=(name,suffix,zIndex)=>renderer.g(name).attr({zIndex:zIndex}).addClass(`highcharts-${coll.toLowerCase()}${suffix} `+(this.isRadial?`highcharts-radial-axis${suffix} `:"")+(options.className||"")).add(axisParent);if(!this.axisGroup){this.gridGroup=createGroup("grid","-grid",options.gridZIndex);this.axisGroup=createGroup("axis","",options.zIndex);this.labelGroup=createGroup("axis-labels","-labels",options.labels.zIndex)}}getOffset(){const axis=this,{chart,horiz,options,side,ticks,tickPositions,coll}=axis,invertedSide=chart.inverted&&!axis.isZAxis?[1,0,3,2][side]:side,hasData=axis.hasData(),axisTitleOptions=options.title,labelOptions=options.labels,hasCrossing=Axis_isNumber(options.crossing),axisOffset=chart.axisOffset,clipOffset=chart.clipOffset,directionFactor=[-1,1,1,-1][side];let showAxis,titleOffset=0,titleOffsetOption,titleMargin=0,labelOffset=0,labelOffsetPadded,lineHeightCorrection;axis.showAxis=showAxis=hasData||options.showEmpty;axis.staggerLines=axis.horiz&&labelOptions.staggerLines||void 0;axis.createGroups();if(hasData||axis.isLinked){tickPositions.forEach(function(pos){axis.generateTick(pos)});axis.renderUnsquish();axis.reserveSpaceDefault=side===0||side===2||{1:"left",3:"right"}[side]===axis.labelAlign;if(Axis_pick(labelOptions.reserveSpace,hasCrossing?false:null,axis.labelAlign==="center"?true:null,axis.reserveSpaceDefault)){tickPositions.forEach(function(pos){labelOffset=Math.max(ticks[pos].getLabelSize(),labelOffset)})}if(axis.staggerLines){labelOffset*=axis.staggerLines}axis.labelOffset=labelOffset*(axis.opposite?-1:1)}else{Axis_objectEach(ticks,function(tick,n){tick.destroy();delete ticks[n]})}if(axisTitleOptions?.text&&axisTitleOptions.enabled!==false){axis.addTitle(showAxis);if(showAxis&&!hasCrossing&&axisTitleOptions.reserveSpace!==false){axis.titleOffset=titleOffset=axis.axisTitle.getBBox()[horiz?"height":"width"];titleOffsetOption=axisTitleOptions.offset;titleMargin=Axis_defined(titleOffsetOption)?0:Axis_pick(axisTitleOptions.margin,horiz?5:10)}}axis.renderLine();axis.offset=directionFactor*Axis_pick(options.offset,axisOffset[side]?axisOffset[side]+(options.margin||0):0);axis.tickRotCorr=axis.tickRotCorr||{x:0,y:0};if(side===0){lineHeightCorrection=-axis.labelMetrics().h}else if(side===2){lineHeightCorrection=axis.tickRotCorr.y}else{lineHeightCorrection=0}labelOffsetPadded=Math.abs(labelOffset)+titleMargin;if(labelOffset){labelOffsetPadded-=lineHeightCorrection;labelOffsetPadded+=directionFactor*(horiz?Axis_pick(labelOptions.y,axis.tickRotCorr.y+directionFactor*labelOptions.distance):Axis_pick(labelOptions.x,directionFactor*labelOptions.distance))}axis.axisTitleMargin=Axis_pick(titleOffsetOption,labelOffsetPadded);if(axis.getMaxLabelDimensions){axis.maxLabelDimensions=axis.getMaxLabelDimensions(ticks,tickPositions)}if(coll!=="colorAxis"&&clipOffset){const tickSize=this.tickSize("tick");axisOffset[side]=Math.max(axisOffset[side],(axis.axisTitleMargin||0)+titleOffset+directionFactor*axis.offset,labelOffsetPadded,tickPositions&&tickPositions.length&&tickSize?tickSize[0]+directionFactor*axis.offset:0);const clip=!axis.axisLine||options.offset?0:axis.axisLine.strokeWidth()/2;clipOffset[invertedSide]=Math.max(clipOffset[invertedSide],clip)}Axis_fireEvent(this,"afterGetOffset")}getLinePath(lineWidth){const chart=this.chart,opposite=this.opposite,offset=this.offset,horiz=this.horiz,lineLeft=this.left+(opposite?this.width:0)+offset,lineTop=chart.chartHeight-this.bottom-(opposite?this.height:0)+offset;if(opposite){lineWidth*=-1}return chart.renderer.crispLine([["M",horiz?this.left:lineLeft,horiz?lineTop:this.top],["L",horiz?chart.chartWidth-this.right:lineLeft,horiz?lineTop:chart.chartHeight-this.bottom]],lineWidth)}renderLine(){if(!this.axisLine){this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);if(!this.chart.styledMode){this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7})}}}getTitlePosition(axisTitle){const horiz=this.horiz,axisLeft=this.left,axisTop=this.top,axisLength=this.len,axisTitleOptions=this.options.title,margin=horiz?axisLeft:axisTop,opposite=this.opposite,offset=this.offset,xOption=axisTitleOptions.x,yOption=axisTitleOptions.y,fontMetrics=this.chart.renderer.fontMetrics(axisTitle),textHeightOvershoot=axisTitle?Math.max(axisTitle.getBBox(false,0).height-fontMetrics.h-1,0):0,alongAxis={low:margin+(horiz?0:axisLength),middle:margin+axisLength/2,high:margin+(horiz?axisLength:0)}[axisTitleOptions.align],offAxis=(horiz?axisTop+this.height:axisLeft)+(horiz?1:-1)*(opposite?-1:1)*(this.axisTitleMargin||0)+[-textHeightOvershoot,textHeightOvershoot,fontMetrics.f,-textHeightOvershoot][this.side],titlePosition={x:horiz?alongAxis+xOption:offAxis+(opposite?this.width:0)+offset+xOption,y:horiz?offAxis+yOption-(opposite?this.height:0)+offset:alongAxis+yOption};Axis_fireEvent(this,"afterGetTitlePosition",{titlePosition:titlePosition});return titlePosition}renderMinorTick(pos,slideIn){const axis=this;const minorTicks=axis.minorTicks;if(!minorTicks[pos]){minorTicks[pos]=new Axis_Tick(axis,pos,"minor")}if(slideIn&&minorTicks[pos].isNew){minorTicks[pos].render(null,true)}minorTicks[pos].render(null,false,1)}renderTick(pos,i,slideIn){const axis=this,isLinked=axis.isLinked,ticks=axis.ticks;if(!isLinked||pos>=axis.min&&pos<=axis.max||axis.grid&&axis.grid.isColumn){if(!ticks[pos]){ticks[pos]=new Axis_Tick(axis,pos)}if(slideIn&&ticks[pos].isNew){ticks[pos].render(i,true,-1)}ticks[pos].render(i)}}render(){const axis=this,chart=axis.chart,log=axis.logarithmic,renderer=chart.renderer,options=axis.options,isLinked=axis.isLinked,tickPositions=axis.tickPositions,axisTitle=axis.axisTitle,ticks=axis.ticks,minorTicks=axis.minorTicks,alternateBands=axis.alternateBands,stackLabelOptions=options.stackLabels,alternateGridColor=options.alternateGridColor,crossing=options.crossing,tickmarkOffset=axis.tickmarkOffset,axisLine=axis.axisLine,showAxis=axis.showAxis,animation=Axis_animObject(renderer.globalAnimation);let from,to;axis.labelEdge.length=0;axis.overlap=false;[ticks,minorTicks,alternateBands].forEach(function(coll){Axis_objectEach(coll,function(tick){tick.isActive=false})});if(Axis_isNumber(crossing)){const otherAxis=this.isXAxis?chart.yAxis[0]:chart.xAxis[0],directionFactor=[1,-1,-1,1][this.side];if(otherAxis){let px=otherAxis.toPixels(crossing,true);if(axis.horiz){px=otherAxis.len-px}axis.offset=directionFactor*px}}if(axis.hasData()||isLinked){const slideInTicks=axis.chart.hasRendered&&axis.old&&Axis_isNumber(axis.old.min);if(axis.minorTickInterval&&!axis.categories){axis.getMinorTickPositions().forEach(function(pos){axis.renderMinorTick(pos,slideInTicks)})}if(tickPositions.length){tickPositions.forEach(function(pos,i){axis.renderTick(pos,i,slideInTicks)});if(tickmarkOffset&&(axis.min===0||axis.single)){if(!ticks[-1]){ticks[-1]=new Axis_Tick(axis,-1,null,true)}ticks[-1].render(-1)}}if(alternateGridColor){tickPositions.forEach(function(pos,i){to=typeof tickPositions[i+1]!=="undefined"?tickPositions[i+1]+tickmarkOffset:axis.max-tickmarkOffset;if(i%2===0&&pos<axis.max&&to<=axis.max+(chart.polar?-tickmarkOffset:tickmarkOffset)){if(!alternateBands[pos]){alternateBands[pos]=new Core_Globals.PlotLineOrBand(axis,{})}from=pos+tickmarkOffset;alternateBands[pos].options={from:log?log.lin2log(from):from,to:log?log.lin2log(to):to,color:alternateGridColor,className:"highcharts-alternate-grid"};alternateBands[pos].render();alternateBands[pos].isActive=true}})}if(!axis._addedPlotLB){axis._addedPlotLB=true;(options.plotLines||[]).concat(options.plotBands||[]).forEach(function(plotLineOptions){axis.addPlotBandOrLine(plotLineOptions)})}}[ticks,minorTicks,alternateBands].forEach(function(coll){const forDestruction=[],delay=animation.duration,destroyInactiveItems=function(){let i=forDestruction.length;while(i--){if(coll[forDestruction[i]]&&!coll[forDestruction[i]].isActive){coll[forDestruction[i]].destroy();delete coll[forDestruction[i]]}}};Axis_objectEach(coll,function(tick,pos){if(!tick.isActive){tick.render(pos,false,0);tick.isActive=false;forDestruction.push(pos)}});Axis_syncTimeout(destroyInactiveItems,coll===alternateBands||!chart.hasRendered||!delay?0:delay)});if(axisLine){axisLine[axisLine.isPlaced?"animate":"attr"]({d:this.getLinePath(axisLine.strokeWidth())});axisLine.isPlaced=true;axisLine[showAxis?"show":"hide"](showAxis)}if(axisTitle&&showAxis){axisTitle[axisTitle.isNew?"attr":"animate"](axis.getTitlePosition(axisTitle));axisTitle.isNew=false}if(stackLabelOptions&&stackLabelOptions.enabled&&axis.stacking){axis.stacking.renderStackTotals()}axis.old={len:axis.len,max:axis.max,min:axis.min,transA:axis.transA,userMax:axis.userMax,userMin:axis.userMin};axis.isDirty=false;Axis_fireEvent(this,"afterRender")}redraw(){if(this.visible){this.render();this.plotLinesAndBands.forEach(function(plotLine){plotLine.render()})}this.series.forEach(function(series){series.isDirty=true})}getKeepProps(){return this.keepProps||Axis.keepProps}destroy(keepEvents){const axis=this,plotLinesAndBands=axis.plotLinesAndBands,eventOptions=this.eventOptions;Axis_fireEvent(this,"destroy",{keepEvents:keepEvents});if(!keepEvents){Axis_removeEvent(axis)}[axis.ticks,axis.minorTicks,axis.alternateBands].forEach(function(coll){Axis_destroyObjectProperties(coll)});if(plotLinesAndBands){let i=plotLinesAndBands.length;while(i--){plotLinesAndBands[i].destroy()}}["axisLine","axisTitle","axisGroup","gridGroup","labelGroup","cross","scrollbar"].forEach(function(prop){if(axis[prop]){axis[prop]=axis[prop].destroy()}});for(const plotGroup in axis.plotLinesAndBandsGroups){axis.plotLinesAndBandsGroups[plotGroup]=axis.plotLinesAndBandsGroups[plotGroup].destroy()}Axis_objectEach(axis,function(val,key){if(axis.getKeepProps().indexOf(key)===-1){delete axis[key]}});this.eventOptions=eventOptions}drawCrosshair(e,point){const options=this.crosshair,snap=Axis_pick(options&&options.snap,true),chart=this.chart;let path,pos,categorized,graphic=this.cross,crossOptions;Axis_fireEvent(this,"drawCrosshair",{e:e,point:point});if(!e){e=this.cross&&this.cross.e}if(!options||(Axis_defined(point)||!snap)===false){this.hideCrosshair()}else{if(!snap){pos=e&&(this.horiz?e.chartX-this.pos:this.len-e.chartY+this.pos)}else if(Axis_defined(point)){pos=Axis_pick(this.coll!=="colorAxis"?point.crosshairPos:null,this.isXAxis?point.plotX:this.len-point.plotY)}if(Axis_defined(pos)){crossOptions={value:point&&(this.isXAxis?point.x:Axis_pick(point.stackY,point.y)),translatedValue:pos};if(chart.polar){Axis_extend(crossOptions,{isCrosshair:true,chartX:e&&e.chartX,chartY:e&&e.chartY,point:point})}path=this.getPlotLinePath(crossOptions)||null}if(!Axis_defined(path)){this.hideCrosshair();return}categorized=this.categories&&!this.isRadial;if(!graphic){this.cross=graphic=chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(categorized?"category ":"thin ")+(options.className||"")).attr({zIndex:Axis_pick(options.zIndex,2)}).add();if(!chart.styledMode){graphic.attr({stroke:options.color||(categorized?Color_Color.parse("#ccd3ff").setOpacity(.25).get():"#cccccc"),"stroke-width":Axis_pick(options.width,1)}).css({"pointer-events":"none"});if(options.dashStyle){graphic.attr({dashstyle:options.dashStyle})}}}graphic.show().attr({d:path});if(categorized&&!options.width){graphic.attr({"stroke-width":this.transA})}this.cross.e=e}Axis_fireEvent(this,"afterDrawCrosshair",{e:e,point:point})}hideCrosshair(){if(this.cross){this.cross.hide()}Axis_fireEvent(this,"afterHideCrosshair")}update(options,redraw){const chart=this.chart;options=Axis_merge(this.userOptions,options);this.destroy(true);this.init(chart,options);chart.isDirtyBox=true;if(Axis_pick(redraw,true)){chart.redraw()}}remove(redraw){const chart=this.chart,coll=this.coll,axisSeries=this.series;let i=axisSeries.length;while(i--){if(axisSeries[i]){axisSeries[i].remove(false)}}Axis_erase(chart.axes,this);Axis_erase(chart[coll]||[],this);chart.orderItems(coll);this.destroy();chart.isDirtyBox=true;if(Axis_pick(redraw,true)){chart.redraw()}}setTitle(titleOptions,redraw){this.update({title:titleOptions},redraw)}setCategories(categories,redraw){this.update({categories:categories},redraw)}}Axis.keepProps=["coll","extKey","hcEvents","len","names","series","userMax","userMin"];const Axis_Axis=Axis;"";const{addEvent:DateTimeAxis_addEvent,getMagnitude:DateTimeAxis_getMagnitude,normalizeTickInterval:DateTimeAxis_normalizeTickInterval,timeUnits:DateTimeAxis_timeUnits}=Core_Utilities;var DateTimeAxis;(function(DateTimeAxis){function compose(AxisClass){if(!AxisClass.keepProps.includes("dateTime")){AxisClass.keepProps.push("dateTime");const axisProto=AxisClass.prototype;axisProto.getTimeTicks=getTimeTicks;DateTimeAxis_addEvent(AxisClass,"afterSetType",onAfterSetType)}return AxisClass}DateTimeAxis.compose=compose;function getTimeTicks(){return this.chart.time.getTimeTicks.apply(this.chart.time,arguments)}function onAfterSetType(){if(this.type!=="datetime"){this.dateTime=void 0;return}if(!this.dateTime){this.dateTime=new Additions(this)}}class Additions{constructor(axis){this.axis=axis}normalizeTimeTickInterval(tickInterval,unitsOption){const units=unitsOption||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]];let unit=units[units.length-1],interval=DateTimeAxis_timeUnits[unit[0]],multiples=unit[1],i;for(i=0;i<units.length;i++){unit=units[i];interval=DateTimeAxis_timeUnits[unit[0]];multiples=unit[1];if(units[i+1]){const lessThan=(interval*multiples[multiples.length-1]+DateTimeAxis_timeUnits[units[i+1][0]])/2;if(tickInterval<=lessThan){break}}}if(interval===DateTimeAxis_timeUnits.year&&tickInterval<5*interval){multiples=[1,2,5]}const count=DateTimeAxis_normalizeTickInterval(tickInterval/interval,multiples,unit[0]==="year"?Math.max(DateTimeAxis_getMagnitude(tickInterval/interval),1):1);return{unitRange:interval,count:count,unitName:unit[0]}}getXDateFormat(x,dateTimeLabelFormats){const{axis}=this,time=axis.chart.time;return axis.closestPointRange?time.getDateFormat(axis.closestPointRange,x,axis.options.startOfWeek,dateTimeLabelFormats)||time.resolveDTLFormat(dateTimeLabelFormats.year).main:time.resolveDTLFormat(dateTimeLabelFormats.day).main}}DateTimeAxis.Additions=Additions})(DateTimeAxis||(DateTimeAxis={}));const Axis_DateTimeAxis=DateTimeAxis;const{addEvent:LogarithmicAxis_addEvent,normalizeTickInterval:LogarithmicAxis_normalizeTickInterval,pick:LogarithmicAxis_pick}=Core_Utilities;var LogarithmicAxis;(function(LogarithmicAxis){function compose(AxisClass){if(!AxisClass.keepProps.includes("logarithmic")){AxisClass.keepProps.push("logarithmic");LogarithmicAxis_addEvent(AxisClass,"afterSetType",onAfterSetType);LogarithmicAxis_addEvent(AxisClass,"afterInit",onAfterInit)}return AxisClass}LogarithmicAxis.compose=compose;function onAfterSetType(){if(this.type!=="logarithmic"){this.logarithmic=void 0}else{this.logarithmic??(this.logarithmic=new Additions(this))}}function onAfterInit(){const axis=this;const log=axis.logarithmic;if(log){axis.lin2val=function(num){return log.lin2log(num)};axis.val2lin=function(num){return log.log2lin(num)}}}class Additions{constructor(axis){this.axis=axis}getLogTickPositions(interval,min,max,minor){const log=this;const axis=log.axis;const axisLength=axis.len;const options=axis.options;let positions=[];if(!minor){log.minorAutoInterval=void 0}if(interval>=.5){interval=Math.round(interval);positions=axis.getLinearTickPositions(interval,min,max)}else if(interval>=.08){const roundedMin=Math.floor(min);let intermediate,i,j,len,pos,lastPos,break2;if(interval>.3){intermediate=[1,2,4]}else if(interval>.15){intermediate=[1,2,4,6,8]}else{intermediate=[1,2,3,4,5,6,7,8,9]}for(i=roundedMin;i<max+1&&!break2;i++){len=intermediate.length;for(j=0;j<len&&!break2;j++){pos=log.log2lin(log.lin2log(i)*intermediate[j]);if(pos>min&&(!minor||lastPos<=max)&&typeof lastPos!=="undefined"){positions.push(lastPos)}if(lastPos>max){break2=true}lastPos=pos}}}else{const realMin=log.lin2log(min),realMax=log.lin2log(max),tickIntervalOption=minor?axis.getMinorTickInterval():options.tickInterval,filteredTickIntervalOption=tickIntervalOption==="auto"?null:tickIntervalOption,tickPixelIntervalOption=options.tickPixelInterval/(minor?5:1),totalPixelLength=minor?axisLength/axis.tickPositions.length:axisLength;interval=LogarithmicAxis_pick(filteredTickIntervalOption,log.minorAutoInterval,(realMax-realMin)*tickPixelIntervalOption/(totalPixelLength||1));interval=LogarithmicAxis_normalizeTickInterval(interval);positions=axis.getLinearTickPositions(interval,realMin,realMax).map(log.log2lin);if(!minor){log.minorAutoInterval=interval/5}}if(!minor){axis.tickInterval=interval}return positions}lin2log(num){return Math.pow(10,num)}log2lin(num){return Math.log(num)/Math.LN10}}LogarithmicAxis.Additions=Additions})(LogarithmicAxis||(LogarithmicAxis={}));const Axis_LogarithmicAxis=LogarithmicAxis;const{erase:PlotLineOrBandAxis_erase,extend:PlotLineOrBandAxis_extend,isNumber:PlotLineOrBandAxis_isNumber}=Core_Utilities;var PlotLineOrBandAxis;(function(PlotLineOrBandAxis){let PlotLineOrBandClass;function addPlotBand(options){return this.addPlotBandOrLine(options,"plotBands")}function addPlotBandOrLine(options,coll){const userOptions=this.userOptions;let obj=new PlotLineOrBandClass(this,options);if(this.visible){obj=obj.render()}if(obj){if(!this._addedPlotLB){this._addedPlotLB=true;(userOptions.plotLines||[]).concat(userOptions.plotBands||[]).forEach(plotLineOptions=>{this.addPlotBandOrLine(plotLineOptions)})}if(coll){const updatedOptions=userOptions[coll]||[];updatedOptions.push(options);userOptions[coll]=updatedOptions}this.plotLinesAndBands.push(obj)}return obj}function addPlotLine(options){return this.addPlotBandOrLine(options,"plotLines")}function compose(PlotLineOrBandType,AxisClass){const axisProto=AxisClass.prototype;if(!axisProto.addPlotBand){PlotLineOrBandClass=PlotLineOrBandType;PlotLineOrBandAxis_extend(axisProto,{addPlotBand:addPlotBand,addPlotLine:addPlotLine,addPlotBandOrLine:addPlotBandOrLine,getPlotBandPath:getPlotBandPath,removePlotBand:removePlotBand,removePlotLine:removePlotLine,removePlotBandOrLine:removePlotBandOrLine})}return AxisClass}PlotLineOrBandAxis.compose=compose;function getPlotBandPath(from,to,options){options=options||this.options;const toPath=this.getPlotLinePath({value:to,force:true,acrossPanes:options.acrossPanes}),result=[],horiz=this.horiz,outside=!PlotLineOrBandAxis_isNumber(this.min)||!PlotLineOrBandAxis_isNumber(this.max)||from<this.min&&to<this.min||from>this.max&&to>this.max,path=this.getPlotLinePath({value:from,force:true,acrossPanes:options.acrossPanes});let i,plus=1,isFlat;if(path&&toPath){if(outside){isFlat=path.toString()===toPath.toString();plus=0}for(i=0;i<path.length;i+=2){const pathStart=path[i],pathEnd=path[i+1],toPathStart=toPath[i],toPathEnd=toPath[i+1];if((pathStart[0]==="M"||pathStart[0]==="L")&&(pathEnd[0]==="M"||pathEnd[0]==="L")&&(toPathStart[0]==="M"||toPathStart[0]==="L")&&(toPathEnd[0]==="M"||toPathEnd[0]==="L")){if(horiz&&toPathStart[1]===pathStart[1]){toPathStart[1]+=plus;toPathEnd[1]+=plus}else if(!horiz&&toPathStart[2]===pathStart[2]){toPathStart[2]+=plus;toPathEnd[2]+=plus}result.push(["M",pathStart[1],pathStart[2]],["L",pathEnd[1],pathEnd[2]],["L",toPathEnd[1],toPathEnd[2]],["L",toPathStart[1],toPathStart[2]],["Z"])}result.isFlat=isFlat}}return result}function removePlotBand(id){this.removePlotBandOrLine(id)}function removePlotBandOrLine(id){const plotLinesAndBands=this.plotLinesAndBands,options=this.options,userOptions=this.userOptions;if(plotLinesAndBands){let i=plotLinesAndBands.length;while(i--){if(plotLinesAndBands[i].id===id){plotLinesAndBands[i].destroy()}}[options.plotLines||[],userOptions.plotLines||[],options.plotBands||[],userOptions.plotBands||[]].forEach(function(arr){i=arr.length;while(i--){if((arr[i]||{}).id===id){PlotLineOrBandAxis_erase(arr,arr[i])}}})}}function removePlotLine(id){this.removePlotBandOrLine(id)}})(PlotLineOrBandAxis||(PlotLineOrBandAxis={}));const PlotLineOrBand_PlotLineOrBandAxis=PlotLineOrBandAxis;const{addEvent:PlotLineOrBand_addEvent,arrayMax:PlotLineOrBand_arrayMax,arrayMin:PlotLineOrBand_arrayMin,defined:PlotLineOrBand_defined,destroyObjectProperties:PlotLineOrBand_destroyObjectProperties,erase:PlotLineOrBand_erase,fireEvent:PlotLineOrBand_fireEvent,merge:PlotLineOrBand_merge,objectEach:PlotLineOrBand_objectEach,pick:PlotLineOrBand_pick}=Core_Utilities;class PlotLineOrBand{static compose(ChartClass,AxisClass){PlotLineOrBand_addEvent(ChartClass,"afterInit",function(){this.labelCollectors.push(()=>{const labels=[];for(const axis of this.axes){for(const{label,options}of axis.plotLinesAndBands){if(label&&!options?.label?.allowOverlap){labels.push(label)}}}return labels})});return PlotLineOrBand_PlotLineOrBandAxis.compose(PlotLineOrBand,AxisClass)}constructor(axis,options){this.axis=axis;this.options=options;this.id=options.id}render(){PlotLineOrBand_fireEvent(this,"render");const{axis,options}=this,{horiz,logarithmic}=axis,{color,events,zIndex=0}=options,{renderer,time}=axis.chart,groupAttribs={},to=time.parse(options.to),from=time.parse(options.from),value=time.parse(options.value),borderWidth=options.borderWidth;let optionsLabel=options.label,{label,svgElem}=this,path=[],group;const isBand=PlotLineOrBand_defined(from)&&PlotLineOrBand_defined(to),isLine=PlotLineOrBand_defined(value),isNew=!svgElem,attribs={class:"highcharts-plot-"+(isBand?"band ":"line ")+(options.className||"")};let groupName=isBand?"bands":"lines";if(!axis.chart.styledMode){if(isLine){attribs.stroke=color||"#999999";attribs["stroke-width"]=PlotLineOrBand_pick(options.width,1);if(options.dashStyle){attribs.dashstyle=options.dashStyle}}else if(isBand){attribs.fill=color||"#e6e9ff";if(borderWidth){attribs.stroke=options.borderColor;attribs["stroke-width"]=borderWidth}}}groupAttribs.zIndex=zIndex;groupName+="-"+zIndex;group=axis.plotLinesAndBandsGroups[groupName];if(!group){axis.plotLinesAndBandsGroups[groupName]=group=renderer.g("plot-"+groupName).attr(groupAttribs).add()}if(!svgElem){this.svgElem=svgElem=renderer.path().attr(attribs).add(group)}if(PlotLineOrBand_defined(value)){path=axis.getPlotLinePath({value:logarithmic?.log2lin(value)??value,lineWidth:svgElem.strokeWidth(),acrossPanes:options.acrossPanes})}else if(PlotLineOrBand_defined(from)&&PlotLineOrBand_defined(to)){path=axis.getPlotBandPath(logarithmic?.log2lin(from)??from,logarithmic?.log2lin(to)??to,options)}else{return}if(!this.eventsAdded&&events){PlotLineOrBand_objectEach(events,(event,eventType)=>{svgElem?.on(eventType,e=>{events[eventType].apply(this,[e])})});this.eventsAdded=true}if((isNew||!svgElem.d)&&path?.length){svgElem.attr({d:path})}else if(svgElem){if(path){svgElem.show();svgElem.animate({d:path})}else if(svgElem.d){svgElem.hide();if(label){this.label=label=label.destroy()}}}if(optionsLabel&&(PlotLineOrBand_defined(optionsLabel.text)||PlotLineOrBand_defined(optionsLabel.formatter))&&path?.length&&axis.width>0&&axis.height>0&&!path.isFlat){optionsLabel=PlotLineOrBand_merge({align:horiz&&isBand?"center":void 0,x:horiz?!isBand&&4:10,verticalAlign:!horiz&&isBand?"middle":void 0,y:horiz?isBand?16:10:isBand?6:-4,rotation:horiz&&!isBand?90:0,...isBand?{inside:true}:{}},optionsLabel);this.renderLabel(optionsLabel,path,isBand,zIndex)}else if(label){label.hide()}return this}renderLabel(optionsLabel,path,isBand,zIndex){const plotLine=this,axis=plotLine.axis,renderer=axis.chart.renderer,inside=optionsLabel.inside;let label=plotLine.label;if(!label){plotLine.label=label=renderer.text(this.getLabelText(optionsLabel),0,0,optionsLabel.useHTML).attr({align:optionsLabel.textAlign||optionsLabel.align,rotation:optionsLabel.rotation,class:"highcharts-plot-"+(isBand?"band":"line")+"-label "+(optionsLabel.className||""),zIndex:zIndex});if(!axis.chart.styledMode){label.css(PlotLineOrBand_merge({fontSize:"0.8em",textOverflow:isBand&&!inside?"":"ellipsis"},optionsLabel.style))}label.add()}const xBounds=path.xBounds||[path[0][1],path[1][1],isBand?path[2][1]:path[0][1]],yBounds=path.yBounds||[path[0][2],path[1][2],isBand?path[2][2]:path[0][2]],x=PlotLineOrBand_arrayMin(xBounds),y=PlotLineOrBand_arrayMin(yBounds),bBoxWidth=PlotLineOrBand_arrayMax(xBounds)-x;label.align(optionsLabel,false,{x:x,y:y,width:bBoxWidth,height:PlotLineOrBand_arrayMax(yBounds)-y});if(!label.alignValue||label.alignValue==="left"||PlotLineOrBand_defined(inside)){label.css({width:(optionsLabel.style?.width||(!isBand||!inside?label.rotation===90?axis.height-(label.alignAttr.y-axis.top):(optionsLabel.clip?axis.width:axis.chart.chartWidth)-(label.alignAttr.x-axis.left):bBoxWidth))+"px"})}label.show(true)}getLabelText(optionsLabel){return PlotLineOrBand_defined(optionsLabel.formatter)?optionsLabel.formatter.call(this):optionsLabel.text}destroy(){PlotLineOrBand_erase(this.axis.plotLinesAndBands,this);delete this.axis;PlotLineOrBand_destroyObjectProperties(this)}}const PlotLineOrBand_PlotLineOrBand=PlotLineOrBand;"";"";const{animObject:Tooltip_animObject}=AnimationUtilities;const{format:Tooltip_format}=Core_Templating;const{composed:Tooltip_composed,dateFormats,doc:Tooltip_doc,isSafari}=Core_Globals;const{distribute}=Renderer_RendererUtilities;const{addEvent:Tooltip_addEvent,clamp:Tooltip_clamp,css:Tooltip_css,discardElement:Tooltip_discardElement,extend:Tooltip_extend,fireEvent:Tooltip_fireEvent,isArray:Tooltip_isArray,isNumber:Tooltip_isNumber,isObject:Tooltip_isObject,isString:Tooltip_isString,merge:Tooltip_merge,pick:Tooltip_pick,pushUnique:Tooltip_pushUnique,splat:Tooltip_splat,syncTimeout:Tooltip_syncTimeout}=Core_Utilities;class Tooltip{constructor(chart,options,pointer){this.allowShared=true;this.crosshairs=[];this.distance=0;this.isHidden=true;this.isSticky=false;this.options={};this.outside=false;this.chart=chart;this.init(chart,options);this.pointer=pointer}bodyFormatter(points){return points.map(point=>{const tooltipOptions=point.series.tooltipOptions,formatPrefix=point.formatPrefix||"point";return(tooltipOptions[formatPrefix+"Formatter"]||point.tooltipFormatter).call(point,tooltipOptions[formatPrefix+"Format"]||"")})}cleanSplit(force){this.chart.series.forEach(function(series){const tt=series&&series.tt;if(tt){if(!tt.isActive||force){series.tt=tt.destroy()}else{tt.isActive=false}}})}defaultFormatter(tooltip){const hoverPoints=this.points||Tooltip_splat(this);let s;s=[tooltip.headerFooterFormatter(hoverPoints[0])];s=s.concat(tooltip.bodyFormatter(hoverPoints));s.push(tooltip.headerFooterFormatter(hoverPoints[0],true));return s}destroy(){if(this.label){this.label=this.label.destroy()}if(this.split){this.cleanSplit(true);if(this.tt){this.tt=this.tt.destroy()}}if(this.renderer){this.renderer=this.renderer.destroy();Tooltip_discardElement(this.container)}Core_Utilities.clearTimeout(this.hideTimer)}getAnchor(points,mouseEvent){const{chart,pointer}=this,inverted=chart.inverted,plotTop=chart.plotTop,plotLeft=chart.plotLeft;let ret;points=Tooltip_splat(points);if(points[0].series&&points[0].series.yAxis&&!points[0].series.yAxis.options.reversedStacks){points=points.slice().reverse()}if(this.followPointer&&mouseEvent){if(typeof mouseEvent.chartX==="undefined"){mouseEvent=pointer.normalize(mouseEvent)}ret=[mouseEvent.chartX-plotLeft,mouseEvent.chartY-plotTop]}else if(points[0].tooltipPos){ret=points[0].tooltipPos}else{let chartX=0,chartY=0;points.forEach(function(point){const pos=point.pos(true);if(pos){chartX+=pos[0];chartY+=pos[1]}});chartX/=points.length;chartY/=points.length;if(this.shared&&points.length>1&&mouseEvent){if(inverted){chartX=mouseEvent.chartX}else{chartY=mouseEvent.chartY}}ret=[chartX-plotLeft,chartY-plotTop]}return ret.map(Math.round)}getClassName(point,isSplit,isHeader){const options=this.options,series=point.series,seriesOptions=series.options;return[options.className,"highcharts-label",isHeader&&"highcharts-tooltip-header",isSplit?"highcharts-tooltip-box":"highcharts-tooltip",!isHeader&&"highcharts-color-"+Tooltip_pick(point.colorIndex,series.colorIndex),seriesOptions&&seriesOptions.className].filter(Tooltip_isString).join(" ")}getLabel({anchorX,anchorY}={anchorX:0,anchorY:0}){const tooltip=this,styledMode=this.chart.styledMode,options=this.options,doSplit=this.split&&this.allowShared;let container=this.container,renderer=this.chart.renderer;if(this.label){const wasSplit=!this.label.hasClass("highcharts-label");if(!doSplit&&wasSplit||doSplit&&!wasSplit){this.destroy()}}if(!this.label){if(this.outside){const chart=this.chart,chartStyle=chart.options.chart.style,Renderer=Renderer_RendererRegistry.getRendererType();this.container=container=Core_Globals.doc.createElement("div");container.className="highcharts-tooltip-container "+(chart.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm)||[].join(" "));Tooltip_css(container,{position:"absolute",top:"1px",pointerEvents:"none",zIndex:Math.max(this.options.style.zIndex||0,(chartStyle&&chartStyle.zIndex||0)+3)});this.renderer=renderer=new Renderer(container,0,0,chartStyle,void 0,void 0,renderer.styledMode)}if(doSplit){this.label=renderer.g("tooltip")}else{this.label=renderer.label("",anchorX,anchorY,options.shape,void 0,void 0,options.useHTML,void 0,"tooltip").attr({padding:options.padding,r:options.borderRadius});if(!styledMode){this.label.attr({fill:options.backgroundColor,"stroke-width":options.borderWidth||0}).css(options.style).css({pointerEvents:options.style.pointerEvents||(this.shouldStickOnContact()?"auto":"none")})}}if(tooltip.outside){const label=this.label;[label.xSetter,label.ySetter].forEach((setter,i)=>{label[i?"ySetter":"xSetter"]=value=>{setter.call(label,tooltip.distance);label[i?"y":"x"]=value;if(container){container.style[i?"top":"left"]=`${value}px`}}})}this.label.attr({zIndex:8}).shadow(options.shadow).add()}if(container&&!container.parentElement){Core_Globals.doc.body.appendChild(container)}return this.label}getPlayingField(){const{body,documentElement}=Tooltip_doc,{chart,distance,outside}=this;return{width:outside?Math.max(body.scrollWidth,documentElement.scrollWidth,body.offsetWidth,documentElement.offsetWidth,documentElement.clientWidth)-2*distance-2:chart.chartWidth,height:outside?Math.max(body.scrollHeight,documentElement.scrollHeight,body.offsetHeight,documentElement.offsetHeight,documentElement.clientHeight):chart.chartHeight}}getPosition(boxWidth,boxHeight,point){const{distance,chart,outside,pointer}=this,{inverted,plotLeft,plotTop,polar}=chart,{plotX=0,plotY=0}=point,ret={},h=inverted&&point.h||0,{height:outerHeight,width:outerWidth}=this.getPlayingField(),chartPosition=pointer.getChartPosition(),scaleX=val=>val*chartPosition.scaleX,scaleY=val=>val*chartPosition.scaleY,buildDimensionArray=dim=>{const isX=dim==="x";return[dim,isX?outerWidth:outerHeight,isX?boxWidth:boxHeight].concat(outside?[isX?scaleX(boxWidth):scaleY(boxHeight),isX?chartPosition.left-distance+scaleX(plotX+plotLeft):chartPosition.top-distance+scaleY(plotY+plotTop),0,isX?outerWidth:outerHeight]:[isX?boxWidth:boxHeight,isX?plotX+plotLeft:plotY+plotTop,isX?plotLeft:plotTop,isX?plotLeft+chart.plotWidth:plotTop+chart.plotHeight])};let first=buildDimensionArray("y"),second=buildDimensionArray("x"),swapped;let flipped=!!point.negative;if(!polar&&chart.hoverSeries?.yAxis?.reversed){flipped=!flipped}const preferFarSide=!this.followPointer&&Tooltip_pick(point.ttBelow,polar?false:!inverted===flipped),firstDimension=function(dim,outerSize,innerSize,scaledInnerSize,point,min,max){const scaledDist=outside?dim==="y"?scaleY(distance):scaleX(distance):distance,scaleDiff=(innerSize-scaledInnerSize)/2,roomLeft=scaledInnerSize<point-distance,roomRight=point+distance+scaledInnerSize<outerSize,alignedLeft=point-scaledDist-innerSize+scaleDiff,alignedRight=point+scaledDist-scaleDiff;if(preferFarSide&&roomRight){ret[dim]=alignedRight}else if(!preferFarSide&&roomLeft){ret[dim]=alignedLeft}else if(roomLeft){ret[dim]=Math.min(max-scaledInnerSize,alignedLeft-h<0?alignedLeft:alignedLeft-h)}else if(roomRight){ret[dim]=Math.max(min,alignedRight+h+innerSize>outerSize?alignedRight:alignedRight+h)}else{return false}},secondDimension=function(dim,outerSize,innerSize,scaledInnerSize,point){if(point<distance||point>outerSize-distance){return false}if(point<innerSize/2){ret[dim]=1}else if(point>outerSize-scaledInnerSize/2){ret[dim]=outerSize-scaledInnerSize-2}else{ret[dim]=point-innerSize/2}},swap=function(count){[first,second]=[second,first];swapped=count},run=()=>{if(firstDimension.apply(0,first)!==false){if(secondDimension.apply(0,second)===false&&!swapped){swap(true);run()}}else if(!swapped){swap(true);run()}else{ret.x=ret.y=0}};if(inverted&&!polar||this.len>1){swap()}run();return ret}hide(delay){const tooltip=this;Core_Utilities.clearTimeout(this.hideTimer);delay=Tooltip_pick(delay,this.options.hideDelay);if(!this.isHidden){this.hideTimer=Tooltip_syncTimeout(function(){const label=tooltip.getLabel();tooltip.getLabel().animate({opacity:0},{duration:delay?150:delay,complete:()=>{label.hide();if(tooltip.container){tooltip.container.remove()}}});tooltip.isHidden=true},delay)}}init(chart,options){this.chart=chart;this.options=options;this.crosshairs=[];this.isHidden=true;this.split=options.split&&!chart.inverted&&!chart.polar;this.shared=options.shared||this.split;this.outside=Tooltip_pick(options.outside,Boolean(chart.scrollablePixelsX||chart.scrollablePixelsY))}shouldStickOnContact(pointerEvent){return!!(!this.followPointer&&this.options.stickOnContact&&(!pointerEvent||this.pointer.inClass(pointerEvent.target,"highcharts-tooltip")))}move(x,y,anchorX,anchorY){const tooltip=this,animation=Tooltip_animObject(!tooltip.isHidden&&tooltip.options.animation),skipAnchor=tooltip.followPointer||(tooltip.len||0)>1,attr={x:x,y:y};if(!skipAnchor){attr.anchorX=anchorX;attr.anchorY=anchorY}animation.step=()=>tooltip.drawTracker();tooltip.getLabel().animate(attr,animation)}refresh(pointOrPoints,mouseEvent){const tooltip=this,{chart,options,pointer,shared}=this,points=Tooltip_splat(pointOrPoints),point=points[0],formatString=options.format,formatter=options.formatter||tooltip.defaultFormatter,styledMode=chart.styledMode;let wasShared=tooltip.allowShared;if(!options.enabled||!point.series){return}Core_Utilities.clearTimeout(this.hideTimer);tooltip.allowShared=!(!Tooltip_isArray(pointOrPoints)&&pointOrPoints.series&&pointOrPoints.series.noSharedTooltip);wasShared=wasShared&&!tooltip.allowShared;tooltip.followPointer=!tooltip.split&&point.series.tooltipOptions.followPointer;const anchor=tooltip.getAnchor(pointOrPoints,mouseEvent),x=anchor[0],y=anchor[1];if(shared&&tooltip.allowShared){pointer.applyInactiveState(points);points.forEach(item=>item.setState("hover"));point.points=points}this.len=points.length;const text=Tooltip_isString(formatString)?Tooltip_format(formatString,point,chart):formatter.call(point,tooltip);point.points=void 0;const currentSeries=point.series;this.distance=Tooltip_pick(currentSeries.tooltipOptions.distance,16);if(text===false){this.hide()}else{if(tooltip.split&&tooltip.allowShared){this.renderSplit(text,points)}else{let checkX=x;let checkY=y;if(mouseEvent&&pointer.isDirectTouch){checkX=mouseEvent.chartX-chart.plotLeft;checkY=mouseEvent.chartY-chart.plotTop}if(chart.polar||currentSeries.options.clip===false||points.some(p=>pointer.isDirectTouch||p.series.shouldShowTooltip(checkX,checkY))){const label=tooltip.getLabel(wasShared&&tooltip.tt||{});if(!options.style.width||styledMode){label.css({width:(this.outside?this.getPlayingField():chart.spacingBox).width+"px"})}label.attr({class:tooltip.getClassName(point),text:text&&text.join?text.join(""):text});if(this.outside){label.attr({x:Tooltip_clamp(label.x||0,0,this.getPlayingField().width-(label.width||0)-1)})}if(!styledMode){label.attr({stroke:options.borderColor||point.color||currentSeries.color||"#666666"})}tooltip.updatePosition({plotX:x,plotY:y,negative:point.negative,ttBelow:point.ttBelow,h:anchor[2]||0})}else{tooltip.hide();return}}if(tooltip.isHidden&&tooltip.label){tooltip.label.attr({opacity:1}).show()}tooltip.isHidden=false}Tooltip_fireEvent(this,"refresh")}renderSplit(labels,points){const tooltip=this;const{chart,chart:{chartWidth,chartHeight,plotHeight,plotLeft,plotTop,scrollablePixelsY=0,scrollablePixelsX,styledMode},distance,options,options:{positioner},pointer}=tooltip;const{scrollLeft=0,scrollTop=0}=chart.scrollablePlotArea?.scrollingContainer||{};const bounds=tooltip.outside&&typeof scrollablePixelsX!=="number"?Tooltip_doc.documentElement.getBoundingClientRect():{left:scrollLeft,right:scrollLeft+chartWidth,top:scrollTop,bottom:scrollTop+chartHeight};const tooltipLabel=tooltip.getLabel();const ren=this.renderer||chart.renderer;const headerTop=Boolean(chart.xAxis[0]&&chart.xAxis[0].opposite);const{left:chartLeft,top:chartTop}=pointer.getChartPosition();let distributionBoxTop=plotTop+scrollTop;let headerHeight=0;let adjustedPlotHeight=plotHeight-scrollablePixelsY;function getAnchor(point){const{isHeader,plotX=0,plotY=0,series}=point;let anchorX;let anchorY;if(isHeader){anchorX=Math.max(plotLeft+plotX,plotLeft);anchorY=plotTop+plotHeight/2}else{const{xAxis,yAxis}=series;anchorX=xAxis.pos+Tooltip_clamp(plotX,-distance,xAxis.len+distance);if(series.shouldShowTooltip(0,yAxis.pos-plotTop+plotY,{ignoreX:true})){anchorY=yAxis.pos+plotY}}anchorX=Tooltip_clamp(anchorX,bounds.left-distance,bounds.right+distance);return{anchorX:anchorX,anchorY:anchorY}}function defaultPositioner(anchorX,anchorY,isHeader,boxWidth,alignedLeft=true){let y;let x;if(isHeader){y=headerTop?0:adjustedPlotHeight;x=Tooltip_clamp(anchorX-boxWidth/2,bounds.left,bounds.right-boxWidth-(tooltip.outside?chartLeft:0))}else{y=anchorY-distributionBoxTop;x=alignedLeft?anchorX-boxWidth-distance:anchorX+distance;x=Tooltip_clamp(x,alignedLeft?x:bounds.left,bounds.right)}return{x:x,y:y}}function updatePartialTooltip(partialTooltip,point,str){let tt=partialTooltip;const{isHeader,series}=point;if(!tt){const attribs={padding:options.padding,r:options.borderRadius};if(!styledMode){attribs.fill=options.backgroundColor;attribs["stroke-width"]=options.borderWidth??1}tt=ren.label("",0,0,options[isHeader?"headerShape":"shape"],void 0,void 0,options.useHTML).addClass(tooltip.getClassName(point,true,isHeader)).attr(attribs).add(tooltipLabel)}tt.isActive=true;tt.attr({text:str});if(!styledMode){tt.css(options.style).attr({stroke:options.borderColor||point.color||series.color||"#333333"})}return tt}if(Tooltip_isString(labels)){labels=[false,labels]}let boxes=labels.slice(0,points.length+1).reduce(function(boxes,str,i){if(str!==false&&str!==""){const point=points[i-1]||{isHeader:true,plotX:points[0].plotX,plotY:plotHeight,series:{}};const isHeader=point.isHeader;const owner=isHeader?tooltip:point.series;const tt=owner.tt=updatePartialTooltip(owner.tt,point,str.toString());const bBox=tt.getBBox();const boxWidth=bBox.width+tt.strokeWidth();if(isHeader){headerHeight=bBox.height;adjustedPlotHeight+=headerHeight;if(headerTop){distributionBoxTop-=headerHeight}}const{anchorX,anchorY}=getAnchor(point);if(typeof anchorY==="number"){const size=bBox.height+1;const boxPosition=positioner?positioner.call(tooltip,boxWidth,size,point):defaultPositioner(anchorX,anchorY,isHeader,boxWidth);boxes.push({align:positioner?0:void 0,anchorX:anchorX,anchorY:anchorY,boxWidth:boxWidth,point:point,rank:Tooltip_pick(boxPosition.rank,isHeader?1:0),size:size,target:boxPosition.y,tt:tt,x:boxPosition.x})}else{tt.isActive=false}}return boxes},[]);if(!positioner&&boxes.some(box=>{const{outside}=tooltip;const boxStart=(outside?chartLeft:0)+box.anchorX;if(boxStart<bounds.left&&boxStart+box.boxWidth<bounds.right){return true}return boxStart<chartLeft-bounds.left+box.boxWidth&&bounds.right-boxStart>boxStart})){boxes=boxes.map(box=>{const{x,y}=defaultPositioner(box.anchorX,box.anchorY,box.point.isHeader,box.boxWidth,false);return Tooltip_extend(box,{target:y,x:x})})}tooltip.cleanSplit();distribute(boxes,adjustedPlotHeight);const boxExtremes={left:chartLeft,right:chartLeft};boxes.forEach(function(box){const{x,boxWidth,isHeader}=box;if(!isHeader){if(tooltip.outside&&chartLeft+x<boxExtremes.left){boxExtremes.left=chartLeft+x}if(!isHeader&&tooltip.outside&&boxExtremes.left+boxWidth>boxExtremes.right){boxExtremes.right=chartLeft+x}}});boxes.forEach(function(box){const{x,anchorX,anchorY,pos,point:{isHeader}}=box;const attributes={visibility:typeof pos==="undefined"?"hidden":"inherit",x:x,y:(pos||0)+distributionBoxTop,anchorX:anchorX,anchorY:anchorY};if(tooltip.outside&&x<anchorX){const offset=chartLeft-boxExtremes.left;if(offset>0){if(!isHeader){attributes.x=x+offset;attributes.anchorX=anchorX+offset}if(isHeader){attributes.x=(boxExtremes.right-boxExtremes.left)/2;attributes.anchorX=anchorX+offset}}}box.tt.attr(attributes)});const{container,outside,renderer}=tooltip;if(outside&&container&&renderer){const{width,height,x,y}=tooltipLabel.getBBox();renderer.setSize(width+x,height+y,false);container.style.left=boxExtremes.left+"px";container.style.top=chartTop+"px"}if(isSafari){tooltipLabel.attr({opacity:tooltipLabel.opacity===1?.999:1})}}drawTracker(){const tooltip=this;if(!this.shouldStickOnContact()){if(tooltip.tracker){tooltip.tracker=tooltip.tracker.destroy()}return}const chart=tooltip.chart;const label=tooltip.label;const points=tooltip.shared?chart.hoverPoints:chart.hoverPoint;if(!label||!points){return}const box={x:0,y:0,width:0,height:0};const anchorPos=this.getAnchor(points);const labelBBox=label.getBBox();anchorPos[0]+=chart.plotLeft-(label.translateX||0);anchorPos[1]+=chart.plotTop-(label.translateY||0);box.x=Math.min(0,anchorPos[0]);box.y=Math.min(0,anchorPos[1]);box.width=anchorPos[0]<0?Math.max(Math.abs(anchorPos[0]),labelBBox.width-anchorPos[0]):Math.max(Math.abs(anchorPos[0]),labelBBox.width);box.height=anchorPos[1]<0?Math.max(Math.abs(anchorPos[1]),labelBBox.height-Math.abs(anchorPos[1])):Math.max(Math.abs(anchorPos[1]),labelBBox.height);if(tooltip.tracker){tooltip.tracker.attr(box)}else{tooltip.tracker=label.renderer.rect(box).addClass("highcharts-tracker").add(label);if(!chart.styledMode){tooltip.tracker.attr({fill:"rgba(0,0,0,0)"})}}}styledModeFormat(formatString){return formatString.replace('style="font-size: 0.8em"','class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g,'class="highcharts-color-{$1.colorIndex} '+"{series.options.className} "+'{point.options.className}"')}headerFooterFormatter(point,isFooter){const series=point.series,tooltipOptions=series.tooltipOptions,xAxis=series.xAxis,dateTime=xAxis&&xAxis.dateTime,e={isFooter:isFooter,point:point};let xDateFormat=tooltipOptions.xDateFormat||"",formatString=tooltipOptions[isFooter?"footerFormat":"headerFormat"];Tooltip_fireEvent(this,"headerFormatter",e,function(e){if(dateTime&&!xDateFormat&&Tooltip_isNumber(point.key)){xDateFormat=dateTime.getXDateFormat(point.key,tooltipOptions.dateTimeLabelFormats)}if(dateTime&&xDateFormat){if(Tooltip_isObject(xDateFormat)){const format=xDateFormat;dateFormats[0]=timestamp=>series.chart.time.dateFormat(format,timestamp);xDateFormat="%0"}(point.tooltipDateKeys||["key"]).forEach(key=>{formatString=formatString.replace(new RegExp("point\\."+key+"([ \\)}])",""),`(point.${key}:${xDateFormat})$1`)})}if(series.chart.styledMode){formatString=this.styledModeFormat(formatString)}e.text=Tooltip_format(formatString,point,this.chart)});return e.text||""}update(options){this.destroy();this.init(this.chart,Tooltip_merge(true,this.options,options))}updatePosition(point){const{chart,container,distance,options,pointer,renderer}=this,{height=0,width=0}=this.getLabel(),{left,top,scaleX,scaleY}=pointer.getChartPosition(),pos=(options.positioner||this.getPosition).call(this,width,height,point),doc=Core_Globals.doc;let anchorX=(point.plotX||0)+chart.plotLeft,anchorY=(point.plotY||0)+chart.plotTop,pad;if(renderer&&container){if(options.positioner){pos.x+=left-distance;pos.y+=top-distance}pad=(options.borderWidth||0)+2*distance+2;renderer.setSize(Tooltip_clamp(width+pad,0,doc.documentElement.clientWidth)-1,height+pad,false);if(scaleX!==1||scaleY!==1){Tooltip_css(container,{transform:`scale(${scaleX}, ${scaleY})`});anchorX*=scaleX;anchorY*=scaleY}anchorX+=left-pos.x;anchorY+=top-pos.y}this.move(Math.round(pos.x),Math.round(pos.y||0),anchorX,anchorY)}}(function(Tooltip){function compose(PointerClass){if(Tooltip_pushUnique(Tooltip_composed,"Core.Tooltip")){Tooltip_addEvent(PointerClass,"afterInit",function(){const chart=this.chart;if(chart.options.tooltip){chart.tooltip=new Tooltip(chart,chart.options.tooltip,this)}})}}Tooltip.compose=compose})(Tooltip||(Tooltip={}));const Core_Tooltip=Tooltip;"";const{animObject:Point_animObject}=AnimationUtilities;const{defaultOptions:Point_defaultOptions}=Defaults;const{format:Point_format}=Core_Templating;const{addEvent:Point_addEvent,crisp:Point_crisp,erase:Point_erase,extend:Point_extend,fireEvent:Point_fireEvent,getNestedProperty:Point_getNestedProperty,isArray:Point_isArray,isFunction:Point_isFunction,isNumber:Point_isNumber,isObject:Point_isObject,merge:Point_merge,pick:Point_pick,syncTimeout:Point_syncTimeout,removeEvent:Point_removeEvent,uniqueKey:Point_uniqueKey}=Core_Utilities;class Point{animateBeforeDestroy(){const point=this,animateParams={x:point.startXPos,opacity:0},graphicalProps=point.getGraphicalProps();graphicalProps.singular.forEach(function(prop){const isDataLabel=prop==="dataLabel";point[prop]=point[prop].animate(isDataLabel?{x:point[prop].startXPos,y:point[prop].startYPos,opacity:0}:animateParams)});graphicalProps.plural.forEach(function(plural){point[plural].forEach(function(item){if(item.element){item.animate(Point_extend({x:point.startXPos},item.startYPos?{x:item.startXPos,y:item.startYPos}:{}))}})})}applyOptions(options,x){const point=this,series=point.series,pointValKey=series.options.pointValKey||series.pointValKey;options=Point.prototype.optionsToObject.call(this,options);Point_extend(point,options);point.options=point.options?Point_extend(point.options,options):options;if(options.group){delete point.group}if(options.dataLabels){delete point.dataLabels}if(pointValKey){point.y=Point.prototype.getNestedProperty.call(point,pointValKey)}if(point.selected){point.state="select"}if("name"in point&&typeof x==="undefined"&&series.xAxis&&series.xAxis.hasNames){point.x=series.xAxis.nameToX(point)}if(typeof point.x==="undefined"&&series){point.x=x??series.autoIncrement()}else if(Point_isNumber(options.x)&&series.options.relativeXValue){point.x=series.autoIncrement(options.x)}else if(typeof point.x==="string"){x??(x=series.chart.time.parse(point.x));if(Point_isNumber(x)){point.x=x}}point.isNull=this.isValid&&!this.isValid();point.formatPrefix=point.isNull?"null":"point";return point}destroy(){if(!this.destroyed){const point=this,series=point.series,chart=series.chart,dataSorting=series.options.dataSorting,hoverPoints=chart.hoverPoints,globalAnimation=point.series.chart.renderer.globalAnimation,animation=Point_animObject(globalAnimation);const destroyPoint=()=>{if(point.graphic||point.graphics||point.dataLabel||point.dataLabels){Point_removeEvent(point);point.destroyElements()}for(const prop in point){delete point[prop]}};if(point.legendItem){chart.legend.destroyItem(point)}if(hoverPoints){point.setState();Point_erase(hoverPoints,point);if(!hoverPoints.length){chart.hoverPoints=null}}if(point===chart.hoverPoint){point.onMouseOut()}if(!dataSorting||!dataSorting.enabled){destroyPoint()}else{this.animateBeforeDestroy();Point_syncTimeout(destroyPoint,animation.duration)}chart.pointCount--}this.destroyed=true}destroyElements(kinds){const point=this,props=point.getGraphicalProps(kinds);props.singular.forEach(function(prop){point[prop]=point[prop].destroy()});props.plural.forEach(function(plural){point[plural].forEach(function(item){if(item&&item.element){item.destroy()}});delete point[plural]})}firePointEvent(eventType,eventArgs,defaultFunction){const point=this,series=this.series,seriesOptions=series.options;point.manageEvent(eventType);if(eventType==="click"&&seriesOptions.allowPointSelect){defaultFunction=function(event){if(!point.destroyed&&point.select){point.select(null,event.ctrlKey||event.metaKey||event.shiftKey)}}}Point_fireEvent(point,eventType,eventArgs,defaultFunction)}getClassName(){const point=this;return"highcharts-point"+(point.selected?" highcharts-point-select":"")+(point.negative?" highcharts-negative":"")+(point.isNull?" highcharts-null-point":"")+(typeof point.colorIndex!=="undefined"?" highcharts-color-"+point.colorIndex:"")+(point.options.className?" "+point.options.className:"")+(point.zone&&point.zone.className?" "+point.zone.className.replace("highcharts-negative",""):"")}getGraphicalProps(kinds){const point=this,props=[],graphicalProps={singular:[],plural:[]};let prop,i;kinds=kinds||{graphic:1,dataLabel:1};if(kinds.graphic){props.push("graphic","connector")}if(kinds.dataLabel){props.push("dataLabel","dataLabelPath","dataLabelUpper")}i=props.length;while(i--){prop=props[i];if(point[prop]){graphicalProps.singular.push(prop)}}["graphic","dataLabel"].forEach(function(prop){const plural=prop+"s";if(kinds[prop]&&point[plural]){graphicalProps.plural.push(plural)}});return graphicalProps}getNestedProperty(key){if(!key){return}if(key.indexOf("custom.")===0){return Point_getNestedProperty(key,this.options)}return this[key]}getZone(){const series=this.series,zones=series.zones,zoneAxis=series.zoneAxis||"y";let zone,i=0;zone=zones[i];while(this[zoneAxis]>=zone.value){zone=zones[++i]}if(!this.nonZonedColor){this.nonZonedColor=this.color}if(zone&&zone.color&&!this.options.color){this.color=zone.color}else{this.color=this.nonZonedColor}return zone}hasNewShapeType(){const point=this;const oldShapeType=point.graphic&&(point.graphic.symbolName||point.graphic.element.nodeName);return oldShapeType!==this.shapeType}constructor(series,options,x){this.formatPrefix="point";this.visible=true;this.point=this;this.series=series;this.applyOptions(options,x);this.id??(this.id=Point_uniqueKey());this.resolveColor();series.chart.pointCount++;Point_fireEvent(this,"afterInit")}isValid(){return(Point_isNumber(this.x)||this.x instanceof Date)&&Point_isNumber(this.y)}optionsToObject(options){const series=this.series,keys=series.options.keys,pointArrayMap=keys||series.pointArrayMap||["y"],valueCount=pointArrayMap.length;let ret={},firstItemType,i=0,j=0;if(Point_isNumber(options)||options===null){ret[pointArrayMap[0]]=options}else if(Point_isArray(options)){if(!keys&&options.length>valueCount){firstItemType=typeof options[0];if(firstItemType==="string"){if(series.xAxis?.dateTime){ret.x=series.chart.time.parse(options[0])}else{ret.name=options[0]}}else if(firstItemType==="number"){ret.x=options[0]}i++}while(j<valueCount){if(!keys||typeof options[i]!=="undefined"){if(pointArrayMap[j].indexOf(".")>0){Point.prototype.setNestedProperty(ret,options[i],pointArrayMap[j])}else{ret[pointArrayMap[j]]=options[i]}}i++;j++}}else if(typeof options==="object"){ret=options;if(options.dataLabels){series.hasDataLabels=()=>true}if(options.marker){series._hasPointMarkers=true}}return ret}pos(chartCoordinates,plotY=this.plotY){if(!this.destroyed){const{plotX,series}=this,{chart,xAxis,yAxis}=series;let posX=0,posY=0;if(Point_isNumber(plotX)&&Point_isNumber(plotY)){if(chartCoordinates){posX=xAxis?xAxis.pos:chart.plotLeft;posY=yAxis?yAxis.pos:chart.plotTop}return chart.inverted&&xAxis&&yAxis?[yAxis.len-plotY+posY,xAxis.len-plotX+posX]:[plotX+posX,plotY+posY]}}}resolveColor(){const series=this.series,optionsChart=series.chart.options.chart,styledMode=series.chart.styledMode;let color,colors,colorCount=optionsChart.colorCount,colorIndex;delete this.nonZonedColor;if(series.options.colorByPoint){if(!styledMode){colors=series.options.colors||series.chart.options.colors;color=colors[series.colorCounter];colorCount=colors.length}colorIndex=series.colorCounter;series.colorCounter++;if(series.colorCounter===colorCount){series.colorCounter=0}}else{if(!styledMode){color=series.color}colorIndex=series.colorIndex}this.colorIndex=Point_pick(this.options.colorIndex,colorIndex);this.color=Point_pick(this.options.color,color)}setNestedProperty(object,value,key){const nestedKeys=key.split(".");nestedKeys.reduce(function(result,key,i,arr){const isLastKey=arr.length-1===i;result[key]=isLastKey?value:Point_isObject(result[key],true)?result[key]:{};return result[key]},object);return object}shouldDraw(){return!this.isNull}tooltipFormatter(pointFormat){const{chart,pointArrayMap=["y"],tooltipOptions}=this.series,{valueDecimals="",valuePrefix="",valueSuffix=""}=tooltipOptions;if(chart.styledMode){pointFormat=chart.tooltip?.styledModeFormat(pointFormat)||pointFormat}pointArrayMap.forEach(key=>{key="{point."+key;if(valuePrefix||valueSuffix){pointFormat=pointFormat.replace(RegExp(key+"}","g"),valuePrefix+key+"}"+valueSuffix)}pointFormat=pointFormat.replace(RegExp(key+"}","g"),key+":,."+valueDecimals+"f}")});return Point_format(pointFormat,this,chart)}update(options,redraw,animation,runEvent){const point=this,series=point.series,graphic=point.graphic,chart=series.chart,seriesOptions=series.options;let i;redraw=Point_pick(redraw,true);function update(){point.applyOptions(options);const hasMockGraphic=graphic&&point.hasMockGraphic;const shouldDestroyGraphic=point.y===null?!hasMockGraphic:hasMockGraphic;if(graphic&&shouldDestroyGraphic){point.graphic=graphic.destroy();delete point.hasMockGraphic}if(Point_isObject(options,true)){if(graphic&&graphic.element){if(options&&options.marker&&typeof options.marker.symbol!=="undefined"){point.graphic=graphic.destroy()}}if(options?.dataLabels&&point.dataLabel){point.dataLabel=point.dataLabel.destroy()}}i=point.index;const row={};for(const key of series.dataColumnKeys()){row[key]=point[key]}series.dataTable.setRow(row,i);seriesOptions.data[i]=Point_isObject(seriesOptions.data[i],true)||Point_isObject(options,true)?point.options:Point_pick(options,seriesOptions.data[i]);series.isDirty=series.isDirtyData=true;if(!series.fixedBox&&series.hasCartesianSeries){chart.isDirtyBox=true}if(seriesOptions.legendType==="point"){chart.isDirtyLegend=true}if(redraw){chart.redraw(animation)}}if(runEvent===false){update()}else{point.firePointEvent("update",{options:options},update)}}remove(redraw,animation){this.series.removePoint(this.series.data.indexOf(this),redraw,animation)}select(selected,accumulate){const point=this,series=point.series,chart=series.chart;selected=Point_pick(selected,!point.selected);this.selectedStaging=selected;point.firePointEvent(selected?"select":"unselect",{accumulate:accumulate},function(){point.selected=point.options.selected=selected;series.options.data[series.data.indexOf(point)]=point.options;point.setState(selected&&"select");if(!accumulate){chart.getSelectedPoints().forEach(function(loopPoint){const loopSeries=loopPoint.series;if(loopPoint.selected&&loopPoint!==point){loopPoint.selected=loopPoint.options.selected=false;loopSeries.options.data[loopSeries.data.indexOf(loopPoint)]=loopPoint.options;loopPoint.setState(chart.hoverPoints&&loopSeries.options.inactiveOtherPoints?"inactive":"");loopPoint.firePointEvent("unselect")}})}});delete this.selectedStaging}onMouseOver(e){const point=this,series=point.series,{inverted,pointer}=series.chart;if(pointer){e=e?pointer.normalize(e):pointer.getChartCoordinatesFromPoint(point,inverted);pointer.runPointActions(e,point)}}onMouseOut(){const point=this,chart=point.series.chart;point.firePointEvent("mouseOut");if(!point.series.options.inactiveOtherPoints){(chart.hoverPoints||[]).forEach(function(p){p.setState()})}chart.hoverPoints=chart.hoverPoint=null}manageEvent(eventType){const point=this,options=Point_merge(point.series.options.point,point.options),userEvent=options.events?.[eventType];if(Point_isFunction(userEvent)&&(!point.hcEvents?.[eventType]||point.hcEvents?.[eventType]?.map(el=>el.fn).indexOf(userEvent)===-1)){point.importedUserEvent?.();point.importedUserEvent=Point_addEvent(point,eventType,userEvent);if(point.hcEvents){point.hcEvents[eventType].userEvent=true}}else if(point.importedUserEvent&&!userEvent&&point.hcEvents?.[eventType]&&point.hcEvents?.[eventType].userEvent){Point_removeEvent(point,eventType);delete point.hcEvents[eventType];if(!Object.keys(point.hcEvents)){delete point.importedUserEvent}}}setState(state,move){const point=this,series=point.series,previousState=point.state,stateOptions=series.options.states[state||"normal"]||{},markerOptions=Point_defaultOptions.plotOptions[series.type].marker&&series.options.marker,normalDisabled=markerOptions&&markerOptions.enabled===false,markerStateOptions=markerOptions&&markerOptions.states&&markerOptions.states[state||"normal"]||{},stateDisabled=markerStateOptions.enabled===false,pointMarker=point.marker||{},chart=series.chart,hasMarkers=markerOptions&&series.markerAttribs;let halo=series.halo,markerAttribs,pointAttribs,pointAttribsAnimation,stateMarkerGraphic=series.stateMarkerGraphic,newSymbol;state=state||"";if(state===point.state&&!move||point.selected&&state!=="select"||stateOptions.enabled===false||state&&(stateDisabled||normalDisabled&&markerStateOptions.enabled===false)||state&&pointMarker.states&&pointMarker.states[state]&&pointMarker.states[state].enabled===false){return}point.state=state;if(hasMarkers){markerAttribs=series.markerAttribs(point,state)}if(point.graphic&&!point.hasMockGraphic){if(previousState){point.graphic.removeClass("highcharts-point-"+previousState)}if(state){point.graphic.addClass("highcharts-point-"+state)}if(!chart.styledMode){pointAttribs=series.pointAttribs(point,state);pointAttribsAnimation=Point_pick(chart.options.chart.animation,stateOptions.animation);const opacity=pointAttribs.opacity;if(series.options.inactiveOtherPoints&&Point_isNumber(opacity)){(point.dataLabels||[]).forEach(function(label){if(label&&!label.hasClass("highcharts-data-label-hidden")){label.animate({opacity:opacity},pointAttribsAnimation);if(label.connector){label.connector.animate({opacity:opacity},pointAttribsAnimation)}}})}point.graphic.animate(pointAttribs,pointAttribsAnimation)}if(markerAttribs){point.graphic.animate(markerAttribs,Point_pick(chart.options.chart.animation,markerStateOptions.animation,markerOptions.animation))}if(stateMarkerGraphic){stateMarkerGraphic.hide()}}else{if(state&&markerStateOptions){newSymbol=pointMarker.symbol||series.symbol;if(stateMarkerGraphic&&stateMarkerGraphic.currentSymbol!==newSymbol){stateMarkerGraphic=stateMarkerGraphic.destroy()}if(markerAttribs){if(!stateMarkerGraphic){if(newSymbol){series.stateMarkerGraphic=stateMarkerGraphic=chart.renderer.symbol(newSymbol,markerAttribs.x,markerAttribs.y,markerAttribs.width,markerAttribs.height,Point_merge(markerOptions,markerStateOptions)).add(series.markerGroup);stateMarkerGraphic.currentSymbol=newSymbol}}else{stateMarkerGraphic[move?"animate":"attr"]({x:markerAttribs.x,y:markerAttribs.y})}}if(!chart.styledMode&&stateMarkerGraphic&&point.state!=="inactive"){stateMarkerGraphic.attr(series.pointAttribs(point,state))}}if(stateMarkerGraphic){stateMarkerGraphic[state&&point.isInside?"show":"hide"]();stateMarkerGraphic.element.point=point;stateMarkerGraphic.addClass(point.getClassName(),true)}}const haloOptions=stateOptions.halo;const markerGraphic=point.graphic||stateMarkerGraphic;const markerVisibility=markerGraphic&&markerGraphic.visibility||"inherit";if(haloOptions&&haloOptions.size&&markerGraphic&&markerVisibility!=="hidden"&&!point.isCluster){if(!halo){series.halo=halo=chart.renderer.path().add(markerGraphic.parentGroup)}halo.show()[move?"animate":"attr"]({d:point.haloPath(haloOptions.size)});halo.attr({class:"highcharts-halo highcharts-color-"+Point_pick(point.colorIndex,series.colorIndex)+(point.className?" "+point.className:""),visibility:markerVisibility,zIndex:-1});halo.point=point;if(!chart.styledMode){halo.attr(Point_extend({fill:point.color||series.color,"fill-opacity":haloOptions.opacity},HTML_AST.filterUserAttributes(haloOptions.attributes||{})))}}else if(halo?.point?.haloPath&&!halo.point.destroyed){halo.animate({d:halo.point.haloPath(0)},null,halo.hide)}Point_fireEvent(point,"afterSetState",{state:state})}haloPath(size){const pos=this.pos();return pos?this.series.chart.renderer.symbols.circle(Point_crisp(pos[0],1)-size,pos[1]-size,size*2,size*2):[]}}const Series_Point=Point;"";const{parse:Pointer_color}=Color_Color;const{charts:Pointer_charts,composed:Pointer_composed,isTouchDevice:Pointer_isTouchDevice}=Core_Globals;const{addEvent:Pointer_addEvent,attr:Pointer_attr,css:Pointer_css,extend:Pointer_extend,find:Pointer_find,fireEvent:Pointer_fireEvent,isNumber:Pointer_isNumber,isObject:Pointer_isObject,objectEach:Pointer_objectEach,offset:Pointer_offset,pick:Pointer_pick,pushUnique:Pointer_pushUnique,splat:Pointer_splat}=Core_Utilities;class Pointer{applyInactiveState(points){let activeSeries=[],series;(points||[]).forEach(function(item){series=item.series;activeSeries.push(series);if(series.linkedParent){activeSeries.push(series.linkedParent)}if(series.linkedSeries){activeSeries=activeSeries.concat(series.linkedSeries)}if(series.navigatorSeries){activeSeries.push(series.navigatorSeries)}});this.chart.series.forEach(function(inactiveSeries){if(activeSeries.indexOf(inactiveSeries)===-1){inactiveSeries.setState("inactive",true)}else if(inactiveSeries.options.inactiveOtherPoints){inactiveSeries.setAllPointsToState("inactive")}})}destroy(){const pointer=this;this.eventsToUnbind.forEach(unbind=>unbind());this.eventsToUnbind=[];if(!Core_Globals.chartCount){Pointer.unbindDocumentMouseUp.forEach(el=>el.unbind());Pointer.unbindDocumentMouseUp.length=0;if(Pointer.unbindDocumentTouchEnd){Pointer.unbindDocumentTouchEnd=Pointer.unbindDocumentTouchEnd()}}clearInterval(pointer.tooltipTimeout);Pointer_objectEach(pointer,function(_val,prop){pointer[prop]=void 0})}getSelectionMarkerAttrs(chartX,chartY){const e={args:{chartX:chartX,chartY:chartY},attrs:{},shapeType:"rect"};Pointer_fireEvent(this,"getSelectionMarkerAttrs",e,e=>{const{chart,zoomHor,zoomVert}=this,{mouseDownX=0,mouseDownY=0}=chart,attrs=e.attrs;let size;attrs.x=chart.plotLeft;attrs.y=chart.plotTop;attrs.width=zoomHor?1:chart.plotWidth;attrs.height=zoomVert?1:chart.plotHeight;if(zoomHor){size=chartX-mouseDownX;attrs.width=Math.max(1,Math.abs(size));attrs.x=(size>0?0:size)+mouseDownX}if(zoomVert){size=chartY-mouseDownY;attrs.height=Math.max(1,Math.abs(size));attrs.y=(size>0?0:size)+mouseDownY}});return e}drag(e){const{chart}=this,{mouseDownX=0,mouseDownY=0}=chart,{panning,panKey,selectionMarkerFill}=chart.options.chart,plotLeft=chart.plotLeft,plotTop=chart.plotTop,plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,panningEnabled=Pointer_isObject(panning)?panning.enabled:panning,panKeyPressed=panKey&&e[`${panKey}Key`];let chartX=e.chartX,chartY=e.chartY,clickedInside,selectionMarker=this.selectionMarker;if(selectionMarker&&selectionMarker.touch){return}if(chartX<plotLeft){chartX=plotLeft}else if(chartX>plotLeft+plotWidth){chartX=plotLeft+plotWidth}if(chartY<plotTop){chartY=plotTop}else if(chartY>plotTop+plotHeight){chartY=plotTop+plotHeight}this.hasDragged=Math.sqrt(Math.pow(mouseDownX-chartX,2)+Math.pow(mouseDownY-chartY,2));if(this.hasDragged>10){clickedInside=chart.isInsidePlot(mouseDownX-plotLeft,mouseDownY-plotTop,{visiblePlotOnly:true});const{shapeType,attrs}=this.getSelectionMarkerAttrs(chartX,chartY);if((chart.hasCartesianSeries||chart.mapView)&&this.hasZoom&&clickedInside&&!panKeyPressed){if(!selectionMarker){this.selectionMarker=selectionMarker=chart.renderer[shapeType]();selectionMarker.attr({class:"highcharts-selection-marker",zIndex:7}).add();if(!chart.styledMode){selectionMarker.attr({fill:selectionMarkerFill||Pointer_color("#334eff").setOpacity(.25).get()})}}}if(selectionMarker){selectionMarker.attr(attrs)}if(clickedInside&&!selectionMarker&&panningEnabled){chart.pan(e,panning)}}}dragStart(e){const chart=this.chart;chart.mouseIsDown=e.type;chart.cancelClick=false;chart.mouseDownX=e.chartX;chart.mouseDownY=e.chartY}getSelectionBox(marker){const e={args:{marker:marker},result:marker.getBBox()};Pointer_fireEvent(this,"getSelectionBox",e);return e.result}drop(e){const{chart,selectionMarker}=this;let redraw;for(const axis of chart.axes){if(axis.isPanning){axis.isPanning=false;if(axis.options.startOnTick||axis.options.endOnTick||axis.series.some(s=>s.boosted)){axis.forceRedraw=true;axis.setExtremes(axis.userMin,axis.userMax,false);redraw=true}}}if(redraw){chart.redraw()}if(selectionMarker&&e){if(this.hasDragged){const from=this.getSelectionBox(selectionMarker);chart.transform({axes:chart.axes.filter(a=>a.zoomEnabled&&(a.coll==="xAxis"&&this.zoomX||a.coll==="yAxis"&&this.zoomY)),selection:{originalEvent:e,xAxis:[],yAxis:[],...from},from:from})}if(Pointer_isNumber(chart.index)){this.selectionMarker=selectionMarker.destroy()}}if(chart&&Pointer_isNumber(chart.index)){Pointer_css(chart.container,{cursor:chart._cursor});chart.cancelClick=this.hasDragged>10;chart.mouseIsDown=false;this.hasDragged=0;this.pinchDown=[]}}findNearestKDPoint(series,shared,e){let closest;function sort(p1,p2){const isCloserX=p1.distX-p2.distX,isCloser=p1.dist-p2.dist,isAbove=p2.series.group?.zIndex-p1.series.group?.zIndex;let result;if(isCloserX!==0&&shared){result=isCloserX}else if(isCloser!==0){result=isCloser}else if(isAbove!==0){result=isAbove}else{result=p1.series.index>p2.series.index?-1:1}return result}series.forEach(function(s){const noSharedTooltip=s.noSharedTooltip&&shared,compareX=!noSharedTooltip&&s.options.findNearestPointBy.indexOf("y")<0,point=s.searchPoint(e,compareX);if(Pointer_isObject(point,true)&&point.series&&(!Pointer_isObject(closest,true)||sort(closest,point)>0)){closest=point}});return closest}getChartCoordinatesFromPoint(point,inverted){const{xAxis,yAxis}=point.series,shapeArgs=point.shapeArgs;if(xAxis&&yAxis){let x=point.clientX??point.plotX??0,y=point.plotY||0;if(point.isNode&&shapeArgs&&Pointer_isNumber(shapeArgs.x)&&Pointer_isNumber(shapeArgs.y)){x=shapeArgs.x;y=shapeArgs.y}return inverted?{chartX:yAxis.len+yAxis.pos-y,chartY:xAxis.len+xAxis.pos-x}:{chartX:x+xAxis.pos,chartY:y+yAxis.pos}}if(shapeArgs&&shapeArgs.x&&shapeArgs.y){return{chartX:shapeArgs.x,chartY:shapeArgs.y}}}getChartPosition(){if(this.chartPosition){return this.chartPosition}const{container}=this.chart;const pos=Pointer_offset(container);this.chartPosition={left:pos.left,top:pos.top,scaleX:1,scaleY:1};const{offsetHeight,offsetWidth}=container;if(offsetWidth>2&&offsetHeight>2){this.chartPosition.scaleX=pos.width/offsetWidth;this.chartPosition.scaleY=pos.height/offsetHeight}return this.chartPosition}getCoordinates(e){const coordinates={xAxis:[],yAxis:[]};for(const axis of this.chart.axes){coordinates[axis.isXAxis?"xAxis":"yAxis"].push({axis:axis,value:axis.toValue(e[axis.horiz?"chartX":"chartY"])})}return coordinates}getHoverData(existingHoverPoint,existingHoverSeries,series,isDirectTouch,shared,e){const hoverPoints=[],useExisting=!!(isDirectTouch&&existingHoverPoint),filter=function(s){return s.visible&&!(!shared&&s.directTouch)&&Pointer_pick(s.options.enableMouseTracking,true)};let hoverSeries=existingHoverSeries,searchSeries,eventArgs={chartX:e?e.chartX:void 0,chartY:e?e.chartY:void 0,shared:shared};Pointer_fireEvent(this,"beforeGetHoverData",eventArgs);const notSticky=hoverSeries&&!hoverSeries.stickyTracking;searchSeries=notSticky?[hoverSeries]:series.filter(s=>s.stickyTracking&&(eventArgs.filter||filter)(s));const hoverPoint=useExisting||!e?existingHoverPoint:this.findNearestKDPoint(searchSeries,shared,e);hoverSeries=hoverPoint&&hoverPoint.series;if(hoverPoint){if(shared&&!hoverSeries.noSharedTooltip){searchSeries=series.filter(function(s){return eventArgs.filter?eventArgs.filter(s):filter(s)&&!s.noSharedTooltip});searchSeries.forEach(function(s){let point=Pointer_find(s.points,function(p){return p.x===hoverPoint.x&&!p.isNull});if(Pointer_isObject(point)){if(s.boosted&&s.boost){point=s.boost.getPoint(point)}hoverPoints.push(point)}})}else{hoverPoints.push(hoverPoint)}}eventArgs={hoverPoint:hoverPoint};Pointer_fireEvent(this,"afterGetHoverData",eventArgs);return{hoverPoint:eventArgs.hoverPoint,hoverSeries:hoverSeries,hoverPoints:hoverPoints}}getPointFromEvent(e){let target=e.target,point;while(target&&!point){point=target.point;target=target.parentNode}return point}onTrackerMouseOut(e){const chart=this.chart;const relatedTarget=e.relatedTarget;const series=chart.hoverSeries;this.isDirectTouch=false;if(series&&relatedTarget&&!series.stickyTracking&&!this.inClass(relatedTarget,"highcharts-tooltip")&&(!this.inClass(relatedTarget,"highcharts-series-"+series.index)||!this.inClass(relatedTarget,"highcharts-tracker"))){series.onMouseOut()}}inClass(element,className){let elem=element,elemClassName;while(elem){elemClassName=Pointer_attr(elem,"class");if(elemClassName){if(elemClassName.indexOf(className)!==-1){return true}if(elemClassName.indexOf("highcharts-container")!==-1){return false}}elem=elem.parentElement}}constructor(chart,options){this.hasDragged=0;this.pointerCaptureEventsToUnbind=[];this.eventsToUnbind=[];this.options=options;this.chart=chart;this.runChartClick=Boolean(options.chart.events?.click);this.pinchDown=[];this.setDOMEvents();Pointer_fireEvent(this,"afterInit")}normalize(e,chartPosition){const touches=e.touches;const ePos=touches?touches.length?touches.item(0):Pointer_pick(touches.changedTouches,e.changedTouches)[0]:e;if(!chartPosition){chartPosition=this.getChartPosition()}let chartX=ePos.pageX-chartPosition.left,chartY=ePos.pageY-chartPosition.top;chartX/=chartPosition.scaleX;chartY/=chartPosition.scaleY;return Pointer_extend(e,{chartX:Math.round(chartX),chartY:Math.round(chartY)})}onContainerClick(e){const chart=this.chart;const hoverPoint=chart.hoverPoint;const pEvt=this.normalize(e);const plotLeft=chart.plotLeft;const plotTop=chart.plotTop;if(!chart.cancelClick){if(hoverPoint&&this.inClass(pEvt.target,"highcharts-tracker")){Pointer_fireEvent(hoverPoint.series,"click",Pointer_extend(pEvt,{point:hoverPoint}));if(chart.hoverPoint){hoverPoint.firePointEvent("click",pEvt)}}else{Pointer_extend(pEvt,this.getCoordinates(pEvt));if(chart.isInsidePlot(pEvt.chartX-plotLeft,pEvt.chartY-plotTop,{visiblePlotOnly:true})){Pointer_fireEvent(chart,"click",pEvt)}}}}onContainerMouseDown(e){const isPrimaryButton=((e.buttons||e.button)&1)===1;e=this.normalize(e);if(Core_Globals.isFirefox&&e.button!==0){this.onContainerMouseMove(e)}if(typeof e.button==="undefined"||isPrimaryButton){this.zoomOption(e);if(isPrimaryButton){e.preventDefault?.()}this.dragStart(e)}}onContainerMouseLeave(e){const{pointer}=Pointer_charts[Pointer_pick(Pointer.hoverChartIndex,-1)]||{};e=this.normalize(e);this.onContainerMouseMove(e);if(pointer&&!this.inClass(e.relatedTarget,"highcharts-tooltip")){pointer.reset();pointer.chartPosition=void 0}}onContainerMouseEnter(){delete this.chartPosition}onContainerMouseMove(e){const chart=this.chart,tooltip=chart.tooltip,pEvt=this.normalize(e);this.setHoverChartIndex(e);if(chart.mouseIsDown==="mousedown"||this.touchSelect(pEvt)){this.drag(pEvt)}if(!chart.openMenu&&(this.inClass(pEvt.target,"highcharts-tracker")||chart.isInsidePlot(pEvt.chartX-chart.plotLeft,pEvt.chartY-chart.plotTop,{visiblePlotOnly:true}))&&!(tooltip&&tooltip.shouldStickOnContact(pEvt))){if(this.inClass(pEvt.target,"highcharts-no-tooltip")){this.reset(false,0)}else{this.runPointActions(pEvt)}}}onDocumentTouchEnd(e){this.onDocumentMouseUp(e)}onContainerTouchMove(e){if(this.touchSelect(e)){this.onContainerMouseMove(e)}else{this.touch(e)}}onContainerTouchStart(e){if(this.touchSelect(e)){this.onContainerMouseDown(e)}else{this.zoomOption(e);this.touch(e,true)}}onDocumentMouseMove(e){const chart=this.chart;const tooltip=chart.tooltip;const chartPosition=this.chartPosition;const pEvt=this.normalize(e,chartPosition);if(chartPosition&&!chart.isInsidePlot(pEvt.chartX-chart.plotLeft,pEvt.chartY-chart.plotTop,{visiblePlotOnly:true})&&!(tooltip&&tooltip.shouldStickOnContact(pEvt))&&(pEvt.target===chart.container.ownerDocument||!this.inClass(pEvt.target,"highcharts-tracker"))){this.reset()}}onDocumentMouseUp(e){Pointer_charts[Pointer_pick(Pointer.hoverChartIndex,-1)]?.pointer?.drop(e)}pinch(e){const pointer=this,{chart,hasZoom,lastTouches}=pointer,touches=[].map.call(e.touches||[],touch=>pointer.normalize(touch)),touchesLength=touches.length,fireClickEvent=touchesLength===1&&(pointer.inClass(e.target,"highcharts-tracker")&&chart.runTrackerClick||pointer.runChartClick),tooltip=chart.tooltip,followTouchMove=touchesLength===1&&Pointer_pick(tooltip?.options.followTouchMove,true);if(touchesLength>1){pointer.initiated=true}else if(followTouchMove){pointer.initiated=false}if(hasZoom&&pointer.initiated&&!fireClickEvent&&e.cancelable!==false){e.preventDefault()}if(e.type==="touchstart"){pointer.pinchDown=touches;pointer.res=true;chart.mouseDownX=e.chartX}else if(followTouchMove){this.runPointActions(pointer.normalize(e))}else if(lastTouches){Pointer_fireEvent(chart,"touchpan",{originalEvent:e,touches:touches},()=>{const boxFromTouches=touches=>{const finger0=touches[0],finger1=touches[1]||finger0;return{x:finger0.chartX,y:finger0.chartY,width:finger1.chartX-finger0.chartX,height:finger1.chartY-finger0.chartY}};chart.transform({axes:chart.axes.filter(axis=>axis.zoomEnabled&&(this.zoomHor&&axis.horiz||this.zoomVert&&!axis.horiz)),to:boxFromTouches(touches),from:boxFromTouches(lastTouches),trigger:e.type})});if(pointer.res){pointer.res=false;this.reset(false,0)}}pointer.lastTouches=touches}reset(allowMove,delay){const pointer=this,chart=pointer.chart,hoverSeries=chart.hoverSeries,hoverPoint=chart.hoverPoint,hoverPoints=chart.hoverPoints,tooltip=chart.tooltip,tooltipPoints=tooltip&&tooltip.shared?hoverPoints:hoverPoint;if(allowMove&&tooltipPoints){Pointer_splat(tooltipPoints).forEach(function(point){if(point.series.isCartesian&&typeof point.plotX==="undefined"){allowMove=false}})}if(allowMove){if(tooltip&&tooltipPoints&&Pointer_splat(tooltipPoints).length){tooltip.refresh(tooltipPoints);if(tooltip.shared&&hoverPoints){hoverPoints.forEach(function(point){point.setState(point.state,true);if(point.series.isCartesian){if(point.series.xAxis.crosshair){point.series.xAxis.drawCrosshair(null,point)}if(point.series.yAxis.crosshair){point.series.yAxis.drawCrosshair(null,point)}}})}else if(hoverPoint){hoverPoint.setState(hoverPoint.state,true);chart.axes.forEach(function(axis){if(axis.crosshair&&hoverPoint.series[axis.coll]===axis){axis.drawCrosshair(null,hoverPoint)}})}}}else{if(hoverPoint){hoverPoint.onMouseOut()}if(hoverPoints){hoverPoints.forEach(function(point){point.setState()})}if(hoverSeries){hoverSeries.onMouseOut()}if(tooltip){tooltip.hide(delay)}if(pointer.unDocMouseMove){pointer.unDocMouseMove=pointer.unDocMouseMove()}chart.axes.forEach(function(axis){axis.hideCrosshair()});chart.hoverPoints=chart.hoverPoint=void 0}}runPointActions(e,p,force){const pointer=this,chart=pointer.chart,series=chart.series,tooltip=chart.tooltip&&chart.tooltip.options.enabled?chart.tooltip:void 0,shared=tooltip?tooltip.shared:false;let hoverPoint=p||chart.hoverPoint,hoverSeries=hoverPoint&&hoverPoint.series||chart.hoverSeries;const isDirectTouch=(!e||e.type!=="touchmove")&&(!!p||hoverSeries&&hoverSeries.directTouch&&pointer.isDirectTouch),hoverData=this.getHoverData(hoverPoint,hoverSeries,series,isDirectTouch,shared,e);hoverPoint=hoverData.hoverPoint;hoverSeries=hoverData.hoverSeries;const points=hoverData.hoverPoints,followPointer=hoverSeries&&hoverSeries.tooltipOptions.followPointer&&!hoverSeries.tooltipOptions.split,useSharedTooltip=shared&&hoverSeries&&!hoverSeries.noSharedTooltip;if(hoverPoint&&(force||hoverPoint!==chart.hoverPoint||tooltip&&tooltip.isHidden)){(chart.hoverPoints||[]).forEach(function(p){if(points.indexOf(p)===-1){p.setState()}});if(chart.hoverSeries!==hoverSeries){hoverSeries.onMouseOver()}pointer.applyInactiveState(points);(points||[]).forEach(function(p){p.setState("hover")});if(chart.hoverPoint){chart.hoverPoint.firePointEvent("mouseOut")}if(!hoverPoint.series){return}chart.hoverPoints=points;chart.hoverPoint=hoverPoint;hoverPoint.firePointEvent("mouseOver",void 0,()=>{if(tooltip&&hoverPoint){tooltip.refresh(useSharedTooltip?points:hoverPoint,e)}})}else if(followPointer&&tooltip&&!tooltip.isHidden){const anchor=tooltip.getAnchor([{}],e);if(chart.isInsidePlot(anchor[0],anchor[1],{visiblePlotOnly:true})){tooltip.updatePosition({plotX:anchor[0],plotY:anchor[1]})}}if(!pointer.unDocMouseMove){pointer.unDocMouseMove=Pointer_addEvent(chart.container.ownerDocument,"mousemove",e=>Pointer_charts[Pointer.hoverChartIndex??-1]?.pointer?.onDocumentMouseMove(e));pointer.eventsToUnbind.push(pointer.unDocMouseMove)}chart.axes.forEach(function drawAxisCrosshair(axis){const snap=Pointer_pick((axis.crosshair||{}).snap,true);let point;if(snap){point=chart.hoverPoint;if(!point||point.series[axis.coll]!==axis){point=Pointer_find(points,p=>p.series&&p.series[axis.coll]===axis)}}if(point||!snap){axis.drawCrosshair(e,point)}else{axis.hideCrosshair()}})}setDOMEvents(){const container=this.chart.container,ownerDoc=container.ownerDocument;container.onmousedown=this.onContainerMouseDown.bind(this);container.onmousemove=this.onContainerMouseMove.bind(this);container.onclick=this.onContainerClick.bind(this);this.eventsToUnbind.push(Pointer_addEvent(container,"mouseenter",this.onContainerMouseEnter.bind(this)),Pointer_addEvent(container,"mouseleave",this.onContainerMouseLeave.bind(this)));if(!Pointer.unbindDocumentMouseUp.some(el=>el.doc===ownerDoc)){Pointer.unbindDocumentMouseUp.push({doc:ownerDoc,unbind:Pointer_addEvent(ownerDoc,"mouseup",this.onDocumentMouseUp.bind(this))})}let parent=this.chart.renderTo.parentElement;while(parent&&parent.tagName!=="BODY"){this.eventsToUnbind.push(Pointer_addEvent(parent,"scroll",()=>{delete this.chartPosition}));parent=parent.parentElement}this.eventsToUnbind.push(Pointer_addEvent(container,"touchstart",this.onContainerTouchStart.bind(this),{passive:false}),Pointer_addEvent(container,"touchmove",this.onContainerTouchMove.bind(this),{passive:false}));if(!Pointer.unbindDocumentTouchEnd){Pointer.unbindDocumentTouchEnd=Pointer_addEvent(ownerDoc,"touchend",this.onDocumentTouchEnd.bind(this),{passive:false})}this.setPointerCapture();Pointer_addEvent(this.chart,"redraw",this.setPointerCapture.bind(this))}setPointerCapture(){if(!Pointer_isTouchDevice){return}const pointer=this,events=pointer.pointerCaptureEventsToUnbind,chart=pointer.chart,container=chart.container,followTouchMove=Pointer_pick(chart.options.tooltip?.followTouchMove,true),shouldHave=followTouchMove&&chart.series.some(series=>series.options.findNearestPointBy.indexOf("y")>-1);if(!pointer.hasPointerCapture&&shouldHave){events.push(Pointer_addEvent(container,"pointerdown",e=>{if(e.target?.hasPointerCapture(e.pointerId)){e.target?.releasePointerCapture(e.pointerId)}}),Pointer_addEvent(container,"pointermove",e=>{chart.pointer?.getPointFromEvent(e)?.onMouseOver(e)}));if(!chart.styledMode){Pointer_css(container,{"touch-action":"none"})}container.className+=" highcharts-no-touch-action";pointer.hasPointerCapture=true}else if(pointer.hasPointerCapture&&!shouldHave){events.forEach(e=>e());events.length=0;if(!chart.styledMode){Pointer_css(container,{"touch-action":Pointer_pick(chart.options.chart.style?.["touch-action"],"manipulation")})}container.className=container.className.replace(" highcharts-no-touch-action","");pointer.hasPointerCapture=false}}setHoverChartIndex(e){const chart=this.chart;const hoverChart=Core_Globals.charts[Pointer_pick(Pointer.hoverChartIndex,-1)];if(hoverChart&&hoverChart!==chart){const relatedTargetObj={relatedTarget:chart.container};if(e&&!e?.relatedTarget){e={...relatedTargetObj,...e}}hoverChart.pointer?.onContainerMouseLeave(e||relatedTargetObj)}if(!hoverChart||!hoverChart.mouseIsDown){Pointer.hoverChartIndex=chart.index}}touch(e,start){const{chart,pinchDown=[]}=this;let hasMoved,isInside;this.setHoverChartIndex();e=this.normalize(e);if(e.touches.length===1){isInside=chart.isInsidePlot(e.chartX-chart.plotLeft,e.chartY-chart.plotTop,{visiblePlotOnly:true});if(isInside&&!chart.openMenu){if(start){this.runPointActions(e)}if(e.type==="touchmove"){hasMoved=pinchDown[0]?Math.pow(pinchDown[0].chartX-e.chartX,2)+Math.pow(pinchDown[0].chartY-e.chartY,2)>=16:false}if(Pointer_pick(hasMoved,true)){this.pinch(e)}}else if(start){this.reset()}}else if(e.touches.length===2){this.pinch(e)}}touchSelect(e){return Boolean(this.chart.zooming.singleTouch&&e.touches&&e.touches.length===1)}zoomOption(e){const chart=this.chart,inverted=chart.inverted;let zoomType=chart.zooming.type||"",zoomX,zoomY;if(/touch/.test(e.type)){zoomType=Pointer_pick(chart.zooming.pinchType,zoomType)}this.zoomX=zoomX=/x/.test(zoomType);this.zoomY=zoomY=/y/.test(zoomType);this.zoomHor=zoomX&&!inverted||zoomY&&inverted;this.zoomVert=zoomY&&!inverted||zoomX&&inverted;this.hasZoom=zoomX||zoomY}}Pointer.unbindDocumentMouseUp=[];(function(Pointer){function compose(ChartClass){if(Pointer_pushUnique(Pointer_composed,"Core.Pointer")){Pointer_addEvent(ChartClass,"beforeRender",function(){this.pointer=new Pointer(this,this.options)})}}Pointer.compose=compose})(Pointer||(Pointer={}));const Core_Pointer=Pointer;"";const{fireEvent:DataTableCore_fireEvent,isArray:DataTableCore_isArray,objectEach:DataTableCore_objectEach,uniqueKey:DataTableCore_uniqueKey}=Core_Utilities;class DataTableCore{constructor(options={}){this.autoId=!options.id;this.columns={};this.id=options.id||DataTableCore_uniqueKey();this.modified=this;this.rowCount=0;this.versionTag=DataTableCore_uniqueKey();let rowCount=0;DataTableCore_objectEach(options.columns||{},(column,columnName)=>{this.columns[columnName]=column.slice();rowCount=Math.max(rowCount,column.length)});this.applyRowCount(rowCount)}applyRowCount(rowCount){this.rowCount=rowCount;DataTableCore_objectEach(this.columns,column=>{if(DataTableCore_isArray(column)){column.length=rowCount}})}getColumn(columnName,asReference){return this.columns[columnName]}getColumns(columnNames,asReference){return(columnNames||Object.keys(this.columns)).reduce((columns,columnName)=>{columns[columnName]=this.columns[columnName];return columns},{})}getRow(rowIndex,columnNames){return(columnNames||Object.keys(this.columns)).map(key=>this.columns[key]?.[rowIndex])}setColumn(columnName,column=[],rowIndex=0,eventDetail){this.setColumns({[columnName]:column},rowIndex,eventDetail)}setColumns(columns,rowIndex,eventDetail){let rowCount=this.rowCount;DataTableCore_objectEach(columns,(column,columnName)=>{this.columns[columnName]=column.slice();rowCount=column.length});this.applyRowCount(rowCount);if(!eventDetail?.silent){DataTableCore_fireEvent(this,"afterSetColumns");this.versionTag=DataTableCore_uniqueKey()}}setRow(row,rowIndex=this.rowCount,insert,eventDetail){const{columns}=this,indexRowCount=insert?this.rowCount+1:rowIndex+1;DataTableCore_objectEach(row,(cellValue,columnName)=>{const column=columns[columnName]||eventDetail?.addColumns!==false&&new Array(indexRowCount);if(column){if(insert){column.splice(rowIndex,0,cellValue)}else{column[rowIndex]=cellValue}columns[columnName]=column}});if(indexRowCount>this.rowCount){this.applyRowCount(indexRowCount)}if(!eventDetail?.silent){DataTableCore_fireEvent(this,"afterSetRows");this.versionTag=DataTableCore_uniqueKey()}}}const Data_DataTableCore=DataTableCore;"";const{extend:LegendSymbol_extend,merge:LegendSymbol_merge,pick:LegendSymbol_pick}=Core_Utilities;var LegendSymbol;(function(LegendSymbol){function areaMarker(legend,item){lineMarker.call(this,legend,item,true)}LegendSymbol.areaMarker=areaMarker;function lineMarker(legend,item,hasArea){const legendItem=this.legendItem=this.legendItem||{},{chart,options}=this,{baseline=0,symbolWidth,symbolHeight}=legend,symbol=this.symbol||"circle",generalRadius=symbolHeight/2,renderer=chart.renderer,legendItemGroup=legendItem.group,verticalCenter=baseline-Math.round((legend.fontMetrics?.b||symbolHeight)*(hasArea?.4:.3)),attr={};let legendSymbol,markerOptions=options.marker,lineSizer=0;if(!chart.styledMode){attr["stroke-width"]=Math.min(options.lineWidth||0,24);if(options.dashStyle){attr.dashstyle=options.dashStyle}else if(options.linecap!=="square"){attr["stroke-linecap"]="round"}}legendItem.line=renderer.path().addClass("highcharts-graph").attr(attr).add(legendItemGroup);if(hasArea){legendItem.area=renderer.path().addClass("highcharts-area").add(legendItemGroup)}if(attr["stroke-linecap"]){lineSizer=Math.min(legendItem.line.strokeWidth(),symbolWidth)/2}if(symbolWidth){const d=[["M",lineSizer,verticalCenter],["L",symbolWidth-lineSizer,verticalCenter]];legendItem.line.attr({d:d});legendItem.area?.attr({d:[...d,["L",symbolWidth-lineSizer,baseline],["L",lineSizer,baseline]]})}if(markerOptions&&markerOptions.enabled!==false&&symbolWidth){let radius=Math.min(LegendSymbol_pick(markerOptions.radius,generalRadius),generalRadius);if(symbol.indexOf("url")===0){markerOptions=LegendSymbol_merge(markerOptions,{width:symbolHeight,height:symbolHeight});radius=0}legendItem.symbol=legendSymbol=renderer.symbol(symbol,symbolWidth/2-radius,verticalCenter-radius,2*radius,2*radius,LegendSymbol_extend({context:"legend"},markerOptions)).addClass("highcharts-point").add(legendItemGroup);legendSymbol.isMarker=true}}LegendSymbol.lineMarker=lineMarker;function rectangle(legend,item){const legendItem=item.legendItem||{},options=legend.options,symbolHeight=legend.symbolHeight,square=options.squareSymbol,symbolWidth=square?symbolHeight:legend.symbolWidth;legendItem.symbol=this.chart.renderer.rect(square?(legend.symbolWidth-symbolHeight)/2:0,legend.baseline-symbolHeight+1,symbolWidth,symbolHeight,LegendSymbol_pick(legend.options.symbolRadius,symbolHeight/2)).addClass("highcharts-point").attr({zIndex:3}).add(legendItem.group)}LegendSymbol.rectangle=rectangle})(LegendSymbol||(LegendSymbol={}));const Legend_LegendSymbol=LegendSymbol;const seriesDefaults={lineWidth:2,allowPointSelect:false,crisp:true,showCheckbox:false,animation:{duration:1e3},enableMouseTracking:true,events:{},marker:{enabledThreshold:2,lineColor:"#ffffff",lineWidth:0,radius:4,states:{normal:{animation:true},hover:{animation:{duration:150},enabled:true,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{animation:{},align:"center",borderWidth:0,defer:true,formatter:function(){const{numberFormatter}=this.series.chart;return typeof this.y!=="number"?"":numberFormatter(this.y,-1)},padding:5,style:{fontSize:"0.7em",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0},cropThreshold:300,opacity:1,pointRange:0,softThreshold:true,states:{normal:{animation:true},hover:{animation:{duration:150},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{animation:{duration:0}},inactive:{animation:{duration:150},opacity:.2}},stickyTracking:true,turboThreshold:1e3,findNearestPointBy:"x"};const SeriesDefaults=seriesDefaults;const{defaultOptions:SeriesRegistry_defaultOptions}=Defaults;const{extend:SeriesRegistry_extend,extendClass:SeriesRegistry_extendClass,merge:SeriesRegistry_merge}=Core_Utilities;var SeriesRegistry;(function(SeriesRegistry){SeriesRegistry.seriesTypes=Core_Globals.seriesTypes;function registerSeriesType(seriesType,SeriesClass){const defaultPlotOptions=SeriesRegistry_defaultOptions.plotOptions||{},seriesOptions=SeriesClass.defaultOptions,seriesProto=SeriesClass.prototype;seriesProto.type=seriesType;if(!seriesProto.pointClass){seriesProto.pointClass=Series_Point}if(SeriesRegistry.seriesTypes[seriesType]){return false}if(seriesOptions){defaultPlotOptions[seriesType]=seriesOptions}SeriesRegistry.seriesTypes[seriesType]=SeriesClass;return true}SeriesRegistry.registerSeriesType=registerSeriesType;function seriesType(type,parent,options,seriesProto,pointProto){const defaultPlotOptions=SeriesRegistry_defaultOptions.plotOptions||{};parent=parent||"";defaultPlotOptions[type]=SeriesRegistry_merge(defaultPlotOptions[parent],options);delete SeriesRegistry.seriesTypes[type];registerSeriesType(type,SeriesRegistry_extendClass(SeriesRegistry.seriesTypes[parent]||function(){},seriesProto));SeriesRegistry.seriesTypes[type].prototype.type=type;if(pointProto){class PointClass extends Series_Point{}SeriesRegistry_extend(PointClass.prototype,pointProto);SeriesRegistry.seriesTypes[type].prototype.pointClass=PointClass}return SeriesRegistry.seriesTypes[type]}SeriesRegistry.seriesType=seriesType})(SeriesRegistry||(SeriesRegistry={}));const Series_SeriesRegistry=SeriesRegistry;const{animObject:Series_animObject,setAnimation:Series_setAnimation}=AnimationUtilities;const{defaultOptions:Series_defaultOptions}=Defaults;const{registerEventOptions:Series_registerEventOptions}=Core_Foundation;const{svg:Series_svg,win:Series_win}=Core_Globals;const{seriesTypes}=Series_SeriesRegistry;const{arrayMax:Series_arrayMax,arrayMin:Series_arrayMin,clamp:Series_clamp,correctFloat:Series_correctFloat,crisp:Series_crisp,defined:Series_defined,destroyObjectProperties:Series_destroyObjectProperties,diffObjects:Series_diffObjects,erase:Series_erase,error:Series_error,extend:Series_extend,find:Series_find,fireEvent:Series_fireEvent,getClosestDistance:Series_getClosestDistance,getNestedProperty:Series_getNestedProperty,insertItem:Series_insertItem,isArray:Series_isArray,isNumber:Series_isNumber,isString:Series_isString,merge:Series_merge,objectEach:Series_objectEach,pick:Series_pick,removeEvent:Series_removeEvent,syncTimeout:Series_syncTimeout}=Core_Utilities;class Series{constructor(){this.zoneAxis="y"}init(chart,userOptions){Series_fireEvent(this,"init",{options:userOptions});this.dataTable??(this.dataTable=new Data_DataTableCore);const series=this,chartSeries=chart.series;this.eventsToUnbind=[];series.chart=chart;series.options=series.setOptions(userOptions);const options=series.options,visible=options.visible!==false;series.linkedSeries=[];series.bindAxes();Series_extend(series,{name:options.name,state:"",visible:visible,selected:options.selected===true});Series_registerEventOptions(this,options);const events=options.events;if(events&&events.click||options.point&&options.point.events&&options.point.events.click||options.allowPointSelect){chart.runTrackerClick=true}series.getColor();series.getSymbol();if(series.isCartesian){chart.hasCartesianSeries=true}let lastSeries;if(chartSeries.length){lastSeries=chartSeries[chartSeries.length-1]}series._i=Series_pick(lastSeries&&lastSeries._i,-1)+1;series.opacity=series.options.opacity;chart.orderItems("series",Series_insertItem(this,chartSeries));if(options.dataSorting&&options.dataSorting.enabled){series.setDataSortingOptions()}else if(!series.points&&!series.data){series.setData(options.data,false)}Series_fireEvent(this,"afterInit")}is(type){return seriesTypes[type]&&this instanceof seriesTypes[type]}bindAxes(){const series=this,seriesOptions=series.options,chart=series.chart;let axisOptions;Series_fireEvent(this,"bindAxes",null,function(){(series.axisTypes||[]).forEach(function(coll){(chart[coll]||[]).forEach(function(axis){axisOptions=axis.options;if(Series_pick(seriesOptions[coll],0)===axis.index||typeof seriesOptions[coll]!=="undefined"&&seriesOptions[coll]===axisOptions.id){Series_insertItem(series,axis.series);series[coll]=axis;axis.isDirty=true}});if(!series[coll]&&series.optionalAxis!==coll){Series_error(18,true,chart)}})});Series_fireEvent(this,"afterBindAxes")}hasData(){return this.visible&&typeof this.dataMax!=="undefined"&&typeof this.dataMin!=="undefined"||this.visible&&this.dataTable.rowCount>0}hasMarkerChanged(options,oldOptions){const marker=options.marker,oldMarker=oldOptions.marker||{};return marker&&(oldMarker.enabled&&!marker.enabled||oldMarker.symbol!==marker.symbol||oldMarker.height!==marker.height||oldMarker.width!==marker.width)}autoIncrement(x){const options=this.options,{pointIntervalUnit,relativeXValue}=this.options,time=this.chart.time,xIncrement=this.xIncrement??time.parse(options.pointStart)??0;let pointInterval;this.pointInterval=pointInterval=Series_pick(this.pointInterval,options.pointInterval,1);if(relativeXValue&&Series_isNumber(x)){pointInterval*=x}if(pointIntervalUnit){const d=time.toParts(xIncrement);if(pointIntervalUnit==="day"){d[2]+=pointInterval}else if(pointIntervalUnit==="month"){d[1]+=pointInterval}else if(pointIntervalUnit==="year"){d[0]+=pointInterval}pointInterval=time.makeTime.apply(time,d)-xIncrement}if(relativeXValue&&Series_isNumber(x)){return xIncrement+pointInterval}this.xIncrement=xIncrement+pointInterval;return xIncrement}setDataSortingOptions(){const options=this.options;Series_extend(this,{requireSorting:false,sorted:false,enabledDataSorting:true,allowDG:false});if(!Series_defined(options.pointRange)){options.pointRange=1}}setOptions(itemOptions){const chart=this.chart,chartOptions=chart.options,plotOptions=chartOptions.plotOptions,userOptions=chart.userOptions||{},seriesUserOptions=Series_merge(itemOptions),styledMode=chart.styledMode,e={plotOptions:plotOptions,userOptions:seriesUserOptions};let zone;Series_fireEvent(this,"setOptions",e);const typeOptions=e.plotOptions[this.type],userPlotOptions=userOptions.plotOptions||{},userPlotOptionsSeries=userPlotOptions.series||{},defaultPlotOptionsType=Series_defaultOptions.plotOptions[this.type]||{},userPlotOptionsType=userPlotOptions[this.type]||{};this.userOptions=e.userOptions;const options=Series_merge(typeOptions,plotOptions.series,userPlotOptionsType,seriesUserOptions);this.tooltipOptions=Series_merge(Series_defaultOptions.tooltip,Series_defaultOptions.plotOptions.series?.tooltip,defaultPlotOptionsType?.tooltip,chart.userOptions.tooltip,userPlotOptions.series?.tooltip,userPlotOptionsType.tooltip,seriesUserOptions.tooltip);this.stickyTracking=Series_pick(seriesUserOptions.stickyTracking,userPlotOptionsType.stickyTracking,userPlotOptionsSeries.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?true:options.stickyTracking);if(typeOptions.marker===null){delete options.marker}this.zoneAxis=options.zoneAxis||"y";const zones=this.zones=(options.zones||[]).map(z=>({...z}));if((options.negativeColor||options.negativeFillColor)&&!options.zones){zone={value:options[this.zoneAxis+"Threshold"]||options.threshold||0,className:"highcharts-negative"};if(!styledMode){zone.color=options.negativeColor;zone.fillColor=options.negativeFillColor}zones.push(zone)}if(zones.length&&Series_defined(zones[zones.length-1].value)){zones.push(styledMode?{}:{color:this.color,fillColor:this.fillColor})}Series_fireEvent(this,"afterSetOptions",{options:options});return options}getName(){return Series_pick(this.options.name,"Series "+(this.index+1))}getCyclic(prop,value,defaults){const chart=this.chart,indexName=`${prop}Index`,counterName=`${prop}Counter`,len=defaults?.length||chart.options.chart.colorCount;let i,setting;if(!value){setting=Series_pick(prop==="color"?this.options.colorIndex:void 0,this[indexName]);if(Series_defined(setting)){i=setting}else{if(!chart.series.length){chart[counterName]=0}i=chart[counterName]%len;chart[counterName]+=1}if(defaults){value=defaults[i]}}if(typeof i!=="undefined"){this[indexName]=i}this[prop]=value}getColor(){if(this.chart.styledMode){this.getCyclic("color")}else if(this.options.colorByPoint){this.color="#cccccc"}else{this.getCyclic("color",this.options.color||Series_defaultOptions.plotOptions[this.type].color,this.chart.options.colors)}}getPointsCollection(){return(this.hasGroupedData?this.points:this.data)||[]}getSymbol(){const seriesMarkerOption=this.options.marker;this.getCyclic("symbol",seriesMarkerOption.symbol,this.chart.options.symbols)}getColumn(columnName,modified){return(modified?this.dataTable.modified:this.dataTable).getColumn(columnName,true)||[]}findPointIndex(optionsObject,fromIndex){const id=optionsObject.id,x=optionsObject.x,oldData=this.points,dataSorting=this.options.dataSorting;let matchingPoint,matchedById,pointIndex;if(id){const item=this.chart.get(id);if(item instanceof Series_Point){matchingPoint=item}}else if(this.linkedParent||this.enabledDataSorting||this.options.relativeXValue){let matcher=oldPoint=>!oldPoint.touched&&oldPoint.index===optionsObject.index;if(dataSorting&&dataSorting.matchByName){matcher=oldPoint=>!oldPoint.touched&&oldPoint.name===optionsObject.name}else if(this.options.relativeXValue){matcher=oldPoint=>!oldPoint.touched&&oldPoint.options.x===optionsObject.x}matchingPoint=Series_find(oldData,matcher);if(!matchingPoint){return void 0}}if(matchingPoint){pointIndex=matchingPoint&&matchingPoint.index;if(typeof pointIndex!=="undefined"){matchedById=true}}if(typeof pointIndex==="undefined"&&Series_isNumber(x)){pointIndex=this.getColumn("x").indexOf(x,fromIndex)}if(pointIndex!==-1&&typeof pointIndex!=="undefined"&&this.cropped){pointIndex=pointIndex>=this.cropStart?pointIndex-this.cropStart:pointIndex}if(!matchedById&&Series_isNumber(pointIndex)&&oldData[pointIndex]&&oldData[pointIndex].touched){pointIndex=void 0}return pointIndex}updateData(data,animation){const options=this.options,dataSorting=options.dataSorting,oldData=this.points,pointsToAdd=[],requireSorting=this.requireSorting,equalLength=data.length===oldData.length;let hasUpdatedByKey,i,point,lastIndex,succeeded=true;this.xIncrement=null;data.forEach(function(pointOptions,i){const optionsObject=Series_defined(pointOptions)&&this.pointClass.prototype.optionsToObject.call({series:this},pointOptions)||{};let pointIndex;const x=optionsObject.x,id=optionsObject.id;if(id||Series_isNumber(x)){pointIndex=this.findPointIndex(optionsObject,lastIndex);if(pointIndex===-1||typeof pointIndex==="undefined"){pointsToAdd.push(pointOptions)}else if(oldData[pointIndex]&&pointOptions!==options.data[pointIndex]){oldData[pointIndex].update(pointOptions,false,null,false);oldData[pointIndex].touched=true;if(requireSorting){lastIndex=pointIndex+1}}else if(oldData[pointIndex]){oldData[pointIndex].touched=true}if(!equalLength||i!==pointIndex||dataSorting&&dataSorting.enabled||this.hasDerivedData){hasUpdatedByKey=true}}else{pointsToAdd.push(pointOptions)}},this);if(hasUpdatedByKey){i=oldData.length;while(i--){point=oldData[i];if(point&&!point.touched&&point.remove){point.remove(false,animation)}}}else if(equalLength&&(!dataSorting||!dataSorting.enabled)){data.forEach(function(point,i){if(point!==oldData[i].y&&!oldData[i].destroyed){oldData[i].update(point,false,null,false)}});pointsToAdd.length=0}else{succeeded=false}oldData.forEach(function(point){if(point){point.touched=false}});if(!succeeded){return false}pointsToAdd.forEach(function(point){this.addPoint(point,false,null,null,false)},this);const xData=this.getColumn("x");if(this.xIncrement===null&&xData.length){this.xIncrement=Series_arrayMax(xData);this.autoIncrement()}return true}dataColumnKeys(){return["x",...this.pointArrayMap||["y"]]}setData(data,redraw=true,animation,updatePoints){const series=this,oldData=series.points,oldDataLength=oldData&&oldData.length||0,options=series.options,chart=series.chart,dataSorting=options.dataSorting,xAxis=series.xAxis,turboThreshold=options.turboThreshold,table=this.dataTable,dataColumnKeys=this.dataColumnKeys(),pointValKey=series.pointValKey||"y",pointArrayMap=series.pointArrayMap||[],valueCount=pointArrayMap.length,keys=options.keys;let i,updatedData,indexOfX=0,indexOfY=1,copiedData;if(!chart.options.chart.allowMutatingData){if(options.data){delete series.options.data}if(series.userOptions.data){delete series.userOptions.data}copiedData=Series_merge(true,data)}data=copiedData||data||[];const dataLength=data.length;if(dataSorting&&dataSorting.enabled){data=this.sortData(data)}if(chart.options.chart.allowMutatingData&&updatePoints!==false&&dataLength&&oldDataLength&&!series.cropped&&!series.hasGroupedData&&series.visible&&!series.boosted){updatedData=this.updateData(data,animation)}if(!updatedData){series.xIncrement=null;series.colorCounter=0;let runTurbo=turboThreshold&&dataLength>turboThreshold;if(runTurbo){const firstPoint=series.getFirstValidPoint(data),lastPoint=series.getFirstValidPoint(data,dataLength-1,-1),isShortArray=a=>Boolean(Series_isArray(a)&&(keys||Series_isNumber(a[0])));if(Series_isNumber(firstPoint)&&Series_isNumber(lastPoint)){const x=[],valueData=[];for(const value of data){x.push(this.autoIncrement());valueData.push(value)}table.setColumns({x:x,[pointValKey]:valueData})}else if(isShortArray(firstPoint)&&isShortArray(lastPoint)){if(valueCount){const autoX=firstPoint.length===valueCount?1:0,colArray=new Array(dataColumnKeys.length).fill(0).map(()=>[]);for(const pt of data){if(autoX){colArray[0].push(this.autoIncrement())}for(let j=autoX;j<=valueCount;j++){colArray[j]?.push(pt[j-autoX])}}table.setColumns(dataColumnKeys.reduce((columns,columnName,i)=>{columns[columnName]=colArray[i];return columns},{}))}else{if(keys){indexOfX=keys.indexOf("x");indexOfY=keys.indexOf("y");indexOfX=indexOfX>=0?indexOfX:0;indexOfY=indexOfY>=0?indexOfY:1}if(firstPoint.length===1){indexOfY=0}const xData=[],valueData=[];if(indexOfX===indexOfY){for(const pt of data){xData.push(this.autoIncrement());valueData.push(pt[indexOfY])}}else{for(const pt of data){xData.push(pt[indexOfX]);valueData.push(pt[indexOfY])}}table.setColumns({x:xData,[pointValKey]:valueData})}}else{runTurbo=false}}if(!runTurbo){const columns=dataColumnKeys.reduce((columns,columnName)=>{columns[columnName]=[];return columns},{});for(i=0;i<dataLength;i++){const pt=series.pointClass.prototype.applyOptions.apply({series:series},[data[i]]);for(const key of dataColumnKeys){columns[key][i]=pt[key]}}table.setColumns(columns)}if(Series_isString(this.getColumn("y")[0])){Series_error(14,true,chart)}series.data=[];series.options.data=series.userOptions.data=data;i=oldDataLength;while(i--){oldData[i]?.destroy()}if(xAxis){xAxis.minRange=xAxis.userMinRange}series.isDirty=chart.isDirtyBox=true;series.isDirtyData=!!oldData;animation=false}if(options.legendType==="point"){this.processData();this.generatePoints()}if(redraw){chart.redraw(animation)}}sortData(data){const series=this,options=series.options,dataSorting=options.dataSorting,sortKey=dataSorting.sortKey||"y",getPointOptionsObject=function(series,pointOptions){return Series_defined(pointOptions)&&series.pointClass.prototype.optionsToObject.call({series:series},pointOptions)||{}};data.forEach(function(pointOptions,i){data[i]=getPointOptionsObject(series,pointOptions);data[i].index=i},this);const sortedData=data.concat().sort((a,b)=>{const aValue=Series_getNestedProperty(sortKey,a);const bValue=Series_getNestedProperty(sortKey,b);return bValue<aValue?-1:bValue>aValue?1:0});sortedData.forEach(function(point,i){point.x=i},this);if(series.linkedSeries){series.linkedSeries.forEach(function(linkedSeries){const options=linkedSeries.options,seriesData=options.data;if((!options.dataSorting||!options.dataSorting.enabled)&&seriesData){seriesData.forEach(function(pointOptions,i){seriesData[i]=getPointOptionsObject(linkedSeries,pointOptions);if(data[i]){seriesData[i].x=data[i].x;seriesData[i].index=i}});linkedSeries.setData(seriesData,false)}})}return data}getProcessedData(forceExtremesFromAll){const series=this,{dataTable:table,isCartesian,options,xAxis}=series,cropThreshold=options.cropThreshold,getExtremesFromAll=forceExtremesFromAll||series.getExtremesFromAll,logarithmic=xAxis?.logarithmic,dataLength=table.rowCount;let croppedData,cropped,cropStart=0,xExtremes,min,max,xData=series.getColumn("x"),modified=table,updatingNames=false;if(xAxis){xExtremes=xAxis.getExtremes();min=xExtremes.min;max=xExtremes.max;updatingNames=!!(xAxis.categories&&!xAxis.names.length);if(isCartesian&&series.sorted&&!getExtremesFromAll&&(!cropThreshold||dataLength>cropThreshold||series.forceCrop)){if(xData[dataLength-1]<min||xData[0]>max){modified=new Data_DataTableCore}else if(series.getColumn(series.pointValKey||"y").length&&(xData[0]<min||xData[dataLength-1]>max)){croppedData=this.cropData(table,min,max);modified=croppedData.modified;cropStart=croppedData.start;cropped=true}}}xData=modified.getColumn("x")||[];const closestPointRange=Series_getClosestDistance([logarithmic?xData.map(logarithmic.log2lin):xData],()=>series.requireSorting&&!updatingNames&&Series_error(15,false,series.chart));return{modified:modified,cropped:cropped,cropStart:cropStart,closestPointRange:closestPointRange}}processData(force){const series=this,xAxis=series.xAxis,table=series.dataTable;if(series.isCartesian&&!series.isDirty&&!xAxis.isDirty&&!series.yAxis.isDirty&&!force){return false}const processedData=series.getProcessedData();table.modified=processedData.modified;series.cropped=processedData.cropped;series.cropStart=processedData.cropStart;series.closestPointRange=series.basePointRange=processedData.closestPointRange;Series_fireEvent(series,"afterProcessData")}cropData(table,min,max){const xData=table.getColumn("x",true)||[],dataLength=xData.length,columns={};let i,j,start=0,end=dataLength;for(i=0;i<dataLength;i++){if(xData[i]>=min){start=Math.max(0,i-1);break}}for(j=i;j<dataLength;j++){if(xData[j]>max){end=j+1;break}}for(const key of this.dataColumnKeys()){const column=table.getColumn(key,true);if(column){columns[key]=column.slice(start,end)}}return{modified:new Data_DataTableCore({columns:columns}),start:start,end:end}}generatePoints(){const series=this,options=series.options,dataOptions=series.processedData||options.data,table=series.dataTable.modified,xData=series.getColumn("x",true),PointClass=series.pointClass,processedDataLength=table.rowCount,cropStart=series.cropStart||0,hasGroupedData=series.hasGroupedData,keys=options.keys,points=[],groupCropStartIndex=options.dataGrouping&&options.dataGrouping.groupAll?cropStart:0,categories=series.xAxis?.categories,pointArrayMap=series.pointArrayMap||["y"],dataColumnKeys=this.dataColumnKeys();let dataLength,cursor,point,i,data=series.data,pOptions;if(!data&&!hasGroupedData){const arr=[];arr.length=dataOptions?.length||0;data=series.data=arr}if(keys&&hasGroupedData){series.options.keys=false}for(i=0;i<processedDataLength;i++){cursor=cropStart+i;if(!hasGroupedData){point=data[cursor];pOptions=dataOptions?dataOptions[cursor]:table.getRow(i,pointArrayMap);if(!point&&pOptions!==void 0){data[cursor]=point=new PointClass(series,pOptions,xData[i])}}else{point=new PointClass(series,table.getRow(i,dataColumnKeys)||[]);point.dataGroup=series.groupMap[groupCropStartIndex+i];if(point.dataGroup?.options){point.options=point.dataGroup.options;Series_extend(point,point.dataGroup.options);delete point.dataLabels}}if(point){point.index=hasGroupedData?groupCropStartIndex+i:cursor;points[i]=point;point.category=categories?.[point.x]??point.x;point.key=point.name??point.category}}series.options.keys=keys;if(data&&(processedDataLength!==(dataLength=data.length)||hasGroupedData)){for(i=0;i<dataLength;i++){if(i===cropStart&&!hasGroupedData){i+=processedDataLength}if(data[i]){data[i].destroyElements();data[i].plotX=void 0}}}series.data=data;series.points=points;Series_fireEvent(this,"afterGeneratePoints")}getXExtremes(xData){return{min:Series_arrayMin(xData),max:Series_arrayMax(xData)}}getExtremes(yData,forceExtremesFromAll){const{xAxis,yAxis}=this,getExtremesFromAll=forceExtremesFromAll||this.getExtremesFromAll||this.options.getExtremesFromAll,table=getExtremesFromAll&&this.cropped?this.dataTable:this.dataTable.modified,rowCount=table.rowCount,customData=yData||this.stackedYData,yAxisData=customData?[customData]:(this.keysAffectYAxis||this.pointArrayMap||["y"])?.map(key=>table.getColumn(key,true)||[])||[],xData=this.getColumn("x",true),activeYData=[],shoulder=this.requireSorting&&!this.is("column")?1:0,positiveValuesOnly=yAxis?yAxis.positiveValuesOnly:false,doAll=getExtremesFromAll||this.cropped||!xAxis;let xExtremes,x,i,xMin=0,xMax=0;if(xAxis){xExtremes=xAxis.getExtremes();xMin=xExtremes.min;xMax=xExtremes.max}for(i=0;i<rowCount;i++){x=xData[i];if(doAll||(xData[i+shoulder]||x)>=xMin&&(xData[i-shoulder]||x)<=xMax){for(const values of yAxisData){const val=values[i];if(Series_isNumber(val)&&(val>0||!positiveValuesOnly)){activeYData.push(val)}}}}const dataExtremes={activeYData:activeYData,dataMin:Series_arrayMin(activeYData),dataMax:Series_arrayMax(activeYData)};Series_fireEvent(this,"afterGetExtremes",{dataExtremes:dataExtremes});return dataExtremes}applyExtremes(){const dataExtremes=this.getExtremes();this.dataMin=dataExtremes.dataMin;this.dataMax=dataExtremes.dataMax;return dataExtremes}getFirstValidPoint(data,start=0,increment=1){const dataLength=data.length;let i=start;while(i>=0&&i<dataLength){if(Series_defined(data[i])){return data[i]}i+=increment}}translate(){this.generatePoints();const series=this,options=series.options,stacking=options.stacking,xAxis=series.xAxis,enabledDataSorting=series.enabledDataSorting,yAxis=series.yAxis,points=series.points,dataLength=points.length,pointPlacement=series.pointPlacementToXValue(),dynamicallyPlaced=Boolean(pointPlacement),threshold=options.threshold,stackThreshold=options.startFromThreshold?threshold:0;let i,plotX,lastPlotX,stackIndicator,closestPointRangePx=Number.MAX_VALUE;function limitedRange(val){return Series_clamp(val,-1e9,1e9)}for(i=0;i<dataLength;i++){const point=points[i],xValue=point.x;let stackItem,stackValues,yValue=point.y,lowValue=point.low;const stacks=stacking&&yAxis.stacking?.stacks[(series.negStacks&&yValue<(stackThreshold?0:threshold)?"-":"")+series.stackKey];plotX=xAxis.translate(xValue,false,false,false,true,pointPlacement);point.plotX=Series_isNumber(plotX)?Series_correctFloat(limitedRange(plotX)):void 0;if(stacking&&series.visible&&stacks&&stacks[xValue]){stackIndicator=series.getStackIndicator(stackIndicator,xValue,series.index);if(!point.isNull&&stackIndicator.key){stackItem=stacks[xValue];stackValues=stackItem.points[stackIndicator.key]}if(stackItem&&Series_isArray(stackValues)){lowValue=stackValues[0];yValue=stackValues[1];if(lowValue===stackThreshold&&stackIndicator.key===stacks[xValue].base){lowValue=Series_pick(Series_isNumber(threshold)?threshold:yAxis.min)}if(yAxis.positiveValuesOnly&&Series_defined(lowValue)&&lowValue<=0){lowValue=void 0}point.total=point.stackTotal=Series_pick(stackItem.total);point.percentage=Series_defined(point.y)&&stackItem.total?point.y/stackItem.total*100:void 0;point.stackY=yValue;if(!series.irregularWidths){stackItem.setOffset(series.pointXOffset||0,series.barW||0,void 0,void 0,void 0,series.xAxis)}}}point.yBottom=Series_defined(lowValue)?limitedRange(yAxis.translate(lowValue,false,true,false,true)):void 0;if(series.dataModify){yValue=series.dataModify.modifyValue(yValue,i)}let plotY;if(Series_isNumber(yValue)&&point.plotX!==void 0){plotY=yAxis.translate(yValue,false,true,false,true);plotY=Series_isNumber(plotY)?limitedRange(plotY):void 0}point.plotY=plotY;point.isInside=this.isPointInside(point);point.clientX=dynamicallyPlaced?Series_correctFloat(xAxis.translate(xValue,false,false,false,true,pointPlacement)):plotX;point.negative=(point.y||0)<(threshold||0);if(!point.isNull&&point.visible!==false){if(typeof lastPlotX!=="undefined"){closestPointRangePx=Math.min(closestPointRangePx,Math.abs(plotX-lastPlotX))}lastPlotX=plotX}point.zone=this.zones.length?point.getZone():void 0;if(!point.graphic&&series.group&&enabledDataSorting){point.isNew=true}}series.closestPointRangePx=closestPointRangePx;Series_fireEvent(this,"afterTranslate")}getValidPoints(points,insideOnly,allowNull){const chart=this.chart;return(points||this.points||[]).filter(function(point){const{plotX,plotY}=point,asNull=!allowNull&&(point.isNull||!Series_isNumber(plotY));if(asNull||insideOnly&&!chart.isInsidePlot(plotX,plotY,{inverted:chart.inverted})){return false}return point.visible!==false})}getClipBox(){const{chart,xAxis,yAxis}=this;let{x,y,width,height}=Series_merge(chart.clipBox);if(xAxis&&xAxis.len!==chart.plotSizeX){width=xAxis.len}if(yAxis&&yAxis.len!==chart.plotSizeY){height=yAxis.len}if(chart.inverted&&!this.invertible){[width,height]=[height,width]}return{x:x,y:y,width:width,height:height}}getSharedClipKey(){this.sharedClipKey=(this.options.xAxis||0)+","+(this.options.yAxis||0);return this.sharedClipKey}setClip(){const{chart,group,markerGroup}=this,sharedClips=chart.sharedClips,renderer=chart.renderer,clipBox=this.getClipBox(),sharedClipKey=this.getSharedClipKey();let clipRect=sharedClips[sharedClipKey];if(!clipRect){sharedClips[sharedClipKey]=clipRect=renderer.clipRect(clipBox)}else{clipRect.animate(clipBox)}if(group){group.clip(this.options.clip===false?void 0:clipRect)}if(markerGroup){markerGroup.clip()}}animate(init){const{chart,group,markerGroup}=this,inverted=chart.inverted,animation=Series_animObject(this.options.animation),animationClipKey=[this.getSharedClipKey(),animation.duration,animation.easing,animation.defer].join(",");let animationClipRect=chart.sharedClips[animationClipKey],markerAnimationClipRect=chart.sharedClips[animationClipKey+"m"];if(init&&group){const clipBox=this.getClipBox();if(!animationClipRect){clipBox.width=0;if(inverted){clipBox.x=chart.plotHeight}animationClipRect=chart.renderer.clipRect(clipBox);chart.sharedClips[animationClipKey]=animationClipRect;const markerClipBox={x:inverted?-99:-99,y:inverted?-99:-99,width:inverted?chart.plotWidth+199:99,height:inverted?99:chart.plotHeight+199};markerAnimationClipRect=chart.renderer.clipRect(markerClipBox);chart.sharedClips[animationClipKey+"m"]=markerAnimationClipRect}else{animationClipRect.attr("height",clipBox.height)}group.clip(animationClipRect);markerGroup?.clip(markerAnimationClipRect)}else if(animationClipRect&&!animationClipRect.hasClass("highcharts-animating")){const finalBox=this.getClipBox(),step=animation.step;if(markerGroup?.element.childNodes.length||chart.series.length>1){animation.step=function(val,fx){if(step){step.apply(fx,arguments)}if(fx.prop==="width"&&markerAnimationClipRect?.element){markerAnimationClipRect.attr(inverted?"height":"width",val+99)}}}animationClipRect.addClass("highcharts-animating").animate(finalBox,animation)}}afterAnimate(){this.setClip();Series_objectEach(this.chart.sharedClips,(clip,key,sharedClips)=>{if(clip&&!this.chart.container.querySelector(`[clip-path="url(#${clip.id})"]`)){clip.destroy();delete sharedClips[key]}});this.finishedAnimating=true;Series_fireEvent(this,"afterAnimate")}drawPoints(points=this.points){const series=this,chart=series.chart,styledMode=chart.styledMode,{colorAxis,options}=series,seriesMarkerOptions=options.marker,markerGroup=series[series.specialGroup||"markerGroup"],xAxis=series.xAxis,globallyEnabled=Series_pick(seriesMarkerOptions.enabled,!xAxis||xAxis.isRadial?true:null,series.closestPointRangePx>=seriesMarkerOptions.enabledThreshold*seriesMarkerOptions.radius);let i,point,graphic,verb,pointMarkerOptions,hasPointMarker,markerAttribs;if(seriesMarkerOptions.enabled!==false||series._hasPointMarkers){for(i=0;i<points.length;i++){point=points[i];graphic=point.graphic;verb=graphic?"animate":"attr";pointMarkerOptions=point.marker||{};hasPointMarker=!!point.marker;const shouldDrawMarker=(globallyEnabled&&typeof pointMarkerOptions.enabled==="undefined"||pointMarkerOptions.enabled)&&!point.isNull&&point.visible!==false;if(shouldDrawMarker){const symbol=Series_pick(pointMarkerOptions.symbol,series.symbol,"rect");markerAttribs=series.markerAttribs(point,point.selected&&"select");if(series.enabledDataSorting){point.startXPos=xAxis.reversed?-(markerAttribs.width||0):xAxis.width}const isInside=point.isInside!==false;if(!graphic&&isInside&&((markerAttribs.width||0)>0||point.hasImage)){point.graphic=graphic=chart.renderer.symbol(symbol,markerAttribs.x,markerAttribs.y,markerAttribs.width,markerAttribs.height,hasPointMarker?pointMarkerOptions:seriesMarkerOptions).add(markerGroup);if(series.enabledDataSorting&&chart.hasRendered){graphic.attr({x:point.startXPos});verb="animate"}}if(graphic&&verb==="animate"){graphic[isInside?"show":"hide"](isInside).animate(markerAttribs)}if(graphic){const pointAttr=series.pointAttribs(point,styledMode||!point.selected?void 0:"select");if(!styledMode){graphic[verb](pointAttr)}else if(colorAxis){graphic["css"]({fill:pointAttr.fill})}}if(graphic){graphic.addClass(point.getClassName(),true)}}else if(graphic){point.graphic=graphic.destroy()}}}}markerAttribs(point,state){const seriesOptions=this.options,seriesMarkerOptions=seriesOptions.marker,pointMarkerOptions=point.marker||{},symbol=pointMarkerOptions.symbol||seriesMarkerOptions.symbol,attribs={};let seriesStateOptions,pointStateOptions,radius=Series_pick(pointMarkerOptions.radius,seriesMarkerOptions&&seriesMarkerOptions.radius);if(state){seriesStateOptions=seriesMarkerOptions.states[state];pointStateOptions=pointMarkerOptions.states&&pointMarkerOptions.states[state];radius=Series_pick(pointStateOptions&&pointStateOptions.radius,seriesStateOptions&&seriesStateOptions.radius,radius&&radius+(seriesStateOptions&&seriesStateOptions.radiusPlus||0))}point.hasImage=symbol&&symbol.indexOf("url")===0;if(point.hasImage){radius=0}const pos=point.pos();if(Series_isNumber(radius)&&pos){if(seriesOptions.crisp){pos[0]=Series_crisp(pos[0],point.hasImage?0:symbol==="rect"?seriesMarkerOptions?.lineWidth||0:1)}attribs.x=pos[0]-radius;attribs.y=pos[1]-radius}if(radius){attribs.width=attribs.height=2*radius}return attribs}pointAttribs(point,state){const seriesMarkerOptions=this.options.marker,pointOptions=point&&point.options,pointMarkerOptions=pointOptions&&pointOptions.marker||{},pointColorOption=pointOptions&&pointOptions.color,pointColor=point&&point.color,zoneColor=point&&point.zone&&point.zone.color;let seriesStateOptions,pointStateOptions,color=this.color,fill,stroke,strokeWidth=Series_pick(pointMarkerOptions.lineWidth,seriesMarkerOptions.lineWidth),opacity=1;color=pointColorOption||zoneColor||pointColor||color;fill=pointMarkerOptions.fillColor||seriesMarkerOptions.fillColor||color;stroke=pointMarkerOptions.lineColor||seriesMarkerOptions.lineColor||color;state=state||"normal";if(state){seriesStateOptions=seriesMarkerOptions.states[state]||{};pointStateOptions=pointMarkerOptions.states&&pointMarkerOptions.states[state]||{};strokeWidth=Series_pick(pointStateOptions.lineWidth,seriesStateOptions.lineWidth,strokeWidth+Series_pick(pointStateOptions.lineWidthPlus,seriesStateOptions.lineWidthPlus,0));fill=pointStateOptions.fillColor||seriesStateOptions.fillColor||fill;stroke=pointStateOptions.lineColor||seriesStateOptions.lineColor||stroke;opacity=Series_pick(pointStateOptions.opacity,seriesStateOptions.opacity,opacity)}return{stroke:stroke,"stroke-width":strokeWidth,fill:fill,opacity:opacity}}destroy(keepEventsForUpdate){const series=this,chart=series.chart,issue134=/AppleWebKit\/533/.test(Series_win.navigator.userAgent),data=series.data||[];let destroy,i,point,axis;Series_fireEvent(series,"destroy",{keepEventsForUpdate:keepEventsForUpdate});this.removeEvents(keepEventsForUpdate);(series.axisTypes||[]).forEach(function(AXIS){axis=series[AXIS];if(axis&&axis.series){Series_erase(axis.series,series);axis.isDirty=axis.forceRedraw=true}});if(series.legendItem){series.chart.legend.destroyItem(series)}i=data.length;while(i--){point=data[i];if(point&&point.destroy){point.destroy()}}for(const zone of series.zones){Series_destroyObjectProperties(zone,void 0,true)}Core_Utilities.clearTimeout(series.animationTimeout);Series_objectEach(series,function(val,prop){if(val instanceof SVG_SVGElement&&!val.survive){destroy=issue134&&prop==="group"?"hide":"destroy";val[destroy]()}});if(chart.hoverSeries===series){chart.hoverSeries=void 0}Series_erase(chart.series,series);chart.orderItems("series");Series_objectEach(series,function(val,prop){if(!keepEventsForUpdate||prop!=="hcEvents"){delete series[prop]}})}applyZones(){const series=this,{area,chart,graph,zones,points,xAxis,yAxis,zoneAxis}=series,{inverted,renderer}=chart,axis=this[`${zoneAxis}Axis`],{isXAxis,len=0,minPointOffset=0}=axis||{},halfWidth=(graph?.strokeWidth()||0)/2+1,avoidClose=(zone,plotX=0,plotY=0)=>{if(inverted){plotY=len-plotY}const{translated=0,lineClip}=zone,distance=plotY-translated;lineClip?.push(["L",plotX,Math.abs(distance)<halfWidth?plotY-halfWidth*(distance<=0?-1:1):translated])};if(zones.length&&(graph||area)&&axis&&Series_isNumber(axis.min)){const axisMax=axis.getExtremes().max+minPointOffset,invertPath=path=>{path.forEach((segment,i)=>{if(segment[0]==="M"||segment[0]==="L"){path[i]=[segment[0],isXAxis?len-segment[1]:segment[1],isXAxis?segment[2]:len-segment[2]]}})};zones.forEach(zone=>{zone.lineClip=[];zone.translated=Series_clamp(axis.toPixels(Series_pick(zone.value,axisMax),true)||0,0,len)});if(graph&&!this.showLine){graph.hide()}if(area){area.hide()}if(zoneAxis==="y"&&points.length<xAxis.len){for(const point of points){const{plotX,plotY,zone}=point,zoneBelow=zone&&zones[zones.indexOf(zone)-1];if(zone){avoidClose(zone,plotX,plotY)}if(zoneBelow){avoidClose(zoneBelow,plotX,plotY)}}}let lastLineClip=[],lastTranslated=axis.toPixels(axis.getExtremes().min-minPointOffset,true);zones.forEach(zone=>{const lineClip=zone.lineClip||[],translated=Math.round(zone.translated||0);if(xAxis.reversed){lineClip.reverse()}let{clip,simpleClip}=zone,x1=0,y1=0,x2=xAxis.len,y2=yAxis.len;if(isXAxis){x1=translated;x2=lastTranslated}else{y1=translated;y2=lastTranslated}const simplePath=[["M",x1,y1],["L",x2,y1],["L",x2,y2],["L",x1,y2],["Z"]],adaptivePath=[simplePath[0],...lineClip,simplePath[1],simplePath[2],...lastLineClip,simplePath[3],simplePath[4]];lastLineClip=lineClip.reverse();lastTranslated=translated;if(inverted){invertPath(adaptivePath);if(area){invertPath(simplePath)}}if(clip){clip.animate({d:adaptivePath});simpleClip?.animate({d:simplePath})}else{clip=zone.clip=renderer.path(adaptivePath);if(area){simpleClip=zone.simpleClip=renderer.path(simplePath)}}if(graph){zone.graph?.clip(clip)}if(area){zone.area?.clip(simpleClip)}})}else if(series.visible){if(graph){graph.show()}if(area){area.show()}}}plotGroup(prop,name,visibility,zIndex,parent){let group=this[prop];const isNew=!group,attrs={visibility:visibility,zIndex:zIndex||.1};if(Series_defined(this.opacity)&&!this.chart.styledMode&&this.state!=="inactive"){attrs.opacity=this.opacity}if(!group){this[prop]=group=this.chart.renderer.g().add(parent)}group.addClass("highcharts-"+name+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(Series_defined(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(group.hasClass("highcharts-tracker")?" highcharts-tracker":""),true);group.attr(attrs)[isNew?"attr":"animate"](this.getPlotBox(name));return group}getPlotBox(name){let horAxis=this.xAxis,vertAxis=this.yAxis;const chart=this.chart,inverted=chart.inverted&&!chart.polar&&horAxis&&this.invertible&&name==="series";if(chart.inverted){horAxis=vertAxis;vertAxis=this.xAxis}return{translateX:horAxis?horAxis.left:chart.plotLeft,translateY:vertAxis?vertAxis.top:chart.plotTop,rotation:inverted?90:0,rotationOriginX:inverted?(horAxis.len-vertAxis.len)/2:0,rotationOriginY:inverted?(horAxis.len+vertAxis.len)/2:0,scaleX:inverted?-1:1,scaleY:1}}removeEvents(keepEventsForUpdate){const{eventsToUnbind}=this;if(!keepEventsForUpdate){Series_removeEvent(this)}if(eventsToUnbind.length){eventsToUnbind.forEach(unbind=>{unbind()});eventsToUnbind.length=0}}render(){const series=this,{chart,options,hasRendered}=series,animOptions=Series_animObject(options.animation),visibility=series.visible?"inherit":"hidden",zIndex=options.zIndex,chartSeriesGroup=chart.seriesGroup;let animDuration=series.finishedAnimating?0:animOptions.duration;Series_fireEvent(this,"render");series.plotGroup("group","series",visibility,zIndex,chartSeriesGroup);series.markerGroup=series.plotGroup("markerGroup","markers",visibility,zIndex,chartSeriesGroup);if(options.clip!==false){series.setClip()}if(animDuration){series.animate?.(true)}if(series.drawGraph){series.drawGraph();series.applyZones()}if(series.visible){series.drawPoints()}series.drawDataLabels?.();series.redrawPoints?.();if(options.enableMouseTracking){series.drawTracker?.()}if(animDuration){series.animate?.()}if(!hasRendered){if(animDuration&&animOptions.defer){animDuration+=animOptions.defer}series.animationTimeout=Series_syncTimeout(()=>{series.afterAnimate()},animDuration||0)}series.isDirty=false;series.hasRendered=true;Series_fireEvent(series,"afterRender")}redraw(){const wasDirty=this.isDirty||this.isDirtyData;this.translate();this.render();if(wasDirty){delete this.kdTree}}reserveSpace(){return this.visible||!this.chart.options.chart.ignoreHiddenSeries}searchPoint(e,compareX){const{xAxis,yAxis}=this,inverted=this.chart.inverted;return this.searchKDTree({clientX:inverted?xAxis.len-e.chartY+xAxis.pos:e.chartX-xAxis.pos,plotY:inverted?yAxis.len-e.chartX+yAxis.pos:e.chartY-yAxis.pos},compareX,e)}buildKDTree(e){this.buildingKdTree=true;const series=this,dimensions=series.options.findNearestPointBy.indexOf("y")>-1?2:1;function kdtree(points,depth,dimensions){const length=points?.length;let axis,median;if(length){axis=series.kdAxisArray[depth%dimensions];points.sort((a,b)=>(a[axis]||0)-(b[axis]||0));median=Math.floor(length/2);return{point:points[median],left:kdtree(points.slice(0,median),depth+1,dimensions),right:kdtree(points.slice(median+1),depth+1,dimensions)}}}function startRecursive(){series.kdTree=kdtree(series.getValidPoints(void 0,!series.directTouch),dimensions,dimensions);series.buildingKdTree=false}delete series.kdTree;Series_syncTimeout(startRecursive,series.options.kdNow||e?.type==="touchstart"?0:1)}searchKDTree(point,compareX,e){const series=this,[kdX,kdY]=this.kdAxisArray,kdComparer=compareX?"distX":"dist",kdDimensions=(series.options.findNearestPointBy||"").indexOf("y")>-1?2:1,useRadius=!!series.isBubble;function setDistance(p1,p2){const p1kdX=p1[kdX],p2kdX=p2[kdX],x=Series_defined(p1kdX)&&Series_defined(p2kdX)?p1kdX-p2kdX:null,p1kdY=p1[kdY],p2kdY=p2[kdY],y=Series_defined(p1kdY)&&Series_defined(p2kdY)?p1kdY-p2kdY:0,radius=useRadius?p2.marker?.radius||0:0;p2.dist=Math.sqrt((x&&x*x||0)+y*y)-radius;p2.distX=Series_defined(x)?Math.abs(x)-radius:Number.MAX_VALUE}function doSearch(search,tree,depth,dimensions){const point=tree.point,axis=series.kdAxisArray[depth%dimensions];let nPoint1,nPoint2,ret=point;setDistance(search,point);const tdist=(search[axis]||0)-(point[axis]||0)+(useRadius?point.marker?.radius||0:0),sideA=tdist<0?"left":"right",sideB=tdist<0?"right":"left";if(tree[sideA]){nPoint1=doSearch(search,tree[sideA],depth+1,dimensions);ret=nPoint1[kdComparer]<ret[kdComparer]?nPoint1:point}if(tree[sideB]){if(Math.sqrt(tdist*tdist)<ret[kdComparer]){nPoint2=doSearch(search,tree[sideB],depth+1,dimensions);ret=nPoint2[kdComparer]<ret[kdComparer]?nPoint2:ret}}return ret}if(!this.kdTree&&!this.buildingKdTree){this.buildKDTree(e)}if(this.kdTree){return doSearch(point,this.kdTree,kdDimensions,kdDimensions)}}pointPlacementToXValue(){const{options,xAxis}=this;let factor=options.pointPlacement;if(factor==="between"){factor=xAxis.reversed?-.5:.5}return Series_isNumber(factor)?factor*(options.pointRange||xAxis.pointRange):0}isPointInside(point){const{chart,xAxis,yAxis}=this,{plotX=-1,plotY=-1}=point,isInside=plotY>=0&&plotY<=(yAxis?yAxis.len:chart.plotHeight)&&plotX>=0&&plotX<=(xAxis?xAxis.len:chart.plotWidth);return isInside}drawTracker(){const series=this,options=series.options,trackByArea=options.trackByArea,trackerPath=[].concat((trackByArea?series.areaPath:series.graphPath)||[]),chart=series.chart,pointer=chart.pointer,renderer=chart.renderer,snap=chart.options.tooltip?.snap||0,onMouseOver=()=>{if(options.enableMouseTracking&&chart.hoverSeries!==series){series.onMouseOver()}},TRACKER_FILL="rgba(192,192,192,"+(Series_svg?1e-4:.002)+")";let tracker=series.tracker;if(tracker){tracker.attr({d:trackerPath})}else if(series.graph){series.tracker=tracker=renderer.path(trackerPath).attr({visibility:series.visible?"inherit":"hidden",zIndex:2}).addClass(trackByArea?"highcharts-tracker-area":"highcharts-tracker-line").add(series.group);if(!chart.styledMode){tracker.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:TRACKER_FILL,fill:trackByArea?TRACKER_FILL:"none","stroke-width":series.graph.strokeWidth()+(trackByArea?0:2*snap)})}[series.tracker,series.markerGroup,series.dataLabelsGroup].forEach(tracker=>{if(tracker){tracker.addClass("highcharts-tracker").on("mouseover",onMouseOver).on("mouseout",e=>{pointer?.onTrackerMouseOut(e)});if(options.cursor&&!chart.styledMode){tracker.css({cursor:options.cursor})}tracker.on("touchstart",onMouseOver)}})}Series_fireEvent(this,"afterDrawTracker")}addPoint(options,redraw,shift,animation,withEvent){const series=this,seriesOptions=series.options,{chart,data,dataTable:table,xAxis}=series,names=xAxis&&xAxis.hasNames&&xAxis.names,dataOptions=seriesOptions.data,xData=series.getColumn("x");let isInTheMiddle,i;redraw=Series_pick(redraw,true);const point={series:series};series.pointClass.prototype.applyOptions.apply(point,[options]);const x=point.x;i=xData.length;if(series.requireSorting&&x<xData[i-1]){isInTheMiddle=true;while(i&&xData[i-1]>x){i--}}table.setRow(point,i,true,{addColumns:false});if(names&&point.name){names[x]=point.name}dataOptions?.splice(i,0,options);if(isInTheMiddle||series.processedData){series.data.splice(i,0,null);series.processData()}if(seriesOptions.legendType==="point"){series.generatePoints()}if(shift){if(data[0]&&!!data[0].remove){data[0].remove(false)}else{[data,dataOptions,...Object.values(table.getColumns())].filter(Series_defined).forEach(coll=>{coll.shift()});table.rowCount-=1;Series_fireEvent(table,"afterDeleteRows")}}if(withEvent!==false){Series_fireEvent(series,"addPoint",{point:point})}series.isDirty=true;series.isDirtyData=true;if(redraw){chart.redraw(animation)}}removePoint(i,redraw,animation){const series=this,{chart,data,points,dataTable:table}=series,point=data[i],remove=function(){[points?.length===data.length?points:void 0,data,series.options.data,...Object.values(table.getColumns())].filter(Series_defined).forEach(coll=>{coll.splice(i,1)});table.rowCount-=1;Series_fireEvent(table,"afterDeleteRows");point?.destroy();series.isDirty=true;series.isDirtyData=true;if(redraw){chart.redraw()}};Series_setAnimation(animation,chart);redraw=Series_pick(redraw,true);if(point){point.firePointEvent("remove",null,remove)}else{remove()}}remove(redraw,animation,withEvent,keepEvents){const series=this,chart=series.chart;function remove(){series.destroy(keepEvents);chart.isDirtyLegend=chart.isDirtyBox=true;chart.linkSeries(keepEvents);if(Series_pick(redraw,true)){chart.redraw(animation)}}if(withEvent!==false){Series_fireEvent(series,"remove",null,remove)}else{remove()}}update(options,redraw){options=Series_diffObjects(options,this.userOptions);Series_fireEvent(this,"update",{options:options});const series=this,chart=series.chart,oldOptions=series.userOptions,initialType=series.initialType||series.type,plotOptions=chart.options.plotOptions,initialSeriesProto=seriesTypes[initialType].prototype,groups=["group","markerGroup","dataLabelsGroup","transformGroup"],optionsToCheck=["dataGrouping","pointStart","pointInterval","pointIntervalUnit","keys"],animation=series.finishedAnimating&&{animation:false},kinds={};let seriesOptions,n,preserve=["colorIndex","eventOptions","navigatorSeries","symbolIndex","baseSeries"],newType=options.type||oldOptions.type||chart.options.chart.type;const keepPoints=!(this.hasDerivedData||newType&&newType!==this.type||typeof options.keys!=="undefined"||typeof options.pointStart!=="undefined"||typeof options.pointInterval!=="undefined"||typeof options.relativeXValue!=="undefined"||options.joinBy||options.mapData||optionsToCheck.some(option=>series.hasOptionChanged(option)));newType=newType||initialType;if(keepPoints){preserve.push("data","isDirtyData","isDirtyCanvas","points","dataTable","processedData","xIncrement","cropped","_hasPointMarkers","hasDataLabels","nodes","layout","level","mapMap","mapData","minY","maxY","minX","maxX","transformGroups");if(options.visible!==false){preserve.push("area","graph")}series.parallelArrays.forEach(function(key){preserve.push(key+"Data")});if(options.data){if(options.dataSorting){Series_extend(series.options.dataSorting,options.dataSorting)}this.setData(options.data,false)}}else{this.dataTable.modified=this.dataTable}options=Series_merge(oldOptions,{index:oldOptions.index===void 0?series.index:oldOptions.index,pointStart:plotOptions?.series?.pointStart??oldOptions.pointStart??series.getColumn("x")[0]},!keepPoints&&{data:series.options.data},options,animation);if(keepPoints&&options.data){options.data=series.options.data}preserve=groups.concat(preserve);preserve.forEach(function(prop){preserve[prop]=series[prop];delete series[prop]});let casting=false;if(seriesTypes[newType]){casting=newType!==series.type;series.remove(false,false,false,true);if(casting){chart.propFromSeries();if(Object.setPrototypeOf){Object.setPrototypeOf(series,seriesTypes[newType].prototype)}else{const ownEvents=Object.hasOwnProperty.call(series,"hcEvents")&&series.hcEvents;for(n in initialSeriesProto){series[n]=void 0}Series_extend(series,seriesTypes[newType].prototype);if(ownEvents){series.hcEvents=ownEvents}else{delete series.hcEvents}}}}else{Series_error(17,true,chart,{missingModuleFor:newType})}preserve.forEach(function(prop){series[prop]=preserve[prop]});series.init(chart,options);if(keepPoints&&this.points){seriesOptions=series.options;if(seriesOptions.visible===false){kinds.graphic=1;kinds.dataLabel=1}else{if(this.hasMarkerChanged(seriesOptions,oldOptions)){kinds.graphic=1}if(!series.hasDataLabels?.()){kinds.dataLabel=1}}for(const point of this.points){if(point&&point.series){point.resolveColor();if(Object.keys(kinds).length){point.destroyElements(kinds)}if(seriesOptions.showInLegend===false&&point.legendItem){chart.legend.destroyItem(point)}}}}series.initialType=initialType;chart.linkSeries();chart.setSortedData();if(casting&&series.linkedSeries.length){series.isDirtyData=true}Series_fireEvent(this,"afterUpdate");if(Series_pick(redraw,true)){chart.redraw(keepPoints?void 0:false)}}setName(name){this.name=this.options.name=this.userOptions.name=name;this.chart.isDirtyLegend=true}hasOptionChanged(optionName){const chart=this.chart,option=this.options[optionName],plotOptions=chart.options.plotOptions,oldOption=this.userOptions[optionName],plotOptionsOption=Series_pick(plotOptions?.[this.type]?.[optionName],plotOptions?.series?.[optionName]);if(oldOption&&!Series_defined(plotOptionsOption)){return option!==oldOption}return option!==Series_pick(plotOptionsOption,option)}onMouseOver(){const series=this,chart=series.chart,hoverSeries=chart.hoverSeries,pointer=chart.pointer;pointer?.setHoverChartIndex();if(hoverSeries&&hoverSeries!==series){hoverSeries.onMouseOut()}if(series.options.events.mouseOver){Series_fireEvent(series,"mouseOver")}series.setState("hover");chart.hoverSeries=series}onMouseOut(){const series=this,options=series.options,chart=series.chart,tooltip=chart.tooltip,hoverPoint=chart.hoverPoint;chart.hoverSeries=null;if(hoverPoint){hoverPoint.onMouseOut()}if(series&&options.events.mouseOut){Series_fireEvent(series,"mouseOut")}if(tooltip&&!series.stickyTracking&&(!tooltip.shared||series.noSharedTooltip)){tooltip.hide()}chart.series.forEach(function(s){s.setState("",true)})}setState(state,inherit){const series=this,options=series.options,graph=series.graph,inactiveOtherPoints=options.inactiveOtherPoints,stateOptions=options.states,stateAnimation=Series_pick(stateOptions[state||"normal"]&&stateOptions[state||"normal"].animation,series.chart.options.chart.animation);let lineWidth=options.lineWidth,opacity=options.opacity;state=state||"";if(series.state!==state){[series.group,series.markerGroup,series.dataLabelsGroup].forEach(function(group){if(group){if(series.state){group.removeClass("highcharts-series-"+series.state)}if(state){group.addClass("highcharts-series-"+state)}}});series.state=state;if(!series.chart.styledMode){if(stateOptions[state]&&stateOptions[state].enabled===false){return}if(state){lineWidth=stateOptions[state].lineWidth||lineWidth+(stateOptions[state].lineWidthPlus||0);opacity=Series_pick(stateOptions[state].opacity,opacity)}if(graph&&!graph.dashstyle&&Series_isNumber(lineWidth)){for(const graphElement of[graph,...this.zones.map(zone=>zone.graph)]){graphElement?.animate({"stroke-width":lineWidth},stateAnimation)}}if(!inactiveOtherPoints){[series.group,series.markerGroup,series.dataLabelsGroup,series.labelBySeries].forEach(function(group){if(group){group.animate({opacity:opacity},stateAnimation)}})}}}if(inherit&&inactiveOtherPoints&&series.points){series.setAllPointsToState(state||void 0)}}setAllPointsToState(state){this.points.forEach(function(point){if(point.setState){point.setState(state)}})}setVisible(vis,redraw){const series=this,chart=series.chart,ignoreHiddenSeries=chart.options.chart.ignoreHiddenSeries,oldVisibility=series.visible;series.visible=vis=series.options.visible=series.userOptions.visible=typeof vis==="undefined"?!oldVisibility:vis;const showOrHide=vis?"show":"hide";["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(key=>{series[key]?.[showOrHide]()});if(chart.hoverSeries===series||chart.hoverPoint?.series===series){series.onMouseOut()}if(series.legendItem){chart.legend.colorizeItem(series,vis)}series.isDirty=true;if(series.options.stacking){chart.series.forEach(otherSeries=>{if(otherSeries.options.stacking&&otherSeries.visible){otherSeries.isDirty=true}})}series.linkedSeries.forEach(otherSeries=>{otherSeries.setVisible(vis,false)});if(ignoreHiddenSeries){chart.isDirtyBox=true}Series_fireEvent(series,showOrHide);if(redraw!==false){chart.redraw()}}show(){this.setVisible(true)}hide(){this.setVisible(false)}select(selected){const series=this;series.selected=selected=this.options.selected=typeof selected==="undefined"?!series.selected:selected;if(series.checkbox){series.checkbox.checked=selected}Series_fireEvent(series,selected?"select":"unselect")}shouldShowTooltip(plotX,plotY,options={}){options.series=this;options.visiblePlotOnly=true;return this.chart.isInsidePlot(plotX,plotY,options)}drawLegendSymbol(legend,item){Legend_LegendSymbol[this.options.legendSymbol||"rectangle"]?.call(this,legend,item)}}Series.defaultOptions=SeriesDefaults;Series.types=Series_SeriesRegistry.seriesTypes;Series.registerType=Series_SeriesRegistry.registerSeriesType;Series_extend(Series.prototype,{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,directTouch:false,invertible:true,isCartesian:true,kdAxisArray:["clientX","plotY"],parallelArrays:["x","y"],pointClass:Series_Point,requireSorting:true,sorted:true});Series_SeriesRegistry.series=Series;const Series_Series=Series;"";"";const{animObject:Legend_animObject,setAnimation:Legend_setAnimation}=AnimationUtilities;const{registerEventOptions:Legend_registerEventOptions}=Core_Foundation;const{composed:Legend_composed,marginNames}=Core_Globals;const{distribute:Legend_distribute}=Renderer_RendererUtilities;const{format:Legend_format}=Core_Templating;const{addEvent:Legend_addEvent,createElement:Legend_createElement,css:Legend_css,defined:Legend_defined,discardElement:Legend_discardElement,find:Legend_find,fireEvent:Legend_fireEvent,isNumber:Legend_isNumber,merge:Legend_merge,pick:Legend_pick,pushUnique:Legend_pushUnique,relativeLength:Legend_relativeLength,stableSort:Legend_stableSort,syncTimeout:Legend_syncTimeout}=Core_Utilities;class Legend{constructor(chart,options){this.allItems=[];this.initialItemY=0;this.itemHeight=0;this.itemMarginBottom=0;this.itemMarginTop=0;this.itemX=0;this.itemY=0;this.lastItemY=0;this.lastLineHeight=0;this.legendHeight=0;this.legendWidth=0;this.maxItemWidth=0;this.maxLegendWidth=0;this.offsetWidth=0;this.padding=0;this.pages=[];this.symbolHeight=0;this.symbolWidth=0;this.titleHeight=0;this.totalItemWidth=0;this.widthOption=0;this.chart=chart;this.setOptions(options);if(options.enabled){this.render();Legend_registerEventOptions(this,options);Legend_addEvent(this.chart,"endResize",function(){this.legend.positionCheckboxes()})}Legend_addEvent(this.chart,"render",()=>{if(this.options.enabled&&this.proximate){this.proximatePositions();this.positionItems()}})}setOptions(options){const padding=Legend_pick(options.padding,8);this.options=options;if(!this.chart.styledMode){this.itemStyle=options.itemStyle;this.itemHiddenStyle=Legend_merge(this.itemStyle,options.itemHiddenStyle)}this.itemMarginTop=options.itemMarginTop;this.itemMarginBottom=options.itemMarginBottom;this.padding=padding;this.initialItemY=padding-5;this.symbolWidth=Legend_pick(options.symbolWidth,16);this.pages=[];this.proximate=options.layout==="proximate"&&!this.chart.inverted;this.baseline=void 0}update(options,redraw){const chart=this.chart;this.setOptions(Legend_merge(true,this.options,options));if("events"in this.options){Legend_registerEventOptions(this,this.options)}this.destroy();chart.isDirtyLegend=chart.isDirtyBox=true;if(Legend_pick(redraw,true)){chart.redraw()}Legend_fireEvent(this,"afterUpdate",{redraw:redraw})}colorizeItem(item,visible){const originalColor=item.color,{area,group,label,line,symbol}=item.legendItem||{};if(item instanceof Series_Series||item instanceof Series_Point){item.color=item.options?.legendSymbolColor||originalColor}group?.[visible?"removeClass":"addClass"]("highcharts-legend-item-hidden");if(!this.chart.styledMode){const{itemHiddenStyle={}}=this,hiddenColor=itemHiddenStyle.color,{fillColor,fillOpacity,lineColor,marker}=item.options,colorizeHidden=attr=>{if(!visible){if(attr.fill){attr.fill=hiddenColor}if(attr.stroke){attr.stroke=hiddenColor}}return attr};label?.css(Legend_merge(visible?this.itemStyle:itemHiddenStyle));line?.attr(colorizeHidden({stroke:lineColor||item.color}));if(symbol){symbol.attr(colorizeHidden(marker&&symbol.isMarker?item.pointAttribs():{fill:item.color}))}area?.attr(colorizeHidden({fill:fillColor||item.color,"fill-opacity":fillColor?1:fillOpacity??.75}))}item.color=originalColor;Legend_fireEvent(this,"afterColorizeItem",{item:item,visible:visible})}positionItems(){this.allItems.forEach(this.positionItem,this);if(!this.chart.isResizing){this.positionCheckboxes()}}positionItem(item){const legend=this,{group,x=0,y=0}=item.legendItem||{},options=legend.options,symbolPadding=options.symbolPadding,ltr=!options.rtl,checkbox=item.checkbox;if(group&&group.element){const attribs={translateX:ltr?x:legend.legendWidth-x-2*symbolPadding-4,translateY:y};const complete=()=>{Legend_fireEvent(this,"afterPositionItem",{item:item})};group[Legend_defined(group.translateY)?"animate":"attr"](attribs,void 0,complete)}if(checkbox){checkbox.x=x;checkbox.y=y}}destroyItem(item){const checkbox=item.checkbox,legendItem=item.legendItem||{};for(const key of["group","label","line","symbol"]){if(legendItem[key]){legendItem[key]=legendItem[key].destroy()}}if(checkbox){Legend_discardElement(checkbox)}item.legendItem=void 0}destroy(){const legend=this;for(const item of this.getAllItems()){this.destroyItem(item)}for(const key of["clipRect","up","down","pager","nav","box","title","group"]){if(legend[key]){legend[key]=legend[key].destroy()}}this.display=null}positionCheckboxes(){const alignAttr=this.group&&this.group.alignAttr,clipHeight=this.clipHeight||this.legendHeight,titleHeight=this.titleHeight;let translateY;if(alignAttr){translateY=alignAttr.translateY;this.allItems.forEach(function(item){const checkbox=item.checkbox;let top;if(checkbox){top=translateY+titleHeight+checkbox.y+(this.scrollOffset||0)+3;Legend_css(checkbox,{left:alignAttr.translateX+item.checkboxOffset+checkbox.x-20+"px",top:top+"px",display:this.proximate||top>translateY-6&&top<translateY+clipHeight-6?"":"none"})}},this)}}renderTitle(){const options=this.options,padding=this.padding,titleOptions=options.title;let bBox,titleHeight=0;if(titleOptions.text){if(!this.title){this.title=this.chart.renderer.label(titleOptions.text,padding-3,padding-4,void 0,void 0,void 0,options.useHTML,void 0,"legend-title").attr({zIndex:1});if(!this.chart.styledMode){this.title.css(titleOptions.style)}this.title.add(this.group)}if(!titleOptions.width){this.title.css({width:this.maxLegendWidth+"px"})}bBox=this.title.getBBox();titleHeight=bBox.height;this.offsetWidth=bBox.width;this.contentGroup.attr({translateY:titleHeight})}this.titleHeight=titleHeight}setText(item){const options=this.options;item.legendItem.label.attr({text:options.labelFormat?Legend_format(options.labelFormat,item,this.chart):options.labelFormatter.call(item)})}renderItem(item){const legend=this,legendItem=item.legendItem=item.legendItem||{},chart=legend.chart,renderer=chart.renderer,options=legend.options,horizontal=options.layout==="horizontal",symbolWidth=legend.symbolWidth,symbolPadding=options.symbolPadding||0,itemStyle=legend.itemStyle,itemHiddenStyle=legend.itemHiddenStyle,itemDistance=horizontal?Legend_pick(options.itemDistance,20):0,ltr=!options.rtl,isSeries=!item.series,series=!isSeries&&item.series.drawLegendSymbol?item.series:item,seriesOptions=series.options,showCheckbox=!!legend.createCheckboxForItem&&seriesOptions&&seriesOptions.showCheckbox,useHTML=options.useHTML,itemClassName=item.options.className;let label=legendItem.label,itemExtraWidth=symbolWidth+symbolPadding+itemDistance+(showCheckbox?20:0);if(!label){legendItem.group=renderer.g("legend-item").addClass("highcharts-"+series.type+"-series "+"highcharts-color-"+item.colorIndex+(itemClassName?" "+itemClassName:"")+(isSeries?" highcharts-series-"+item.index:"")).attr({zIndex:1}).add(legend.scrollGroup);legendItem.label=label=renderer.text("",ltr?symbolWidth+symbolPadding:-symbolPadding,legend.baseline||0,useHTML);if(!chart.styledMode){label.css(Legend_merge(item.visible?itemStyle:itemHiddenStyle))}label.attr({align:ltr?"left":"right",zIndex:2}).add(legendItem.group);if(!legend.baseline){legend.fontMetrics=renderer.fontMetrics(label);legend.baseline=legend.fontMetrics.f+3+legend.itemMarginTop;label.attr("y",legend.baseline);legend.symbolHeight=Legend_pick(options.symbolHeight,legend.fontMetrics.f);if(options.squareSymbol){legend.symbolWidth=Legend_pick(options.symbolWidth,Math.max(legend.symbolHeight,16));itemExtraWidth=legend.symbolWidth+symbolPadding+itemDistance+(showCheckbox?20:0);if(ltr){label.attr("x",legend.symbolWidth+symbolPadding)}}}series.drawLegendSymbol(legend,item);if(legend.setItemEvents){legend.setItemEvents(item,label,useHTML)}}if(showCheckbox&&!item.checkbox&&legend.createCheckboxForItem){legend.createCheckboxForItem(item)}legend.colorizeItem(item,item.visible);if(chart.styledMode||!itemStyle.width){label.css({width:(options.itemWidth||legend.widthOption||chart.spacingBox.width)-itemExtraWidth+"px"})}legend.setText(item);const bBox=label.getBBox();const fontMetricsH=legend.fontMetrics&&legend.fontMetrics.h||0;item.itemWidth=item.checkboxOffset=options.itemWidth||legendItem.labelWidth||bBox.width+itemExtraWidth;legend.maxItemWidth=Math.max(legend.maxItemWidth,item.itemWidth);legend.totalItemWidth+=item.itemWidth;legend.itemHeight=item.itemHeight=Math.round(legendItem.labelHeight||(bBox.height>fontMetricsH*1.5?bBox.height:fontMetricsH))}layoutItem(item){const options=this.options,padding=this.padding,horizontal=options.layout==="horizontal",itemHeight=item.itemHeight,itemMarginBottom=this.itemMarginBottom,itemMarginTop=this.itemMarginTop,itemDistance=horizontal?Legend_pick(options.itemDistance,20):0,maxLegendWidth=this.maxLegendWidth,itemWidth=options.alignColumns&&this.totalItemWidth>maxLegendWidth?this.maxItemWidth:item.itemWidth,legendItem=item.legendItem||{};if(horizontal&&this.itemX-padding+itemWidth>maxLegendWidth){this.itemX=padding;if(this.lastLineHeight){this.itemY+=itemMarginTop+this.lastLineHeight+itemMarginBottom}this.lastLineHeight=0}this.lastItemY=itemMarginTop+this.itemY+itemMarginBottom;this.lastLineHeight=Math.max(itemHeight,this.lastLineHeight);legendItem.x=this.itemX;legendItem.y=this.itemY;if(horizontal){this.itemX+=itemWidth}else{this.itemY+=itemMarginTop+itemHeight+itemMarginBottom;this.lastLineHeight=itemHeight}this.offsetWidth=this.widthOption||Math.max((horizontal?this.itemX-padding-(item.checkbox?0:itemDistance):itemWidth)+padding,this.offsetWidth)}getAllItems(){let allItems=[];this.chart.series.forEach(function(series){const seriesOptions=series&&series.options;if(series&&Legend_pick(seriesOptions.showInLegend,!Legend_defined(seriesOptions.linkedTo)?void 0:false,true)){allItems=allItems.concat((series.legendItem||{}).labels||(seriesOptions.legendType==="point"?series.data:series))}});Legend_fireEvent(this,"afterGetAllItems",{allItems:allItems});return allItems}getAlignment(){const options=this.options;if(this.proximate){return options.align.charAt(0)+"tv"}return options.floating?"":options.align.charAt(0)+options.verticalAlign.charAt(0)+options.layout.charAt(0)}adjustMargins(margin,spacing){const chart=this.chart,options=this.options,alignment=this.getAlignment();if(alignment){[/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/].forEach(function(alignments,side){if(alignments.test(alignment)&&!Legend_defined(margin[side])){chart[marginNames[side]]=Math.max(chart[marginNames[side]],chart.legend[(side+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][side]*options[side%2?"x":"y"]+Legend_pick(options.margin,12)+spacing[side]+(chart.titleOffset[side]||0))}})}}proximatePositions(){const chart=this.chart,boxes=[],alignLeft=this.options.align==="left";this.allItems.forEach(function(item){let lastPoint,height,useFirstPoint=alignLeft,target,top;if(item.yAxis){if(item.xAxis.options.reversed){useFirstPoint=!useFirstPoint}if(item.points){lastPoint=Legend_find(useFirstPoint?item.points:item.points.slice(0).reverse(),function(item){return Legend_isNumber(item.plotY)})}height=this.itemMarginTop+item.legendItem.label.getBBox().height+this.itemMarginBottom;top=item.yAxis.top-chart.plotTop;if(item.visible){target=lastPoint?lastPoint.plotY:item.yAxis.height;target+=top-.3*height}else{target=top+item.yAxis.height}boxes.push({target:target,size:height,item:item})}},this);let legendItem;for(const box of Legend_distribute(boxes,chart.plotHeight)){legendItem=box.item.legendItem||{};if(Legend_isNumber(box.pos)){legendItem.y=chart.plotTop-chart.spacing[0]+box.pos}}}render(){const legend=this,chart=legend.chart,renderer=chart.renderer,options=legend.options,padding=legend.padding,allItems=legend.getAllItems();let display,legendWidth,legendHeight,legendGroup=legend.group,allowedWidth,box=legend.box;legend.itemX=padding;legend.itemY=legend.initialItemY;legend.offsetWidth=0;legend.lastItemY=0;legend.widthOption=Legend_relativeLength(options.width,chart.spacingBox.width-padding);allowedWidth=chart.spacingBox.width-2*padding-options.x;if(["rm","lm"].indexOf(legend.getAlignment().substring(0,2))>-1){allowedWidth/=2}legend.maxLegendWidth=legend.widthOption||allowedWidth;if(!legendGroup){legend.group=legendGroup=renderer.g("legend").addClass(options.className||"").attr({zIndex:7}).add();legend.contentGroup=renderer.g().attr({zIndex:1}).add(legendGroup);legend.scrollGroup=renderer.g().add(legend.contentGroup)}legend.renderTitle();Legend_stableSort(allItems,(a,b)=>(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0));if(options.reversed){allItems.reverse()}legend.allItems=allItems;legend.display=display=!!allItems.length;legend.lastLineHeight=0;legend.maxItemWidth=0;legend.totalItemWidth=0;legend.itemHeight=0;allItems.forEach(legend.renderItem,legend);allItems.forEach(legend.layoutItem,legend);legendWidth=(legend.widthOption||legend.offsetWidth)+padding;legendHeight=legend.lastItemY+legend.lastLineHeight+legend.titleHeight;legendHeight=legend.handleOverflow(legendHeight);legendHeight+=padding;if(!box){legend.box=box=renderer.rect().addClass("highcharts-legend-box").attr({r:options.borderRadius}).add(legendGroup)}if(!chart.styledMode){box.attr({stroke:options.borderColor,"stroke-width":options.borderWidth||0,fill:options.backgroundColor||"none"}).shadow(options.shadow)}if(legendWidth>0&&legendHeight>0){box[box.placed?"animate":"attr"](box.crisp.call({},{x:0,y:0,width:legendWidth,height:legendHeight},box.strokeWidth()))}legendGroup[display?"show":"hide"]();if(chart.styledMode&&legendGroup.getStyle("display")==="none"){legendWidth=legendHeight=0}legend.legendWidth=legendWidth;legend.legendHeight=legendHeight;if(display){legend.align()}if(!this.proximate){this.positionItems()}Legend_fireEvent(this,"afterRender")}align(alignTo=this.chart.spacingBox){const chart=this.chart,options=this.options;let y=alignTo.y;if(/(lth|ct|rth)/.test(this.getAlignment())&&chart.titleOffset[0]>0){y+=chart.titleOffset[0]}else if(/(lbh|cb|rbh)/.test(this.getAlignment())&&chart.titleOffset[2]>0){y-=chart.titleOffset[2]}if(y!==alignTo.y){alignTo=Legend_merge(alignTo,{y:y})}if(!chart.hasRendered){this.group.placed=false}this.group.align(Legend_merge(options,{width:this.legendWidth,height:this.legendHeight,verticalAlign:this.proximate?"top":options.verticalAlign}),true,alignTo)}handleOverflow(legendHeight){const legend=this,chart=this.chart,renderer=chart.renderer,options=this.options,optionsY=options.y,alignTop=options.verticalAlign==="top",padding=this.padding,maxHeight=options.maxHeight,navOptions=options.navigation,animation=Legend_pick(navOptions.animation,true),arrowSize=navOptions.arrowSize||12,pages=this.pages,allItems=this.allItems,clipToHeight=function(height){if(typeof height==="number"){clipRect.attr({height:height})}else if(clipRect){legend.clipRect=clipRect.destroy();legend.contentGroup.clip()}if(legend.contentGroup.div){legend.contentGroup.div.style.clip=height?"rect("+padding+"px,9999px,"+(padding+height)+"px,0)":"auto"}},addTracker=function(key){legend[key]=renderer.circle(0,0,arrowSize*1.3).translate(arrowSize/2,arrowSize/2).add(nav);if(!chart.styledMode){legend[key].attr("fill","rgba(0,0,0,0.0001)")}return legend[key]};let clipHeight,lastY,legendItem,spaceHeight=chart.spacingBox.height+(alignTop?-optionsY:optionsY)-padding,nav=this.nav,clipRect=this.clipRect;if(options.layout==="horizontal"&&options.verticalAlign!=="middle"&&!options.floating){spaceHeight/=2}if(maxHeight){spaceHeight=Math.min(spaceHeight,maxHeight)}pages.length=0;if(legendHeight&&spaceHeight>0&&legendHeight>spaceHeight&&navOptions.enabled!==false){this.clipHeight=clipHeight=Math.max(spaceHeight-20-this.titleHeight-padding,0);this.currentPage=Legend_pick(this.currentPage,1);this.fullHeight=legendHeight;allItems.forEach((item,i)=>{legendItem=item.legendItem||{};const y=legendItem.y||0,h=Math.round(legendItem.label.getBBox().height);let len=pages.length;if(!len||y-pages[len-1]>clipHeight&&(lastY||y)!==pages[len-1]){pages.push(lastY||y);len++}legendItem.pageIx=len-1;if(lastY){(allItems[i-1].legendItem||{}).pageIx=len-1}if(i===allItems.length-1&&y+h-pages[len-1]>clipHeight&&y>pages[len-1]){pages.push(y);legendItem.pageIx=len}if(y!==lastY){lastY=y}});if(!clipRect){clipRect=legend.clipRect=renderer.clipRect(0,padding-2,9999,0);legend.contentGroup.clip(clipRect)}clipToHeight(clipHeight);if(!nav){this.nav=nav=renderer.g().attr({zIndex:1}).add(this.group);this.up=renderer.symbol("triangle",0,0,arrowSize,arrowSize).add(nav);addTracker("upTracker").on("click",function(){legend.scroll(-1,animation)});this.pager=renderer.text("",15,10).addClass("highcharts-legend-navigation");if(!chart.styledMode&&navOptions.style){this.pager.css(navOptions.style)}this.pager.add(nav);this.down=renderer.symbol("triangle-down",0,0,arrowSize,arrowSize).add(nav);addTracker("downTracker").on("click",function(){legend.scroll(1,animation)})}legend.scroll(0);legendHeight=spaceHeight}else if(nav){clipToHeight();this.nav=nav.destroy();this.scrollGroup.attr({translateY:1});this.clipHeight=0}return legendHeight}scroll(scrollBy,animation){const chart=this.chart,pages=this.pages,pageCount=pages.length,clipHeight=this.clipHeight,navOptions=this.options.navigation,pager=this.pager,padding=this.padding;let currentPage=this.currentPage+scrollBy;if(currentPage>pageCount){currentPage=pageCount}if(currentPage>0){if(typeof animation!=="undefined"){Legend_setAnimation(animation,chart)}this.nav.attr({translateX:padding,translateY:clipHeight+this.padding+7+this.titleHeight,visibility:"inherit"});[this.up,this.upTracker].forEach(function(elem){elem.attr({class:currentPage===1?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"})});pager.attr({text:currentPage+"/"+pageCount});[this.down,this.downTracker].forEach(function(elem){elem.attr({x:18+this.pager.getBBox().width,class:currentPage===pageCount?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"})},this);if(!chart.styledMode){this.up.attr({fill:currentPage===1?navOptions.inactiveColor:navOptions.activeColor});this.upTracker.css({cursor:currentPage===1?"default":"pointer"});this.down.attr({fill:currentPage===pageCount?navOptions.inactiveColor:navOptions.activeColor});this.downTracker.css({cursor:currentPage===pageCount?"default":"pointer"})}this.scrollOffset=-pages[currentPage-1]+this.initialItemY;this.scrollGroup.animate({translateY:this.scrollOffset});this.currentPage=currentPage;this.positionCheckboxes();const animOptions=Legend_animObject(Legend_pick(animation,chart.renderer.globalAnimation,true));Legend_syncTimeout(()=>{Legend_fireEvent(this,"afterScroll",{currentPage:currentPage})},animOptions.duration)}}setItemEvents(item,legendLabel,useHTML){const legend=this,legendItem=item.legendItem||{},boxWrapper=legend.chart.renderer.boxWrapper,isPoint=item instanceof Series_Point,isSeries=item instanceof Series_Series,activeClass="highcharts-legend-"+(isPoint?"point":"series")+"-active",styledMode=legend.chart.styledMode,legendElements=useHTML?[legendLabel,legendItem.symbol]:[legendItem.group];const setOtherItemsState=state=>{legend.allItems.forEach(otherItem=>{if(item!==otherItem){[otherItem].concat(otherItem.linkedSeries||[]).forEach(otherItem=>{otherItem.setState(state,!isPoint)})}})};for(const element of legendElements){if(element){element.on("mouseover",function(){if(item.visible){setOtherItemsState("inactive")}item.setState("hover");if(item.visible){boxWrapper.addClass(activeClass)}if(!styledMode){legendLabel.css(legend.options.itemHoverStyle)}}).on("mouseout",function(){if(!legend.chart.styledMode){legendLabel.css(Legend_merge(item.visible?legend.itemStyle:legend.itemHiddenStyle))}setOtherItemsState("");boxWrapper.removeClass(activeClass);item.setState()}).on("click",function(event){const defaultItemClick=function(){if(item.setVisible){item.setVisible()}setOtherItemsState(item.visible?"inactive":"")};boxWrapper.removeClass(activeClass);Legend_fireEvent(legend,"itemClick",{browserEvent:event,legendItem:item},defaultItemClick);if(isPoint){item.firePointEvent("legendItemClick",{browserEvent:event})}else if(isSeries){Legend_fireEvent(item,"legendItemClick",{browserEvent:event})}})}}}createCheckboxForItem(item){const legend=this;item.checkbox=Legend_createElement("input",{type:"checkbox",className:"highcharts-legend-checkbox",checked:item.selected,defaultChecked:item.selected},legend.options.itemCheckboxStyle,legend.chart.container);Legend_addEvent(item.checkbox,"click",function(event){const target=event.target;Legend_fireEvent(item.series||item,"checkboxClick",{checked:target.checked,item:item},function(){item.select()})})}}(function(Legend){function compose(ChartClass){if(Legend_pushUnique(Legend_composed,"Core.Legend")){Legend_addEvent(ChartClass,"beforeMargins",function(){this.legend=new Legend(this,this.options.legend)})}}Legend.compose=compose})(Legend||(Legend={}));const Legend_Legend=Legend;"";const{animate:Chart_animate,animObject:Chart_animObject,setAnimation:Chart_setAnimation}=AnimationUtilities;const{defaultOptions:Chart_defaultOptions}=Defaults;const{numberFormat:Chart_numberFormat}=Core_Templating;const{registerEventOptions:Chart_registerEventOptions}=Core_Foundation;const{charts:Chart_charts,doc:Chart_doc,marginNames:Chart_marginNames,svg:Chart_svg,win:Chart_win}=Core_Globals;const{seriesTypes:Chart_seriesTypes}=Series_SeriesRegistry;const{addEvent:Chart_addEvent,attr:Chart_attr,createElement:Chart_createElement,css:Chart_css,defined:Chart_defined,diffObjects:Chart_diffObjects,discardElement:Chart_discardElement,erase:Chart_erase,error:Chart_error,extend:Chart_extend,find:Chart_find,fireEvent:Chart_fireEvent,getAlignFactor:Chart_getAlignFactor,getStyle:Chart_getStyle,isArray:Chart_isArray,isNumber:Chart_isNumber,isObject:Chart_isObject,isString:Chart_isString,merge:Chart_merge,objectEach:Chart_objectEach,pick:Chart_pick,pInt:Chart_pInt,relativeLength:Chart_relativeLength,removeEvent:Chart_removeEvent,splat:Chart_splat,syncTimeout:Chart_syncTimeout,uniqueKey:Chart_uniqueKey}=Core_Utilities;class Chart{static chart(a,b,c){return new Chart(a,b,c)}constructor(a,b,c){this.sharedClips={};const args=[...arguments];if(Chart_isString(a)||a.nodeName){this.renderTo=args.shift()}this.init(args[0],args[1])}setZoomOptions(){const chart=this,options=chart.options.chart,zooming=options.zooming;chart.zooming={...zooming,type:Chart_pick(options.zoomType,zooming.type),key:Chart_pick(options.zoomKey,zooming.key),pinchType:Chart_pick(options.pinchType,zooming.pinchType),singleTouch:Chart_pick(options.zoomBySingleTouch,zooming.singleTouch,false),resetButton:Chart_merge(zooming.resetButton,options.resetZoomButton)}}init(userOptions,callback){Chart_fireEvent(this,"init",{args:arguments},function(){const options=Chart_merge(Chart_defaultOptions,userOptions),optionsChart=options.chart,renderTo=this.renderTo||optionsChart.renderTo;this.userOptions=Chart_extend({},userOptions);if(!(this.renderTo=Chart_isString(renderTo)?Chart_doc.getElementById(renderTo):renderTo)){Chart_error(13,true,this)}this.margin=[];this.spacing=[];this.labelCollectors=[];this.callback=callback;this.isResizing=0;this.options=options;this.axes=[];this.series=[];this.locale=options.lang.locale??this.renderTo.closest("[lang]")?.lang;this.time=new Core_Time(Chart_extend(options.time||{},{locale:this.locale}));options.time=this.time.options;this.numberFormatter=(optionsChart.numberFormatter||Chart_numberFormat).bind(this);this.styledMode=optionsChart.styledMode;this.hasCartesianSeries=optionsChart.showAxes;const chart=this;chart.index=Chart_charts.length;Chart_charts.push(chart);Core_Globals.chartCount++;Chart_registerEventOptions(this,optionsChart);chart.xAxis=[];chart.yAxis=[];chart.pointCount=chart.colorCounter=chart.symbolCounter=0;this.setZoomOptions();Chart_fireEvent(chart,"afterInit");chart.firstRender()})}initSeries(options){const chart=this,optionsChart=chart.options.chart,type=options.type||optionsChart.type,SeriesClass=Chart_seriesTypes[type];if(!SeriesClass){Chart_error(17,true,chart,{missingModuleFor:type})}const series=new SeriesClass;if(typeof series.init==="function"){series.init(chart,options)}return series}setSortedData(){this.getSeriesOrderByLinks().forEach(function(series){if(!series.points&&!series.data&&series.enabledDataSorting){series.setData(series.options.data,false)}})}getSeriesOrderByLinks(){return this.series.concat().sort(function(a,b){if(a.linkedSeries.length||b.linkedSeries.length){return b.linkedSeries.length-a.linkedSeries.length}return 0})}orderItems(coll,fromIndex=0){const collection=this[coll],optionsArray=this.options[coll]=Chart_splat(this.options[coll]).slice(),userOptionsArray=this.userOptions[coll]=this.userOptions[coll]?Chart_splat(this.userOptions[coll]).slice():[];if(this.hasRendered){optionsArray.splice(fromIndex);userOptionsArray.splice(fromIndex)}if(collection){for(let i=fromIndex,iEnd=collection.length;i<iEnd;++i){const item=collection[i];if(item){item.index=i;if(item instanceof Series_Series){item.name=item.getName()}if(!item.options.isInternal){optionsArray[i]=item.options;userOptionsArray[i]=item.userOptions}}}}}isInsidePlot(plotX,plotY,options={}){const{inverted,plotBox,plotLeft,plotTop,scrollablePlotBox}=this,{scrollLeft=0,scrollTop=0}=options.visiblePlotOnly&&this.scrollablePlotArea?.scrollingContainer||{},series=options.series,box=options.visiblePlotOnly&&scrollablePlotBox||plotBox,x=options.inverted?plotY:plotX,y=options.inverted?plotX:plotY,e={x:x,y:y,isInsidePlot:true,options:options};if(!options.ignoreX){const xAxis=series&&(inverted&&!this.polar?series.yAxis:series.xAxis)||{pos:plotLeft,len:Infinity};const chartX=options.paneCoordinates?xAxis.pos+x:plotLeft+x;if(!(chartX>=Math.max(scrollLeft+plotLeft,xAxis.pos)&&chartX<=Math.min(scrollLeft+plotLeft+box.width,xAxis.pos+xAxis.len))){e.isInsidePlot=false}}if(!options.ignoreY&&e.isInsidePlot){const yAxis=!inverted&&options.axis&&!options.axis.isXAxis&&options.axis||series&&(inverted?series.xAxis:series.yAxis)||{pos:plotTop,len:Infinity};const chartY=options.paneCoordinates?yAxis.pos+y:plotTop+y;if(!(chartY>=Math.max(scrollTop+plotTop,yAxis.pos)&&chartY<=Math.min(scrollTop+plotTop+box.height,yAxis.pos+yAxis.len))){e.isInsidePlot=false}}Chart_fireEvent(this,"afterIsInsidePlot",e);return e.isInsidePlot}redraw(animation){Chart_fireEvent(this,"beforeRedraw");const chart=this,axes=chart.hasCartesianSeries?chart.axes:chart.colorAxis||[],series=chart.series,pointer=chart.pointer,legend=chart.legend,legendUserOptions=chart.userOptions.legend,renderer=chart.renderer,isHiddenChart=renderer.isHidden(),afterRedraw=[];let hasDirtyStacks,hasStackedSeries,i,isDirtyBox=chart.isDirtyBox,redrawLegend=chart.isDirtyLegend,serie;renderer.rootFontSize=renderer.boxWrapper.getStyle("font-size");if(chart.setResponsive){chart.setResponsive(false)}Chart_setAnimation(chart.hasRendered?animation:false,chart);if(isHiddenChart){chart.temporaryDisplay()}chart.layOutTitles(false);i=series.length;while(i--){serie=series[i];if(serie.options.stacking||serie.options.centerInCategory){hasStackedSeries=true;if(serie.isDirty){hasDirtyStacks=true;break}}}if(hasDirtyStacks){i=series.length;while(i--){serie=series[i];if(serie.options.stacking){serie.isDirty=true}}}series.forEach(function(serie){if(serie.isDirty){if(serie.options.legendType==="point"){if(typeof serie.updateTotals==="function"){serie.updateTotals()}redrawLegend=true}else if(legendUserOptions&&(!!legendUserOptions.labelFormatter||legendUserOptions.labelFormat)){redrawLegend=true}}if(serie.isDirtyData){Chart_fireEvent(serie,"updatedData")}});if(redrawLegend&&legend&&legend.options.enabled){legend.render();chart.isDirtyLegend=false}if(hasStackedSeries){chart.getStacks()}axes.forEach(function(axis){axis.updateNames();axis.setScale()});chart.getMargins();axes.forEach(function(axis){if(axis.isDirty){isDirtyBox=true}});axes.forEach(function(axis){const key=axis.min+","+axis.max;if(axis.extKey!==key){axis.extKey=key;afterRedraw.push(function(){Chart_fireEvent(axis,"afterSetExtremes",Chart_extend(axis.eventArgs,axis.getExtremes()));delete axis.eventArgs})}if(isDirtyBox||hasStackedSeries){axis.redraw()}});if(isDirtyBox){chart.drawChartBox()}Chart_fireEvent(chart,"predraw");series.forEach(function(serie){if((isDirtyBox||serie.isDirty)&&serie.visible){serie.redraw()}serie.isDirtyData=false});if(pointer){pointer.reset(true)}renderer.draw();Chart_fireEvent(chart,"redraw");Chart_fireEvent(chart,"render");if(isHiddenChart){chart.temporaryDisplay(true)}afterRedraw.forEach(function(callback){callback.call()})}get(id){const series=this.series;function itemById(item){return item.id===id||item.options&&item.options.id===id}let ret=Chart_find(this.axes,itemById)||Chart_find(this.series,itemById);for(let i=0;!ret&&i<series.length;i++){ret=Chart_find(series[i].points||[],itemById)}return ret}createAxes(){const options=this.userOptions;Chart_fireEvent(this,"createAxes");for(const coll of["xAxis","yAxis"]){const arr=options[coll]=Chart_splat(options[coll]||{});for(const axisOptions of arr){new Axis_Axis(this,axisOptions,coll)}}Chart_fireEvent(this,"afterCreateAxes")}getSelectedPoints(){return this.series.reduce((acc,series)=>{series.getPointsCollection().forEach(point=>{if(Chart_pick(point.selectedStaging,point.selected)){acc.push(point)}});return acc},[])}getSelectedSeries(){return this.series.filter(s=>s.selected)}setTitle(titleOptions,subtitleOptions,redraw){this.applyDescription("title",titleOptions);this.applyDescription("subtitle",subtitleOptions);this.applyDescription("caption",void 0);this.layOutTitles(redraw)}applyDescription(key,explicitOptions){const chart=this;const options=this.options[key]=Chart_merge(this.options[key],explicitOptions);let elem=this[key];if(elem&&explicitOptions){this[key]=elem=elem.destroy()}if(options&&!elem){elem=this.renderer.text(options.text,0,0,options.useHTML).attr({align:options.align,class:"highcharts-"+key,zIndex:options.zIndex||4}).css({textOverflow:"ellipsis",whiteSpace:"nowrap"}).add();elem.update=function(updateOptions,redraw){chart.applyDescription(key,updateOptions);chart.layOutTitles(redraw)};if(!this.styledMode){elem.css(Chart_extend(key==="title"?{fontSize:this.options.isStock?"1em":"1.2em"}:{},options.style))}elem.textPxLength=elem.getBBox().width;elem.css({whiteSpace:options.style?.whiteSpace});this[key]=elem}}layOutTitles(redraw=true){const titleOffset=[0,0,0],{options,renderer,spacingBox}=this;["title","subtitle","caption"].forEach(key=>{const desc=this[key],descOptions=this.options[key],alignTo=Chart_merge(spacingBox),textPxLength=desc?.textPxLength||0;if(desc&&descOptions){Chart_fireEvent(this,"layOutTitle",{alignTo:alignTo,key:key,textPxLength:textPxLength});const fontMetrics=renderer.fontMetrics(desc),baseline=fontMetrics.b,lineHeight=fontMetrics.h,verticalAlign=descOptions.verticalAlign||"top",topAligned=verticalAlign==="top",minScale=topAligned&&descOptions.minScale||1,offset=key==="title"?topAligned?-3:0:topAligned?titleOffset[0]+2:0,uncappedScale=Math.min(alignTo.width/textPxLength,1),scale=Math.max(minScale,uncappedScale),alignAttr=Chart_merge({y:verticalAlign==="bottom"?baseline:offset+baseline},{align:key==="title"?uncappedScale<minScale?"left":"center":this.title?.alignValue},descOptions),width=descOptions.width||(uncappedScale>minScale?this.chartWidth:alignTo.width)/scale;if(desc.alignValue!==alignAttr.align){desc.placed=false}const height=Math.round(desc.css({width:`${width}px`}).getBBox(descOptions.useHTML).height);alignAttr.height=height;desc.align(alignAttr,false,alignTo).attr({align:alignAttr.align,scaleX:scale,scaleY:scale,"transform-origin":`${alignTo.x+textPxLength*scale*Chart_getAlignFactor(alignAttr.align)} ${lineHeight}`});if(!descOptions.floating){const offset=height*(height<lineHeight*1.2?1:scale);if(verticalAlign==="top"){titleOffset[0]=Math.ceil(titleOffset[0]+offset)}else if(verticalAlign==="bottom"){titleOffset[2]=Math.ceil(titleOffset[2]+offset)}}}},this);if(titleOffset[0]&&(options.title?.verticalAlign||"top")==="top"){titleOffset[0]+=options.title?.margin||0}if(titleOffset[2]&&options.caption?.verticalAlign==="bottom"){titleOffset[2]+=options.caption?.margin||0}const requiresDirtyBox=!this.titleOffset||this.titleOffset.join(",")!==titleOffset.join(",");this.titleOffset=titleOffset;Chart_fireEvent(this,"afterLayOutTitles");if(!this.isDirtyBox&&requiresDirtyBox){this.isDirtyBox=this.isDirtyLegend=requiresDirtyBox;if(this.hasRendered&&redraw&&this.isDirtyBox){this.redraw()}}}getContainerBox(){const nonContainers=[].map.call(this.renderTo.children,child=>{if(child!==this.container){const display=child.style.display;child.style.display="none";return[child,display]}}),box={width:Chart_getStyle(this.renderTo,"width",true)||0,height:Chart_getStyle(this.renderTo,"height",true)||0};nonContainers.filter(Boolean).forEach(([div,display])=>{div.style.display=display});return box}getChartSize(){const chart=this,optionsChart=chart.options.chart,widthOption=optionsChart.width,heightOption=optionsChart.height,containerBox=chart.getContainerBox(),enableDefaultHeight=containerBox.height<=1||!chart.renderTo.parentElement?.style.height&&chart.renderTo.style.height==="100%";chart.chartWidth=Math.max(0,widthOption||containerBox.width||600);chart.chartHeight=Math.max(0,Chart_relativeLength(heightOption,chart.chartWidth)||(enableDefaultHeight?400:containerBox.height));chart.containerBox=containerBox}temporaryDisplay(revert){let node=this.renderTo,tempStyle;if(!revert){while(node&&node.style){if(!Chart_doc.body.contains(node)&&!node.parentNode){node.hcOrigDetached=true;Chart_doc.body.appendChild(node)}if(Chart_getStyle(node,"display",false)==="none"||node.hcOricDetached){node.hcOrigStyle={display:node.style.display,height:node.style.height,overflow:node.style.overflow};tempStyle={display:"block",overflow:"hidden"};if(node!==this.renderTo){tempStyle.height=0}Chart_css(node,tempStyle);if(!node.offsetWidth){node.style.setProperty("display","block","important")}}node=node.parentNode;if(node===Chart_doc.body){break}}}else{while(node&&node.style){if(node.hcOrigStyle){Chart_css(node,node.hcOrigStyle);delete node.hcOrigStyle}if(node.hcOrigDetached){Chart_doc.body.removeChild(node);node.hcOrigDetached=false}node=node.parentNode}}}setClassName(className){this.container.className="highcharts-container "+(className||"")}getContainer(){const chart=this,options=chart.options,optionsChart=options.chart,indexAttrName="data-highcharts-chart",containerId=Chart_uniqueKey(),renderTo=chart.renderTo;let containerStyle;const oldChartIndex=Chart_pInt(Chart_attr(renderTo,indexAttrName));if(Chart_isNumber(oldChartIndex)&&Chart_charts[oldChartIndex]&&Chart_charts[oldChartIndex].hasRendered){Chart_charts[oldChartIndex].destroy()}Chart_attr(renderTo,indexAttrName,chart.index);renderTo.innerHTML=HTML_AST.emptyHTML;if(!optionsChart.skipClone&&!renderTo.offsetWidth){chart.temporaryDisplay()}chart.getChartSize();const chartHeight=chart.chartHeight;let chartWidth=chart.chartWidth;Chart_css(renderTo,{overflow:"hidden"});if(!chart.styledMode){containerStyle=Chart_extend({position:"relative",overflow:"hidden",width:chartWidth+"px",height:chartHeight+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)",userSelect:"none","touch-action":"manipulation",outline:"none",padding:"0px"},optionsChart.style||{})}const container=Chart_createElement("div",{id:containerId},containerStyle,renderTo);chart.container=container;chart.getChartSize();if(chartWidth!==chart.chartWidth){chartWidth=chart.chartWidth;if(!chart.styledMode){Chart_css(container,{width:Chart_pick(optionsChart.style?.width,chartWidth+"px")})}}chart.containerBox=chart.getContainerBox();chart._cursor=container.style.cursor;const Renderer=optionsChart.renderer||!Chart_svg?Renderer_RendererRegistry.getRendererType(optionsChart.renderer):SVG_SVGRenderer;chart.renderer=new Renderer(container,chartWidth,chartHeight,void 0,optionsChart.forExport,options.exporting&&options.exporting.allowHTML,chart.styledMode);Chart_setAnimation(void 0,chart);chart.setClassName(optionsChart.className);if(!chart.styledMode){chart.renderer.setStyle(optionsChart.style)}else{for(const key in options.defs){this.renderer.definition(options.defs[key])}}chart.renderer.chartIndex=chart.index;Chart_fireEvent(this,"afterGetContainer")}getMargins(skipAxes){const{spacing,margin,titleOffset}=this;this.resetMargins();if(titleOffset[0]&&!Chart_defined(margin[0])){this.plotTop=Math.max(this.plotTop,titleOffset[0]+spacing[0])}if(titleOffset[2]&&!Chart_defined(margin[2])){this.marginBottom=Math.max(this.marginBottom,titleOffset[2]+spacing[2])}if(this.legend&&this.legend.display){this.legend.adjustMargins(margin,spacing)}Chart_fireEvent(this,"getMargins");if(!skipAxes){this.getAxisMargins()}}getAxisMargins(){const chart=this,axisOffset=chart.axisOffset=[0,0,0,0],colorAxis=chart.colorAxis,margin=chart.margin,getOffset=function(axes){axes.forEach(function(axis){if(axis.visible){axis.getOffset()}})};if(chart.hasCartesianSeries){getOffset(chart.axes)}else if(colorAxis&&colorAxis.length){getOffset(colorAxis)}Chart_marginNames.forEach(function(m,side){if(!Chart_defined(margin[side])){chart[m]+=axisOffset[side]}});chart.setChartSize()}getOptions(){return Chart_diffObjects(this.userOptions,Chart_defaultOptions)}reflow(e){const chart=this,oldBox=chart.containerBox,containerBox=chart.getContainerBox();delete chart.pointer?.chartPosition;if(!chart.isPrinting&&!chart.isResizing&&oldBox&&containerBox.width){if(containerBox.width!==oldBox.width||containerBox.height!==oldBox.height){Core_Utilities.clearTimeout(chart.reflowTimeout);chart.reflowTimeout=Chart_syncTimeout(function(){if(chart.container){chart.setSize(void 0,void 0,false)}},e?100:0)}chart.containerBox=containerBox}}setReflow(){const chart=this;const runReflow=e=>{if(chart.options?.chart.reflow&&chart.hasLoaded){chart.reflow(e)}};if(typeof ResizeObserver==="function"){new ResizeObserver(runReflow).observe(chart.renderTo)}else{const unbind=Chart_addEvent(Chart_win,"resize",runReflow);Chart_addEvent(this,"destroy",unbind)}}setSize(width,height,animation){const chart=this,renderer=chart.renderer;chart.isResizing+=1;Chart_setAnimation(animation,chart);const globalAnimation=renderer.globalAnimation;chart.oldChartHeight=chart.chartHeight;chart.oldChartWidth=chart.chartWidth;if(typeof width!=="undefined"){chart.options.chart.width=width}if(typeof height!=="undefined"){chart.options.chart.height=height}chart.getChartSize();const{chartWidth,chartHeight,scrollablePixelsX=0,scrollablePixelsY=0}=chart;if(chart.isDirtyBox||chartWidth!==chart.oldChartWidth||chartHeight!==chart.oldChartHeight){if(!chart.styledMode){(globalAnimation?Chart_animate:Chart_css)(chart.container,{width:`${chartWidth+scrollablePixelsX}px`,height:`${chartHeight+scrollablePixelsY}px`},globalAnimation)}chart.setChartSize(true);renderer.setSize(chartWidth,chartHeight,globalAnimation);chart.axes.forEach(function(axis){axis.isDirty=true;axis.setScale()});chart.isDirtyLegend=true;chart.isDirtyBox=true;chart.layOutTitles();chart.getMargins();chart.redraw(globalAnimation);chart.oldChartHeight=void 0;Chart_fireEvent(chart,"resize");setTimeout(()=>{if(chart){Chart_fireEvent(chart,"endResize")}},Chart_animObject(globalAnimation).duration)}chart.isResizing-=1}setChartSize(skipAxes){const chart=this,{chartHeight,chartWidth,inverted,spacing,renderer}=chart,clipOffset=chart.clipOffset,clipRoundFunc=Math[inverted?"floor":"round"];let plotLeft,plotTop,plotWidth,plotHeight;chart.plotLeft=plotLeft=Math.round(chart.plotLeft);chart.plotTop=plotTop=Math.round(chart.plotTop);chart.plotWidth=plotWidth=Math.max(0,Math.round(chartWidth-plotLeft-chart.marginRight));chart.plotHeight=plotHeight=Math.max(0,Math.round(chartHeight-plotTop-chart.marginBottom));chart.plotSizeX=inverted?plotHeight:plotWidth;chart.plotSizeY=inverted?plotWidth:plotHeight;chart.spacingBox=renderer.spacingBox={x:spacing[3],y:spacing[0],width:chartWidth-spacing[3]-spacing[1],height:chartHeight-spacing[0]-spacing[2]};chart.plotBox=renderer.plotBox={x:plotLeft,y:plotTop,width:plotWidth,height:plotHeight};if(clipOffset){chart.clipBox={x:clipRoundFunc(clipOffset[3]),y:clipRoundFunc(clipOffset[0]),width:clipRoundFunc(chart.plotSizeX-clipOffset[1]-clipOffset[3]),height:clipRoundFunc(chart.plotSizeY-clipOffset[0]-clipOffset[2])}}if(!skipAxes){chart.axes.forEach(function(axis){axis.setAxisSize();axis.setAxisTranslation()});renderer.alignElements()}Chart_fireEvent(chart,"afterSetChartSize",{skipAxes:skipAxes})}resetMargins(){Chart_fireEvent(this,"resetMargins");const chart=this,chartOptions=chart.options.chart,plotBorderWidth=chartOptions.plotBorderWidth||0,halfWidth=plotBorderWidth/2;["margin","spacing"].forEach(function splashArrays(target){const value=chartOptions[target],values=Chart_isObject(value)?value:[value,value,value,value];["Top","Right","Bottom","Left"].forEach(function(sideName,side){chart[target][side]=Chart_pick(chartOptions[target+sideName],values[side])})});Chart_marginNames.forEach(function(m,side){chart[m]=Chart_pick(chart.margin[side],chart.spacing[side])});chart.axisOffset=[0,0,0,0];chart.clipOffset=[halfWidth,halfWidth,halfWidth,halfWidth];chart.plotBorderWidth=plotBorderWidth}drawChartBox(){const chart=this,optionsChart=chart.options.chart,renderer=chart.renderer,chartWidth=chart.chartWidth,chartHeight=chart.chartHeight,styledMode=chart.styledMode,plotBGImage=chart.plotBGImage,chartBackgroundColor=optionsChart.backgroundColor,plotBackgroundColor=optionsChart.plotBackgroundColor,plotBackgroundImage=optionsChart.plotBackgroundImage,plotLeft=chart.plotLeft,plotTop=chart.plotTop,plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,plotBox=chart.plotBox,clipRect=chart.clipRect,clipBox=chart.clipBox;let chartBackground=chart.chartBackground,plotBackground=chart.plotBackground,plotBorder=chart.plotBorder,chartBorderWidth,mgn,bgAttr,verb="animate";if(!chartBackground){chart.chartBackground=chartBackground=renderer.rect().addClass("highcharts-background").add();verb="attr"}if(!styledMode){chartBorderWidth=optionsChart.borderWidth||0;mgn=chartBorderWidth+(optionsChart.shadow?8:0);bgAttr={fill:chartBackgroundColor||"none"};if(chartBorderWidth||chartBackground["stroke-width"]){bgAttr.stroke=optionsChart.borderColor;bgAttr["stroke-width"]=chartBorderWidth}chartBackground.attr(bgAttr).shadow(optionsChart.shadow)}else{chartBorderWidth=mgn=chartBackground.strokeWidth()}chartBackground[verb]({x:mgn/2,y:mgn/2,width:chartWidth-mgn-chartBorderWidth%2,height:chartHeight-mgn-chartBorderWidth%2,r:optionsChart.borderRadius});verb="animate";if(!plotBackground){verb="attr";chart.plotBackground=plotBackground=renderer.rect().addClass("highcharts-plot-background").add()}plotBackground[verb](plotBox);if(!styledMode){plotBackground.attr({fill:plotBackgroundColor||"none"}).shadow(optionsChart.plotShadow);if(plotBackgroundImage){if(!plotBGImage){chart.plotBGImage=renderer.image(plotBackgroundImage,plotLeft,plotTop,plotWidth,plotHeight).add()}else{if(plotBackgroundImage!==plotBGImage.attr("href")){plotBGImage.attr("href",plotBackgroundImage)}plotBGImage.animate(plotBox)}}}if(!clipRect){chart.clipRect=renderer.clipRect(clipBox)}else{clipRect.animate({width:clipBox.width,height:clipBox.height})}verb="animate";if(!plotBorder){verb="attr";chart.plotBorder=plotBorder=renderer.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add()}if(!styledMode){plotBorder.attr({stroke:optionsChart.plotBorderColor,"stroke-width":optionsChart.plotBorderWidth||0,fill:"none"})}plotBorder[verb](plotBorder.crisp({x:plotLeft,y:plotTop,width:plotWidth,height:plotHeight},-plotBorder.strokeWidth()));chart.isDirtyBox=false;Chart_fireEvent(this,"afterDrawChartBox")}propFromSeries(){const chart=this,optionsChart=chart.options.chart,seriesOptions=chart.options.series;let i,klass,value;["inverted","angular","polar"].forEach(function(key){klass=Chart_seriesTypes[optionsChart.type];value=optionsChart[key]||klass&&klass.prototype[key];i=seriesOptions&&seriesOptions.length;while(!value&&i--){klass=Chart_seriesTypes[seriesOptions[i].type];if(klass&&klass.prototype[key]){value=true}}chart[key]=value})}linkSeries(isUpdating){const chart=this,chartSeries=chart.series;chartSeries.forEach(function(series){series.linkedSeries.length=0});chartSeries.forEach(function(series){const{linkedTo}=series.options;if(Chart_isString(linkedTo)){let linkedParent;if(linkedTo===":previous"){linkedParent=chart.series[series.index-1]}else{linkedParent=chart.get(linkedTo)}if(linkedParent&&linkedParent.linkedParent!==series){linkedParent.linkedSeries.push(series);series.linkedParent=linkedParent;if(linkedParent.enabledDataSorting){series.setDataSortingOptions()}series.visible=Chart_pick(series.options.visible,linkedParent.options.visible,series.visible)}}});Chart_fireEvent(this,"afterLinkSeries",{isUpdating:isUpdating})}renderSeries(){this.series.forEach(function(serie){serie.translate();serie.render()})}render(){const chart=this,axes=chart.axes,colorAxis=chart.colorAxis,renderer=chart.renderer,axisLayoutRuns=chart.options.chart.axisLayoutRuns||2,renderAxes=axes=>{axes.forEach(axis=>{if(axis.visible){axis.render()}})};let expectedSpace=0,redoHorizontal=true,redoVertical,run=0;chart.setTitle();Chart_fireEvent(chart,"beforeMargins");chart.getStacks?.();chart.getMargins(true);chart.setChartSize();for(const axis of axes){const{options}=axis,{labels}=options;if(chart.hasCartesianSeries&&axis.horiz&&axis.visible&&labels.enabled&&axis.series.length&&axis.coll!=="colorAxis"&&!chart.polar){expectedSpace=options.tickLength;axis.createGroups();const mockTick=new Axis_Tick(axis,0,"",true),label=mockTick.createLabel("x",labels);mockTick.destroy();if(label&&Chart_pick(labels.reserveSpace,!Chart_isNumber(options.crossing))){expectedSpace=label.getBBox().height+labels.distance+Math.max(options.offset||0,0)}if(expectedSpace){label?.destroy();break}}}chart.plotHeight=Math.max(chart.plotHeight-expectedSpace,0);while((redoHorizontal||redoVertical||axisLayoutRuns>1)&&run<axisLayoutRuns){const tempWidth=chart.plotWidth,tempHeight=chart.plotHeight;for(const axis of axes){if(run===0){axis.setScale()}else if(axis.horiz&&redoHorizontal||!axis.horiz&&redoVertical){axis.setTickInterval(true)}}if(run===0){chart.getAxisMargins()}else{chart.getMargins()}redoHorizontal=tempWidth/chart.plotWidth>(run?1:1.1);redoVertical=tempHeight/chart.plotHeight>(run?1:1.05);run++}chart.drawChartBox();if(chart.hasCartesianSeries){renderAxes(axes)}else if(colorAxis&&colorAxis.length){renderAxes(colorAxis)}if(!chart.seriesGroup){chart.seriesGroup=renderer.g("series-group").attr({zIndex:3}).shadow(chart.options.chart.seriesGroupShadow).add()}chart.renderSeries();chart.addCredits();if(chart.setResponsive){chart.setResponsive()}chart.hasRendered=true}addCredits(credits){const chart=this,creds=Chart_merge(true,this.options.credits,credits);if(creds.enabled&&!this.credits){this.credits=this.renderer.text(creds.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){if(creds.href){Chart_win.location.href=creds.href}}).attr({align:creds.position.align,zIndex:8});if(!chart.styledMode){this.credits.css(creds.style)}this.credits.add().align(creds.position);this.credits.update=function(options){chart.credits=chart.credits.destroy();chart.addCredits(options)}}}destroy(){const chart=this,axes=chart.axes,series=chart.series,container=chart.container,parentNode=container&&container.parentNode;let i;Chart_fireEvent(chart,"destroy");if(chart.renderer.forExport){Chart_erase(Chart_charts,chart)}else{Chart_charts[chart.index]=void 0}Core_Globals.chartCount--;chart.renderTo.removeAttribute("data-highcharts-chart");Chart_removeEvent(chart);i=axes.length;while(i--){axes[i]=axes[i].destroy()}if(this.scroller&&this.scroller.destroy){this.scroller.destroy()}i=series.length;while(i--){series[i]=series[i].destroy()}["title","subtitle","chartBackground","plotBackground","plotBGImage","plotBorder","seriesGroup","clipRect","credits","pointer","rangeSelector","legend","resetZoomButton","tooltip","renderer"].forEach(function(name){const prop=chart[name];if(prop&&prop.destroy){chart[name]=prop.destroy()}});if(container){container.innerHTML=HTML_AST.emptyHTML;Chart_removeEvent(container);if(parentNode){Chart_discardElement(container)}}Chart_objectEach(chart,function(val,key){delete chart[key]})}firstRender(){const chart=this,options=chart.options;chart.getContainer();chart.resetMargins();chart.setChartSize();chart.propFromSeries();chart.createAxes();const series=Chart_isArray(options.series)?options.series:[];options.series=[];series.forEach(function(serieOptions){chart.initSeries(serieOptions)});chart.linkSeries();chart.setSortedData();Chart_fireEvent(chart,"beforeRender");chart.render();chart.pointer?.getChartPosition();if(!chart.renderer.imgCount&&!chart.hasLoaded){chart.onload()}chart.temporaryDisplay(true)}onload(){this.callbacks.concat([this.callback]).forEach(function(fn){if(fn&&typeof this.index!=="undefined"){fn.apply(this,[this])}},this);Chart_fireEvent(this,"load");Chart_fireEvent(this,"render");if(Chart_defined(this.index)){this.setReflow()}this.warnIfA11yModuleNotLoaded();this.hasLoaded=true}warnIfA11yModuleNotLoaded(){const{options,title}=this;if(options&&!this.accessibility){this.renderer.boxWrapper.attr({role:"img","aria-label":(title&&title.element.textContent||"").replace(/</g,"&lt;")});if(!(options.accessibility&&options.accessibility.enabled===false)){Chart_error("Highcharts warning: Consider including the "+'"accessibility.js" module to make your chart more '+"usable for people with disabilities. Set the "+'"accessibility.enabled" option to false to remove this '+"warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.",false,this)}}}addSeries(options,redraw,animation){const chart=this;let series;if(options){redraw=Chart_pick(redraw,true);Chart_fireEvent(chart,"addSeries",{options:options},function(){series=chart.initSeries(options);chart.isDirtyLegend=true;chart.linkSeries();if(series.enabledDataSorting){series.setData(options.data,false)}Chart_fireEvent(chart,"afterAddSeries",{series:series});if(redraw){chart.redraw(animation)}})}return series}addAxis(options,isX,redraw,animation){return this.createAxis(isX?"xAxis":"yAxis",{axis:options,redraw:redraw,animation:animation})}addColorAxis(options,redraw,animation){return this.createAxis("colorAxis",{axis:options,redraw:redraw,animation:animation})}createAxis(coll,options){const axis=new Axis_Axis(this,options.axis,coll);if(Chart_pick(options.redraw,true)){this.redraw(options.animation)}return axis}showLoading(str){const chart=this,options=chart.options,loadingOptions=options.loading,setLoadingSize=function(){if(loadingDiv){Chart_css(loadingDiv,{left:chart.plotLeft+"px",top:chart.plotTop+"px",width:chart.plotWidth+"px",height:chart.plotHeight+"px"})}};let loadingDiv=chart.loadingDiv,loadingSpan=chart.loadingSpan;if(!loadingDiv){chart.loadingDiv=loadingDiv=Chart_createElement("div",{className:"highcharts-loading highcharts-loading-hidden"},null,chart.container)}if(!loadingSpan){chart.loadingSpan=loadingSpan=Chart_createElement("span",{className:"highcharts-loading-inner"},null,loadingDiv);Chart_addEvent(chart,"redraw",setLoadingSize)}loadingDiv.className="highcharts-loading";HTML_AST.setElementHTML(loadingSpan,Chart_pick(str,options.lang.loading,""));if(!chart.styledMode){Chart_css(loadingDiv,Chart_extend(loadingOptions.style,{zIndex:10}));Chart_css(loadingSpan,loadingOptions.labelStyle);if(!chart.loadingShown){Chart_css(loadingDiv,{opacity:0,display:""});Chart_animate(loadingDiv,{opacity:loadingOptions.style.opacity||.5},{duration:loadingOptions.showDuration||0})}}chart.loadingShown=true;setLoadingSize()}hideLoading(){const options=this.options,loadingDiv=this.loadingDiv;if(loadingDiv){loadingDiv.className="highcharts-loading highcharts-loading-hidden";if(!this.styledMode){Chart_animate(loadingDiv,{opacity:0},{duration:options.loading.hideDuration||100,complete:function(){Chart_css(loadingDiv,{display:"none"})}})}}this.loadingShown=false}update(options,redraw,oneToOne,animation){const chart=this,adders={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"},isResponsiveOptions=options.isResponsiveOptions,itemsForRemoval=[];let updateAllAxes,updateAllSeries,runSetSize;Chart_fireEvent(chart,"update",{options:options});if(!isResponsiveOptions){chart.setResponsive(false,true)}options=Chart_diffObjects(options,chart.options);chart.userOptions=Chart_merge(chart.userOptions,options);const optionsChart=options.chart;if(optionsChart){Chart_merge(true,chart.options.chart,optionsChart);this.setZoomOptions();if("className"in optionsChart){chart.setClassName(optionsChart.className)}if("inverted"in optionsChart||"polar"in optionsChart||"type"in optionsChart){chart.propFromSeries();updateAllAxes=true}if("alignTicks"in optionsChart){updateAllAxes=true}if("events"in optionsChart){Chart_registerEventOptions(this,optionsChart)}Chart_objectEach(optionsChart,function(val,key){if(chart.propsRequireUpdateSeries.indexOf("chart."+key)!==-1){updateAllSeries=true}if(chart.propsRequireDirtyBox.indexOf(key)!==-1){chart.isDirtyBox=true}if(chart.propsRequireReflow.indexOf(key)!==-1){chart.isDirtyBox=true;if(!isResponsiveOptions){runSetSize=true}}});if(!chart.styledMode&&optionsChart.style){chart.renderer.setStyle(chart.options.chart.style||{})}}if(!chart.styledMode&&options.colors){this.options.colors=options.colors}Chart_objectEach(options,function(val,key){if(chart[key]&&typeof chart[key].update==="function"){chart[key].update(val,false)}else if(typeof chart[adders[key]]==="function"){chart[adders[key]](val)}else if(key!=="colors"&&chart.collectionsWithUpdate.indexOf(key)===-1){Chart_merge(true,chart.options[key],options[key])}if(key!=="chart"&&chart.propsRequireUpdateSeries.indexOf(key)!==-1){updateAllSeries=true}});this.collectionsWithUpdate.forEach(function(coll){if(options[coll]){Chart_splat(options[coll]).forEach(function(newOptions,i){const hasId=Chart_defined(newOptions.id);let item;if(hasId){item=chart.get(newOptions.id)}if(!item&&chart[coll]){item=chart[coll][Chart_pick(newOptions.index,i)];if(item&&(hasId&&Chart_defined(item.options.id)||item.options.isInternal)){item=void 0}}if(item&&item.coll===coll){item.update(newOptions,false);if(oneToOne){item.touched=true}}if(!item&&oneToOne&&chart.collectionsWithInit[coll]){chart.collectionsWithInit[coll][0].apply(chart,[newOptions].concat(chart.collectionsWithInit[coll][1]||[]).concat([false])).touched=true}});if(oneToOne){chart[coll].forEach(function(item){if(!item.touched&&!item.options.isInternal){itemsForRemoval.push(item)}else{delete item.touched}})}}});itemsForRemoval.forEach(function(item){if(item.chart&&item.remove){item.remove(false)}});if(updateAllAxes){chart.axes.forEach(function(axis){axis.update({},false)})}if(updateAllSeries){chart.getSeriesOrderByLinks().forEach(function(series){if(series.chart){series.update({},false)}},this)}const newWidth=optionsChart&&optionsChart.width;const newHeight=optionsChart&&(Chart_isString(optionsChart.height)?Chart_relativeLength(optionsChart.height,newWidth||chart.chartWidth):optionsChart.height);if(runSetSize||Chart_isNumber(newWidth)&&newWidth!==chart.chartWidth||Chart_isNumber(newHeight)&&newHeight!==chart.chartHeight){chart.setSize(newWidth,newHeight,animation)}else if(Chart_pick(redraw,true)){chart.redraw(animation)}Chart_fireEvent(chart,"afterUpdate",{options:options,redraw:redraw,animation:animation})}setSubtitle(options,redraw){this.applyDescription("subtitle",options);this.layOutTitles(redraw)}setCaption(options,redraw){this.applyDescription("caption",options);this.layOutTitles(redraw)}showResetZoom(){const chart=this,lang=Chart_defaultOptions.lang,btnOptions=chart.zooming.resetButton,theme=btnOptions.theme,alignTo=btnOptions.relativeTo==="chart"||btnOptions.relativeTo==="spacingBox"?null:"plotBox";function zoomOut(){chart.zoomOut()}Chart_fireEvent(this,"beforeShowResetZoom",null,function(){chart.resetZoomButton=chart.renderer.button(lang.resetZoom,null,null,zoomOut,theme).attr({align:btnOptions.position.align,title:lang.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(btnOptions.position,false,alignTo)});Chart_fireEvent(this,"afterShowResetZoom")}zoomOut(){Chart_fireEvent(this,"selection",{resetSelection:true},()=>this.transform({reset:true,trigger:"zoom"}))}pan(event,panning){const chart=this,panningOptions=typeof panning==="object"?panning:{enabled:panning,type:"x"},type=panningOptions.type,axes=type&&chart[{x:"xAxis",xy:"axes",y:"yAxis"}[type]].filter(axis=>axis.options.panningEnabled&&!axis.options.isInternal),chartOptions=chart.options.chart;if(chartOptions?.panning){chartOptions.panning=panningOptions}Chart_fireEvent(this,"pan",{originalEvent:event},()=>{chart.transform({axes:axes,event:event,to:{x:event.chartX-(chart.mouseDownX||0),y:event.chartY-(chart.mouseDownY||0)},trigger:"pan"});Chart_css(chart.container,{cursor:"move"})})}transform(params){const{axes=this.axes,event,from={},reset,selection,to={},trigger}=params,{inverted,time}=this;let hasZoomed=false,displayButton,isAnyAxisPanning;this.hoverPoints?.forEach(point=>point.setState());for(const axis of axes){const{horiz,len,minPointOffset=0,options,reversed}=axis,wh=horiz?"width":"height",xy=horiz?"x":"y",toLength=Chart_pick(to[wh],axis.len),fromLength=Chart_pick(from[wh],axis.len),scale=Math.abs(toLength)<10?1:toLength/fromLength,fromCenter=(from[xy]||0)+fromLength/2-axis.pos,toCenter=(to[xy]??axis.pos)+toLength/2-axis.pos,move=fromCenter-toCenter/scale,pointRangeDirection=reversed&&!inverted||!reversed&&inverted?-1:1,minPx=move;if(!reset&&(fromCenter<0||fromCenter>axis.len)){continue}let newMin=axis.toValue(minPx,true)+(selection||axis.isOrdinal?0:minPointOffset*pointRangeDirection),newMax=axis.toValue(minPx+len/scale,true)-(selection||axis.isOrdinal?0:minPointOffset*pointRangeDirection||0),allExtremes=axis.allExtremes;if(newMin>newMax){[newMin,newMax]=[newMax,newMin]}if(scale===1&&!reset&&axis.coll==="yAxis"&&!allExtremes){for(const series of axis.series){const seriesExtremes=series.getExtremes(series.getProcessedData(true).modified.getColumn("y")||[],true);allExtremes??(allExtremes={dataMin:Number.MAX_VALUE,dataMax:-Number.MAX_VALUE});if(Chart_isNumber(seriesExtremes.dataMin)&&Chart_isNumber(seriesExtremes.dataMax)){allExtremes.dataMin=Math.min(seriesExtremes.dataMin,allExtremes.dataMin);allExtremes.dataMax=Math.max(seriesExtremes.dataMax,allExtremes.dataMax)}}axis.allExtremes=allExtremes}const{dataMin,dataMax,min,max}=Chart_extend(axis.getExtremes(),allExtremes||{}),optionsMin=time.parse(options.min),optionsMax=time.parse(options.max),safeDataMin=dataMin??optionsMin,safeDataMax=dataMax??optionsMax,range=newMax-newMin,padRange=axis.categories?0:Math.min(range,safeDataMax-safeDataMin),paddedMin=safeDataMin-padRange*(Chart_defined(optionsMin)?0:options.minPadding),paddedMax=safeDataMax+padRange*(Chart_defined(optionsMax)?0:options.maxPadding),allowZoomOutside=axis.allowZoomOutside||scale===1||trigger!=="zoom"&&scale>1,floor=Math.min(optionsMin??paddedMin,paddedMin,allowZoomOutside?min:paddedMin),ceiling=Math.max(optionsMax??paddedMax,paddedMax,allowZoomOutside?max:paddedMax);if(!axis.isOrdinal||axis.options.overscroll||scale!==1||reset){if(newMin<floor){newMin=floor;if(scale>=1){newMax=newMin+range}}if(newMax>ceiling){newMax=ceiling;if(scale>=1){newMin=newMax-range}}if(reset||axis.series.length&&(newMin!==min||newMax!==max)&&newMin>=floor&&newMax<=ceiling){if(selection){selection[axis.coll].push({axis:axis,min:newMin,max:newMax})}else{axis.isPanning=trigger!=="zoom";if(axis.isPanning){isAnyAxisPanning=true}axis.setExtremes(reset?void 0:newMin,reset?void 0:newMax,false,false,{move:move,trigger:trigger,scale:scale});if(!reset&&(newMin>floor||newMax<ceiling)&&trigger!=="mousewheel"){displayButton=true}}hasZoomed=true}if(event){this[horiz?"mouseDownX":"mouseDownY"]=event[horiz?"chartX":"chartY"]}}}if(hasZoomed){if(selection){Chart_fireEvent(this,"selection",selection,()=>{delete params.selection;params.trigger="zoom";this.transform(params)})}else{if(displayButton&&!isAnyAxisPanning&&!this.resetZoomButton){this.showResetZoom()}else if(!displayButton&&this.resetZoomButton){this.resetZoomButton=this.resetZoomButton.destroy()}this.redraw(trigger==="zoom"&&(this.options.chart.animation??this.pointCount<100))}}return hasZoomed}}Chart_extend(Chart.prototype,{callbacks:[],collectionsWithInit:{xAxis:[Chart.prototype.addAxis,[true]],yAxis:[Chart.prototype.addAxis,[false]],series:[Chart.prototype.addSeries]},collectionsWithUpdate:["xAxis","yAxis","series"],propsRequireDirtyBox:["backgroundColor","borderColor","borderWidth","borderRadius","plotBackgroundColor","plotBackgroundImage","plotBorderColor","plotBorderWidth","plotShadow","shadow"],propsRequireReflow:["margin","marginTop","marginRight","marginBottom","marginLeft","spacing","spacingTop","spacingRight","spacingBottom","spacingLeft"],propsRequireUpdateSeries:["chart.inverted","chart.polar","chart.ignoreHiddenSeries","chart.type","colors","plotOptions","time","tooltip"]});const Chart_Chart=Chart;"";const{stop:ScrollablePlotArea_stop}=AnimationUtilities;const{composed:ScrollablePlotArea_composed}=Core_Globals;const{addEvent:ScrollablePlotArea_addEvent,createElement:ScrollablePlotArea_createElement,css:ScrollablePlotArea_css,defined:ScrollablePlotArea_defined,erase:ScrollablePlotArea_erase,merge:ScrollablePlotArea_merge,pushUnique:ScrollablePlotArea_pushUnique}=Core_Utilities;function onChartRender(){let scrollablePlotArea=this.scrollablePlotArea;if((this.scrollablePixelsX||this.scrollablePixelsY)&&!scrollablePlotArea){this.scrollablePlotArea=scrollablePlotArea=new ScrollablePlotArea(this)}scrollablePlotArea?.applyFixed()}function markDirty(){if(this.chart.scrollablePlotArea){this.chart.scrollablePlotArea.isDirty=true}}class ScrollablePlotArea{static compose(AxisClass,ChartClass,SeriesClass){if(ScrollablePlotArea_pushUnique(ScrollablePlotArea_composed,this.compose)){ScrollablePlotArea_addEvent(AxisClass,"afterInit",markDirty);ScrollablePlotArea_addEvent(ChartClass,"afterSetChartSize",e=>this.afterSetSize(e.target,e));ScrollablePlotArea_addEvent(ChartClass,"render",onChartRender);ScrollablePlotArea_addEvent(SeriesClass,"show",markDirty)}}static afterSetSize(chart,e){const{minWidth,minHeight}=chart.options.chart.scrollablePlotArea||{},{clipBox,plotBox,inverted,renderer}=chart;let scrollablePixelsX,scrollablePixelsY,recalculateHoriz;if(!renderer.forExport){if(minWidth){chart.scrollablePixelsX=scrollablePixelsX=Math.max(0,minWidth-chart.chartWidth);if(scrollablePixelsX){chart.scrollablePlotBox=ScrollablePlotArea_merge(chart.plotBox);plotBox.width=chart.plotWidth+=scrollablePixelsX;clipBox[inverted?"height":"width"]+=scrollablePixelsX;recalculateHoriz=true}}else if(minHeight){chart.scrollablePixelsY=scrollablePixelsY=Math.max(0,minHeight-chart.chartHeight);if(ScrollablePlotArea_defined(scrollablePixelsY)){chart.scrollablePlotBox=ScrollablePlotArea_merge(chart.plotBox);plotBox.height=chart.plotHeight+=scrollablePixelsY;clipBox[inverted?"width":"height"]+=scrollablePixelsY;recalculateHoriz=false}}if(ScrollablePlotArea_defined(recalculateHoriz)&&!e.skipAxes){for(const axis of chart.axes){if(axis.horiz===recalculateHoriz||chart.hasParallelCoordinates&&axis.coll==="yAxis"){axis.setAxisSize();axis.setAxisTranslation()}}}}}constructor(chart){const chartOptions=chart.options.chart,Renderer=Renderer_RendererRegistry.getRendererType(),scrollableOptions=chartOptions.scrollablePlotArea||{},moveFixedElements=this.moveFixedElements.bind(this),styles={WebkitOverflowScrolling:"touch",overflowX:"hidden",overflowY:"hidden"};if(chart.scrollablePixelsX){styles.overflowX="auto"}if(chart.scrollablePixelsY){styles.overflowY="auto"}this.chart=chart;const parentDiv=this.parentDiv=ScrollablePlotArea_createElement("div",{className:"highcharts-scrolling-parent"},{position:"relative"},chart.renderTo),scrollingContainer=this.scrollingContainer=ScrollablePlotArea_createElement("div",{className:"highcharts-scrolling"},styles,parentDiv),innerContainer=this.innerContainer=ScrollablePlotArea_createElement("div",{className:"highcharts-inner-container"},void 0,scrollingContainer),fixedDiv=this.fixedDiv=ScrollablePlotArea_createElement("div",{className:"highcharts-fixed"},{position:"absolute",overflow:"hidden",pointerEvents:"none",zIndex:(chartOptions.style?.zIndex||0)+2,top:0},void 0,true),fixedRenderer=this.fixedRenderer=new Renderer(fixedDiv,chart.chartWidth,chart.chartHeight,chartOptions.style);this.mask=fixedRenderer.path().attr({fill:chartOptions.backgroundColor||"#fff","fill-opacity":scrollableOptions.opacity??.85,zIndex:-1}).addClass("highcharts-scrollable-mask").add();scrollingContainer.parentNode.insertBefore(fixedDiv,scrollingContainer);ScrollablePlotArea_css(chart.renderTo,{overflow:"visible"});ScrollablePlotArea_addEvent(chart,"afterShowResetZoom",moveFixedElements);ScrollablePlotArea_addEvent(chart,"afterApplyDrilldown",moveFixedElements);ScrollablePlotArea_addEvent(chart,"afterLayOutTitles",moveFixedElements);let lastHoverPoint;ScrollablePlotArea_addEvent(scrollingContainer,"scroll",()=>{const{pointer,hoverPoint}=chart;if(pointer){delete pointer.chartPosition;if(hoverPoint){lastHoverPoint=hoverPoint}pointer.runPointActions(void 0,lastHoverPoint,true)}});innerContainer.appendChild(chart.container)}applyFixed(){const{chart,fixedRenderer,isDirty,scrollingContainer}=this,{axisOffset,chartWidth,chartHeight,container,plotHeight,plotLeft,plotTop,plotWidth,scrollablePixelsX=0,scrollablePixelsY=0}=chart,chartOptions=chart.options.chart,scrollableOptions=chartOptions.scrollablePlotArea||{},{scrollPositionX=0,scrollPositionY=0}=scrollableOptions,scrollableWidth=chartWidth+scrollablePixelsX,scrollableHeight=chartHeight+scrollablePixelsY;fixedRenderer.setSize(chartWidth,chartHeight);if(isDirty??true){this.isDirty=false;this.moveFixedElements()}ScrollablePlotArea_stop(chart.container);ScrollablePlotArea_css(container,{width:`${scrollableWidth}px`,height:`${scrollableHeight}px`});chart.renderer.boxWrapper.attr({width:scrollableWidth,height:scrollableHeight,viewBox:[0,0,scrollableWidth,scrollableHeight].join(" ")});chart.chartBackground?.attr({width:scrollableWidth,height:scrollableHeight});ScrollablePlotArea_css(scrollingContainer,{width:`${chartWidth}px`,height:`${chartHeight}px`});if(!ScrollablePlotArea_defined(isDirty)){scrollingContainer.scrollLeft=scrollablePixelsX*scrollPositionX;scrollingContainer.scrollTop=scrollablePixelsY*scrollPositionY}const maskTop=plotTop-axisOffset[0]-1,maskLeft=plotLeft-axisOffset[3]-1,maskBottom=plotTop+plotHeight+axisOffset[2]+1,maskRight=plotLeft+plotWidth+axisOffset[1]+1,maskPlotRight=plotLeft+plotWidth-scrollablePixelsX,maskPlotBottom=plotTop+plotHeight-scrollablePixelsY;let d=[["M",0,0]];if(scrollablePixelsX){d=[["M",0,maskTop],["L",plotLeft-1,maskTop],["L",plotLeft-1,maskBottom],["L",0,maskBottom],["Z"],["M",maskPlotRight,maskTop],["L",chartWidth,maskTop],["L",chartWidth,maskBottom],["L",maskPlotRight,maskBottom],["Z"]]}else if(scrollablePixelsY){d=[["M",maskLeft,0],["L",maskLeft,plotTop-1],["L",maskRight,plotTop-1],["L",maskRight,0],["Z"],["M",maskLeft,maskPlotBottom],["L",maskLeft,chartHeight],["L",maskRight,chartHeight],["L",maskRight,maskPlotBottom],["Z"]]}if(chart.redrawTrigger!=="adjustHeight"){this.mask.attr({d:d})}}moveFixedElements(){const{container,inverted,scrollablePixelsX,scrollablePixelsY}=this.chart,fixedRenderer=this.fixedRenderer,fixedSelectors=ScrollablePlotArea.fixedSelectors;let axisClass;if(scrollablePixelsX&&!inverted){axisClass=".highcharts-yaxis"}else if(scrollablePixelsX&&inverted){axisClass=".highcharts-xaxis"}else if(scrollablePixelsY&&!inverted){axisClass=".highcharts-xaxis"}else if(scrollablePixelsY&&inverted){axisClass=".highcharts-yaxis"}if(axisClass&&!(this.chart.hasParallelCoordinates&&axisClass===".highcharts-yaxis")){for(const className of[`${axisClass}:not(.highcharts-radial-axis)`,`${axisClass}-labels:not(.highcharts-radial-axis-labels)`]){ScrollablePlotArea_pushUnique(fixedSelectors,className)}}else{for(const classBase of[".highcharts-xaxis",".highcharts-yaxis"]){for(const className of[`${classBase}:not(.highcharts-radial-axis)`,`${classBase}-labels:not(.highcharts-radial-axis-labels)`]){ScrollablePlotArea_erase(fixedSelectors,className)}}}for(const className of fixedSelectors){[].forEach.call(container.querySelectorAll(className),elem=>{(elem.namespaceURI===fixedRenderer.SVG_NS?fixedRenderer.box:fixedRenderer.box.parentNode).appendChild(elem);elem.style.pointerEvents="auto"})}}}ScrollablePlotArea.fixedSelectors=[".highcharts-breadcrumbs-group",".highcharts-contextbutton",".highcharts-caption",".highcharts-credits",".highcharts-drillup-button",".highcharts-legend",".highcharts-legend-checkbox",".highcharts-navigator-series",".highcharts-navigator-xaxis",".highcharts-navigator-yaxis",".highcharts-navigator",".highcharts-range-selector-group",".highcharts-reset-zoom",".highcharts-scrollbar",".highcharts-subtitle",".highcharts-title"];const Extensions_ScrollablePlotArea=ScrollablePlotArea;"";const{format:StackItem_format}=Core_Templating;const{series:StackItem_Series}=Series_SeriesRegistry;const{destroyObjectProperties:StackItem_destroyObjectProperties,fireEvent:StackItem_fireEvent,getAlignFactor:StackItem_getAlignFactor,isNumber:StackItem_isNumber,pick:StackItem_pick}=Core_Utilities;class StackItem{constructor(axis,options,negativeValue,x,stackOption){const inverted=axis.chart.inverted,reversed=axis.reversed;this.axis=axis;const isNegative=this.isNegative=!!negativeValue!==!!reversed;this.options=options=options||{};this.x=x;this.total=null;this.cumulative=null;this.points={};this.hasValidPoints=false;this.stack=stackOption;this.leftCliff=0;this.rightCliff=0;this.alignOptions={align:options.align||(inverted?isNegative?"left":"right":"center"),verticalAlign:options.verticalAlign||(inverted?"middle":isNegative?"bottom":"top"),y:options.y,x:options.x};this.textAlign=options.textAlign||(inverted?!isNegative?"left":"right":"center")}destroy(){StackItem_destroyObjectProperties(this,this.axis)}render(group){const chart=this.axis.chart,options=this.options,formatOption=options.format,str=formatOption?StackItem_format(formatOption,this,chart):options.formatter.call(this);if(this.label){this.label.attr({text:str,visibility:"hidden"})}else{this.label=chart.renderer.label(str,null,void 0,options.shape,void 0,void 0,options.useHTML,false,"stack-labels");const attr={r:options.borderRadius||0,text:str,padding:StackItem_pick(options.padding,5),visibility:"hidden"};if(!chart.styledMode){attr.fill=options.backgroundColor;attr.stroke=options.borderColor;attr["stroke-width"]=options.borderWidth;this.label.css(options.style||{})}this.label.attr(attr);if(!this.label.added){this.label.add(group)}}this.label.labelrank=chart.plotSizeY;StackItem_fireEvent(this,"afterRender")}setOffset(xOffset,width,boxBottom,boxTop,defaultX,xAxis){const{alignOptions,axis,label,options,textAlign}=this,chart=axis.chart,stackBox=this.getStackBox({xOffset:xOffset,width:width,boxBottom:boxBottom,boxTop:boxTop,defaultX:defaultX,xAxis:xAxis}),{verticalAlign}=alignOptions;if(label&&stackBox){const labelBox=label.getBBox(void 0,0),padding=label.padding;let isJustify=StackItem_pick(options.overflow,"justify")==="justify",visible;alignOptions.x=options.x||0;alignOptions.y=options.y||0;const{x,y}=this.adjustStackPosition({labelBox:labelBox,verticalAlign:verticalAlign,textAlign:textAlign});stackBox.x-=x;stackBox.y-=y;label.align(alignOptions,false,stackBox);visible=chart.isInsidePlot(label.alignAttr.x+alignOptions.x+x,label.alignAttr.y+alignOptions.y+y);if(!visible){isJustify=false}if(isJustify){StackItem_Series.prototype.justifyDataLabel.call(axis,label,alignOptions,label.alignAttr,labelBox,stackBox)}label.attr({x:label.alignAttr.x,y:label.alignAttr.y,rotation:options.rotation,rotationOriginX:labelBox.width*StackItem_getAlignFactor(options.textAlign||"center"),rotationOriginY:labelBox.height/2});if(StackItem_pick(!isJustify&&options.crop,true)){visible=StackItem_isNumber(label.x)&&StackItem_isNumber(label.y)&&chart.isInsidePlot(label.x-padding+(label.width||0),label.y)&&chart.isInsidePlot(label.x+padding,label.y)}label[visible?"show":"hide"]()}StackItem_fireEvent(this,"afterSetOffset",{xOffset:xOffset,width:width})}adjustStackPosition({labelBox,verticalAlign,textAlign}){return{x:labelBox.width/2+labelBox.width/2*(2*StackItem_getAlignFactor(textAlign)-1),y:labelBox.height/2*2*(1-StackItem_getAlignFactor(verticalAlign))}}getStackBox(stackBoxProps){const stackItem=this,axis=this.axis,chart=axis.chart,{boxTop,defaultX,xOffset,width,boxBottom}=stackBoxProps,totalStackValue=axis.stacking.usePercentage?100:StackItem_pick(boxTop,this.total,0),y=axis.toPixels(totalStackValue),xAxis=stackBoxProps.xAxis||chart.xAxis[0],x=StackItem_pick(defaultX,xAxis.translate(this.x))+xOffset,yZero=axis.toPixels(boxBottom||StackItem_isNumber(axis.min)&&axis.logarithmic&&axis.logarithmic.lin2log(axis.min)||0),height=Math.abs(y-yZero),inverted=chart.inverted,neg=stackItem.isNegative;return inverted?{x:(neg?y:y-height)-chart.plotLeft,y:xAxis.height-x-width+xAxis.top-chart.plotTop,width:height,height:width}:{x:x+xAxis.transB-chart.plotLeft,y:(neg?y-height:y)-chart.plotTop,width:width,height:height}}}const Stacking_StackItem=StackItem;"";const{getDeferredAnimation:StackingAxis_getDeferredAnimation}=AnimationUtilities;const{series:{prototype:seriesProto}}=Series_SeriesRegistry;const{addEvent:StackingAxis_addEvent,correctFloat:StackingAxis_correctFloat,defined:StackingAxis_defined,destroyObjectProperties:StackingAxis_destroyObjectProperties,fireEvent:StackingAxis_fireEvent,isNumber:StackingAxis_isNumber,objectEach:StackingAxis_objectEach,pick:StackingAxis_pick}=Core_Utilities;function chartGetStacks(){const chart=this,inverted=chart.inverted;chart.axes.forEach(axis=>{if(axis.stacking&&axis.stacking.stacks&&axis.hasVisibleSeries){axis.stacking.oldStacks=axis.stacking.stacks}});chart.series.forEach(series=>{const xAxisOptions=series.xAxis&&series.xAxis.options||{};if(series.options.stacking&&series.reserveSpace()){series.stackKey=[series.type,StackingAxis_pick(series.options.stack,""),inverted?xAxisOptions.top:xAxisOptions.left,inverted?xAxisOptions.height:xAxisOptions.width].join(",")}})}function onAxisDestroy(){const stacking=this.stacking;if(stacking){const stacks=stacking.stacks;StackingAxis_objectEach(stacks,(stack,stackKey)=>{StackingAxis_destroyObjectProperties(stack);delete stacks[stackKey]});stacking.stackTotalGroup?.destroy()}}function onAxisInit(){if(!this.stacking){this.stacking=new AxisAdditions(this)}}function seriesGetStackIndicator(stackIndicator,x,index,key){if(!StackingAxis_defined(stackIndicator)||stackIndicator.x!==x||key&&stackIndicator.stackKey!==key){stackIndicator={x:x,index:0,key:key,stackKey:key}}else{stackIndicator.index++}stackIndicator.key=[index,x,stackIndicator.index].join(",");return stackIndicator}function seriesModifyStacks(){const series=this,yAxis=series.yAxis,stackKey=series.stackKey||"",stacks=yAxis.stacking.stacks,processedXData=series.getColumn("x",true),stacking=series.options.stacking,stacker=series[stacking+"Stacker"];let stackIndicator;if(stacker){[stackKey,"-"+stackKey].forEach(key=>{let i=processedXData.length,x,stackItem,pointExtremes;while(i--){x=processedXData[i];stackIndicator=series.getStackIndicator(stackIndicator,x,series.index,key);stackItem=stacks[key]?.[x];pointExtremes=stackItem?.points[stackIndicator.key||""];if(pointExtremes){stacker.call(series,pointExtremes,stackItem,i)}}})}}function seriesPercentStacker(pointExtremes,stack,i){const totalFactor=stack.total?100/stack.total:0;pointExtremes[0]=StackingAxis_correctFloat(pointExtremes[0]*totalFactor);pointExtremes[1]=StackingAxis_correctFloat(pointExtremes[1]*totalFactor);this.stackedYData[i]=pointExtremes[1]}function seriesSetGroupedPoints(axis){if(this.is("column")||this.is("columnrange")){if(this.options.centerInCategory&&this.chart.series.length>1){seriesProto.setStackedPoints.call(this,axis,"group")}else{axis.stacking.resetStacks()}}}function seriesSetStackedPoints(axis,stackingParam){const type=stackingParam||this.options.stacking;if(!type||!this.reserveSpace()||({group:"xAxis"}[type]||"yAxis")!==axis.coll){return}const series=this,xData=series.getColumn("x",true),yData=series.getColumn(series.pointValKey||"y",true),stackedYData=[],yDataLength=yData.length,seriesOptions=series.options,threshold=seriesOptions.threshold||0,stackThreshold=seriesOptions.startFromThreshold?threshold:0,stackOption=seriesOptions.stack,stackKey=stackingParam?`${series.type},${type}`:series.stackKey||"",negKey="-"+stackKey,negStacks=series.negStacks,stacking=axis.stacking,stacks=stacking.stacks,oldStacks=stacking.oldStacks;let stackIndicator,isNegative,stack,other,key,pointKey,i;stacking.stacksTouched+=1;for(i=0;i<yDataLength;i++){const x=xData[i]||0,y=yData[i],yNumber=StackingAxis_isNumber(y)&&y||0;stackIndicator=series.getStackIndicator(stackIndicator,x,series.index);pointKey=stackIndicator.key||"";isNegative=negStacks&&yNumber<(stackThreshold?0:threshold);key=isNegative?negKey:stackKey;if(!stacks[key]){stacks[key]={}}if(!stacks[key][x]){if(oldStacks[key]?.[x]){stacks[key][x]=oldStacks[key][x];stacks[key][x].total=null}else{stacks[key][x]=new Stacking_StackItem(axis,axis.options.stackLabels,!!isNegative,x,stackOption)}}stack=stacks[key][x];if(y!==null){stack.points[pointKey]=stack.points[series.index]=[StackingAxis_pick(stack.cumulative,stackThreshold)];if(!StackingAxis_defined(stack.cumulative)){stack.base=pointKey}stack.touched=stacking.stacksTouched;if(stackIndicator.index>0&&series.singleStacks===false){stack.points[pointKey][0]=stack.points[series.index+","+x+",0"][0]}}else{delete stack.points[pointKey];delete stack.points[series.index]}let total=stack.total||0;if(type==="percent"){other=isNegative?stackKey:negKey;if(negStacks&&stacks[other]?.[x]){other=stacks[other][x];total=other.total=Math.max(other.total||0,total)+Math.abs(yNumber)}else{total=StackingAxis_correctFloat(total+Math.abs(yNumber))}}else if(type==="group"){if(StackingAxis_isNumber(y)){total++}}else{total=StackingAxis_correctFloat(total+yNumber)}if(type==="group"){stack.cumulative=(total||1)-1}else{stack.cumulative=StackingAxis_correctFloat(StackingAxis_pick(stack.cumulative,stackThreshold)+yNumber)}stack.total=total;if(y!==null){stack.points[pointKey].push(stack.cumulative);stackedYData[i]=stack.cumulative;stack.hasValidPoints=true}}if(type==="percent"){stacking.usePercentage=true}if(type!=="group"){this.stackedYData=stackedYData}stacking.oldStacks={}}class AxisAdditions{constructor(axis){this.oldStacks={};this.stacks={};this.stacksTouched=0;this.axis=axis}buildStacks(){const stacking=this,axis=stacking.axis,axisSeries=axis.series,isXAxis=axis.coll==="xAxis",reversedStacks=axis.options.reversedStacks,len=axisSeries.length;let actualSeries,i;this.resetStacks();stacking.usePercentage=false;i=len;while(i--){actualSeries=axisSeries[reversedStacks?i:len-i-1];if(isXAxis){actualSeries.setGroupedPoints(axis)}actualSeries.setStackedPoints(axis)}if(!isXAxis){for(i=0;i<len;i++){axisSeries[i].modifyStacks()}}StackingAxis_fireEvent(axis,"afterBuildStacks")}cleanStacks(){if(this.oldStacks){this.stacks=this.oldStacks;StackingAxis_objectEach(this.stacks,type=>{StackingAxis_objectEach(type,stack=>{stack.cumulative=stack.total})})}}resetStacks(){StackingAxis_objectEach(this.stacks,type=>{StackingAxis_objectEach(type,(stack,x)=>{if(StackingAxis_isNumber(stack.touched)&&stack.touched<this.stacksTouched){stack.destroy();delete type[x]}else{stack.total=null;stack.cumulative=null}})})}renderStackTotals(){const stacking=this,axis=stacking.axis,chart=axis.chart,renderer=chart.renderer,stacks=stacking.stacks,stackLabelsAnim=axis.options.stackLabels?.animation,animationConfig=StackingAxis_getDeferredAnimation(chart,stackLabelsAnim||false),stackTotalGroup=stacking.stackTotalGroup=stacking.stackTotalGroup||renderer.g("stack-labels").attr({zIndex:6,opacity:0}).add();stackTotalGroup.translate(chart.plotLeft,chart.plotTop);StackingAxis_objectEach(stacks,type=>{StackingAxis_objectEach(type,stack=>{stack.render(stackTotalGroup)})});stackTotalGroup.animate({opacity:1},animationConfig)}}var StackingAxis;(function(StackingAxis){function compose(AxisClass,ChartClass,SeriesClass){const chartProto=ChartClass.prototype,seriesProto=SeriesClass.prototype;if(!chartProto.getStacks){StackingAxis_addEvent(AxisClass,"init",onAxisInit);StackingAxis_addEvent(AxisClass,"destroy",onAxisDestroy);chartProto.getStacks=chartGetStacks;seriesProto.getStackIndicator=seriesGetStackIndicator;seriesProto.modifyStacks=seriesModifyStacks;seriesProto.percentStacker=seriesPercentStacker;seriesProto.setGroupedPoints=seriesSetGroupedPoints;seriesProto.setStackedPoints=seriesSetStackedPoints}}StackingAxis.compose=compose})(StackingAxis||(StackingAxis={}));const Stacking_StackingAxis=StackingAxis;const{defined:LineSeries_defined,merge:LineSeries_merge,isObject:LineSeries_isObject}=Core_Utilities;class LineSeries extends Series_Series{drawGraph(){const options=this.options,graphPath=(this.gappedPath||this.getGraphPath).call(this),styledMode=this.chart.styledMode;[this,...this.zones].forEach((owner,i)=>{let attribs,graph=owner.graph;const verb=graph?"animate":"attr",dashStyle=owner.dashStyle||options.dashStyle;if(graph){graph.endX=this.preventGraphAnimation?null:graphPath.xMap;graph.animate({d:graphPath})}else if(graphPath.length){owner.graph=graph=this.chart.renderer.path(graphPath).addClass("highcharts-graph"+(i?` highcharts-zone-graph-${i-1} `:" ")+(i&&owner.className||"")).attr({zIndex:1}).add(this.group)}if(graph&&!styledMode){attribs={stroke:!i&&options.lineColor||owner.color||this.color||"#cccccc","stroke-width":options.lineWidth||0,fill:this.fillGraph&&this.color||"none"};if(dashStyle){attribs.dashstyle=dashStyle}else if(options.linecap!=="square"){attribs["stroke-linecap"]=attribs["stroke-linejoin"]="round"}graph[verb](attribs).shadow(options.shadow&&LineSeries_merge({filterUnits:"userSpaceOnUse"},LineSeries_isObject(options.shadow)?options.shadow:{}))}if(graph){graph.startX=graphPath.xMap;graph.isArea=graphPath.isArea}})}getGraphPath(points,nullsAsZeroes,connectCliffs){const series=this,options=series.options,graphPath=[],xMap=[];let gap,step=options.step;points=points||series.points;const reversed=points.reversed;if(reversed){points.reverse()}step={right:1,center:2}[step]||step&&3;if(step&&reversed){step=4-step}points=this.getValidPoints(points,false,!(options.connectNulls&&!nullsAsZeroes&&!connectCliffs));points.forEach(function(point,i){const plotX=point.plotX,plotY=point.plotY,lastPoint=points[i-1],isNull=point.isNull||typeof plotY!=="number";let pathToPoint;if((point.leftCliff||lastPoint&&lastPoint.rightCliff)&&!connectCliffs){gap=true}if(isNull&&!LineSeries_defined(nullsAsZeroes)&&i>0){gap=!options.connectNulls}else if(isNull&&!nullsAsZeroes){gap=true}else{if(i===0||gap){pathToPoint=[["M",point.plotX,point.plotY]]}else if(series.getPointSpline){pathToPoint=[series.getPointSpline(points,point,i)]}else if(step){if(step===1){pathToPoint=[["L",lastPoint.plotX,plotY]]}else if(step===2){pathToPoint=[["L",(lastPoint.plotX+plotX)/2,lastPoint.plotY],["L",(lastPoint.plotX+plotX)/2,plotY]]}else{pathToPoint=[["L",plotX,lastPoint.plotY]]}pathToPoint.push(["L",plotX,plotY])}else{pathToPoint=[["L",plotX,plotY]]}xMap.push(point.x);if(step){xMap.push(point.x);if(step===2){xMap.push(point.x)}}graphPath.push.apply(graphPath,pathToPoint);gap=false}});graphPath.xMap=xMap;series.graphPath=graphPath;return graphPath}}LineSeries.defaultOptions=LineSeries_merge(Series_Series.defaultOptions,{legendSymbol:"lineMarker"});Series_SeriesRegistry.registerSeriesType("line",LineSeries);const Line_LineSeries=null&&LineSeries;"";const AreaSeriesDefaults={threshold:0,legendSymbol:"areaMarker"};"";const Area_AreaSeriesDefaults=AreaSeriesDefaults;const{seriesTypes:{line:AreaSeries_LineSeries}}=Series_SeriesRegistry;const{extend:AreaSeries_extend,merge:AreaSeries_merge,objectEach:AreaSeries_objectEach,pick:AreaSeries_pick}=Core_Utilities;class AreaSeries extends AreaSeries_LineSeries{drawGraph(){this.areaPath=[];super.drawGraph.apply(this);const{areaPath,options}=this;[this,...this.zones].forEach((owner,i)=>{const attribs={},fillColor=owner.fillColor||options.fillColor;let area=owner.area;const verb=area?"animate":"attr";if(area){area.endX=this.preventGraphAnimation?null:areaPath.xMap;area.animate({d:areaPath})}else{attribs.zIndex=0;area=owner.area=this.chart.renderer.path(areaPath).addClass("highcharts-area"+(i?` highcharts-zone-area-${i-1} `:" ")+(i&&owner.className||"")).add(this.group);area.isArea=true}if(!this.chart.styledMode){attribs.fill=fillColor||owner.color||this.color;attribs["fill-opacity"]=fillColor?1:options.fillOpacity??.75;area.css({pointerEvents:this.stickyTracking?"none":"auto"})}area[verb](attribs);area.startX=areaPath.xMap;area.shiftUnit=options.step?2:1})}getGraphPath(points){const getGraphPath=AreaSeries_LineSeries.prototype.getGraphPath,options=this.options,stacking=options.stacking,yAxis=this.yAxis,bottomPoints=[],graphPoints=[],seriesIndex=this.index,stacks=yAxis.stacking.stacks[this.stackKey],threshold=options.threshold,translatedThreshold=Math.round(yAxis.getThreshold(options.threshold)),connectNulls=AreaSeries_pick(options.connectNulls,stacking==="percent"),addDummyPoints=function(i,otherI,side){const point=points[i],stackedValues=stacking&&stacks[point.x].points[seriesIndex],nullVal=point[side+"Null"]||0,cliffVal=point[side+"Cliff"]||0;let top,bottom,isNull=true;if(cliffVal||nullVal){top=(nullVal?stackedValues[0]:stackedValues[1])+cliffVal;bottom=stackedValues[0]+cliffVal;isNull=!!nullVal}else if(!stacking&&points[otherI]&&points[otherI].isNull){top=bottom=threshold}if(typeof top!=="undefined"){graphPoints.push({plotX:plotX,plotY:top===null?translatedThreshold:yAxis.getThreshold(top),isNull:isNull,isCliff:true});bottomPoints.push({plotX:plotX,plotY:bottom===null?translatedThreshold:yAxis.getThreshold(bottom),doCurve:false})}};let plotX,isNull,yBottom;points=points||this.points;if(stacking){points=this.getStackPoints(points)}for(let i=0,iEnd=points.length;i<iEnd;++i){if(!stacking){points[i].leftCliff=points[i].rightCliff=points[i].leftNull=points[i].rightNull=void 0}isNull=points[i].isNull;plotX=AreaSeries_pick(points[i].rectPlotX,points[i].plotX);yBottom=stacking?AreaSeries_pick(points[i].yBottom,translatedThreshold):translatedThreshold;if(!isNull||connectNulls){if(!connectNulls){addDummyPoints(i,i-1,"left")}if(!(isNull&&!stacking&&connectNulls)){graphPoints.push(points[i]);bottomPoints.push({x:i,plotX:plotX,plotY:yBottom})}if(!connectNulls){addDummyPoints(i,i+1,"right")}}}const topPath=getGraphPath.call(this,graphPoints,true,true);bottomPoints.reversed=true;const bottomPath=getGraphPath.call(this,bottomPoints,true,true);const firstBottomPoint=bottomPath[0];if(firstBottomPoint&&firstBottomPoint[0]==="M"){bottomPath[0]=["L",firstBottomPoint[1],firstBottomPoint[2]]}const areaPath=topPath.concat(bottomPath);if(areaPath.length){areaPath.push(["Z"])}const graphPath=getGraphPath.call(this,graphPoints,false,connectNulls);if(this.chart.series.length>1&&stacking&&graphPoints.some(point=>point.isCliff)){areaPath.hasStackedCliffs=graphPath.hasStackedCliffs=true}areaPath.xMap=topPath.xMap;this.areaPath=areaPath;return graphPath}getStackPoints(points){const series=this,segment=[],keys=[],xAxis=this.xAxis,yAxis=this.yAxis,stack=yAxis.stacking.stacks[this.stackKey],pointMap={},yAxisSeries=yAxis.series,seriesLength=yAxisSeries.length,upOrDown=yAxis.options.reversedStacks?1:-1,seriesIndex=yAxisSeries.indexOf(series);points=points||this.points;if(this.options.stacking){for(let i=0;i<points.length;i++){points[i].leftNull=points[i].rightNull=void 0;pointMap[points[i].x]=points[i]}AreaSeries_objectEach(stack,function(stackX,x){if(stackX.total!==null){keys.push(x)}});keys.sort(function(a,b){return a-b});const visibleSeries=yAxisSeries.map(s=>s.visible);keys.forEach(function(x,idx){let y=0,stackPoint,stackedValues;if(pointMap[x]&&!pointMap[x].isNull){segment.push(pointMap[x]);[-1,1].forEach(function(direction){const nullName=direction===1?"rightNull":"leftNull",cliffName=direction===1?"rightCliff":"leftCliff",otherStack=stack[keys[idx+direction]];let cliff=0;if(otherStack){let i=seriesIndex;while(i>=0&&i<seriesLength){const si=yAxisSeries[i].index;stackPoint=otherStack.points[si];if(!stackPoint){if(si===series.index){pointMap[x][nullName]=true}else if(visibleSeries[i]){stackedValues=stack[x].points[si];if(stackedValues){cliff-=stackedValues[1]-stackedValues[0]}}}i+=upOrDown}}pointMap[x][cliffName]=cliff})}else{let i=seriesIndex;while(i>=0&&i<seriesLength){const si=yAxisSeries[i].index;stackPoint=stack[x].points[si];if(stackPoint){y=stackPoint[1];break}i+=upOrDown}y=AreaSeries_pick(y,0);y=yAxis.translate(y,0,1,0,1);segment.push({isNull:true,plotX:xAxis.translate(x,0,0,0,1),x:x,plotY:y,yBottom:y})}})}return segment}}AreaSeries.defaultOptions=AreaSeries_merge(AreaSeries_LineSeries.defaultOptions,Area_AreaSeriesDefaults);AreaSeries_extend(AreaSeries.prototype,{singleStacks:false});Series_SeriesRegistry.registerSeriesType("area",AreaSeries);const Area_AreaSeries=null&&AreaSeries;const{line:SplineSeries_LineSeries}=Series_SeriesRegistry.seriesTypes;const{merge:SplineSeries_merge,pick:SplineSeries_pick}=Core_Utilities;class SplineSeries extends SplineSeries_LineSeries{getPointSpline(points,point,i){const smoothing=1.5,denom=smoothing+1,plotX=point.plotX||0,plotY=point.plotY||0,lastPoint=points[i-1],nextPoint=points[i+1];let leftContX,leftContY,rightContX,rightContY;function doCurve(otherPoint){return otherPoint&&!otherPoint.isNull&&otherPoint.doCurve!==false&&!point.isCliff}if(doCurve(lastPoint)&&doCurve(nextPoint)){const lastX=lastPoint.plotX||0,lastY=lastPoint.plotY||0,nextX=nextPoint.plotX||0,nextY=nextPoint.plotY||0;let correction=0;leftContX=(smoothing*plotX+lastX)/denom;leftContY=(smoothing*plotY+lastY)/denom;rightContX=(smoothing*plotX+nextX)/denom;rightContY=(smoothing*plotY+nextY)/denom;if(rightContX!==leftContX){correction=(rightContY-leftContY)*(rightContX-plotX)/(rightContX-leftContX)+plotY-rightContY}leftContY+=correction;rightContY+=correction;if(leftContY>lastY&&leftContY>plotY){leftContY=Math.max(lastY,plotY);rightContY=2*plotY-leftContY}else if(leftContY<lastY&&leftContY<plotY){leftContY=Math.min(lastY,plotY);rightContY=2*plotY-leftContY}if(rightContY>nextY&&rightContY>plotY){rightContY=Math.max(nextY,plotY);leftContY=2*plotY-rightContY}else if(rightContY<nextY&&rightContY<plotY){rightContY=Math.min(nextY,plotY);leftContY=2*plotY-rightContY}point.rightContX=rightContX;point.rightContY=rightContY;point.controlPoints={low:[leftContX,leftContY],high:[rightContX,rightContY]}}const ret=["C",SplineSeries_pick(lastPoint.rightContX,lastPoint.plotX,0),SplineSeries_pick(lastPoint.rightContY,lastPoint.plotY,0),SplineSeries_pick(leftContX,plotX,0),SplineSeries_pick(leftContY,plotY,0),plotX,plotY];lastPoint.rightContX=lastPoint.rightContY=void 0;return ret}}SplineSeries.defaultOptions=SplineSeries_merge(SplineSeries_LineSeries.defaultOptions);Series_SeriesRegistry.registerSeriesType("spline",SplineSeries);const Spline_SplineSeries=SplineSeries;"";const{area:AreaSplineSeries_AreaSeries,area:{prototype:areaProto}}=Series_SeriesRegistry.seriesTypes;const{extend:AreaSplineSeries_extend,merge:AreaSplineSeries_merge}=Core_Utilities;class AreaSplineSeries extends Spline_SplineSeries{}AreaSplineSeries.defaultOptions=AreaSplineSeries_merge(Spline_SplineSeries.defaultOptions,AreaSplineSeries_AreaSeries.defaultOptions);AreaSplineSeries_extend(AreaSplineSeries.prototype,{getGraphPath:areaProto.getGraphPath,getStackPoints:areaProto.getStackPoints,drawGraph:areaProto.drawGraph});Series_SeriesRegistry.registerSeriesType("areaspline",AreaSplineSeries);const AreaSpline_AreaSplineSeries=null&&AreaSplineSeries;"";const ColumnSeriesDefaults={borderRadius:3,centerInCategory:false,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:false,brightness:.1},select:{color:"#cccccc",borderColor:"#000000"}},dataLabels:{align:void 0,verticalAlign:void 0,y:void 0},startFromThreshold:true,stickyTracking:false,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"};"";const Column_ColumnSeriesDefaults=ColumnSeriesDefaults;const{animObject:ColumnSeries_animObject}=AnimationUtilities;const{parse:ColumnSeries_color}=Color_Color;const{noop:ColumnSeries_noop}=Core_Globals;const{clamp:ColumnSeries_clamp,crisp:ColumnSeries_crisp,defined:ColumnSeries_defined,extend:ColumnSeries_extend,fireEvent:ColumnSeries_fireEvent,isArray:ColumnSeries_isArray,isNumber:ColumnSeries_isNumber,merge:ColumnSeries_merge,pick:ColumnSeries_pick,objectEach:ColumnSeries_objectEach}=Core_Utilities;class ColumnSeries extends Series_Series{animate(init){const series=this,yAxis=this.yAxis,yAxisPos=yAxis.pos,reversed=yAxis.reversed,options=series.options,{clipOffset,inverted}=this.chart,attr={},translateProp=inverted?"translateX":"translateY";let translateStart,translatedThreshold;if(init&&clipOffset){attr.scaleY=.001;translatedThreshold=ColumnSeries_clamp(yAxis.toPixels(options.threshold||0),yAxisPos,yAxisPos+yAxis.len);if(inverted){translatedThreshold+=reversed?-Math.floor(clipOffset[0]):Math.ceil(clipOffset[2]);attr.translateX=translatedThreshold-yAxis.len}else{translatedThreshold+=reversed?Math.ceil(clipOffset[0]):-Math.floor(clipOffset[2]);attr.translateY=translatedThreshold}if(series.clipBox){series.setClip()}series.group.attr(attr)}else{translateStart=Number(series.group.attr(translateProp));series.group.animate({scaleY:1},ColumnSeries_extend(ColumnSeries_animObject(series.options.animation),{step:function(val,fx){if(series.group){attr[translateProp]=translateStart+fx.pos*(yAxisPos-translateStart);series.group.attr(attr)}}}))}}init(chart,options){super.init.apply(this,arguments);const series=this;chart=series.chart;if(chart.hasRendered){chart.series.forEach(function(otherSeries){if(otherSeries.type===series.type){otherSeries.isDirty=true}})}}getColumnMetrics(){const series=this,options=series.options,xAxis=series.xAxis,yAxis=series.yAxis,reversedStacks=xAxis.options.reversedStacks,reverseStacks=xAxis.reversed&&!reversedStacks||!xAxis.reversed&&reversedStacks,stackGroups={};let stackKey,columnCount=0;if(options.grouping===false){columnCount=1}else{series.chart.series.forEach(function(otherSeries){const otherYAxis=otherSeries.yAxis,otherOptions=otherSeries.options;let columnIndex;if(otherSeries.type===series.type&&otherSeries.reserveSpace()&&yAxis.len===otherYAxis.len&&yAxis.pos===otherYAxis.pos){if(otherOptions.stacking&&otherOptions.stacking!=="group"){stackKey=otherSeries.stackKey;if(typeof stackGroups[stackKey]==="undefined"){stackGroups[stackKey]=columnCount++}columnIndex=stackGroups[stackKey]}else if(otherOptions.grouping!==false){columnIndex=columnCount++}otherSeries.columnIndex=columnIndex}})}const categoryWidth=Math.min(Math.abs(xAxis.transA)*(!xAxis.brokenAxis?.hasBreaks&&xAxis.ordinal?.slope||options.pointRange||xAxis.closestPointRange||xAxis.tickInterval||1),xAxis.len),groupPadding=categoryWidth*options.groupPadding,groupWidth=categoryWidth-2*groupPadding,pointOffsetWidth=groupWidth/(columnCount||1),pointWidth=Math.min(options.maxPointWidth||xAxis.len,ColumnSeries_pick(options.pointWidth,pointOffsetWidth*(1-2*options.pointPadding))),pointPadding=(pointOffsetWidth-pointWidth)/2,colIndex=(series.columnIndex||0)+(reverseStacks?1:0),pointXOffset=pointPadding+(groupPadding+colIndex*pointOffsetWidth-categoryWidth/2)*(reverseStacks?-1:1);series.columnMetrics={width:pointWidth,offset:pointXOffset,paddedWidth:pointOffsetWidth,columnCount:columnCount};return series.columnMetrics}crispCol(x,y,width,height){const borderWidth=this.borderWidth,inverted=this.chart.inverted,bottom=ColumnSeries_crisp(y+height,borderWidth,inverted);y=ColumnSeries_crisp(y,borderWidth,inverted);height=bottom-y;if(this.options.crisp){const right=ColumnSeries_crisp(x+width,borderWidth);x=ColumnSeries_crisp(x,borderWidth);width=right-x}return{x:x,y:y,width:width,height:height}}adjustForMissingColumns(x,pointWidth,point,metrics){if(!point.isNull&&metrics.columnCount>1){const visibleSeries=this.xAxis.series.filter(s=>s.visible).map(s=>s.index);let indexInCategory=0,totalInCategory=0;ColumnSeries_objectEach(this.xAxis.stacking?.stacks,stack=>{const points=typeof point.x==="number"?stack[point.x.toString()]?.points:void 0,pointValues=points?.[this.index],yStackMap={};if(points&&ColumnSeries_isArray(pointValues)){let baseIndex=this.index;const seriesIndexes=Object.keys(points).filter(pointKey=>!pointKey.match(",")&&points[pointKey]&&points[pointKey].length>1).map(parseFloat).filter(index=>visibleSeries.indexOf(index)!==-1).filter(index=>{const otherOptions=this.chart.series[index].options,yStack=otherOptions.stacking&&otherOptions.stack;if(ColumnSeries_defined(yStack)){if(ColumnSeries_isNumber(yStackMap[yStack])){if(baseIndex===index){baseIndex=yStackMap[yStack]}return false}yStackMap[yStack]=index}return true}).sort((a,b)=>b-a);indexInCategory=seriesIndexes.indexOf(baseIndex);totalInCategory=seriesIndexes.length}});indexInCategory=this.xAxis.reversed?totalInCategory-1-indexInCategory:indexInCategory;const boxWidth=(totalInCategory-1)*metrics.paddedWidth+pointWidth;x=(point.plotX||0)+boxWidth/2-pointWidth-indexInCategory*metrics.paddedWidth}return x}translate(){const series=this,chart=series.chart,options=series.options,dense=series.dense=series.closestPointRange*series.xAxis.transA<2,borderWidth=series.borderWidth=ColumnSeries_pick(options.borderWidth,dense?0:1),xAxis=series.xAxis,yAxis=series.yAxis,threshold=options.threshold,minPointLength=ColumnSeries_pick(options.minPointLength,5),metrics=series.getColumnMetrics(),seriesPointWidth=metrics.width,seriesXOffset=series.pointXOffset=metrics.offset,dataMin=series.dataMin,dataMax=series.dataMax,translatedThreshold=series.translatedThreshold=yAxis.getThreshold(threshold);let seriesBarW=series.barW=Math.max(seriesPointWidth,1+2*borderWidth);if(options.pointPadding&&options.crisp){seriesBarW=Math.ceil(seriesBarW)}Series_Series.prototype.translate.apply(series);series.points.forEach(function(point){const yBottom=ColumnSeries_pick(point.yBottom,translatedThreshold),safeDistance=999+Math.abs(yBottom),plotX=point.plotX||0,plotY=ColumnSeries_clamp(point.plotY,-safeDistance,yAxis.len+safeDistance);let up,barY=Math.min(plotY,yBottom),barH=Math.max(plotY,yBottom)-barY,pointWidth=seriesPointWidth,barX=plotX+seriesXOffset,barW=seriesBarW;if(minPointLength&&Math.abs(barH)<minPointLength){barH=minPointLength;up=!yAxis.reversed&&!point.negative||yAxis.reversed&&point.negative;if(ColumnSeries_isNumber(threshold)&&ColumnSeries_isNumber(dataMax)&&point.y===threshold&&dataMax<=threshold&&(yAxis.min||0)<threshold&&(dataMin!==dataMax||(yAxis.max||0)<=threshold)){up=!up;point.negative=!point.negative}barY=Math.abs(barY-translatedThreshold)>minPointLength?yBottom-minPointLength:translatedThreshold-(up?minPointLength:0)}if(ColumnSeries_defined(point.options.pointWidth)){pointWidth=barW=Math.ceil(point.options.pointWidth);barX-=Math.round((pointWidth-seriesPointWidth)/2)}if(options.centerInCategory){barX=series.adjustForMissingColumns(barX,pointWidth,point,metrics)}point.barX=barX;point.pointWidth=pointWidth;point.tooltipPos=chart.inverted?[ColumnSeries_clamp(yAxis.len+yAxis.pos-chart.plotLeft-plotY,yAxis.pos-chart.plotLeft,yAxis.len+yAxis.pos-chart.plotLeft),xAxis.len+xAxis.pos-chart.plotTop-barX-barW/2,barH]:[xAxis.left-chart.plotLeft+barX+barW/2,ColumnSeries_clamp(plotY+yAxis.pos-chart.plotTop,yAxis.pos-chart.plotTop,yAxis.len+yAxis.pos-chart.plotTop),barH];point.shapeType=series.pointClass.prototype.shapeType||"roundedRect";point.shapeArgs=series.crispCol(barX,point.isNull?translatedThreshold:barY,barW,point.isNull?0:barH)});ColumnSeries_fireEvent(this,"afterColumnTranslate")}drawGraph(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")}pointAttribs(point,state){const options=this.options,p2o=this.pointAttrToOptions||{},strokeOption=p2o.stroke||"borderColor",strokeWidthOption=p2o["stroke-width"]||"borderWidth";let stateOptions,zone,brightness,fill=point&&point.color||this.color,stroke=point&&point[strokeOption]||options[strokeOption]||fill,dashstyle=point&&point.options.dashStyle||options.dashStyle,strokeWidth=point&&point[strokeWidthOption]||options[strokeWidthOption]||this[strokeWidthOption]||0,opacity=ColumnSeries_pick(point&&point.opacity,options.opacity,1);if(point&&this.zones.length){zone=point.getZone();fill=point.options.color||zone&&(zone.color||point.nonZonedColor)||this.color;if(zone){stroke=zone.borderColor||stroke;dashstyle=zone.dashStyle||dashstyle;strokeWidth=zone.borderWidth||strokeWidth}}if(state&&point){stateOptions=ColumnSeries_merge(options.states[state],point.options.states&&point.options.states[state]||{});brightness=stateOptions.brightness;fill=stateOptions.color||typeof brightness!=="undefined"&&ColumnSeries_color(fill).brighten(stateOptions.brightness).get()||fill;stroke=stateOptions[strokeOption]||stroke;strokeWidth=stateOptions[strokeWidthOption]||strokeWidth;dashstyle=stateOptions.dashStyle||dashstyle;opacity=ColumnSeries_pick(stateOptions.opacity,opacity)}const ret={fill:fill,stroke:stroke,"stroke-width":strokeWidth,opacity:opacity};if(dashstyle){ret.dashstyle=dashstyle}return ret}drawPoints(points=this.points){const series=this,chart=this.chart,options=series.options,renderer=chart.renderer,animationLimit=options.animationLimit||250;let shapeArgs;points.forEach(function(point){const plotY=point.plotY;let graphic=point.graphic,hasGraphic=!!graphic,verb=graphic&&chart.pointCount<animationLimit?"animate":"attr";if(ColumnSeries_isNumber(plotY)&&point.y!==null){shapeArgs=point.shapeArgs;if(graphic&&point.hasNewShapeType()){graphic=graphic.destroy()}if(series.enabledDataSorting){point.startXPos=series.xAxis.reversed?-(shapeArgs?shapeArgs.width||0:0):series.xAxis.width}if(!graphic){point.graphic=graphic=renderer[point.shapeType](shapeArgs).add(point.group||series.group);if(graphic&&series.enabledDataSorting&&chart.hasRendered&&chart.pointCount<animationLimit){graphic.attr({x:point.startXPos});hasGraphic=true;verb="animate"}}if(graphic&&hasGraphic){graphic[verb](ColumnSeries_merge(shapeArgs))}if(!chart.styledMode){graphic[verb](series.pointAttribs(point,point.selected&&"select")).shadow(point.allowShadow!==false&&options.shadow)}if(graphic){graphic.addClass(point.getClassName(),true);graphic.attr({visibility:point.visible?"inherit":"hidden"})}}else if(graphic){point.graphic=graphic.destroy()}})}drawTracker(points=this.points){const series=this,chart=series.chart,pointer=chart.pointer,onMouseOver=function(e){pointer?.normalize(e);const point=pointer?.getPointFromEvent(e),isInsidePlot=chart.scrollablePlotArea?chart.isInsidePlot(e.chartX-chart.plotLeft,e.chartY-chart.plotTop,{visiblePlotOnly:true}):true;if(pointer&&point&&series.options.enableMouseTracking&&isInsidePlot){pointer.isDirectTouch=true;point.onMouseOver(e)}};let dataLabels;points.forEach(function(point){dataLabels=ColumnSeries_isArray(point.dataLabels)?point.dataLabels:point.dataLabel?[point.dataLabel]:[];if(point.graphic){point.graphic.element.point=point}dataLabels.forEach(function(dataLabel){(dataLabel.div||dataLabel.element).point=point})});if(!series._hasTracking){series.trackerGroups.forEach(function(key){if(series[key]){series[key].addClass("highcharts-tracker").on("mouseover",onMouseOver).on("mouseout",function(e){pointer?.onTrackerMouseOut(e)}).on("touchstart",onMouseOver);if(!chart.styledMode&&series.options.cursor){series[key].css({cursor:series.options.cursor})}}});series._hasTracking=true}ColumnSeries_fireEvent(this,"afterDrawTracker")}remove(){const series=this,chart=series.chart;if(chart.hasRendered){chart.series.forEach(function(otherSeries){if(otherSeries.type===series.type){otherSeries.isDirty=true}})}Series_Series.prototype.remove.apply(series,arguments)}}ColumnSeries.defaultOptions=ColumnSeries_merge(Series_Series.defaultOptions,Column_ColumnSeriesDefaults);ColumnSeries_extend(ColumnSeries.prototype,{directTouch:true,getSymbol:ColumnSeries_noop,negStacks:true,trackerGroups:["group","dataLabelsGroup"]});Series_SeriesRegistry.registerSeriesType("column",ColumnSeries);const Column_ColumnSeries=ColumnSeries;"";const{getDeferredAnimation:DataLabel_getDeferredAnimation}=AnimationUtilities;const{format:DataLabel_format}=Core_Templating;const{defined:DataLabel_defined,extend:DataLabel_extend,fireEvent:DataLabel_fireEvent,getAlignFactor:DataLabel_getAlignFactor,isArray:DataLabel_isArray,isString:DataLabel_isString,merge:DataLabel_merge,objectEach:DataLabel_objectEach,pick:DataLabel_pick,pInt:DataLabel_pInt,splat:DataLabel_splat}=Core_Utilities;var DataLabel;(function(DataLabel){function hasDataLabels(){return mergedDataLabelOptions(this).some(o=>o?.enabled)}function alignDataLabel(point,dataLabel,options,alignTo,isNew){const series=this,{chart,enabledDataSorting}=this,inverted=this.isCartesian&&chart.inverted,plotX=point.plotX,plotY=point.plotY,rotation=options.rotation||0,isInsidePlot=DataLabel_defined(plotX)&&DataLabel_defined(plotY)&&chart.isInsidePlot(plotX,Math.round(plotY),{inverted:inverted,paneCoordinates:true,series:series}),setStartPos=alignOptions=>{if(enabledDataSorting&&series.xAxis&&!justify){series.setDataLabelStartPos(point,dataLabel,isNew,isInsidePlot,alignOptions)}},justify=rotation===0?DataLabel_pick(options.overflow,enabledDataSorting?"none":"justify")==="justify":false;let visible=this.visible&&point.visible!==false&&DataLabel_defined(plotX)&&(point.series.forceDL||enabledDataSorting&&!justify||isInsidePlot||DataLabel_pick(options.inside,!!this.options.stacking)&&alignTo&&chart.isInsidePlot(plotX,inverted?alignTo.x+1:alignTo.y+alignTo.height-1,{inverted:inverted,paneCoordinates:true,series:series}));const pos=point.pos();if(visible&&pos){const bBox=dataLabel.getBBox(),unrotatedbBox=dataLabel.getBBox(void 0,0);alignTo=DataLabel_extend({x:pos[0],y:Math.round(pos[1]),width:0,height:0},alignTo||{});if(options.alignTo==="plotEdges"&&series.isCartesian){alignTo[inverted?"x":"y"]=0;alignTo[inverted?"width":"height"]=this.yAxis?.len||0}DataLabel_extend(options,{width:bBox.width,height:bBox.height});setStartPos(alignTo);dataLabel.align(DataLabel_merge(options,{width:unrotatedbBox.width,height:unrotatedbBox.height}),false,alignTo,false);dataLabel.alignAttr.x+=DataLabel_getAlignFactor(options.align)*(unrotatedbBox.width-bBox.width);dataLabel.alignAttr.y+=DataLabel_getAlignFactor(options.verticalAlign)*(unrotatedbBox.height-bBox.height);dataLabel[dataLabel.placed?"animate":"attr"]({x:dataLabel.alignAttr.x+(bBox.width-unrotatedbBox.width)/2,y:dataLabel.alignAttr.y+(bBox.height-unrotatedbBox.height)/2,rotationOriginX:(dataLabel.width||0)/2,rotationOriginY:(dataLabel.height||0)/2});if(justify&&alignTo.height>=0){this.justifyDataLabel(dataLabel,options,dataLabel.alignAttr,bBox,alignTo,isNew)}else if(DataLabel_pick(options.crop,true)){const{x,y}=dataLabel.alignAttr,correction=1;visible=chart.isInsidePlot(x,y,{paneCoordinates:true,series:series})&&chart.isInsidePlot(x+bBox.width-correction,y+bBox.height-correction,{paneCoordinates:true,series:series})}if(options.shape&&!rotation){dataLabel[isNew?"attr":"animate"]({anchorX:pos[0],anchorY:pos[1]})}}if(isNew&&enabledDataSorting){dataLabel.placed=false}if(!visible&&(!enabledDataSorting||justify)){dataLabel.hide();dataLabel.placed=false}else{dataLabel.show();dataLabel.placed=true}}function applyFilter(point,options){const filter=options.filter;if(filter){const op=filter.operator,prop=point[filter.property],val=filter.value;if(op===">"&&prop>val||op==="<"&&prop<val||op===">="&&prop>=val||op==="<="&&prop<=val||op==="=="&&prop==val||op==="==="&&prop===val||op==="!="&&prop!=val||op==="!=="&&prop!==val){return true}return false}return true}function compose(SeriesClass){const seriesProto=SeriesClass.prototype;if(!seriesProto.initDataLabels){seriesProto.initDataLabels=initDataLabels;seriesProto.initDataLabelsGroup=initDataLabelsGroup;seriesProto.alignDataLabel=alignDataLabel;seriesProto.drawDataLabels=drawDataLabels;seriesProto.justifyDataLabel=justifyDataLabel;seriesProto.setDataLabelStartPos=setDataLabelStartPos;seriesProto.hasDataLabels=hasDataLabels}}DataLabel.compose=compose;function initDataLabelsGroup(){return this.plotGroup("dataLabelsGroup","data-labels",this.hasRendered?"inherit":"hidden",this.options.dataLabels.zIndex||6)}function initDataLabels(animationConfig){const series=this,hasRendered=series.hasRendered||0;const dataLabelsGroup=this.initDataLabelsGroup().attr({opacity:+hasRendered});if(!hasRendered&&dataLabelsGroup){if(series.visible){dataLabelsGroup.show()}if(series.options.animation){dataLabelsGroup.animate({opacity:1},animationConfig)}else{dataLabelsGroup.attr({opacity:1})}}return dataLabelsGroup}function drawDataLabels(points){points=points||this.points;const series=this,chart=series.chart,seriesOptions=series.options,renderer=chart.renderer,{backgroundColor,plotBackgroundColor}=chart.options.chart,contrastColor=renderer.getContrast(DataLabel_isString(plotBackgroundColor)&&plotBackgroundColor||DataLabel_isString(backgroundColor)&&backgroundColor||"#000000"),seriesDlOptions=mergedDataLabelOptions(series);let pointOptions,dataLabelsGroup;const{animation,defer}=seriesDlOptions[0],animationConfig=defer?DataLabel_getDeferredAnimation(chart,animation,series):{defer:0,duration:0};DataLabel_fireEvent(this,"drawDataLabels");if(series.hasDataLabels?.()){dataLabelsGroup=this.initDataLabels(animationConfig);points.forEach(point=>{const dataLabels=point.dataLabels||[];pointOptions=DataLabel_splat(mergeArrays(seriesDlOptions,point.dlOptions||point.options?.dataLabels));pointOptions.forEach((labelOptions,i)=>{const labelEnabled=labelOptions.enabled&&(point.visible||point.dataLabelOnHidden)&&(!point.isNull||point.dataLabelOnNull)&&applyFilter(point,labelOptions),{backgroundColor,borderColor,distance,style={}}=labelOptions;let formatString,labelText,rotation,attr={},dataLabel=dataLabels[i],isNew=!dataLabel,labelBgColor;if(labelEnabled){formatString=DataLabel_pick(labelOptions[point.formatPrefix+"Format"],labelOptions.format);labelText=DataLabel_defined(formatString)?DataLabel_format(formatString,point,chart):(labelOptions[point.formatPrefix+"Formatter"]||labelOptions.formatter).call(point,labelOptions);rotation=labelOptions.rotation;if(!chart.styledMode){style.color=DataLabel_pick(labelOptions.color,style.color,DataLabel_isString(series.color)?series.color:void 0,"#000000");if(style.color==="contrast"){if(backgroundColor!=="none"){labelBgColor=backgroundColor}point.contrastColor=renderer.getContrast(labelBgColor!=="auto"&&labelBgColor||(point.color||series.color));style.color=labelBgColor||!DataLabel_defined(distance)&&labelOptions.inside||DataLabel_pInt(distance||0)<0||seriesOptions.stacking?point.contrastColor:contrastColor}else{delete point.contrastColor}if(seriesOptions.cursor){style.cursor=seriesOptions.cursor}}attr={r:labelOptions.borderRadius||0,rotation:rotation,padding:labelOptions.padding,zIndex:1};if(!chart.styledMode){attr.fill=backgroundColor==="auto"?point.color:backgroundColor;attr.stroke=borderColor==="auto"?point.color:borderColor;attr["stroke-width"]=labelOptions.borderWidth}DataLabel_objectEach(attr,(val,name)=>{if(typeof val==="undefined"){delete attr[name]}})}if(dataLabel&&(!labelEnabled||!DataLabel_defined(labelText)||!!dataLabel.div!==!!labelOptions.useHTML||(!dataLabel.rotation||!labelOptions.rotation)&&dataLabel.rotation!==labelOptions.rotation)){dataLabel=void 0;isNew=true}if(labelEnabled&&DataLabel_defined(labelText)){if(!dataLabel){dataLabel=renderer.label(labelText,0,0,labelOptions.shape,void 0,void 0,labelOptions.useHTML,void 0,"data-label");dataLabel.addClass(" highcharts-data-label-color-"+point.colorIndex+" "+(labelOptions.className||"")+(labelOptions.useHTML?" highcharts-tracker":""))}else{attr.text=labelText}if(dataLabel){dataLabel.options=labelOptions;dataLabel.attr(attr);if(!chart.styledMode){dataLabel.css(style).shadow(labelOptions.shadow)}else if(style.width){dataLabel.css({width:style.width,textOverflow:style.textOverflow,whiteSpace:style.whiteSpace})}DataLabel_fireEvent(dataLabel,"beforeAddingDataLabel",{labelOptions:labelOptions,point:point});if(!dataLabel.added){dataLabel.add(dataLabelsGroup)}series.alignDataLabel(point,dataLabel,labelOptions,void 0,isNew);dataLabel.isActive=true;if(dataLabels[i]&&dataLabels[i]!==dataLabel){dataLabels[i].destroy()}dataLabels[i]=dataLabel}}});let j=dataLabels.length;while(j--){if(!dataLabels[j]||!dataLabels[j].isActive){dataLabels[j]?.destroy();dataLabels.splice(j,1)}else{dataLabels[j].isActive=false}}point.dataLabel=dataLabels[0];point.dataLabels=dataLabels})}DataLabel_fireEvent(this,"afterDrawDataLabels")}function justifyDataLabel(dataLabel,options,alignAttr,bBox,alignTo,isNew){const chart=this.chart,align=options.align,verticalAlign=options.verticalAlign,padding=dataLabel.box?0:dataLabel.padding||0,horizontalAxis=chart.inverted?this.yAxis:this.xAxis,horizontalAxisShift=horizontalAxis?horizontalAxis.left-chart.plotLeft:0,verticalAxis=chart.inverted?this.xAxis:this.yAxis,verticalAxisShift=verticalAxis?verticalAxis.top-chart.plotTop:0;let{x=0,y=0}=options,off,justified;off=(alignAttr.x||0)+padding+horizontalAxisShift;if(off<0){if(align==="right"&&x>=0){options.align="left";options.inside=true}else{x-=off}justified=true}off=(alignAttr.x||0)+bBox.width-padding+horizontalAxisShift;if(off>chart.plotWidth){if(align==="left"&&x<=0){options.align="right";options.inside=true}else{x+=chart.plotWidth-off}justified=true}off=alignAttr.y+padding+verticalAxisShift;if(off<0){if(verticalAlign==="bottom"&&y>=0){options.verticalAlign="top";options.inside=true}else{y-=off}justified=true}off=(alignAttr.y||0)+bBox.height-padding+verticalAxisShift;if(off>chart.plotHeight){if(verticalAlign==="top"&&y<=0){options.verticalAlign="bottom";options.inside=true}else{y+=chart.plotHeight-off}justified=true}if(justified){options.x=x;options.y=y;dataLabel.placed=!isNew;dataLabel.align(options,void 0,alignTo)}return justified}function mergeArrays(one,two){let res=[],i;if(DataLabel_isArray(one)&&!DataLabel_isArray(two)){res=one.map(function(el){return DataLabel_merge(el,two)})}else if(DataLabel_isArray(two)&&!DataLabel_isArray(one)){res=two.map(function(el){return DataLabel_merge(one,el)})}else if(!DataLabel_isArray(one)&&!DataLabel_isArray(two)){res=DataLabel_merge(one,two)}else if(DataLabel_isArray(one)&&DataLabel_isArray(two)){i=Math.max(one.length,two.length);while(i--){res[i]=DataLabel_merge(one[i],two[i])}}return res}function mergedDataLabelOptions(series){const plotOptions=series.chart.options.plotOptions;return DataLabel_splat(mergeArrays(mergeArrays(plotOptions?.series?.dataLabels,plotOptions?.[series.type]?.dataLabels),series.options.dataLabels))}function setDataLabelStartPos(point,dataLabel,isNew,isInside,alignOptions){const chart=this.chart,inverted=chart.inverted,xAxis=this.xAxis,reversed=xAxis.reversed,labelCenter=((inverted?dataLabel.height:dataLabel.width)||0)/2,pointWidth=point.pointWidth,halfWidth=pointWidth?pointWidth/2:0;dataLabel.startXPos=inverted?alignOptions.x:reversed?-labelCenter-halfWidth:xAxis.width-labelCenter+halfWidth;dataLabel.startYPos=inverted?reversed?this.yAxis.height-labelCenter+halfWidth:-labelCenter-halfWidth:alignOptions.y;if(!isInside){dataLabel.attr({opacity:1}).animate({opacity:0},void 0,dataLabel.hide)}else if(dataLabel.visibility==="hidden"){dataLabel.show();dataLabel.attr({opacity:0}).animate({opacity:1})}if(!chart.hasRendered){return}if(isNew){dataLabel.attr({x:dataLabel.startXPos,y:dataLabel.startYPos})}dataLabel.placed=true}})(DataLabel||(DataLabel={}));const Series_DataLabel=DataLabel;"";const{composed:ColumnDataLabel_composed}=Core_Globals;const{series:ColumnDataLabel_Series}=Series_SeriesRegistry;const{merge:ColumnDataLabel_merge,pick:ColumnDataLabel_pick,pushUnique:ColumnDataLabel_pushUnique}=Core_Utilities;var ColumnDataLabel;(function(ColumnDataLabel){function alignDataLabel(point,dataLabel,options,alignTo,isNew){const inverted=this.chart.inverted,series=point.series,xLen=(series.xAxis?series.xAxis.len:this.chart.plotSizeX)||0,yLen=(series.yAxis?series.yAxis.len:this.chart.plotSizeY)||0,dlBox=point.dlBox||point.shapeArgs,below=ColumnDataLabel_pick(point.below,point.plotY>ColumnDataLabel_pick(this.translatedThreshold,yLen)),inside=ColumnDataLabel_pick(options.inside,!!this.options.stacking);if(dlBox){alignTo=ColumnDataLabel_merge(dlBox);if(!(options.overflow==="allow"&&options.crop===false)){if(alignTo.y<0){alignTo.height+=alignTo.y;alignTo.y=0}const overshoot=alignTo.y+alignTo.height-yLen;if(overshoot>0&&overshoot<alignTo.height-1){alignTo.height-=overshoot}}if(inverted){alignTo={x:yLen-alignTo.y-alignTo.height,y:xLen-alignTo.x-alignTo.width,width:alignTo.height,height:alignTo.width}}if(!inside){if(inverted){alignTo.x+=below?0:alignTo.width;alignTo.width=0}else{alignTo.y+=below?alignTo.height:0;alignTo.height=0}}}options.align=ColumnDataLabel_pick(options.align,!inverted||inside?"center":below?"right":"left");options.verticalAlign=ColumnDataLabel_pick(options.verticalAlign,inverted||inside?"middle":below?"top":"bottom");ColumnDataLabel_Series.prototype.alignDataLabel.call(this,point,dataLabel,options,alignTo,isNew);if(options.inside&&point.contrastColor){dataLabel.css({color:point.contrastColor})}}function compose(ColumnSeriesClass){Series_DataLabel.compose(ColumnDataLabel_Series);if(ColumnDataLabel_pushUnique(ColumnDataLabel_composed,"ColumnDataLabel")){ColumnSeriesClass.prototype.alignDataLabel=alignDataLabel}}ColumnDataLabel.compose=compose})(ColumnDataLabel||(ColumnDataLabel={}));const Column_ColumnDataLabel=ColumnDataLabel;const{extend:BarSeries_extend,merge:BarSeries_merge}=Core_Utilities;class BarSeries extends Column_ColumnSeries{}BarSeries.defaultOptions=BarSeries_merge(Column_ColumnSeries.defaultOptions,{});BarSeries_extend(BarSeries.prototype,{inverted:true});Series_SeriesRegistry.registerSeriesType("bar",BarSeries);const Bar_BarSeries=null&&BarSeries;"";const ScatterSeriesDefaults={lineWidth:0,findNearestPointBy:"xy",jitter:{x:0,y:0},marker:{enabled:true},tooltip:{headerFormat:'<span style="color:{point.color}">●</span> '+'<span style="font-size: 0.8em"> {series.name}</span><br/>',pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}};"";const Scatter_ScatterSeriesDefaults=ScatterSeriesDefaults;const{column:ScatterSeries_ColumnSeries,line:ScatterSeries_LineSeries}=Series_SeriesRegistry.seriesTypes;const{addEvent:ScatterSeries_addEvent,extend:ScatterSeries_extend,merge:ScatterSeries_merge}=Core_Utilities;class ScatterSeries extends ScatterSeries_LineSeries{applyJitter(){const series=this,jitter=this.options.jitter,len=this.points.length;function unrandom(seed){const rand=Math.sin(seed)*1e4;return rand-Math.floor(rand)}if(jitter){this.points.forEach(function(point,i){["x","y"].forEach(function(dim,j){if(jitter[dim]&&!point.isNull){const plotProp=`plot${dim.toUpperCase()}`,axis=series[`${dim}Axis`],translatedJitter=jitter[dim]*axis.transA;if(axis&&!axis.logarithmic){const min=Math.max(0,(point[plotProp]||0)-translatedJitter),max=Math.min(axis.len,(point[plotProp]||0)+translatedJitter);point[plotProp]=min+(max-min)*unrandom(i+j*len);if(dim==="x"){point.clientX=point.plotX}}}})})}}drawGraph(){if(this.options.lineWidth){super.drawGraph()}else if(this.graph){this.graph=this.graph.destroy()}}}ScatterSeries.defaultOptions=ScatterSeries_merge(ScatterSeries_LineSeries.defaultOptions,Scatter_ScatterSeriesDefaults);ScatterSeries_extend(ScatterSeries.prototype,{drawTracker:ScatterSeries_ColumnSeries.prototype.drawTracker,sorted:false,requireSorting:false,noSharedTooltip:true,trackerGroups:["group","markerGroup","dataLabelsGroup"]});ScatterSeries_addEvent(ScatterSeries,"afterTranslate",function(){this.applyJitter()});Series_SeriesRegistry.registerSeriesType("scatter",ScatterSeries);const Scatter_ScatterSeries=null&&ScatterSeries;const{deg2rad:CenteredUtilities_deg2rad}=Core_Globals;const{fireEvent:CenteredUtilities_fireEvent,isNumber:CenteredUtilities_isNumber,pick:CenteredUtilities_pick,relativeLength:CenteredUtilities_relativeLength}=Core_Utilities;var CenteredUtilities;(function(CenteredUtilities){function getCenter(){const options=this.options,chart=this.chart,slicingRoom=2*(options.slicedOffset||0),plotWidth=chart.plotWidth-2*slicingRoom,plotHeight=chart.plotHeight-2*slicingRoom,centerOption=options.center,smallestSize=Math.min(plotWidth,plotHeight),thickness=options.thickness;let handleSlicingRoom,size=options.size,innerSize=options.innerSize||0,i,value;if(typeof size==="string"){size=parseFloat(size)}if(typeof innerSize==="string"){innerSize=parseFloat(innerSize)}const positions=[CenteredUtilities_pick(centerOption?.[0],"50%"),CenteredUtilities_pick(centerOption?.[1],"50%"),CenteredUtilities_pick(size&&size<0?void 0:options.size,"100%"),CenteredUtilities_pick(innerSize&&innerSize<0?void 0:options.innerSize||0,"0%")];if(chart.angular&&!(this instanceof Series_Series)){positions[3]=0}for(i=0;i<4;++i){value=positions[i];handleSlicingRoom=i<2||i===2&&/%$/.test(value);positions[i]=CenteredUtilities_relativeLength(value,[plotWidth,plotHeight,smallestSize,positions[2]][i])+(handleSlicingRoom?slicingRoom:0)}if(positions[3]>positions[2]){positions[3]=positions[2]}if(CenteredUtilities_isNumber(thickness)&&thickness*2<positions[2]&&thickness>0){positions[3]=positions[2]-thickness*2}CenteredUtilities_fireEvent(this,"afterGetCenter",{positions:positions});return positions}CenteredUtilities.getCenter=getCenter;function getStartAndEndRadians(start,end){const startAngle=CenteredUtilities_isNumber(start)?start:0,endAngle=CenteredUtilities_isNumber(end)&&end>startAngle&&end-startAngle<360?end:startAngle+360,correction=-90;return{start:CenteredUtilities_deg2rad*(startAngle+correction),end:CenteredUtilities_deg2rad*(endAngle+correction)}}CenteredUtilities.getStartAndEndRadians=getStartAndEndRadians})(CenteredUtilities||(CenteredUtilities={}));const Series_CenteredUtilities=CenteredUtilities;"";const{setAnimation:PiePoint_setAnimation}=AnimationUtilities;const{addEvent:PiePoint_addEvent,defined:PiePoint_defined,extend:PiePoint_extend,isNumber:PiePoint_isNumber,pick:PiePoint_pick,relativeLength:PiePoint_relativeLength}=Core_Utilities;class PiePoint extends Series_Point{getConnectorPath(dataLabel){const labelPosition=dataLabel.dataLabelPosition,options=dataLabel.options||{},connectorShape=options.connectorShape,shapeFunc=this.connectorShapes[connectorShape]||connectorShape;return labelPosition&&shapeFunc.call(this,{...labelPosition.computed,alignment:labelPosition.alignment},labelPosition.connectorPosition,options)||[]}getTranslate(){return this.sliced&&this.slicedTranslation||{translateX:0,translateY:0}}haloPath(size){const shapeArgs=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(shapeArgs.x,shapeArgs.y,shapeArgs.r+size,shapeArgs.r+size,{innerR:shapeArgs.r-1,start:shapeArgs.start,end:shapeArgs.end,borderRadius:shapeArgs.borderRadius})}constructor(series,options,x){super(series,options,x);this.half=0;this.name??(this.name="Slice");const toggleSlice=e=>{this.slice(e.type==="select")};PiePoint_addEvent(this,"select",toggleSlice);PiePoint_addEvent(this,"unselect",toggleSlice)}isValid(){return PiePoint_isNumber(this.y)&&this.y>=0}setVisible(vis,redraw=true){if(vis!==this.visible){this.update({visible:vis??!this.visible},redraw,void 0,false)}}slice(sliced,redraw,animation){const series=this.series,chart=series.chart;PiePoint_setAnimation(animation,chart);redraw=PiePoint_pick(redraw,true);this.sliced=this.options.sliced=sliced=PiePoint_defined(sliced)?sliced:!this.sliced;series.options.data[series.data.indexOf(this)]=this.options;if(this.graphic){this.graphic.animate(this.getTranslate())}}}PiePoint_extend(PiePoint.prototype,{connectorShapes:{fixedOffset:function(labelPosition,connectorPosition,options){const breakAt=connectorPosition.breakAt,touchingSliceAt=connectorPosition.touchingSliceAt,lineSegment=options.softConnector?["C",labelPosition.x+(labelPosition.alignment==="left"?-5:5),labelPosition.y,2*breakAt.x-touchingSliceAt.x,2*breakAt.y-touchingSliceAt.y,breakAt.x,breakAt.y]:["L",breakAt.x,breakAt.y];return[["M",labelPosition.x,labelPosition.y],lineSegment,["L",touchingSliceAt.x,touchingSliceAt.y]]},straight:function(labelPosition,connectorPosition){const touchingSliceAt=connectorPosition.touchingSliceAt;return[["M",labelPosition.x,labelPosition.y],["L",touchingSliceAt.x,touchingSliceAt.y]]},crookedLine:function(labelPosition,connectorPosition,options){const{angle=this.angle||0,breakAt,touchingSliceAt}=connectorPosition,{series}=this,[cx,cy,diameter]=series.center,r=diameter/2,{plotLeft,plotWidth}=series.chart,leftAligned=labelPosition.alignment==="left",{x,y}=labelPosition;let crookX=breakAt.x;if(options.crookDistance){const crookDistance=PiePoint_relativeLength(options.crookDistance,1);crookX=leftAligned?cx+r+(plotWidth+plotLeft-cx-r)*(1-crookDistance):plotLeft+(cx-r)*crookDistance}else{crookX=cx+(cy-y)*Math.tan(angle-Math.PI/2)}const path=[["M",x,y]];if(leftAligned?crookX<=x&&crookX>=breakAt.x:crookX>=x&&crookX<=breakAt.x){path.push(["L",crookX,y])}path.push(["L",breakAt.x,breakAt.y],["L",touchingSliceAt.x,touchingSliceAt.y]);return path}}});const Pie_PiePoint=PiePoint;const PieSeriesDefaults={borderRadius:3,center:[null,null],clip:false,colorByPoint:true,dataLabels:{connectorPadding:5,connectorShape:"crookedLine",crookDistance:void 0,distance:30,enabled:true,formatter:function(){return this.isNull?void 0:this.name},softConnector:true,x:0},fillColor:void 0,ignoreHiddenPoint:true,inactiveOtherPoints:true,legendType:"point",marker:null,size:null,showInLegend:false,slicedOffset:10,stickyTracking:false,tooltip:{followPointer:true},borderColor:"#ffffff",borderWidth:1,lineWidth:void 0,states:{hover:{brightness:.1}}};"";const Pie_PieSeriesDefaults=PieSeriesDefaults;const{getStartAndEndRadians}=Series_CenteredUtilities;const{noop:PieSeries_noop}=Core_Globals;const{clamp:PieSeries_clamp,extend:PieSeries_extend,fireEvent:PieSeries_fireEvent,merge:PieSeries_merge,pick:PieSeries_pick}=Core_Utilities;class PieSeries extends Series_Series{animate(init){const series=this,points=series.points,startAngleRad=series.startAngleRad;if(!init){points.forEach(function(point){const graphic=point.graphic,args=point.shapeArgs;if(graphic&&args){graphic.attr({r:PieSeries_pick(point.startR,series.center&&series.center[3]/2),start:startAngleRad,end:startAngleRad});graphic.animate({r:args.r,start:args.start,end:args.end},series.options.animation)}})}}drawEmpty(){const start=this.startAngleRad,end=this.endAngleRad,options=this.options;let centerX,centerY;if(this.total===0&&this.center){centerX=this.center[0];centerY=this.center[1];if(!this.graph){this.graph=this.chart.renderer.arc(centerX,centerY,this.center[1]/2,0,start,end).addClass("highcharts-empty-series").add(this.group)}this.graph.attr({d:SVG_Symbols.arc(centerX,centerY,this.center[2]/2,0,{start:start,end:end,innerR:this.center[3]/2})});if(!this.chart.styledMode){this.graph.attr({"stroke-width":options.borderWidth,fill:options.fillColor||"none",stroke:options.color||"#cccccc"})}}else if(this.graph){this.graph=this.graph.destroy()}}drawPoints(){const renderer=this.chart.renderer;this.points.forEach(function(point){if(point.graphic&&point.hasNewShapeType()){point.graphic=point.graphic.destroy()}if(!point.graphic){point.graphic=renderer[point.shapeType](point.shapeArgs).add(point.series.group);point.delayedRendering=true}})}generatePoints(){super.generatePoints();this.updateTotals()}getX(y,left,point,dataLabel){const center=this.center,radius=this.radii?this.radii[point.index]||0:center[2]/2,labelPosition=dataLabel.dataLabelPosition,distance=labelPosition?.distance||0;const angle=Math.asin(PieSeries_clamp((y-center[1])/(radius+distance),-1,1));const x=center[0]+(left?-1:1)*(Math.cos(angle)*(radius+distance))+(distance>0?(left?-1:1)*(dataLabel.padding||0):0);return x}hasData(){return!!this.dataTable.rowCount}redrawPoints(){const series=this,chart=series.chart;let groupTranslation,graphic,pointAttr,shapeArgs;this.drawEmpty();if(series.group&&!chart.styledMode){series.group.shadow(series.options.shadow)}series.points.forEach(function(point){const animateTo={};graphic=point.graphic;if(!point.isNull&&graphic){shapeArgs=point.shapeArgs;groupTranslation=point.getTranslate();if(!chart.styledMode){pointAttr=series.pointAttribs(point,point.selected&&"select")}if(!point.delayedRendering){graphic.setRadialReference(series.center);if(!chart.styledMode){PieSeries_merge(true,animateTo,pointAttr)}PieSeries_merge(true,animateTo,shapeArgs,groupTranslation);graphic.animate(animateTo)}else{graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);if(!chart.styledMode){graphic.attr(pointAttr).attr({"stroke-linejoin":"round"})}point.delayedRendering=false}graphic.attr({visibility:point.visible?"inherit":"hidden"});graphic.addClass(point.getClassName(),true)}else if(graphic){point.graphic=graphic.destroy()}})}sortByAngle(points,sign){points.sort(function(a,b){return typeof a.angle!=="undefined"&&(b.angle-a.angle)*sign})}translate(positions){PieSeries_fireEvent(this,"translate");this.generatePoints();const series=this,precision=1e3,options=series.options,slicedOffset=options.slicedOffset,radians=getStartAndEndRadians(options.startAngle,options.endAngle),startAngleRad=series.startAngleRad=radians.start,endAngleRad=series.endAngleRad=radians.end,circ=endAngleRad-startAngleRad,points=series.points,ignoreHiddenPoint=options.ignoreHiddenPoint,len=points.length;let start,end,angle,radiusX,radiusY,i,point,cumulative=0;if(!positions){series.center=positions=series.getCenter()}for(i=0;i<len;i++){point=points[i];start=startAngleRad+cumulative*circ;if(point.isValid()&&(!ignoreHiddenPoint||point.visible)){cumulative+=point.percentage/100}end=startAngleRad+cumulative*circ;const shapeArgs={x:positions[0],y:positions[1],r:positions[2]/2,innerR:positions[3]/2,start:Math.round(start*precision)/precision,end:Math.round(end*precision)/precision};point.shapeType="arc";point.shapeArgs=shapeArgs;angle=(end+start)/2;if(angle>1.5*Math.PI){angle-=2*Math.PI}else if(angle<-Math.PI/2){angle+=2*Math.PI}point.slicedTranslation={translateX:Math.round(Math.cos(angle)*slicedOffset),translateY:Math.round(Math.sin(angle)*slicedOffset)};radiusX=Math.cos(angle)*positions[2]/2;radiusY=Math.sin(angle)*positions[2]/2;point.tooltipPos=[positions[0]+radiusX*.7,positions[1]+radiusY*.7];point.half=angle<-Math.PI/2||angle>Math.PI/2?1:0;point.angle=angle}PieSeries_fireEvent(series,"afterTranslate")}updateTotals(){const points=this.points,len=points.length,ignoreHiddenPoint=this.options.ignoreHiddenPoint;let i,point,total=0;for(i=0;i<len;i++){point=points[i];if(point.isValid()&&(!ignoreHiddenPoint||point.visible)){total+=point.y}}this.total=total;for(i=0;i<len;i++){point=points[i];point.percentage=total>0&&(point.visible||!ignoreHiddenPoint)?point.y/total*100:0;point.total=total}}}PieSeries.defaultOptions=PieSeries_merge(Series_Series.defaultOptions,Pie_PieSeriesDefaults);PieSeries_extend(PieSeries.prototype,{axisTypes:[],directTouch:true,drawGraph:void 0,drawTracker:Column_ColumnSeries.prototype.drawTracker,getCenter:Series_CenteredUtilities.getCenter,getSymbol:PieSeries_noop,invertible:false,isCartesian:false,noSharedTooltip:true,pointAttribs:Column_ColumnSeries.prototype.pointAttribs,pointClass:Pie_PiePoint,requireSorting:false,searchPoint:PieSeries_noop,trackerGroups:["group","dataLabelsGroup"]});Series_SeriesRegistry.registerSeriesType("pie",PieSeries);const Pie_PieSeries=null&&PieSeries;const{composed:PieDataLabel_composed,noop:PieDataLabel_noop}=Core_Globals;const{distribute:PieDataLabel_distribute}=Renderer_RendererUtilities;const{series:PieDataLabel_Series}=Series_SeriesRegistry;const{arrayMax:PieDataLabel_arrayMax,clamp:PieDataLabel_clamp,defined:PieDataLabel_defined,pick:PieDataLabel_pick,pushUnique:PieDataLabel_pushUnique,relativeLength:PieDataLabel_relativeLength}=Core_Utilities;var PieDataLabel_ColumnDataLabel;(function(ColumnDataLabel){const dataLabelPositioners={radialDistributionY:function(point,dataLabel){return(dataLabel.dataLabelPosition?.top||0)+point.distributeBox.pos},radialDistributionX:function(series,point,y,naturalY,dataLabel){const pos=dataLabel.dataLabelPosition;return series.getX(y<(pos?.top||0)+2||y>(pos?.bottom||0)-2?naturalY:y,point.half,point,dataLabel)},justify:function(point,dataLabel,radius,seriesCenter){return seriesCenter[0]+(point.half?-1:1)*(radius+(dataLabel.dataLabelPosition?.distance||0))},alignToPlotEdges:function(dataLabel,half,plotWidth,plotLeft){const dataLabelWidth=dataLabel.getBBox().width;return half?dataLabelWidth+plotLeft:plotWidth-dataLabelWidth-plotLeft},alignToConnectors:function(points,half,plotWidth,plotLeft){let maxDataLabelWidth=0,dataLabelWidth;points.forEach(function(point){dataLabelWidth=point.dataLabel.getBBox().width;if(dataLabelWidth>maxDataLabelWidth){maxDataLabelWidth=dataLabelWidth}});return half?maxDataLabelWidth+plotLeft:plotWidth-maxDataLabelWidth-plotLeft}};function compose(PieSeriesClass){Series_DataLabel.compose(PieDataLabel_Series);if(PieDataLabel_pushUnique(PieDataLabel_composed,"PieDataLabel")){const pieProto=PieSeriesClass.prototype;pieProto.dataLabelPositioners=dataLabelPositioners;pieProto.alignDataLabel=PieDataLabel_noop;pieProto.drawDataLabels=drawDataLabels;pieProto.getDataLabelPosition=getDataLabelPosition;pieProto.placeDataLabels=placeDataLabels;pieProto.verifyDataLabelOverflow=verifyDataLabelOverflow}}ColumnDataLabel.compose=compose;function getDataLabelPosition(point,distance){const halfPI=Math.PI/2,{start=0,end=0}=point.shapeArgs||{};let angle=point.angle||0;if(distance>0&&start<halfPI&&end>halfPI&&angle>halfPI/2&&angle<halfPI*1.5){angle=angle<=halfPI?Math.max(halfPI/2,(start+halfPI)/2):Math.min(halfPI*1.5,(halfPI+end)/2)}const{center,options}=this,r=center[2]/2,cosAngle=Math.cos(angle),sinAngle=Math.sin(angle),x=center[0]+cosAngle*r,y=center[1]+sinAngle*r,finalConnectorOffset=Math.min((options.slicedOffset||0)+(options.borderWidth||0),distance/5);return{natural:{x:x+cosAngle*distance,y:y+sinAngle*distance},computed:{},alignment:distance<0?"center":point.half?"right":"left",connectorPosition:{angle:angle,breakAt:{x:x+cosAngle*finalConnectorOffset,y:y+sinAngle*finalConnectorOffset},touchingSliceAt:{x:x,y:y}},distance:distance}}function drawDataLabels(){const series=this,points=series.points,chart=series.chart,plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,plotLeft=chart.plotLeft,maxWidth=Math.round(chart.chartWidth/3),seriesCenter=series.center,radius=seriesCenter[2]/2,centerY=seriesCenter[1],halves=[[],[]],overflow=[0,0,0,0],dataLabelPositioners=series.dataLabelPositioners;let connector,dataLabelWidth,labelHeight,maxLabelDistance=0;if(!series.visible||!series.hasDataLabels?.()){return}points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{if(dataLabel.shortened){dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"});dataLabel.shortened=false}})});PieDataLabel_Series.prototype.drawDataLabels.apply(series);points.forEach(point=>{(point.dataLabels||[]).forEach((dataLabel,i)=>{const r=seriesCenter[2]/2,dataLabelOptions=dataLabel.options,distance=PieDataLabel_relativeLength(dataLabelOptions?.distance||0,r);if(i===0){halves[point.half].push(point)}if(!PieDataLabel_defined(dataLabelOptions?.style?.width)){if(dataLabel.getBBox().width>maxWidth){dataLabel.css({width:Math.round(maxWidth*.7)+"px"});dataLabel.shortened=true}}dataLabel.dataLabelPosition=this.getDataLabelPosition(point,distance);maxLabelDistance=Math.max(maxLabelDistance,distance)})});halves.forEach((points,halfIdx)=>{const length=points.length,positions=[];let top,bottom,size=0,distributionLength;if(!length){return}series.sortByAngle(points,halfIdx-.5);if(maxLabelDistance>0){top=Math.max(0,centerY-radius-maxLabelDistance);bottom=Math.min(centerY+radius+maxLabelDistance,chart.plotHeight);points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const labelPosition=dataLabel.dataLabelPosition;if(labelPosition&&labelPosition.distance>0){labelPosition.top=Math.max(0,centerY-radius-labelPosition.distance);labelPosition.bottom=Math.min(centerY+radius+labelPosition.distance,chart.plotHeight);size=dataLabel.getBBox().height||21;dataLabel.lineHeight=chart.renderer.fontMetrics(dataLabel.text||dataLabel).h+2*dataLabel.padding;point.distributeBox={target:(dataLabel.dataLabelPosition?.natural.y||0)-labelPosition.top+dataLabel.lineHeight/2,size:size,rank:point.y};positions.push(point.distributeBox)}})});distributionLength=bottom+size-top;PieDataLabel_distribute(positions,distributionLength,distributionLength/5)}points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const dataLabelOptions=dataLabel.options||{},distributeBox=point.distributeBox,labelPosition=dataLabel.dataLabelPosition,naturalY=labelPosition?.natural.y||0,connectorPadding=dataLabelOptions.connectorPadding||0,lineHeight=dataLabel.lineHeight||21,bBox=dataLabel.getBBox(),topOffset=(lineHeight-bBox.height)/2;let x=0,y=naturalY,visibility="inherit";if(labelPosition){if(positions&&PieDataLabel_defined(distributeBox)&&labelPosition.distance>0){if(typeof distributeBox.pos==="undefined"){visibility="hidden"}else{labelHeight=distributeBox.size;y=dataLabelPositioners.radialDistributionY(point,dataLabel)}}if(dataLabelOptions.justify){x=dataLabelPositioners.justify(point,dataLabel,radius,seriesCenter)}else{switch(dataLabelOptions.alignTo){case"connectors":x=dataLabelPositioners.alignToConnectors(points,halfIdx,plotWidth,plotLeft);break;case"plotEdges":x=dataLabelPositioners.alignToPlotEdges(dataLabel,halfIdx,plotWidth,plotLeft);break;default:x=dataLabelPositioners.radialDistributionX(series,point,y-topOffset,naturalY,dataLabel)}}labelPosition.attribs={visibility:visibility,align:labelPosition.alignment};labelPosition.posAttribs={x:x+(dataLabelOptions.x||0)+({left:connectorPadding,right:-connectorPadding}[labelPosition.alignment]||0),y:y+(dataLabelOptions.y||0)-lineHeight/2};labelPosition.computed.x=x;labelPosition.computed.y=y-topOffset;if(PieDataLabel_pick(dataLabelOptions.crop,true)){dataLabelWidth=dataLabel.getBBox().width;let sideOverflow;if(x-dataLabelWidth<connectorPadding&&halfIdx===1){sideOverflow=Math.round(dataLabelWidth-x+connectorPadding);overflow[3]=Math.max(sideOverflow,overflow[3])}else if(x+dataLabelWidth>plotWidth-connectorPadding&&halfIdx===0){sideOverflow=Math.round(x+dataLabelWidth-plotWidth+connectorPadding);overflow[1]=Math.max(sideOverflow,overflow[1])}if(y-labelHeight/2<0){overflow[0]=Math.max(Math.round(-y+labelHeight/2),overflow[0])}else if(y+labelHeight/2>plotHeight){overflow[2]=Math.max(Math.round(y+labelHeight/2-plotHeight),overflow[2])}labelPosition.sideOverflow=sideOverflow}}})})});if(PieDataLabel_arrayMax(overflow)===0||this.verifyDataLabelOverflow(overflow)){this.placeDataLabels();this.points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const{connectorColor,connectorWidth=1}=dataLabel.options||{},labelPosition=dataLabel.dataLabelPosition;if(connectorWidth){let isNew;connector=dataLabel.connector;if(labelPosition&&labelPosition.distance>0){isNew=!connector;if(!connector){dataLabel.connector=connector=chart.renderer.path().addClass("highcharts-data-label-connector "+" highcharts-color-"+point.colorIndex+(point.className?" "+point.className:"")).add(series.dataLabelsGroup)}if(!chart.styledMode){connector.attr({"stroke-width":connectorWidth,stroke:connectorColor||point.color||"#666666"})}connector[isNew?"attr":"animate"]({d:point.getConnectorPath(dataLabel)});connector.attr({visibility:labelPosition.attribs?.visibility})}else if(connector){dataLabel.connector=connector.destroy()}}})})}}function placeDataLabels(){this.points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const labelPosition=dataLabel.dataLabelPosition;if(labelPosition){if(labelPosition.sideOverflow){dataLabel.css({width:Math.max(dataLabel.getBBox().width-labelPosition.sideOverflow,0)+"px",textOverflow:(dataLabel.options?.style||{}).textOverflow||"ellipsis"});dataLabel.shortened=true}dataLabel.attr(labelPosition.attribs);dataLabel[dataLabel.moved?"animate":"attr"](labelPosition.posAttribs);dataLabel.moved=true}else if(dataLabel){dataLabel.attr({y:-9999})}});delete point.distributeBox},this)}function verifyDataLabelOverflow(overflow){const center=this.center,options=this.options,centerOption=options.center,minSize=options.minSize||80;let newSize=minSize,ret=options.size!==null;if(!ret){if(centerOption[0]!==null){newSize=Math.max(center[2]-Math.max(overflow[1],overflow[3]),minSize)}else{newSize=Math.max(center[2]-overflow[1]-overflow[3],minSize);center[0]+=(overflow[3]-overflow[1])/2}if(centerOption[1]!==null){newSize=PieDataLabel_clamp(newSize,minSize,center[2]-Math.max(overflow[0],overflow[2]))}else{newSize=PieDataLabel_clamp(newSize,minSize,center[2]-overflow[0]-overflow[2]);center[1]+=(overflow[0]-overflow[2])/2}if(newSize<center[2]){center[2]=newSize;center[3]=Math.min(options.thickness?Math.max(0,newSize-options.thickness*2):Math.max(0,PieDataLabel_relativeLength(options.innerSize||0,newSize)),newSize);this.translate(center);if(this.drawDataLabels){this.drawDataLabels()}}else{ret=true}}return ret}})(PieDataLabel_ColumnDataLabel||(PieDataLabel_ColumnDataLabel={}));const PieDataLabel=PieDataLabel_ColumnDataLabel;var GeometryUtilities;(function(GeometryUtilities){function getCenterOfPoints(points){const sum=points.reduce((sum,point)=>{sum.x+=point.x;sum.y+=point.y;return sum},{x:0,y:0});return{x:sum.x/points.length,y:sum.y/points.length}}GeometryUtilities.getCenterOfPoints=getCenterOfPoints;function getDistanceBetweenPoints(p1,p2){return Math.sqrt(Math.pow(p2.x-p1.x,2)+Math.pow(p2.y-p1.y,2))}GeometryUtilities.getDistanceBetweenPoints=getDistanceBetweenPoints;function getAngleBetweenPoints(p1,p2){return Math.atan2(p2.x-p1.x,p2.y-p1.y)}GeometryUtilities.getAngleBetweenPoints=getAngleBetweenPoints;function pointInPolygon({x,y},polygon){const len=polygon.length;let i,j,inside=false;for(i=0,j=len-1;i<len;j=i++){const[x1,y1]=polygon[i],[x2,y2]=polygon[j];if(y1>y!==y2>y&&x<(x2-x1)*(y-y1)/(y2-y1)+x1){inside=!inside}}return inside}GeometryUtilities.pointInPolygon=pointInPolygon})(GeometryUtilities||(GeometryUtilities={}));const Geometry_GeometryUtilities=GeometryUtilities;const{pointInPolygon}=Geometry_GeometryUtilities;const{addEvent:OverlappingDataLabels_addEvent,fireEvent:OverlappingDataLabels_fireEvent,objectEach:OverlappingDataLabels_objectEach,pick:OverlappingDataLabels_pick}=Core_Utilities;function chartHideOverlappingLabels(labels){const chart=this,len=labels.length,isIntersectRect=(box1,box2)=>!(box2.x>=box1.x+box1.width||box2.x+box2.width<=box1.x||box2.y>=box1.y+box1.height||box2.y+box2.height<=box1.y),isPolygonOverlap=(box1Poly,box2Poly)=>{for(const p of box1Poly){if(pointInPolygon({x:p[0],y:p[1]},box2Poly)){return true}}return false};function getAbsoluteBox(label){if(label&&(!label.alignAttr||label.placed)){const padding=label.box?0:label.padding||0,pos=label.alignAttr||{x:label.attr("x"),y:label.attr("y")},bBox=label.getBBox();label.width=bBox.width;label.height=bBox.height;return{x:pos.x+(label.parentGroup?.translateX||0)+padding,y:pos.y+(label.parentGroup?.translateY||0)+padding,width:(label.width||0)-2*padding,height:(label.height||0)-2*padding,polygon:bBox?.polygon}}}let label,label1,label2,box1,box2,isLabelAffected=false;for(let i=0;i<len;i++){label=labels[i];if(label){label.oldOpacity=label.opacity;label.newOpacity=1;label.absoluteBox=getAbsoluteBox(label)}}labels.sort((a,b)=>(b.labelrank||0)-(a.labelrank||0));for(let i=0;i<len;++i){label1=labels[i];box1=label1&&label1.absoluteBox;const box1Poly=box1?.polygon;for(let j=i+1;j<len;++j){label2=labels[j];box2=label2&&label2.absoluteBox;let toHide=false;if(box1&&box2&&label1!==label2&&label1.newOpacity!==0&&label2.newOpacity!==0&&label1.visibility!=="hidden"&&label2.visibility!=="hidden"){const box2Poly=box2.polygon;if(box1Poly&&box2Poly&&box1Poly!==box2Poly){if(isPolygonOverlap(box1Poly,box2Poly)){toHide=true}}else if(isIntersectRect(box1,box2)){toHide=true}if(toHide){const overlappingLabel=label1.labelrank<label2.labelrank?label1:label2,labelText=overlappingLabel.text;overlappingLabel.newOpacity=0;if(labelText?.element.querySelector("textPath")){labelText.hide()}}}}}for(const label of labels){if(hideOrShow(label,chart)){isLabelAffected=true}}if(isLabelAffected){OverlappingDataLabels_fireEvent(chart,"afterHideAllOverlappingLabels")}}function compose(ChartClass){const chartProto=ChartClass.prototype;if(!chartProto.hideOverlappingLabels){chartProto.hideOverlappingLabels=chartHideOverlappingLabels;OverlappingDataLabels_addEvent(ChartClass,"render",OverlappingDataLabels_onChartRender)}}function hideOrShow(label,chart){let complete,newOpacity,isLabelAffected=false;if(label){newOpacity=label.newOpacity;if(label.oldOpacity!==newOpacity){if(label.hasClass("highcharts-data-label")){label[newOpacity?"removeClass":"addClass"]("highcharts-data-label-hidden");complete=function(){if(!chart.styledMode){label.css({pointerEvents:newOpacity?"auto":"none"})}};isLabelAffected=true;label[label.isOld?"animate":"attr"]({opacity:newOpacity},void 0,complete);OverlappingDataLabels_fireEvent(chart,"afterHideOverlappingLabel")}else{label.attr({opacity:newOpacity})}}label.isOld=true}return isLabelAffected}function OverlappingDataLabels_onChartRender(){const chart=this;let labels=[];for(const collector of chart.labelCollectors||[]){labels=labels.concat(collector())}for(const yAxis of chart.yAxis||[]){if(yAxis.stacking&&yAxis.options.stackLabels&&!yAxis.options.stackLabels.allowOverlap){OverlappingDataLabels_objectEach(yAxis.stacking.stacks,stack=>{OverlappingDataLabels_objectEach(stack,stackItem=>{if(stackItem.label){labels.push(stackItem.label)}})})}}for(const series of chart.series||[]){if(series.visible&&series.hasDataLabels?.()){const push=points=>{for(const point of points){if(point.visible){(point.dataLabels||[]).forEach(label=>{const options=label.options||{};label.labelrank=OverlappingDataLabels_pick(options.labelrank,point.labelrank,point.shapeArgs?.height);if(options.allowOverlap??Number(options.distance)>0){label.oldOpacity=label.opacity;label.newOpacity=1;hideOrShow(label,chart)}else{labels.push(label)}})}}};push(series.nodes||[]);push(series.points)}}this.hideOverlappingLabels(labels)}const OverlappingDataLabels={compose:compose};const Extensions_OverlappingDataLabels=OverlappingDataLabels;const{defaultOptions:BorderRadius_defaultOptions}=Defaults;const{noop:BorderRadius_noop}=Core_Globals;const{addEvent:BorderRadius_addEvent,extend:BorderRadius_extend,isObject:BorderRadius_isObject,merge:BorderRadius_merge,relativeLength:BorderRadius_relativeLength}=Core_Utilities;const defaultBorderRadiusOptions={radius:0,scope:"stack",where:void 0};let oldArc=BorderRadius_noop;let oldRoundedRect=BorderRadius_noop;function applyBorderRadius(path,i,r){const a=path[i];let b=path[i+1];if(b[0]==="Z"){b=path[0]}let line,arc,fromLineToArc;if((a[0]==="M"||a[0]==="L")&&b[0]==="A"){line=a;arc=b;fromLineToArc=true}else if(a[0]==="A"&&(b[0]==="M"||b[0]==="L")){line=b;arc=a}if(line&&arc&&arc.params){const bigR=arc[1],clockwise=arc[5],params=arc.params,{start,end,cx,cy}=params;const relativeR=clockwise?bigR-r:bigR+r,angleOfBorderRadius=relativeR?Math.asin(r/relativeR):0,angleOffset=clockwise?angleOfBorderRadius:-angleOfBorderRadius,distanceBigCenterToStartArc=Math.cos(angleOfBorderRadius)*relativeR;if(fromLineToArc){params.start=start+angleOffset;line[1]=cx+distanceBigCenterToStartArc*Math.cos(start);line[2]=cy+distanceBigCenterToStartArc*Math.sin(start);path.splice(i+1,0,["A",r,r,0,0,1,cx+bigR*Math.cos(params.start),cy+bigR*Math.sin(params.start)])}else{params.end=end-angleOffset;arc[6]=cx+bigR*Math.cos(params.end);arc[7]=cy+bigR*Math.sin(params.end);path.splice(i+1,0,["A",r,r,0,0,1,cx+distanceBigCenterToStartArc*Math.cos(end),cy+distanceBigCenterToStartArc*Math.sin(end)])}arc[4]=Math.abs(params.end-params.start)<Math.PI?0:1}}function BorderRadius_arc(x,y,w,h,options={}){const path=oldArc(x,y,w,h,options),{innerR=0,r=w,start=0,end=0}=options;if(options.open||!options.borderRadius){return path}const alpha=end-start,sinHalfAlpha=Math.sin(alpha/2),borderRadius=Math.max(Math.min(BorderRadius_relativeLength(options.borderRadius||0,r-innerR),(r-innerR)/2,r*sinHalfAlpha/(1+sinHalfAlpha)),0),innerBorderRadius=Math.min(borderRadius,2*(alpha/Math.PI)*innerR);let i=path.length-1;while(i--){applyBorderRadius(path,i,i>1?innerBorderRadius:borderRadius)}return path}function seriesOnAfterColumnTranslate(){if(this.options.borderRadius&&!(this.chart.is3d&&this.chart.is3d())){const{options,yAxis}=this,percent=options.stacking==="percent",seriesDefault=BorderRadius_defaultOptions.plotOptions?.[this.type]?.borderRadius,borderRadius=optionsToObject(options.borderRadius,BorderRadius_isObject(seriesDefault)?seriesDefault:{}),reversed=yAxis.options.reversed;for(const point of this.points){const{shapeArgs}=point;if(point.shapeType==="roundedRect"&&shapeArgs){const{width=0,height=0,y=0}=shapeArgs;let brBoxY=y,brBoxHeight=height;if(borderRadius.scope==="stack"&&point.stackTotal){const stackEnd=yAxis.translate(percent?100:point.stackTotal,false,true,false,true),stackThreshold=yAxis.translate(options.threshold||0,false,true,false,true),box=this.crispCol(0,Math.min(stackEnd,stackThreshold),0,Math.abs(stackEnd-stackThreshold));brBoxY=box.y;brBoxHeight=box.height}const flip=(point.negative?-1:1)*(reversed?-1:1)===-1;let where=borderRadius.where;if(!where&&this.is("waterfall")&&Math.abs((point.yBottom||0)-(this.translatedThreshold||0))>this.borderWidth){where="all"}if(!where){where="end"}const r=Math.min(BorderRadius_relativeLength(borderRadius.radius,width),width/2,where==="all"?height/2:Infinity)||0;if(where==="end"){if(flip){brBoxY-=r;brBoxHeight+=r}else{brBoxHeight+=r}}BorderRadius_extend(shapeArgs,{brBoxHeight:brBoxHeight,brBoxY:brBoxY,r:r})}}}}function BorderRadius_compose(SeriesClass,SVGElementClass,SVGRendererClass){const PieSeriesClass=SeriesClass.types.pie;if(!SVGElementClass.symbolCustomAttribs.includes("borderRadius")){const symbols=SVGRendererClass.prototype.symbols;BorderRadius_addEvent(SeriesClass,"afterColumnTranslate",seriesOnAfterColumnTranslate,{order:9});BorderRadius_addEvent(PieSeriesClass,"afterTranslate",pieSeriesOnAfterTranslate);SVGElementClass.symbolCustomAttribs.push("borderRadius","brBoxHeight","brBoxY");oldArc=symbols.arc;oldRoundedRect=symbols.roundedRect;symbols.arc=BorderRadius_arc;symbols.roundedRect=BorderRadius_roundedRect}}function optionsToObject(options,seriesBROptions){if(!BorderRadius_isObject(options)){options={radius:options||0}}return BorderRadius_merge(defaultBorderRadiusOptions,seriesBROptions,options)}function pieSeriesOnAfterTranslate(){const borderRadius=optionsToObject(this.options.borderRadius);for(const point of this.points){const shapeArgs=point.shapeArgs;if(shapeArgs){shapeArgs.borderRadius=BorderRadius_relativeLength(borderRadius.radius,(shapeArgs.r||0)-(shapeArgs.innerR||0))}}}function BorderRadius_roundedRect(x,y,width,height,options={}){const path=oldRoundedRect(x,y,width,height,options),{r=0,brBoxHeight=height,brBoxY=y}=options,brOffsetTop=y-brBoxY,brOffsetBtm=brBoxY+brBoxHeight-(y+height),rTop=brOffsetTop-r>-.1?0:r,rBtm=brOffsetBtm-r>-.1?0:r,cutTop=Math.max(rTop&&brOffsetTop,0),cutBtm=Math.max(rBtm&&brOffsetBtm,0);const a=[x+rTop,y],b=[x+width-rTop,y],c=[x+width,y+rTop],d=[x+width,y+height-rBtm],e=[x+width-rBtm,y+height],f=[x+rBtm,y+height],g=[x,y+height-rBtm],h=[x,y+rTop];const applyPythagoras=(r,altitude)=>Math.sqrt(Math.pow(r,2)-Math.pow(altitude,2));if(cutTop){const base=applyPythagoras(rTop,rTop-cutTop);a[0]-=base;b[0]+=base;c[1]=h[1]=y+rTop-cutTop}if(height<rTop-cutTop){const base=applyPythagoras(rTop,rTop-cutTop-height);c[0]=d[0]=x+width-rTop+base;e[0]=Math.min(c[0],e[0]);f[0]=Math.max(d[0],f[0]);g[0]=h[0]=x+rTop-base;c[1]=h[1]=y+height}if(cutBtm){const base=applyPythagoras(rBtm,rBtm-cutBtm);e[0]+=base;f[0]-=base;d[1]=g[1]=y+height-rBtm+cutBtm}if(height<rBtm-cutBtm){const base=applyPythagoras(rBtm,rBtm-cutBtm-height);c[0]=d[0]=x+width-rBtm+base;b[0]=Math.min(c[0],b[0]);a[0]=Math.max(d[0],a[0]);g[0]=h[0]=x+rBtm-base;d[1]=g[1]=y}path.length=0;path.push(["M",...a],["L",...b],["A",rTop,rTop,0,0,1,...c],["L",...d],["A",rBtm,rBtm,0,0,1,...e],["L",...f],["A",rBtm,rBtm,0,0,1,...g],["L",...h],["A",rTop,rTop,0,0,1,...a],["Z"]);return path}const BorderRadius={compose:BorderRadius_compose,optionsToObject:optionsToObject};const Extensions_BorderRadius=BorderRadius;"";const{diffObjects:Responsive_diffObjects,extend:Responsive_extend,find:Responsive_find,merge:Responsive_merge,pick:Responsive_pick,uniqueKey:Responsive_uniqueKey}=Core_Utilities;var Responsive;(function(Responsive){function compose(ChartClass){const chartProto=ChartClass.prototype;if(!chartProto.matchResponsiveRule){Responsive_extend(chartProto,{matchResponsiveRule:matchResponsiveRule,setResponsive:setResponsive})}return ChartClass}Responsive.compose=compose;function matchResponsiveRule(rule,matches){const condition=rule.condition,fn=condition.callback||function(){return this.chartWidth<=Responsive_pick(condition.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=Responsive_pick(condition.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=Responsive_pick(condition.minWidth,0)&&this.chartHeight>=Responsive_pick(condition.minHeight,0)};if(fn.call(this)){matches.push(rule._id)}}function setResponsive(redraw,reset){const options=this.options.responsive,currentResponsive=this.currentResponsive;let ruleIds=[],undoOptions;if(!reset&&options&&options.rules){options.rules.forEach(rule=>{if(typeof rule._id==="undefined"){rule._id=Responsive_uniqueKey()}this.matchResponsiveRule(rule,ruleIds)},this)}const mergedOptions=Responsive_merge(...ruleIds.map(ruleId=>Responsive_find((options||{}).rules||[],rule=>rule._id===ruleId)).map(rule=>rule&&rule.chartOptions));mergedOptions.isResponsiveOptions=true;ruleIds=ruleIds.toString()||void 0;const currentRuleIds=currentResponsive&&currentResponsive.ruleIds;if(ruleIds!==currentRuleIds){if(currentResponsive){this.currentResponsive=void 0;this.updatingResponsive=true;this.update(currentResponsive.undoOptions,redraw,true);this.updatingResponsive=false}if(ruleIds){undoOptions=Responsive_diffObjects(mergedOptions,this.options,true,this.collectionsWithUpdate);undoOptions.isResponsiveOptions=true;this.currentResponsive={ruleIds:ruleIds,mergedOptions:mergedOptions,undoOptions:undoOptions};if(!this.updatingResponsive){this.update(mergedOptions,redraw,true)}}else{this.currentResponsive=void 0}}}})(Responsive||(Responsive={}));const Core_Responsive=Responsive;"";"";const G=Core_Globals;G.AST=HTML_AST;G.Axis=Axis_Axis;G.Chart=Chart_Chart;G.Color=Color_Color;G.DataLabel=Series_DataLabel;G.DataTableCore=Data_DataTableCore;G.Fx=Animation_Fx;G.HTMLElement=HTML_HTMLElement;G.Legend=Legend_Legend;G.LegendSymbol=Legend_LegendSymbol;G.OverlappingDataLabels=G.OverlappingDataLabels||Extensions_OverlappingDataLabels;G.PlotLineOrBand=PlotLineOrBand_PlotLineOrBand;G.Point=Series_Point;G.Pointer=Core_Pointer;G.RendererRegistry=Renderer_RendererRegistry;G.Series=Series_Series;G.SeriesRegistry=Series_SeriesRegistry;G.StackItem=Stacking_StackItem;G.SVGElement=SVG_SVGElement;G.SVGRenderer=SVG_SVGRenderer;G.Templating=Core_Templating;G.Tick=Axis_Tick;G.Time=Core_Time;G.Tooltip=Core_Tooltip;G.animate=AnimationUtilities.animate;G.animObject=AnimationUtilities.animObject;G.chart=Chart_Chart.chart;G.color=Color_Color.parse;G.dateFormat=Core_Templating.dateFormat;G.defaultOptions=Defaults.defaultOptions;G.distribute=Renderer_RendererUtilities.distribute;G.format=Core_Templating.format;G.getDeferredAnimation=AnimationUtilities.getDeferredAnimation;G.getOptions=Defaults.getOptions;G.numberFormat=Core_Templating.numberFormat;G.seriesType=Series_SeriesRegistry.seriesType;G.setAnimation=AnimationUtilities.setAnimation;G.setOptions=Defaults.setOptions;G.stop=AnimationUtilities.stop;G.time=Defaults.defaultTime;G.timers=Animation_Fx.timers;Extensions_BorderRadius.compose(G.Series,G.SVGElement,G.SVGRenderer);Column_ColumnDataLabel.compose(G.Series.types.column);Series_DataLabel.compose(G.Series);Axis_DateTimeAxis.compose(G.Axis);HTML_HTMLElement.compose(G.SVGRenderer);Legend_Legend.compose(G.Chart);Axis_LogarithmicAxis.compose(G.Axis);Extensions_OverlappingDataLabels.compose(G.Chart);PieDataLabel.compose(G.Series.types.pie);PlotLineOrBand_PlotLineOrBand.compose(G.Chart,G.Axis);Core_Pointer.compose(G.Chart);Core_Responsive.compose(G.Chart);Extensions_ScrollablePlotArea.compose(G.Axis,G.Chart,G.Series);Stacking_StackingAxis.compose(G.Axis,G.Chart,G.Series);Core_Tooltip.compose(G.Pointer);Core_Utilities.extend(G,Core_Utilities);const highcharts_src=G;const{isTouchDevice:ChartNavigatorComposition_isTouchDevice}=Core_Globals;const{addEvent:ChartNavigatorComposition_addEvent,merge:ChartNavigatorComposition_merge,pick:ChartNavigatorComposition_pick}=Core_Utilities;const composedMembers=[];let NavigatorConstructor;function ChartNavigatorComposition_compose(ChartClass,NavigatorClass){if(Core_Utilities.pushUnique(composedMembers,ChartClass)){const chartProto=ChartClass.prototype;NavigatorConstructor=NavigatorClass;chartProto.callbacks.push(onChartCallback);ChartNavigatorComposition_addEvent(ChartClass,"afterAddSeries",onChartAfterAddSeries);ChartNavigatorComposition_addEvent(ChartClass,"afterSetChartSize",onChartAfterSetChartSize);ChartNavigatorComposition_addEvent(ChartClass,"afterUpdate",onChartAfterUpdate);ChartNavigatorComposition_addEvent(ChartClass,"beforeRender",onChartBeforeRender);ChartNavigatorComposition_addEvent(ChartClass,"beforeShowResetZoom",onChartBeforeShowResetZoom);ChartNavigatorComposition_addEvent(ChartClass,"update",onChartUpdate)}}function onChartAfterAddSeries(){if(this.navigator){this.navigator.setBaseSeries(null,false)}}function onChartAfterSetChartSize(){const legend=this.legend,navigator=this.navigator;let legendOptions,xAxis,yAxis;if(navigator){legendOptions=legend&&legend.options;xAxis=navigator.xAxis;yAxis=navigator.yAxis;const{scrollbarHeight,scrollButtonSize}=navigator;if(this.inverted){navigator.left=navigator.opposite?this.chartWidth-scrollbarHeight-navigator.height:this.spacing[3]+scrollbarHeight;navigator.top=this.plotTop+scrollButtonSize}else{navigator.left=ChartNavigatorComposition_pick(xAxis.left,this.plotLeft+scrollButtonSize);navigator.top=navigator.navigatorOptions.top||this.chartHeight-navigator.height-scrollbarHeight-(this.scrollbar?.options.margin||0)-this.spacing[2]-(this.rangeSelector&&this.extraBottomMargin?this.rangeSelector.getHeight():0)-(legendOptions&&legendOptions.verticalAlign==="bottom"&&legendOptions.layout!=="proximate"&&legendOptions.enabled&&!legendOptions.floating?legend.legendHeight+ChartNavigatorComposition_pick(legendOptions.margin,10):0)-(this.titleOffset?this.titleOffset[2]:0)}if(xAxis&&yAxis){if(this.inverted){xAxis.options.left=yAxis.options.left=navigator.left}else{xAxis.options.top=yAxis.options.top=navigator.top}xAxis.setAxisSize();yAxis.setAxisSize()}}}function onChartAfterUpdate(event){if(!this.navigator&&!this.scroller&&(this.options.navigator.enabled||this.options.scrollbar.enabled)){this.scroller=this.navigator=new NavigatorConstructor(this);if(ChartNavigatorComposition_pick(event.redraw,true)){this.redraw(event.animation)}}}function onChartBeforeRender(){const options=this.options;if(options.navigator.enabled||options.scrollbar.enabled){this.scroller=this.navigator=new NavigatorConstructor(this)}}function onChartBeforeShowResetZoom(){const chartOptions=this.options,navigator=chartOptions.navigator,rangeSelector=chartOptions.rangeSelector;if((navigator&&navigator.enabled||rangeSelector&&rangeSelector.enabled)&&(!ChartNavigatorComposition_isTouchDevice&&this.zooming.type==="x"||ChartNavigatorComposition_isTouchDevice&&this.zooming.pinchType==="x")){return false}}function onChartCallback(chart){const navigator=chart.navigator;if(navigator&&chart.xAxis[0]){const extremes=chart.xAxis[0].getExtremes();navigator.render(extremes.min,extremes.max)}}function onChartUpdate(e){const navigatorOptions=e.options.navigator||{},scrollbarOptions=e.options.scrollbar||{};if(!this.navigator&&!this.scroller&&(navigatorOptions.enabled||scrollbarOptions.enabled)){ChartNavigatorComposition_merge(true,this.options.navigator,navigatorOptions);ChartNavigatorComposition_merge(true,this.options.scrollbar,scrollbarOptions);delete e.options.navigator;delete e.options.scrollbar}}const ChartNavigatorComposition={compose:ChartNavigatorComposition_compose};const Navigator_ChartNavigatorComposition=ChartNavigatorComposition;const{isTouchDevice:NavigatorAxisComposition_isTouchDevice}=Core_Globals;const{addEvent:NavigatorAxisComposition_addEvent,correctFloat:NavigatorAxisComposition_correctFloat,defined:NavigatorAxisComposition_defined,isNumber:NavigatorAxisComposition_isNumber,pick:NavigatorAxisComposition_pick}=Core_Utilities;function NavigatorAxisComposition_onAxisInit(){const axis=this;if(!axis.navigatorAxis){axis.navigatorAxis=new NavigatorAxisAdditions(axis)}}function onAxisSetExtremes(e){const axis=this,chart=axis.chart,chartOptions=chart.options,navigator=chartOptions.navigator,navigatorAxis=axis.navigatorAxis,pinchType=chart.zooming.pinchType,rangeSelector=chartOptions.rangeSelector,zoomType=chart.zooming.type;let zoomed;if(axis.isXAxis&&(navigator?.enabled||rangeSelector?.enabled)){if(zoomType==="y"&&e.trigger==="zoom"){zoomed=false}else if((e.trigger==="zoom"&&zoomType==="xy"||NavigatorAxisComposition_isTouchDevice&&pinchType==="xy")&&axis.options.range){const previousZoom=navigatorAxis.previousZoom;if(NavigatorAxisComposition_defined(e.min)){navigatorAxis.previousZoom=[axis.min,axis.max]}else if(previousZoom){e.min=previousZoom[0];e.max=previousZoom[1];navigatorAxis.previousZoom=void 0}}}if(typeof zoomed!=="undefined"){e.preventDefault()}}class NavigatorAxisAdditions{static compose(AxisClass){if(!AxisClass.keepProps.includes("navigatorAxis")){AxisClass.keepProps.push("navigatorAxis");NavigatorAxisComposition_addEvent(AxisClass,"init",NavigatorAxisComposition_onAxisInit);NavigatorAxisComposition_addEvent(AxisClass,"setExtremes",onAxisSetExtremes)}}constructor(axis){this.axis=axis}destroy(){this.axis=void 0}toFixedRange(pxMin,pxMax,fixedMin,fixedMax){const axis=this.axis,halfPointRange=(axis.pointRange||0)/2;let newMin=NavigatorAxisComposition_pick(fixedMin,axis.translate(pxMin,true,!axis.horiz)),newMax=NavigatorAxisComposition_pick(fixedMax,axis.translate(pxMax,true,!axis.horiz));if(!NavigatorAxisComposition_defined(fixedMin)){newMin=NavigatorAxisComposition_correctFloat(newMin+halfPointRange)}if(!NavigatorAxisComposition_defined(fixedMax)){newMax=NavigatorAxisComposition_correctFloat(newMax-halfPointRange)}if(!NavigatorAxisComposition_isNumber(newMin)||!NavigatorAxisComposition_isNumber(newMax)){newMin=newMax=void 0}return{min:newMin,max:newMax}}}const NavigatorAxisComposition=NavigatorAxisAdditions;const{parse:NavigatorDefaults_color}=Color_Color;const{seriesTypes:NavigatorDefaults_seriesTypes}=Series_SeriesRegistry;const NavigatorDefaults={height:40,margin:25,maskInside:true,handles:{width:7,borderRadius:0,height:15,symbols:["navigator-handle","navigator-handle"],enabled:true,lineWidth:1,backgroundColor:"#f2f2f2",borderColor:"#999999"},maskFill:NavigatorDefaults_color("#667aff").setOpacity(.3).get(),outlineColor:"#999999",outlineWidth:1,series:{type:typeof NavigatorDefaults_seriesTypes.areaspline==="undefined"?"line":"areaspline",fillOpacity:.05,lineWidth:1,compare:null,sonification:{enabled:false},dataGrouping:{approximation:"average",enabled:true,groupPixelWidth:2,firstAnchor:"firstPoint",anchor:"middle",lastAnchor:"lastPoint",units:[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2,3,4]],["week",[1,2,3]],["month",[1,3,6]],["year",null]]},dataLabels:{enabled:false,zIndex:2},id:"highcharts-navigator-series",className:"highcharts-navigator-series",lineColor:null,marker:{enabled:false},threshold:null},xAxis:{className:"highcharts-navigator-xaxis",tickLength:0,lineWidth:0,gridLineColor:"#e6e6e6",id:"navigator-x-axis",gridLineWidth:1,tickPixelInterval:200,labels:{align:"left",style:{color:"#000000",fontSize:"0.7em",opacity:.6,textOutline:"2px contrast"},x:3,y:-4},crosshair:false},yAxis:{className:"highcharts-navigator-yaxis",gridLineWidth:0,startOnTick:false,endOnTick:false,minPadding:.1,id:"navigator-y-axis",maxPadding:.1,labels:{enabled:false},crosshair:false,title:{text:null},tickLength:0,tickWidth:0}};const Navigator_NavigatorDefaults=NavigatorDefaults;"";const{relativeLength:NavigatorSymbols_relativeLength}=Core_Utilities;function navigatorHandle(_x,_y,width,height,options={}){const halfWidth=options.width?options.width/2:width,markerPosition=1.5,r=NavigatorSymbols_relativeLength(options.borderRadius||0,Math.min(halfWidth*2,height));height=options.height||height;return[["M",-markerPosition,height/2-3.5],["L",-markerPosition,height/2+4.5],["M",markerPosition-1,height/2-3.5],["L",markerPosition-1,height/2+4.5],...SVG_Symbols.rect(-halfWidth-1,.5,halfWidth*2+1,height,{r:r})]}const NavigatorSymbols={"navigator-handle":navigatorHandle};const Navigator_NavigatorSymbols=NavigatorSymbols;const{defined:StockUtilities_defined}=Core_Utilities;function setFixedRange(range){const xAxis=this.xAxis[0];if(StockUtilities_defined(xAxis.dataMax)&&StockUtilities_defined(xAxis.dataMin)&&range){this.fixedRange=Math.min(range,xAxis.dataMax-xAxis.dataMin)}else{this.fixedRange=range}}const StockUtilities={setFixedRange:setFixedRange};const Utilities_StockUtilities=StockUtilities;const{setOptions:NavigatorComposition_setOptions}=Defaults;const{composed:NavigatorComposition_composed}=Core_Globals;const{getRendererType}=Renderer_RendererRegistry;const{setFixedRange:NavigatorComposition_setFixedRange}=Utilities_StockUtilities;const{addEvent:NavigatorComposition_addEvent,extend:NavigatorComposition_extend,pushUnique:NavigatorComposition_pushUnique}=Core_Utilities;function NavigatorComposition_compose(ChartClass,AxisClass,SeriesClass){NavigatorAxisComposition.compose(AxisClass);if(NavigatorComposition_pushUnique(NavigatorComposition_composed,"Navigator")){ChartClass.prototype.setFixedRange=NavigatorComposition_setFixedRange;NavigatorComposition_extend(getRendererType().prototype.symbols,Navigator_NavigatorSymbols);NavigatorComposition_addEvent(SeriesClass,"afterUpdate",onSeriesAfterUpdate);NavigatorComposition_setOptions({navigator:Navigator_NavigatorDefaults})}}function onSeriesAfterUpdate(){if(this.chart.navigator&&!this.options.isInternal){this.chart.navigator.setBaseSeries(null,false)}}const NavigatorComposition={compose:NavigatorComposition_compose};const Navigator_NavigatorComposition=NavigatorComposition;const{composed:ScrollbarAxis_composed}=Core_Globals;const{addEvent:ScrollbarAxis_addEvent,defined:ScrollbarAxis_defined,pick:ScrollbarAxis_pick,pushUnique:ScrollbarAxis_pushUnique}=Core_Utilities;var ScrollbarAxis;(function(ScrollbarAxis){let Scrollbar;function compose(AxisClass,ScrollbarClass){if(ScrollbarAxis_pushUnique(ScrollbarAxis_composed,"Axis.Scrollbar")){Scrollbar=ScrollbarClass;ScrollbarAxis_addEvent(AxisClass,"afterGetOffset",onAxisAfterGetOffset);ScrollbarAxis_addEvent(AxisClass,"afterInit",onAxisAfterInit);ScrollbarAxis_addEvent(AxisClass,"afterRender",onAxisAfterRender)}}ScrollbarAxis.compose=compose;function getExtremes(axis){const axisMin=ScrollbarAxis_pick(axis.options&&axis.options.min,axis.min);const axisMax=ScrollbarAxis_pick(axis.options&&axis.options.max,axis.max);return{axisMin:axisMin,axisMax:axisMax,scrollMin:ScrollbarAxis_defined(axis.dataMin)?Math.min(axisMin,axis.min,axis.dataMin,ScrollbarAxis_pick(axis.threshold,Infinity)):axisMin,scrollMax:ScrollbarAxis_defined(axis.dataMax)?Math.max(axisMax,axis.max,axis.dataMax,ScrollbarAxis_pick(axis.threshold,-Infinity)):axisMax}}function onAxisAfterGetOffset(){const axis=this,scrollbar=axis.scrollbar,opposite=scrollbar&&!scrollbar.options.opposite,index=axis.horiz?2:opposite?3:1;if(scrollbar){axis.chart.scrollbarsOffsets=[0,0];axis.chart.axisOffset[index]+=scrollbar.size+(scrollbar.options.margin||0)}}function onAxisAfterInit(){const axis=this;if(axis.options&&axis.options.scrollbar&&axis.options.scrollbar.enabled){axis.options.scrollbar.vertical=!axis.horiz;axis.options.startOnTick=axis.options.endOnTick=false;axis.scrollbar=new Scrollbar(axis.chart.renderer,axis.options.scrollbar,axis.chart);ScrollbarAxis_addEvent(axis.scrollbar,"changed",function(e){const{axisMin,axisMax,scrollMin:unitedMin,scrollMax:unitedMax}=getExtremes(axis),range=unitedMax-unitedMin;let to,from;if(!ScrollbarAxis_defined(axisMin)||!ScrollbarAxis_defined(axisMax)){return}if(axis.horiz&&!axis.reversed||!axis.horiz&&axis.reversed){to=unitedMin+range*this.to;from=unitedMin+range*this.from}else{to=unitedMin+range*(1-this.from);from=unitedMin+range*(1-this.to)}if(this.shouldUpdateExtremes(e.DOMType)){const animate=e.DOMType==="mousemove"||e.DOMType==="touchmove"?false:void 0;axis.setExtremes(from,to,true,animate,e)}else{this.setRange(this.from,this.to)}})}}function onAxisAfterRender(){const axis=this,{scrollMin,scrollMax}=getExtremes(axis),scrollbar=axis.scrollbar,offset=axis.axisTitleMargin+(axis.titleOffset||0),scrollbarsOffsets=axis.chart.scrollbarsOffsets,axisMargin=axis.options.margin||0;let offsetsIndex,from,to;if(scrollbar&&scrollbarsOffsets){if(axis.horiz){if(!axis.opposite){scrollbarsOffsets[1]+=offset}scrollbar.position(axis.left,axis.top+axis.height+2+scrollbarsOffsets[1]-(axis.opposite?axisMargin:0),axis.width,axis.height);if(!axis.opposite){scrollbarsOffsets[1]+=axisMargin}offsetsIndex=1}else{if(axis.opposite){scrollbarsOffsets[0]+=offset}let xPosition;if(!scrollbar.options.opposite){xPosition=axis.opposite?0:axisMargin}else{xPosition=axis.left+axis.width+2+scrollbarsOffsets[0]-(axis.opposite?0:axisMargin)}scrollbar.position(xPosition,axis.top,axis.width,axis.height);if(axis.opposite){scrollbarsOffsets[0]+=axisMargin}offsetsIndex=0}scrollbarsOffsets[offsetsIndex]+=scrollbar.size+(scrollbar.options.margin||0);if(isNaN(scrollMin)||isNaN(scrollMax)||!ScrollbarAxis_defined(axis.min)||!ScrollbarAxis_defined(axis.max)||axis.dataMin===axis.dataMax){scrollbar.setRange(0,1)}else if(axis.min===axis.max){const interval=axis.pointRange/(axis.dataMax+1);from=interval*axis.min;to=interval*(axis.max+1);scrollbar.setRange(from,to)}else{from=(axis.min-scrollMin)/(scrollMax-scrollMin);to=(axis.max-scrollMin)/(scrollMax-scrollMin);if(axis.horiz&&!axis.reversed||!axis.horiz&&axis.reversed){scrollbar.setRange(from,to)}else{scrollbar.setRange(1-to,1-from)}}}}})(ScrollbarAxis||(ScrollbarAxis={}));const Axis_ScrollbarAxis=ScrollbarAxis;const ScrollbarDefaults={height:10,barBorderRadius:5,buttonBorderRadius:0,buttonsEnabled:false,liveRedraw:void 0,margin:void 0,minWidth:6,opposite:true,step:.2,zIndex:3,barBackgroundColor:"#cccccc",barBorderWidth:0,barBorderColor:"#cccccc",buttonArrowColor:"#333333",buttonBackgroundColor:"#e6e6e6",buttonBorderColor:"#cccccc",buttonBorderWidth:1,rifleColor:"none",trackBackgroundColor:"rgba(255, 255, 255, 0.001)",trackBorderColor:"#cccccc",trackBorderRadius:5,trackBorderWidth:1};const Scrollbar_ScrollbarDefaults=ScrollbarDefaults;const{defaultOptions:Scrollbar_defaultOptions}=Defaults;const{addEvent:Scrollbar_addEvent,correctFloat:Scrollbar_correctFloat,crisp:Scrollbar_crisp,defined:Scrollbar_defined,destroyObjectProperties:Scrollbar_destroyObjectProperties,fireEvent:Scrollbar_fireEvent,merge:Scrollbar_merge,pick:Scrollbar_pick,removeEvent:Scrollbar_removeEvent}=Core_Utilities;class Scrollbar{static compose(AxisClass){Axis_ScrollbarAxis.compose(AxisClass,Scrollbar)}static swapXY(path,vertical){if(vertical){path.forEach(seg=>{const len=seg.length;let temp;for(let i=0;i<len;i+=2){temp=seg[i+1];if(typeof temp==="number"){seg[i+1]=seg[i+2];seg[i+2]=temp}}})}return path}constructor(renderer,options,chart){this._events=[];this.chartX=0;this.chartY=0;this.from=0;this.scrollbarButtons=[];this.scrollbarLeft=0;this.scrollbarStrokeWidth=1;this.scrollbarTop=0;this.size=0;this.to=0;this.trackBorderWidth=1;this.x=0;this.y=0;this.init(renderer,options,chart)}addEvents(){const buttonsOrder=this.options.inverted?[1,0]:[0,1],buttons=this.scrollbarButtons,bar=this.scrollbarGroup.element,track=this.track.element,mouseDownHandler=this.mouseDownHandler.bind(this),mouseMoveHandler=this.mouseMoveHandler.bind(this),mouseUpHandler=this.mouseUpHandler.bind(this);const _events=[[buttons[buttonsOrder[0]].element,"click",this.buttonToMinClick.bind(this)],[buttons[buttonsOrder[1]].element,"click",this.buttonToMaxClick.bind(this)],[track,"click",this.trackClick.bind(this)],[bar,"mousedown",mouseDownHandler],[bar.ownerDocument,"mousemove",mouseMoveHandler],[bar.ownerDocument,"mouseup",mouseUpHandler],[bar,"touchstart",mouseDownHandler],[bar.ownerDocument,"touchmove",mouseMoveHandler],[bar.ownerDocument,"touchend",mouseUpHandler]];_events.forEach(function(args){Scrollbar_addEvent.apply(null,args)});this._events=_events}buttonToMaxClick(e){const scroller=this;const range=(scroller.to-scroller.from)*Scrollbar_pick(scroller.options.step,.2);scroller.updatePosition(scroller.from+range,scroller.to+range);Scrollbar_fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMEvent:e})}buttonToMinClick(e){const scroller=this;const range=Scrollbar_correctFloat(scroller.to-scroller.from)*Scrollbar_pick(scroller.options.step,.2);scroller.updatePosition(Scrollbar_correctFloat(scroller.from-range),Scrollbar_correctFloat(scroller.to-range));Scrollbar_fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMEvent:e})}cursorToScrollbarPosition(normalizedEvent){const scroller=this,options=scroller.options,minWidthDifference=options.minWidth>scroller.calculatedWidth?options.minWidth:0;return{chartX:(normalizedEvent.chartX-scroller.x-scroller.xOffset)/(scroller.barWidth-minWidthDifference),chartY:(normalizedEvent.chartY-scroller.y-scroller.yOffset)/(scroller.barWidth-minWidthDifference)}}destroy(){const scroller=this,navigator=scroller.chart.scroller;scroller.removeEvents();["track","scrollbarRifles","scrollbar","scrollbarGroup","group"].forEach(function(prop){if(scroller[prop]&&scroller[prop].destroy){scroller[prop]=scroller[prop].destroy()}});if(navigator&&scroller===navigator.scrollbar){navigator.scrollbar=null;Scrollbar_destroyObjectProperties(navigator.scrollbarButtons)}}drawScrollbarButton(index){const scroller=this,renderer=scroller.renderer,scrollbarButtons=scroller.scrollbarButtons,options=scroller.options,size=scroller.size,group=renderer.g().add(scroller.group);scrollbarButtons.push(group);if(options.buttonsEnabled){const rect=renderer.rect().addClass("highcharts-scrollbar-button").add(group);if(!scroller.chart.styledMode){rect.attr({stroke:options.buttonBorderColor,"stroke-width":options.buttonBorderWidth,fill:options.buttonBackgroundColor})}rect.attr(rect.crisp({x:-.5,y:-.5,width:size,height:size,r:options.buttonBorderRadius},rect.strokeWidth()));const arrow=renderer.path(Scrollbar.swapXY([["M",size/2+(index?-1:1),size/2-3],["L",size/2+(index?-1:1),size/2+3],["L",size/2+(index?2:-2),size/2]],options.vertical)).addClass("highcharts-scrollbar-arrow").add(scrollbarButtons[index]);if(!scroller.chart.styledMode){arrow.attr({fill:options.buttonArrowColor})}}}init(renderer,options,chart){const scroller=this;scroller.scrollbarButtons=[];scroller.renderer=renderer;scroller.userOptions=options;scroller.options=Scrollbar_merge(Scrollbar_ScrollbarDefaults,Scrollbar_defaultOptions.scrollbar,options);scroller.options.margin=Scrollbar_pick(scroller.options.margin,10);scroller.chart=chart;scroller.size=Scrollbar_pick(scroller.options.size,scroller.options.height);if(options.enabled){scroller.render();scroller.addEvents()}}mouseDownHandler(e){const scroller=this,normalizedEvent=scroller.chart.pointer?.normalize(e)||e,mousePosition=scroller.cursorToScrollbarPosition(normalizedEvent);scroller.chartX=mousePosition.chartX;scroller.chartY=mousePosition.chartY;scroller.initPositions=[scroller.from,scroller.to];scroller.grabbedCenter=true}mouseMoveHandler(e){const scroller=this,normalizedEvent=scroller.chart.pointer?.normalize(e)||e,options=scroller.options,direction=options.vertical?"chartY":"chartX",initPositions=scroller.initPositions||[];let scrollPosition,chartPosition,change;if(scroller.grabbedCenter&&(!e.touches||e.touches[0][direction]!==0)){chartPosition=scroller.cursorToScrollbarPosition(normalizedEvent)[direction];scrollPosition=scroller[direction];change=chartPosition-scrollPosition;scroller.hasDragged=true;scroller.updatePosition(initPositions[0]+change,initPositions[1]+change);if(scroller.hasDragged){Scrollbar_fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMType:e.type,DOMEvent:e})}}}mouseUpHandler(e){const scroller=this;if(scroller.hasDragged){Scrollbar_fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMType:e.type,DOMEvent:e})}scroller.grabbedCenter=scroller.hasDragged=scroller.chartX=scroller.chartY=null}position(x,y,width,height){const scroller=this,options=scroller.options,{buttonsEnabled,margin=0,vertical}=options,method=scroller.rendered?"animate":"attr";let xOffset=height,yOffset=0;scroller.group.show();scroller.x=x;scroller.y=y+this.trackBorderWidth;scroller.width=width;scroller.height=height;scroller.xOffset=xOffset;scroller.yOffset=yOffset;if(vertical){scroller.width=scroller.yOffset=width=yOffset=scroller.size;scroller.xOffset=xOffset=0;scroller.yOffset=yOffset=buttonsEnabled?scroller.size:0;scroller.barWidth=height-(buttonsEnabled?width*2:0);scroller.x=x=x+margin}else{scroller.height=height=scroller.size;scroller.xOffset=xOffset=buttonsEnabled?scroller.size:0;scroller.barWidth=width-(buttonsEnabled?height*2:0);scroller.y=scroller.y+margin}scroller.group[method]({translateX:x,translateY:scroller.y});scroller.track[method]({width:width,height:height});scroller.scrollbarButtons[1][method]({translateX:vertical?0:width-xOffset,translateY:vertical?height-yOffset:0})}removeEvents(){this._events.forEach(function(args){Scrollbar_removeEvent.apply(null,args)});this._events.length=0}render(){const scroller=this,renderer=scroller.renderer,options=scroller.options,size=scroller.size,styledMode=scroller.chart.styledMode,group=renderer.g("scrollbar").attr({zIndex:options.zIndex}).hide().add();scroller.group=group;scroller.track=renderer.rect().addClass("highcharts-scrollbar-track").attr({r:options.trackBorderRadius||0,height:size,width:size}).add(group);if(!styledMode){scroller.track.attr({fill:options.trackBackgroundColor,stroke:options.trackBorderColor,"stroke-width":options.trackBorderWidth})}const trackBorderWidth=scroller.trackBorderWidth=scroller.track.strokeWidth();scroller.track.attr({x:-Scrollbar_crisp(0,trackBorderWidth),y:-Scrollbar_crisp(0,trackBorderWidth)});scroller.scrollbarGroup=renderer.g().add(group);scroller.scrollbar=renderer.rect().addClass("highcharts-scrollbar-thumb").attr({height:size-trackBorderWidth,width:size-trackBorderWidth,r:options.barBorderRadius||0}).add(scroller.scrollbarGroup);scroller.scrollbarRifles=renderer.path(Scrollbar.swapXY([["M",-3,size/4],["L",-3,2*size/3],["M",0,size/4],["L",0,2*size/3],["M",3,size/4],["L",3,2*size/3]],options.vertical)).addClass("highcharts-scrollbar-rifles").add(scroller.scrollbarGroup);if(!styledMode){scroller.scrollbar.attr({fill:options.barBackgroundColor,stroke:options.barBorderColor,"stroke-width":options.barBorderWidth});scroller.scrollbarRifles.attr({stroke:options.rifleColor,"stroke-width":1})}scroller.scrollbarStrokeWidth=scroller.scrollbar.strokeWidth();scroller.scrollbarGroup.translate(-Scrollbar_crisp(0,scroller.scrollbarStrokeWidth),-Scrollbar_crisp(0,scroller.scrollbarStrokeWidth));scroller.drawScrollbarButton(0);scroller.drawScrollbarButton(1)}setRange(from,to){const scroller=this,options=scroller.options,vertical=options.vertical,minWidth=options.minWidth,fullWidth=scroller.barWidth,method=this.rendered&&!this.hasDragged&&!(this.chart.navigator&&this.chart.navigator.hasDragged)?"animate":"attr";if(!Scrollbar_defined(fullWidth)){return}const toPX=fullWidth*Math.min(to,1);let fromPX,newSize;from=Math.max(from,0);fromPX=Math.ceil(fullWidth*from);scroller.calculatedWidth=newSize=Scrollbar_correctFloat(toPX-fromPX);if(newSize<minWidth){fromPX=(fullWidth-minWidth+newSize)*from;newSize=minWidth}const newPos=Math.floor(fromPX+scroller.xOffset+scroller.yOffset);const newRiflesPos=newSize/2-.5;scroller.from=from;scroller.to=to;if(!vertical){scroller.scrollbarGroup[method]({translateX:newPos});scroller.scrollbar[method]({width:newSize});scroller.scrollbarRifles[method]({translateX:newRiflesPos});scroller.scrollbarLeft=newPos;scroller.scrollbarTop=0}else{scroller.scrollbarGroup[method]({translateY:newPos});scroller.scrollbar[method]({height:newSize});scroller.scrollbarRifles[method]({translateY:newRiflesPos});scroller.scrollbarTop=newPos;scroller.scrollbarLeft=0}if(newSize<=12){scroller.scrollbarRifles.hide()}else{scroller.scrollbarRifles.show()}if(options.showFull===false){if(from<=0&&to>=1){scroller.group.hide()}else{scroller.group.show()}}scroller.rendered=true}shouldUpdateExtremes(eventType){return Scrollbar_pick(this.options.liveRedraw,Core_Globals.svg&&!Core_Globals.isTouchDevice&&!this.chart.boosted)||eventType==="mouseup"||eventType==="touchend"||!Scrollbar_defined(eventType)}trackClick(e){const scroller=this;const normalizedEvent=scroller.chart.pointer?.normalize(e)||e,range=scroller.to-scroller.from,top=scroller.y+scroller.scrollbarTop,left=scroller.x+scroller.scrollbarLeft;if(scroller.options.vertical&&normalizedEvent.chartY>top||!scroller.options.vertical&&normalizedEvent.chartX>left){scroller.updatePosition(scroller.from+range,scroller.to+range)}else{scroller.updatePosition(scroller.from-range,scroller.to-range)}Scrollbar_fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMEvent:e})}update(options){this.destroy();this.init(this.chart.renderer,Scrollbar_merge(true,this.options,options),this.chart)}updatePosition(from,to){if(to>1){from=Scrollbar_correctFloat(1-Scrollbar_correctFloat(to-from));to=1}if(from<0){to=Scrollbar_correctFloat(to-from);from=0}this.from=from;this.to=to}}Scrollbar.defaultOptions=Scrollbar_ScrollbarDefaults;Scrollbar_defaultOptions.scrollbar=Scrollbar_merge(true,Scrollbar.defaultOptions,Scrollbar_defaultOptions.scrollbar);const Scrollbar_Scrollbar=Scrollbar;const{defaultOptions:Navigator_defaultOptions}=Defaults;const{isTouchDevice:Navigator_isTouchDevice}=Core_Globals;const{prototype:{symbols}}=SVG_SVGRenderer;const{addEvent:Navigator_addEvent,clamp:Navigator_clamp,correctFloat:Navigator_correctFloat,defined:Navigator_defined,destroyObjectProperties:Navigator_destroyObjectProperties,erase:Navigator_erase,extend:Navigator_extend,find:Navigator_find,fireEvent:Navigator_fireEvent,isArray:Navigator_isArray,isNumber:Navigator_isNumber,merge:Navigator_merge,pick:Navigator_pick,removeEvent:Navigator_removeEvent,splat:Navigator_splat}=Core_Utilities;function numExt(extreme,...args){const numbers=[].filter.call(args,Navigator_isNumber);if(numbers.length){return Math[extreme].apply(0,numbers)}}class Navigator{static compose(ChartClass,AxisClass,SeriesClass){Navigator_ChartNavigatorComposition.compose(ChartClass,Navigator);Navigator_NavigatorComposition.compose(ChartClass,AxisClass,SeriesClass)}constructor(chart){this.isDirty=false;this.scrollbarHeight=0;this.init(chart)}drawHandle(x,index,inverted,verb){const navigator=this,height=navigator.navigatorOptions.handles.height;navigator.handles[index][verb](inverted?{translateX:Math.round(navigator.left+navigator.height/2),translateY:Math.round(navigator.top+parseInt(x,10)+.5-height)}:{translateX:Math.round(navigator.left+parseInt(x,10)),translateY:Math.round(navigator.top+navigator.height/2-height/2-1)})}drawOutline(zoomedMin,zoomedMax,inverted,verb){const navigator=this,maskInside=navigator.navigatorOptions.maskInside,outlineWidth=navigator.outline.strokeWidth(),halfOutline=outlineWidth/2,outlineCorrection=outlineWidth%2/2,scrollButtonSize=navigator.scrollButtonSize,navigatorSize=navigator.size,navigatorTop=navigator.top,height=navigator.height,lineTop=navigatorTop-halfOutline,lineBtm=navigatorTop+height;let left=navigator.left,verticalMin,path;if(inverted){verticalMin=navigatorTop+zoomedMax+outlineCorrection;zoomedMax=navigatorTop+zoomedMin+outlineCorrection;path=[["M",left+height,navigatorTop-scrollButtonSize-outlineCorrection],["L",left+height,verticalMin],["L",left,verticalMin],["M",left,zoomedMax],["L",left+height,zoomedMax],["L",left+height,navigatorTop+navigatorSize+scrollButtonSize]];if(maskInside){path.push(["M",left+height,verticalMin-halfOutline],["L",left+height,zoomedMax+halfOutline])}}else{left-=scrollButtonSize;zoomedMin+=left+scrollButtonSize-outlineCorrection;zoomedMax+=left+scrollButtonSize-outlineCorrection;path=[["M",left,lineTop],["L",zoomedMin,lineTop],["L",zoomedMin,lineBtm],["M",zoomedMax,lineBtm],["L",zoomedMax,lineTop],["L",left+navigatorSize+scrollButtonSize*2,lineTop]];if(maskInside){path.push(["M",zoomedMin-halfOutline,lineTop],["L",zoomedMax+halfOutline,lineTop])}}navigator.outline[verb]({d:path})}drawMasks(zoomedMin,zoomedMax,inverted,verb){const navigator=this,left=navigator.left,top=navigator.top,navigatorHeight=navigator.height;let height,width,x,y;if(inverted){x=[left,left,left];y=[top,top+zoomedMin,top+zoomedMax];width=[navigatorHeight,navigatorHeight,navigatorHeight];height=[zoomedMin,zoomedMax-zoomedMin,navigator.size-zoomedMax]}else{x=[left,left+zoomedMin,left+zoomedMax];y=[top,top,top];width=[zoomedMin,zoomedMax-zoomedMin,navigator.size-zoomedMax];height=[navigatorHeight,navigatorHeight,navigatorHeight]}navigator.shades.forEach((shade,i)=>{shade[verb]({x:x[i],y:y[i],width:width[i],height:height[i]})})}renderElements(){const navigator=this,navigatorOptions=navigator.navigatorOptions,maskInside=navigatorOptions.maskInside,chart=navigator.chart,inverted=chart.inverted,renderer=chart.renderer,mouseCursor={cursor:inverted?"ns-resize":"ew-resize"},navigatorGroup=navigator.navigatorGroup??(navigator.navigatorGroup=renderer.g("navigator").attr({zIndex:8,visibility:"hidden"}).add());[!maskInside,maskInside,!maskInside].forEach((hasMask,index)=>{const shade=navigator.shades[index]??(navigator.shades[index]=renderer.rect().addClass("highcharts-navigator-mask"+(index===1?"-inside":"-outside")).add(navigatorGroup));if(!chart.styledMode){shade.attr({fill:hasMask?navigatorOptions.maskFill:"rgba(0,0,0,0)"});if(index===1){shade.css(mouseCursor)}}});if(!navigator.outline){navigator.outline=renderer.path().addClass("highcharts-navigator-outline").add(navigatorGroup)}if(!chart.styledMode){navigator.outline.attr({"stroke-width":navigatorOptions.outlineWidth,stroke:navigatorOptions.outlineColor})}if(navigatorOptions.handles?.enabled){const handlesOptions=navigatorOptions.handles,{height,width}=handlesOptions;[0,1].forEach(index=>{const symbolName=handlesOptions.symbols[index];if(!navigator.handles[index]||navigator.handles[index].symbolUrl!==symbolName){navigator.handles[index]?.destroy();navigator.handles[index]=renderer.symbol(symbolName,-width/2-1,0,width,height,handlesOptions);navigator.handles[index].attr({zIndex:7-index}).addClass("highcharts-navigator-handle "+"highcharts-navigator-handle-"+["left","right"][index]).add(navigatorGroup);navigator.addMouseEvents()}else if(!navigator.handles[index].isImg&&navigator.handles[index].symbolName!==symbolName){const symbolFn=symbols[symbolName],path=symbolFn.call(symbols,-width/2-1,0,width,height);navigator.handles[index].attr({d:path});navigator.handles[index].symbolName=symbolName}if(chart.inverted){navigator.handles[index].attr({rotation:90,rotationOriginX:Math.floor(-width/2),rotationOriginY:(height+width)/2})}if(!chart.styledMode){navigator.handles[index].attr({fill:handlesOptions.backgroundColor,stroke:handlesOptions.borderColor,"stroke-width":handlesOptions.lineWidth,width:handlesOptions.width,height:handlesOptions.height,x:-width/2-1,y:0}).css(mouseCursor)}})}}update(options,redraw=false){const chart=this.chart,invertedUpdate=chart.options.chart.inverted!==chart.scrollbar?.options.vertical;Navigator_merge(true,chart.options.navigator,options);this.navigatorOptions=chart.options.navigator||{};this.setOpposite();if(Navigator_defined(options.enabled)||invertedUpdate){this.destroy();this.navigatorEnabled=options.enabled||this.navigatorEnabled;return this.init(chart)}if(this.navigatorEnabled){this.isDirty=true;if(options.adaptToUpdatedData===false){this.baseSeries.forEach(series=>{Navigator_removeEvent(series,"updatedData",this.updatedDataHandler)},this)}if(options.adaptToUpdatedData){this.baseSeries.forEach(series=>{series.eventsToUnbind.push(Navigator_addEvent(series,"updatedData",this.updatedDataHandler))},this)}if(options.series||options.baseSeries){this.setBaseSeries(void 0,false)}if(options.height||options.xAxis||options.yAxis){this.height=options.height??this.height;const offsets=this.getXAxisOffsets();this.xAxis.update({...options.xAxis,offsets:offsets,[chart.inverted?"width":"height"]:this.height,[chart.inverted?"height":"width"]:void 0},false);this.yAxis.update({...options.yAxis,[chart.inverted?"width":"height"]:this.height},false)}}if(redraw){chart.redraw()}}render(min,max,pxMin,pxMax){const navigator=this,chart=navigator.chart,xAxis=navigator.xAxis,pointRange=xAxis.pointRange||0,scrollbarXAxis=xAxis.navigatorAxis.fake?chart.xAxis[0]:xAxis,navigatorEnabled=navigator.navigatorEnabled,rendered=navigator.rendered,inverted=chart.inverted,minRange=chart.xAxis[0].minRange,maxRange=chart.xAxis[0].options.maxRange,scrollButtonSize=navigator.scrollButtonSize;let navigatorWidth,scrollbarLeft,scrollbarTop,scrollbarHeight=navigator.scrollbarHeight,navigatorSize,verb;if(this.hasDragged&&!Navigator_defined(pxMin)){return}if(this.isDirty){this.renderElements()}min=Navigator_correctFloat(min-pointRange/2);max=Navigator_correctFloat(max+pointRange/2);if(!Navigator_isNumber(min)||!Navigator_isNumber(max)){if(rendered){pxMin=0;pxMax=Navigator_pick(xAxis.width,scrollbarXAxis.width)}else{return}}navigator.left=Navigator_pick(xAxis.left,chart.plotLeft+scrollButtonSize+(inverted?chart.plotWidth:0));let zoomedMax=navigator.size=navigatorSize=Navigator_pick(xAxis.len,(inverted?chart.plotHeight:chart.plotWidth)-2*scrollButtonSize);if(inverted){navigatorWidth=scrollbarHeight}else{navigatorWidth=navigatorSize+2*scrollButtonSize}pxMin=Navigator_pick(pxMin,xAxis.toPixels(min,true));pxMax=Navigator_pick(pxMax,xAxis.toPixels(max,true));if(!Navigator_isNumber(pxMin)||Math.abs(pxMin)===Infinity){pxMin=0;pxMax=navigatorWidth}const newMin=xAxis.toValue(pxMin,true),newMax=xAxis.toValue(pxMax,true),currentRange=Math.abs(Navigator_correctFloat(newMax-newMin));if(currentRange<minRange){if(this.grabbedLeft){pxMin=xAxis.toPixels(newMax-minRange-pointRange,true)}else if(this.grabbedRight){pxMax=xAxis.toPixels(newMin+minRange+pointRange,true)}}else if(Navigator_defined(maxRange)&&Navigator_correctFloat(currentRange-pointRange)>maxRange){if(this.grabbedLeft){pxMin=xAxis.toPixels(newMax-maxRange-pointRange,true)}else if(this.grabbedRight){pxMax=xAxis.toPixels(newMin+maxRange+pointRange,true)}}navigator.zoomedMax=Navigator_clamp(Math.max(pxMin,pxMax),0,zoomedMax);navigator.zoomedMin=Navigator_clamp(navigator.fixedWidth?navigator.zoomedMax-navigator.fixedWidth:Math.min(pxMin,pxMax),0,zoomedMax);navigator.range=navigator.zoomedMax-navigator.zoomedMin;zoomedMax=Math.round(navigator.zoomedMax);const zoomedMin=Math.round(navigator.zoomedMin);if(navigatorEnabled){navigator.navigatorGroup.attr({visibility:"inherit"});verb=rendered&&!navigator.hasDragged?"animate":"attr";navigator.drawMasks(zoomedMin,zoomedMax,inverted,verb);navigator.drawOutline(zoomedMin,zoomedMax,inverted,verb);if(navigator.navigatorOptions.handles.enabled){navigator.drawHandle(zoomedMin,0,inverted,verb);navigator.drawHandle(zoomedMax,1,inverted,verb)}}if(navigator.scrollbar){if(inverted){scrollbarTop=navigator.top-scrollButtonSize;scrollbarLeft=navigator.left-scrollbarHeight+(navigatorEnabled||!scrollbarXAxis.opposite?0:(scrollbarXAxis.titleOffset||0)+scrollbarXAxis.axisTitleMargin);scrollbarHeight=navigatorSize+2*scrollButtonSize}else{scrollbarTop=navigator.top+(navigatorEnabled?navigator.height:-scrollbarHeight);scrollbarLeft=navigator.left-scrollButtonSize}navigator.scrollbar.position(scrollbarLeft,scrollbarTop,navigatorWidth,scrollbarHeight);navigator.scrollbar.setRange(navigator.zoomedMin/(navigatorSize||1),navigator.zoomedMax/(navigatorSize||1))}navigator.rendered=true;this.isDirty=false;Navigator_fireEvent(this,"afterRender")}addMouseEvents(){const navigator=this,chart=navigator.chart,container=chart.container;let eventsToUnbind=[],mouseMoveHandler,mouseUpHandler;navigator.mouseMoveHandler=mouseMoveHandler=function(e){navigator.onMouseMove(e)};navigator.mouseUpHandler=mouseUpHandler=function(e){navigator.onMouseUp(e)};eventsToUnbind=navigator.getPartsEvents("mousedown");eventsToUnbind.push(Navigator_addEvent(chart.renderTo,"mousemove",mouseMoveHandler),Navigator_addEvent(container.ownerDocument,"mouseup",mouseUpHandler),Navigator_addEvent(chart.renderTo,"touchmove",mouseMoveHandler),Navigator_addEvent(container.ownerDocument,"touchend",mouseUpHandler));eventsToUnbind.concat(navigator.getPartsEvents("touchstart"));navigator.eventsToUnbind=eventsToUnbind;if(navigator.series&&navigator.series[0]){eventsToUnbind.push(Navigator_addEvent(navigator.series[0].xAxis,"foundExtremes",function(){chart.navigator.modifyNavigatorAxisExtremes()}))}}getPartsEvents(eventName){const navigator=this,events=[];["shades","handles"].forEach(function(name){navigator[name].forEach(function(navigatorItem,index){events.push(Navigator_addEvent(navigatorItem.element,eventName,function(e){navigator[name+"Mousedown"](e,index)}))})});return events}shadesMousedown(e,index){e=this.chart.pointer?.normalize(e)||e;const navigator=this,chart=navigator.chart,xAxis=navigator.xAxis,zoomedMin=navigator.zoomedMin,navigatorSize=navigator.size,range=navigator.range;let navigatorPosition=navigator.left,chartX=e.chartX,fixedMax,fixedMin,ext,left;if(chart.inverted){chartX=e.chartY;navigatorPosition=navigator.top}if(index===1){navigator.grabbedCenter=chartX;navigator.fixedWidth=range;navigator.dragOffset=chartX-zoomedMin}else{left=chartX-navigatorPosition-range/2;if(index===0){left=Math.max(0,left)}else if(index===2&&left+range>=navigatorSize){left=navigatorSize-range;if(navigator.reversedExtremes){left-=range;fixedMin=navigator.getUnionExtremes().dataMin}else{fixedMax=navigator.getUnionExtremes().dataMax}}if(left!==zoomedMin){navigator.fixedWidth=range;ext=xAxis.navigatorAxis.toFixedRange(left,left+range,fixedMin,fixedMax);if(Navigator_defined(ext.min)){Navigator_fireEvent(this,"setRange",{min:Math.min(ext.min,ext.max),max:Math.max(ext.min,ext.max),redraw:true,eventArguments:{trigger:"navigator"}})}}}}handlesMousedown(e,index){e=this.chart.pointer?.normalize(e)||e;const navigator=this,chart=navigator.chart,baseXAxis=chart.xAxis[0],reverse=navigator.reversedExtremes;if(index===0){navigator.grabbedLeft=true;navigator.otherHandlePos=navigator.zoomedMax;navigator.fixedExtreme=reverse?baseXAxis.min:baseXAxis.max}else{navigator.grabbedRight=true;navigator.otherHandlePos=navigator.zoomedMin;navigator.fixedExtreme=reverse?baseXAxis.max:baseXAxis.min}chart.setFixedRange(void 0)}onMouseMove(e){const navigator=this,chart=navigator.chart,navigatorSize=navigator.navigatorSize,range=navigator.range,dragOffset=navigator.dragOffset,inverted=chart.inverted;let left=navigator.left,chartX;if(!e.touches||e.touches[0].pageX!==0){e=chart.pointer?.normalize(e)||e;chartX=e.chartX;if(inverted){left=navigator.top;chartX=e.chartY}if(navigator.grabbedLeft){navigator.hasDragged=true;navigator.render(0,0,chartX-left,navigator.otherHandlePos)}else if(navigator.grabbedRight){navigator.hasDragged=true;navigator.render(0,0,navigator.otherHandlePos,chartX-left)}else if(navigator.grabbedCenter){navigator.hasDragged=true;if(chartX<dragOffset){chartX=dragOffset}else if(chartX>navigatorSize+dragOffset-range){chartX=navigatorSize+dragOffset-range}navigator.render(0,0,chartX-dragOffset,chartX-dragOffset+range)}if(navigator.hasDragged&&navigator.scrollbar&&Navigator_pick(navigator.scrollbar.options.liveRedraw,!Navigator_isTouchDevice&&!this.chart.boosted)){e.DOMType=e.type;setTimeout(function(){navigator.onMouseUp(e)},0)}}}onMouseUp(e){const navigator=this,chart=navigator.chart,xAxis=navigator.xAxis,scrollbar=navigator.scrollbar,DOMEvent=e.DOMEvent||e,inverted=chart.inverted,verb=navigator.rendered&&!navigator.hasDragged?"animate":"attr";let zoomedMax,zoomedMin,unionExtremes,fixedMin,fixedMax,ext;if(navigator.hasDragged&&(!scrollbar||!scrollbar.hasDragged)||e.trigger==="scrollbar"){unionExtremes=navigator.getUnionExtremes();if(navigator.zoomedMin===navigator.otherHandlePos){fixedMin=navigator.fixedExtreme}else if(navigator.zoomedMax===navigator.otherHandlePos){fixedMax=navigator.fixedExtreme}if(navigator.zoomedMax===navigator.size){fixedMax=navigator.reversedExtremes?unionExtremes.dataMin:unionExtremes.dataMax}if(navigator.zoomedMin===0){fixedMin=navigator.reversedExtremes?unionExtremes.dataMax:unionExtremes.dataMin}ext=xAxis.navigatorAxis.toFixedRange(navigator.zoomedMin,navigator.zoomedMax,fixedMin,fixedMax);if(Navigator_defined(ext.min)){Navigator_fireEvent(this,"setRange",{min:Math.min(ext.min,ext.max),max:Math.max(ext.min,ext.max),redraw:true,animation:navigator.hasDragged?false:null,eventArguments:{trigger:"navigator",triggerOp:"navigator-drag",DOMEvent:DOMEvent}})}}if(e.DOMType!=="mousemove"&&e.DOMType!=="touchmove"){navigator.grabbedLeft=navigator.grabbedRight=navigator.grabbedCenter=navigator.fixedWidth=navigator.fixedExtreme=navigator.otherHandlePos=navigator.hasDragged=navigator.dragOffset=null}if(navigator.navigatorEnabled&&Navigator_isNumber(navigator.zoomedMin)&&Navigator_isNumber(navigator.zoomedMax)){zoomedMin=Math.round(navigator.zoomedMin);zoomedMax=Math.round(navigator.zoomedMax);if(navigator.shades){navigator.drawMasks(zoomedMin,zoomedMax,inverted,verb)}if(navigator.outline){navigator.drawOutline(zoomedMin,zoomedMax,inverted,verb)}if(navigator.navigatorOptions.handles.enabled&&Object.keys(navigator.handles).length===navigator.handles.length){navigator.drawHandle(zoomedMin,0,inverted,verb);navigator.drawHandle(zoomedMax,1,inverted,verb)}}}removeEvents(){if(this.eventsToUnbind){this.eventsToUnbind.forEach(function(unbind){unbind()});this.eventsToUnbind=void 0}this.removeBaseSeriesEvents()}removeBaseSeriesEvents(){const baseSeries=this.baseSeries||[];if(this.navigatorEnabled&&baseSeries[0]){if(this.navigatorOptions.adaptToUpdatedData!==false){baseSeries.forEach(function(series){Navigator_removeEvent(series,"updatedData",this.updatedDataHandler)},this)}if(baseSeries[0].xAxis){Navigator_removeEvent(baseSeries[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes)}}}getXAxisOffsets(){return this.chart.inverted?[this.scrollButtonSize,0,-this.scrollButtonSize,0]:[0,-this.scrollButtonSize,0,this.scrollButtonSize]}init(chart){const chartOptions=chart.options,navigatorOptions=chartOptions.navigator||{},navigatorEnabled=navigatorOptions.enabled,scrollbarOptions=chartOptions.scrollbar||{},scrollbarEnabled=scrollbarOptions.enabled,height=navigatorEnabled&&navigatorOptions.height||0,scrollbarHeight=scrollbarEnabled&&scrollbarOptions.height||0,scrollButtonSize=scrollbarOptions.buttonsEnabled&&scrollbarHeight||0;this.handles=[];this.shades=[];this.chart=chart;this.setBaseSeries();this.height=height;this.scrollbarHeight=scrollbarHeight;this.scrollButtonSize=scrollButtonSize;this.scrollbarEnabled=scrollbarEnabled;this.navigatorEnabled=navigatorEnabled;this.navigatorOptions=navigatorOptions;this.scrollbarOptions=scrollbarOptions;this.setOpposite();const navigator=this,baseSeries=navigator.baseSeries,xAxisIndex=chart.xAxis.length,yAxisIndex=chart.yAxis.length,baseXaxis=baseSeries&&baseSeries[0]&&baseSeries[0].xAxis||chart.xAxis[0]||{options:{}};chart.isDirtyBox=true;if(navigator.navigatorEnabled){const offsets=this.getXAxisOffsets();navigator.xAxis=new Axis_Axis(chart,Navigator_merge({breaks:baseXaxis.options.breaks,ordinal:baseXaxis.options.ordinal,overscroll:baseXaxis.options.overscroll},navigatorOptions.xAxis,{type:"datetime",yAxis:navigatorOptions.yAxis?.id,index:xAxisIndex,isInternal:true,offset:0,keepOrdinalPadding:true,startOnTick:false,endOnTick:false,minPadding:baseXaxis.options.ordinal?0:baseXaxis.options.minPadding,maxPadding:baseXaxis.options.ordinal?0:baseXaxis.options.maxPadding,zoomEnabled:false},chart.inverted?{offsets:offsets,width:height}:{offsets:offsets,height:height}),"xAxis");navigator.yAxis=new Axis_Axis(chart,Navigator_merge(navigatorOptions.yAxis,{alignTicks:false,offset:0,index:yAxisIndex,isInternal:true,reversed:Navigator_pick(navigatorOptions.yAxis&&navigatorOptions.yAxis.reversed,chart.yAxis[0]&&chart.yAxis[0].reversed,false),zoomEnabled:false},chart.inverted?{width:height}:{height:height}),"yAxis");if(baseSeries||navigatorOptions.series.data){navigator.updateNavigatorSeries(false)}else if(chart.series.length===0){navigator.unbindRedraw=Navigator_addEvent(chart,"beforeRedraw",function(){if(chart.series.length>0&&!navigator.series){navigator.setBaseSeries();navigator.unbindRedraw()}})}navigator.reversedExtremes=chart.inverted&&!navigator.xAxis.reversed||!chart.inverted&&navigator.xAxis.reversed;navigator.renderElements();navigator.addMouseEvents()}else{navigator.xAxis={chart:chart,navigatorAxis:{fake:true},translate:function(value,reverse){const axis=chart.xAxis[0],ext=axis.getExtremes(),scrollTrackWidth=axis.len-2*scrollButtonSize,min=numExt("min",axis.options.min,ext.dataMin),valueRange=numExt("max",axis.options.max,ext.dataMax)-min;return reverse?value*valueRange/scrollTrackWidth+min:scrollTrackWidth*(value-min)/valueRange},toPixels:function(value){return this.translate(value)},toValue:function(value){return this.translate(value,true)}};navigator.xAxis.navigatorAxis.axis=navigator.xAxis;navigator.xAxis.navigatorAxis.toFixedRange=NavigatorAxisComposition.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis)}if(chart.options.scrollbar.enabled){const options=Navigator_merge(chart.options.scrollbar,{vertical:chart.inverted});if(!Navigator_isNumber(options.margin)&&navigator.navigatorEnabled){options.margin=chart.inverted?-3:3}chart.scrollbar=navigator.scrollbar=new Scrollbar_Scrollbar(chart.renderer,options,chart);Navigator_addEvent(navigator.scrollbar,"changed",function(e){const range=navigator.size,to=range*this.to,from=range*this.from;navigator.hasDragged=navigator.scrollbar.hasDragged;navigator.render(0,0,from,to);if(this.shouldUpdateExtremes(e.DOMType)){setTimeout(function(){navigator.onMouseUp(e)})}})}navigator.addBaseSeriesEvents();navigator.addChartEvents()}setOpposite(){const navigatorOptions=this.navigatorOptions,navigatorEnabled=this.navigatorEnabled,chart=this.chart;this.opposite=Navigator_pick(navigatorOptions.opposite,Boolean(!navigatorEnabled&&chart.inverted))}getUnionExtremes(returnFalseOnNoBaseSeries){const baseAxis=this.chart.xAxis[0],time=this.chart.time,navAxis=this.xAxis,navAxisOptions=navAxis.options,baseAxisOptions=baseAxis.options;let ret;if(!returnFalseOnNoBaseSeries||baseAxis.dataMin!==null){ret={dataMin:Navigator_pick(time.parse(navAxisOptions?.min),numExt("min",time.parse(baseAxisOptions.min),baseAxis.dataMin,navAxis.dataMin,navAxis.min)),dataMax:Navigator_pick(time.parse(navAxisOptions?.max),numExt("max",time.parse(baseAxisOptions.max),baseAxis.dataMax,navAxis.dataMax,navAxis.max))}}return ret}setBaseSeries(baseSeriesOptions,redraw){const chart=this.chart,baseSeries=this.baseSeries=[];baseSeriesOptions=baseSeriesOptions||chart.options&&chart.options.navigator.baseSeries||(chart.series.length?Navigator_find(chart.series,s=>!s.options.isInternal).index:0);(chart.series||[]).forEach((series,i)=>{if(!series.options.isInternal&&(series.options.showInNavigator||(i===baseSeriesOptions||series.options.id===baseSeriesOptions)&&series.options.showInNavigator!==false)){baseSeries.push(series)}});if(this.xAxis&&!this.xAxis.navigatorAxis.fake){this.updateNavigatorSeries(true,redraw)}}updateNavigatorSeries(addEvents,redraw){const navigator=this,chart=navigator.chart,baseSeries=navigator.baseSeries,navSeriesMixin={enableMouseTracking:false,index:null,linkedTo:null,group:"nav",padXAxis:false,xAxis:this.navigatorOptions.xAxis?.id,yAxis:this.navigatorOptions.yAxis?.id,showInLegend:false,stacking:void 0,isInternal:true,states:{inactive:{opacity:1}}},navigatorSeries=navigator.series=(navigator.series||[]).filter(navSeries=>{const base=navSeries.baseSeries;if(baseSeries.indexOf(base)<0){if(base){Navigator_removeEvent(base,"updatedData",navigator.updatedDataHandler);delete base.navigatorSeries}if(navSeries.chart){navSeries.destroy()}return false}return true});let baseOptions,mergedNavSeriesOptions,chartNavigatorSeriesOptions=navigator.navigatorOptions.series,baseNavigatorOptions;if(baseSeries&&baseSeries.length){baseSeries.forEach(base=>{const linkedNavSeries=base.navigatorSeries,userNavOptions=Navigator_extend({color:base.color,visible:base.visible},!Navigator_isArray(chartNavigatorSeriesOptions)?chartNavigatorSeriesOptions:Navigator_defaultOptions.navigator.series);if(linkedNavSeries&&navigator.navigatorOptions.adaptToUpdatedData===false){return}navSeriesMixin.name="Navigator "+baseSeries.length;baseOptions=base.options||{};baseNavigatorOptions=baseOptions.navigatorOptions||{};userNavOptions.dataLabels=Navigator_splat(userNavOptions.dataLabels);mergedNavSeriesOptions=Navigator_merge(baseOptions,navSeriesMixin,userNavOptions,baseNavigatorOptions);mergedNavSeriesOptions.pointRange=Navigator_pick(userNavOptions.pointRange,baseNavigatorOptions.pointRange,Navigator_defaultOptions.plotOptions[mergedNavSeriesOptions.type||"line"].pointRange);const navigatorSeriesData=baseNavigatorOptions.data||userNavOptions.data;navigator.hasNavigatorData=navigator.hasNavigatorData||!!navigatorSeriesData;mergedNavSeriesOptions.data=navigatorSeriesData||baseOptions.data?.slice(0);if(linkedNavSeries&&linkedNavSeries.options){linkedNavSeries.update(mergedNavSeriesOptions,redraw)}else{base.navigatorSeries=chart.initSeries(mergedNavSeriesOptions);chart.setSortedData();base.navigatorSeries.baseSeries=base;navigatorSeries.push(base.navigatorSeries)}})}if(chartNavigatorSeriesOptions.data&&!(baseSeries&&baseSeries.length)||Navigator_isArray(chartNavigatorSeriesOptions)){navigator.hasNavigatorData=false;chartNavigatorSeriesOptions=Navigator_splat(chartNavigatorSeriesOptions);chartNavigatorSeriesOptions.forEach((userSeriesOptions,i)=>{navSeriesMixin.name="Navigator "+(navigatorSeries.length+1);mergedNavSeriesOptions=Navigator_merge(Navigator_defaultOptions.navigator.series,{color:chart.series[i]&&!chart.series[i].options.isInternal&&chart.series[i].color||chart.options.colors[i]||chart.options.colors[0]},navSeriesMixin,userSeriesOptions);mergedNavSeriesOptions.data=userSeriesOptions.data;if(mergedNavSeriesOptions.data){navigator.hasNavigatorData=true;navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions))}})}if(addEvents){this.addBaseSeriesEvents()}}addBaseSeriesEvents(){const navigator=this,baseSeries=navigator.baseSeries||[];if(baseSeries[0]&&baseSeries[0].xAxis){baseSeries[0].eventsToUnbind.push(Navigator_addEvent(baseSeries[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes))}baseSeries.forEach(base=>{base.eventsToUnbind.push(Navigator_addEvent(base,"show",function(){if(this.navigatorSeries){this.navigatorSeries.setVisible(true,false)}}));base.eventsToUnbind.push(Navigator_addEvent(base,"hide",function(){if(this.navigatorSeries){this.navigatorSeries.setVisible(false,false)}}));if(this.navigatorOptions.adaptToUpdatedData!==false){if(base.xAxis){base.eventsToUnbind.push(Navigator_addEvent(base,"updatedData",this.updatedDataHandler))}}base.eventsToUnbind.push(Navigator_addEvent(base,"remove",function(){if(baseSeries){Navigator_erase(baseSeries,base)}if(this.navigatorSeries&&navigator.series){Navigator_erase(navigator.series,this.navigatorSeries);if(Navigator_defined(this.navigatorSeries.options)){this.navigatorSeries.remove(false)}delete this.navigatorSeries}}))})}getBaseSeriesMin(currentSeriesMin){return this.baseSeries.reduce(function(min,series){return Math.min(min,series.getColumn("x")[0]??min)},currentSeriesMin)}modifyNavigatorAxisExtremes(){const xAxis=this.xAxis;if(typeof xAxis.getExtremes!=="undefined"){const unionExtremes=this.getUnionExtremes(true);if(unionExtremes&&(unionExtremes.dataMin!==xAxis.min||unionExtremes.dataMax!==xAxis.max)){xAxis.min=unionExtremes.dataMin;xAxis.max=unionExtremes.dataMax}}}modifyBaseAxisExtremes(){const baseXAxis=this,navigator=baseXAxis.chart.navigator,baseExtremes=baseXAxis.getExtremes(),baseMin=baseExtremes.min,baseMax=baseExtremes.max,baseDataMin=baseExtremes.dataMin,baseDataMax=baseExtremes.dataMax,range=baseMax-baseMin,stickToMin=navigator.stickToMin,stickToMax=navigator.stickToMax,overscroll=Navigator_pick(baseXAxis.ordinal?.convertOverscroll(baseXAxis.options.overscroll),0),navigatorSeries=navigator.series&&navigator.series[0],hasSetExtremes=!!baseXAxis.setExtremes,unmutable=baseXAxis.eventArgs&&baseXAxis.eventArgs.trigger==="rangeSelectorButton";let newMax,newMin;if(!unmutable){if(stickToMin){newMin=baseDataMin;newMax=newMin+range}if(stickToMax){newMax=baseDataMax+overscroll;if(!stickToMin){newMin=Math.max(baseDataMin,newMax-range,navigator.getBaseSeriesMin(navigatorSeries&&navigatorSeries.xData?navigatorSeries.xData[0]:-Number.MAX_VALUE))}}if(hasSetExtremes&&(stickToMin||stickToMax)){if(Navigator_isNumber(newMin)){baseXAxis.min=baseXAxis.userMin=newMin;baseXAxis.max=baseXAxis.userMax=newMax}}}navigator.stickToMin=navigator.stickToMax=null}updatedDataHandler(){const navigator=this.chart.navigator,baseSeries=this,navigatorSeries=this.navigatorSeries,shouldStickToMax=navigator.reversedExtremes?Math.round(navigator.zoomedMin)===0:Math.round(navigator.zoomedMax)>=Math.round(navigator.size);navigator.stickToMax=Navigator_pick(this.chart.options.navigator&&this.chart.options.navigator.stickToMax,shouldStickToMax);navigator.stickToMin=navigator.shouldStickToMin(baseSeries,navigator);if(navigatorSeries&&!navigator.hasNavigatorData){navigatorSeries.options.pointStart=baseSeries.getColumn("x")[0];navigatorSeries.setData(baseSeries.options.data,false,null,false)}}shouldStickToMin(baseSeries,navigator){const xDataMin=navigator.getBaseSeriesMin(baseSeries.getColumn("x")[0]),xAxis=baseSeries.xAxis,max=xAxis.max,min=xAxis.min,range=xAxis.options.range;let stickToMin=true;if(Navigator_isNumber(max)&&Navigator_isNumber(min)){if(range&&max-xDataMin>0){stickToMin=max-xDataMin<range}else{stickToMin=min<=xDataMin}}else{stickToMin=false}return stickToMin}addChartEvents(){if(!this.eventsToUnbind){this.eventsToUnbind=[]}this.eventsToUnbind.push(Navigator_addEvent(this.chart,"redraw",function(){const navigator=this.navigator,xAxis=navigator&&(navigator.baseSeries&&navigator.baseSeries[0]&&navigator.baseSeries[0].xAxis||this.xAxis[0]);if(xAxis){navigator.render(xAxis.min,xAxis.max)}}),Navigator_addEvent(this.chart,"getMargins",function(){const chart=this,navigator=chart.navigator;let marginName=navigator.opposite?"plotTop":"marginBottom";if(chart.inverted){marginName=navigator.opposite?"marginRight":"plotLeft"}chart[marginName]=(chart[marginName]||0)+(navigator.navigatorEnabled||!chart.inverted?navigator.height+navigator.scrollbarHeight:0)+navigator.navigatorOptions.margin}),Navigator_addEvent(Navigator,"setRange",function(e){this.chart.xAxis[0].setExtremes(e.min,e.max,e.redraw,e.animation,e.eventArguments)}))}destroy(){this.removeEvents();if(this.xAxis){Navigator_erase(this.chart.xAxis,this.xAxis);Navigator_erase(this.chart.axes,this.xAxis)}if(this.yAxis){Navigator_erase(this.chart.yAxis,this.yAxis);Navigator_erase(this.chart.axes,this.yAxis)}(this.series||[]).forEach(s=>{if(s.destroy){s.destroy()}});["series","xAxis","yAxis","shades","outline","scrollbarTrack","scrollbarRifles","scrollbarGroup","scrollbar","navigatorGroup","rendered"].forEach(prop=>{if(this[prop]&&this[prop].destroy){this[prop].destroy()}this[prop]=null});[this.handles].forEach(coll=>{Navigator_destroyObjectProperties(coll)});this.navigatorEnabled=false}}const Navigator_Navigator=Navigator;const standaloneNavigatorDefaults={chart:{height:70,margin:[0,5,0,5]},exporting:{enabled:false},legend:{enabled:false},navigator:{enabled:false},plotOptions:{series:{states:{hover:{enabled:false}},marker:{enabled:false}}},scrollbar:{enabled:false},title:{text:""},tooltip:{enabled:false},xAxis:{visible:false},yAxis:{height:0,visible:false}};const StandaloneNavigatorDefaults=standaloneNavigatorDefaults;const{merge:StandaloneNavigator_merge,addEvent:StandaloneNavigator_addEvent,fireEvent:StandaloneNavigator_fireEvent,pick:StandaloneNavigator_pick}=Core_Utilities;class StandaloneNavigator{static navigator(renderTo,options){const nav=new StandaloneNavigator(renderTo,options);if(!Core_Globals.navigators){Core_Globals.navigators=[nav]}else{Core_Globals.navigators.push(nav)}return nav}constructor(element,userOptions){this.boundAxes=[];this.userOptions=userOptions;this.chartOptions=StandaloneNavigator_merge(Core_Globals.getOptions(),StandaloneNavigatorDefaults,{navigator:userOptions});if(this.chartOptions.chart&&userOptions.height){this.chartOptions.chart.height=userOptions.height}const chart=new Chart_Chart(element,this.chartOptions);chart.options=StandaloneNavigator_merge(chart.options,{navigator:{enabled:true},scrollbar:{enabled:true}});if(this.chartOptions.navigator&&this.chartOptions.scrollbar){this.chartOptions.navigator.enabled=true;this.chartOptions.scrollbar.enabled=true}this.navigator=new Navigator_Navigator(chart);chart.navigator=this.navigator;this.initNavigator()}bind(axisOrChart,twoWay=true){const nav=this;const axis=axisOrChart instanceof Chart_Chart?axisOrChart.xAxis[0]:axisOrChart;if(!(axis instanceof Axis_Axis)){return}const{min,max}=this.navigator.xAxis,removeEventCallbacks=[];if(twoWay){const removeSetExtremesEvent=StandaloneNavigator_addEvent(axis,"setExtremes",e=>{if(e.trigger==="pan"||e.trigger==="zoom"||e.trigger==="mouseWheelZoom"){nav.setRange(e.min,e.max,true,e.trigger!=="pan",{trigger:axis})}});removeEventCallbacks.push(removeSetExtremesEvent)}const removeSetRangeEvent=StandaloneNavigator_addEvent(this.navigator,"setRange",e=>{axis.setExtremes(e.min,e.max,e.redraw,e.animation)});removeEventCallbacks.push(removeSetRangeEvent);let boundAxis=this.boundAxes.filter(function(boundAxis){return boundAxis.axis===axis})[0];if(!boundAxis){boundAxis={axis:axis,callbacks:[]};this.boundAxes.push(boundAxis)}boundAxis.callbacks=removeEventCallbacks;axis.series.forEach(series=>{if(series.options.showInNavigator){nav.addSeries(series.options)}});axis.setExtremes(min,max);StandaloneNavigator_addEvent(axis,"destroy",e=>{if(!e.keepEvents){this.unbind(axis)}})}unbind(axisOrChart){if(!axisOrChart){this.boundAxes.forEach(({callbacks})=>{callbacks.forEach(removeCallback=>removeCallback())});this.boundAxes.length=0;return}const axis=axisOrChart instanceof Axis_Axis?axisOrChart:axisOrChart.xAxis[0];for(let i=this.boundAxes.length-1;i>=0;i--){if(this.boundAxes[i].axis===axis){this.boundAxes[i].callbacks.forEach(callback=>callback());this.boundAxes.splice(i,1)}}}destroy(){this.boundAxes.forEach(({callbacks})=>{callbacks.forEach(removeCallback=>removeCallback())});this.boundAxes.length=0;this.navigator.destroy();this.navigator.chart.destroy()}update(newOptions,redraw){this.chartOptions=StandaloneNavigator_merge(this.chartOptions,newOptions.height&&{chart:{height:newOptions.height}},{navigator:newOptions});this.navigator.chart.update(this.chartOptions,redraw)}redraw(){this.navigator.chart.redraw()}addSeries(seriesOptions){this.navigator.chart.addSeries(StandaloneNavigator_merge(seriesOptions,{showInNavigator:StandaloneNavigator_pick(seriesOptions.showInNavigator,true)}));this.navigator.setBaseSeries()}initNavigator(){const nav=this.navigator;nav.top=1;nav.xAxis.setScale();nav.yAxis.setScale();nav.xAxis.render();nav.yAxis.render();nav.series?.forEach(s=>{s.translate();s.render();s.redraw()});const{min,max}=this.getInitialExtremes();nav.chart.xAxis[0].userMin=min;nav.chart.xAxis[0].userMax=max;nav.render(min,max)}getRange(){const{min,max}=this.navigator.chart.xAxis[0].getExtremes(),{userMin,userMax,min:dataMin,max:dataMax}=this.navigator.xAxis.getExtremes();return{min:StandaloneNavigator_pick(min,dataMin),max:StandaloneNavigator_pick(max,dataMax),dataMin:dataMin,dataMax:dataMax,userMin:userMin,userMax:userMax}}setRange(min,max,redraw,animation,eventArguments){StandaloneNavigator_fireEvent(this.navigator,"setRange",{min:min,max:max,redraw:redraw,animation:animation,eventArguments:StandaloneNavigator_merge(eventArguments,{trigger:"navigator"})})}getInitialExtremes(){const{min,max}=this.navigator.xAxis.getExtremes();return{min:min,max:max}}}const Navigator_StandaloneNavigator=StandaloneNavigator;"";const navigator_src_G=Core_Globals;navigator_src_G.StandaloneNavigator=navigator_src_G.StandaloneNavigator||Navigator_StandaloneNavigator;navigator_src_G.navigator=navigator_src_G.StandaloneNavigator.navigator;Navigator_NavigatorComposition.compose(navigator_src_G.Chart,navigator_src_G.Axis,navigator_src_G.Series);const navigator_src=null&&Highcharts;const standalone_navigator_src=highcharts_src;__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});