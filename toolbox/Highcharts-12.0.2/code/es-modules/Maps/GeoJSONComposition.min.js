"use strict";import H from"../Core/Globals.js";const{win}=H;import T from"../Core/Templating.js";const{format}=T;import U from"../Core/Utilities.js";const{error,extend,merge,wrap}=U;var GeoJSONComposition;(function(GeoJSONComposition){function chartFromLatLonToPoint(lonLat){return this.mapView&&this.mapView.lonLatToProjectedUnits(lonLat)}function chartFromPointToLatLon(point){return this.mapView&&this.mapView.projectedUnitsToLonLat(point)}function chartTransformFromLatLon(latLon,transform){const proj4=this.options.chart.proj4||win.proj4;if(!proj4){error(21,false,this);return}const{jsonmarginX=0,jsonmarginY=0,jsonres=1,scale=1,xoffset=0,xpan=0,yoffset=0,ypan=0}=transform;const projected=proj4(transform.crs,[latLon.lon,latLon.lat]),cosAngle=transform.cosAngle||transform.rotation&&Math.cos(transform.rotation),sinAngle=transform.sinAngle||transform.rotation&&Math.sin(transform.rotation),rotated=transform.rotation?[projected[0]*cosAngle+projected[1]*sinAngle,-projected[0]*sinAngle+projected[1]*cosAngle]:projected;return{x:((rotated[0]-xoffset)*scale+xpan)*jsonres+jsonmarginX,y:-(((yoffset-rotated[1])*scale+ypan)*jsonres-jsonmarginY)}}function chartTransformToLatLon(point,transform){const proj4=this.options.chart.proj4||win.proj4;if(!proj4){error(21,false,this);return}if(point.y===null){return}const{jsonmarginX=0,jsonmarginY=0,jsonres=1,scale=1,xoffset=0,xpan=0,yoffset=0,ypan=0}=transform;const normalized={x:((point.x-jsonmarginX)/jsonres-xpan)/scale+xoffset,y:((point.y-jsonmarginY)/jsonres+ypan)/scale+yoffset},cosAngle=transform.cosAngle||transform.rotation&&Math.cos(transform.rotation),sinAngle=transform.sinAngle||transform.rotation&&Math.sin(transform.rotation),projected=proj4(transform.crs,"WGS84",transform.rotation?{x:normalized.x*cosAngle+normalized.y*-sinAngle,y:normalized.x*sinAngle+normalized.y*cosAngle}:normalized);return{lat:projected.y,lon:projected.x}}function compose(ChartClass){const chartProto=ChartClass.prototype;if(!chartProto.transformFromLatLon){chartProto.fromLatLonToPoint=chartFromLatLonToPoint;chartProto.fromPointToLatLon=chartFromPointToLatLon;chartProto.transformFromLatLon=chartTransformFromLatLon;chartProto.transformToLatLon=chartTransformToLatLon;wrap(chartProto,"addCredits",wrapChartAddCredit)}}GeoJSONComposition.compose=compose;function geojson(json,hType="map",series){const mapData=[];const geojson=json.type==="Topology"?topo2geo(json):json,features=geojson.features;for(let i=0,iEnd=features.length;i<iEnd;++i){const feature=features[i],geometry=feature.geometry||{},type=geometry.type,coordinates=geometry.coordinates,properties=feature.properties;let pointOptions;if((hType==="map"||hType==="mapbubble")&&(type==="Polygon"||type==="MultiPolygon")){if(coordinates.length){pointOptions={geometry:{coordinates:coordinates,type:type}}}}else if(hType==="mapline"&&(type==="LineString"||type==="MultiLineString")){if(coordinates.length){pointOptions={geometry:{coordinates:coordinates,type:type}}}}else if(hType==="mappoint"&&type==="Point"){if(coordinates.length){pointOptions={geometry:{coordinates:coordinates,type:type}}}}if(pointOptions){const name=properties&&(properties.name||properties.NAME),lon=properties&&properties.lon,lat=properties&&properties.lat;mapData.push(extend(pointOptions,{lat:typeof lat==="number"?lat:void 0,lon:typeof lon==="number"?lon:void 0,name:typeof name==="string"?name:void 0,properties:properties}))}}if(series&&geojson.copyrightShort){series.chart.mapCredits=format(series.chart.options.credits?.mapText,{geojson:geojson});series.chart.mapCreditsFull=format(series.chart.options.credits?.mapTextFull,{geojson:geojson})}return mapData}GeoJSONComposition.geojson=geojson;function topo2geo(topology,objectName){if(!objectName){objectName=Object.keys(topology.objects)[0]}const obj=topology.objects[objectName];if(obj["hc-decoded-geojson"]&&obj["hc-decoded-geojson"].title===topology.title){return obj["hc-decoded-geojson"]}let arcsArray=topology.arcs;if(topology.transform){const arcs=topology.arcs,{scale,translate}=topology.transform;let positionArray,x,y;arcsArray=[];for(let i=0,iEnd=arcs.length;i<iEnd;++i){const positions=arcs[i];arcsArray.push(positionArray=[]);x=0;y=0;for(let j=0,jEnd=positions.length;j<jEnd;++j){positionArray.push([(x+=positions[j][0])*scale[0]+translate[0],(y+=positions[j][1])*scale[1]+translate[1]])}}}const arcsToCoordinates=arcs=>{if(typeof arcs[0]==="number"){return arcs.reduce((coordinates,arcNo,i)=>{let arc=arcNo<0?arcsArray[~arcNo]:arcsArray[arcNo];if(arcNo<0){arc=arc.slice(0,i===0?arc.length:arc.length-1);arc.reverse()}else if(i){arc=arc.slice(1)}return coordinates.concat(arc)},[])}return arcs.map(arcsToCoordinates)};const geometries=obj.geometries,features=[];for(let i=0,iEnd=geometries.length;i<iEnd;++i){features.push({type:"Feature",properties:geometries[i].properties,geometry:{type:geometries[i].type,coordinates:geometries[i].coordinates||arcsToCoordinates(geometries[i].arcs)}})}const geojson={type:"FeatureCollection",copyright:topology.copyright,copyrightShort:topology.copyrightShort,copyrightUrl:topology.copyrightUrl,features:features,"hc-recommended-mapview":obj["hc-recommended-mapview"],bbox:topology.bbox,title:topology.title};obj["hc-decoded-geojson"]=geojson;return geojson}GeoJSONComposition.topo2geo=topo2geo;function wrapChartAddCredit(proceed,credits){credits=merge(true,this.options.credits,credits);proceed.call(this,credits);if(this.credits&&this.mapCreditsFull){this.credits.attr({title:this.mapCreditsFull})}}})(GeoJSONComposition||(GeoJSONComposition={}));export default GeoJSONComposition;"";