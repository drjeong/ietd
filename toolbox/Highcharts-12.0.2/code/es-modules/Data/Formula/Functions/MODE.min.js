"use strict";import FormulaProcessor from"../FormulaProcessor.js";function getModeMap(args,table){const modeMap={},values=FormulaProcessor.getArgumentsValues(args,table);for(let i=0,iEnd=values.length,value;i<iEnd;++i){value=values[i];switch(typeof value){case"number":if(!isNaN(value)){modeMap[value]=(modeMap[value]||0)+1}break;case"object":for(let j=0,jEnd=value.length,value2;j<jEnd;++j){value2=value[j];if(typeof value2==="number"&&!isNaN(value2)){modeMap[value2]=(modeMap[value2]||0)+1}}break}}return modeMap}function MULT(args,table){const modeMap=getModeMap(args,table),keys=Object.keys(modeMap);if(!keys.length){return NaN}let modeKeys=[parseFloat(keys[0])],modeCount=modeMap[keys[0]];for(let i=1,iEnd=keys.length,key,count;i<iEnd;++i){key=keys[i];count=modeMap[key];if(modeCount<count){modeKeys=[parseFloat(key)];modeCount=count}else if(modeCount===count){modeKeys.push(parseFloat(key))}}return modeCount>1?modeKeys:NaN}function SNGL(args,table){const modeMap=getModeMap(args,table),keys=Object.keys(modeMap);if(!keys.length){return NaN}let modeKey=parseFloat(keys[0]),modeCount=modeMap[keys[0]];for(let i=1,iEnd=keys.length,key,keyValue,count;i<iEnd;++i){key=keys[i];count=modeMap[key];if(modeCount<count){modeKey=parseFloat(key);modeCount=count}else if(modeCount===count){keyValue=parseFloat(key);if(modeKey>keyValue){modeKey=keyValue;modeCount=count}}}return modeCount>1?modeKey:NaN}FormulaProcessor.registerProcessorFunction("MODE",SNGL);FormulaProcessor.registerProcessorFunction("MODE.MULT",MULT);FormulaProcessor.registerProcessorFunction("MODE.SNGL",SNGL);const MODE={MULT:MULT,SNGL:SNGL};export default MODE;