"use strict";import DataTableCore from"./DataTableCore.js";import U from"../Core/Utilities.js";const{addEvent,defined,fireEvent,extend,uniqueKey}=U;class DataTable extends DataTableCore{static isNull(row){if(row===DataTable.NULL){return true}if(row instanceof Array){if(!row.length){return false}for(let i=0,iEnd=row.length;i<iEnd;++i){if(row[i]!==null){return false}}}else{const columnNames=Object.keys(row);if(!columnNames.length){return false}for(let i=0,iEnd=columnNames.length;i<iEnd;++i){if(row[columnNames[i]]!==null){return false}}}return true}constructor(options={}){super(options);this.modified=this}clone(skipColumns,eventDetail){const table=this,tableOptions={};table.emit({type:"cloneTable",detail:eventDetail});if(!skipColumns){tableOptions.columns=table.columns}if(!table.autoId){tableOptions.id=table.id}const tableClone=new DataTable(tableOptions);if(!skipColumns){tableClone.versionTag=table.versionTag;tableClone.originalRowIndexes=table.originalRowIndexes;tableClone.localRowIndexes=table.localRowIndexes}table.emit({type:"afterCloneTable",detail:eventDetail,tableClone:tableClone});return tableClone}deleteColumns(columnNames,eventDetail){const table=this,columns=table.columns,deletedColumns={},modifiedColumns={},modifier=table.modifier,rowCount=table.rowCount;columnNames=columnNames||Object.keys(columns);if(columnNames.length){table.emit({type:"deleteColumns",columnNames:columnNames,detail:eventDetail});for(let i=0,iEnd=columnNames.length,column,columnName;i<iEnd;++i){columnName=columnNames[i];column=columns[columnName];if(column){deletedColumns[columnName]=column;modifiedColumns[columnName]=new Array(rowCount)}delete columns[columnName]}if(!Object.keys(columns).length){table.rowCount=0;this.deleteRowIndexReferences()}if(modifier){modifier.modifyColumns(table,modifiedColumns,0,eventDetail)}table.emit({type:"afterDeleteColumns",columns:deletedColumns,columnNames:columnNames,detail:eventDetail});return deletedColumns}}deleteRowIndexReferences(){delete this.originalRowIndexes;delete this.localRowIndexes}deleteRows(rowIndex,rowCount=1,eventDetail){const table=this,deletedRows=[],modifiedRows=[],modifier=table.modifier;table.emit({type:"deleteRows",detail:eventDetail,rowCount:rowCount,rowIndex:rowIndex||0});if(typeof rowIndex==="undefined"){rowIndex=0;rowCount=table.rowCount}if(rowCount>0&&rowIndex<table.rowCount){const columns=table.columns,columnNames=Object.keys(columns);for(let i=0,iEnd=columnNames.length,column,deletedCells;i<iEnd;++i){column=columns[columnNames[i]];deletedCells=column.splice(rowIndex,rowCount);if(!i){table.rowCount=column.length}for(let j=0,jEnd=deletedCells.length;j<jEnd;++j){deletedRows[j]=deletedRows[j]||[];deletedRows[j][i]=deletedCells[j]}modifiedRows.push(new Array(iEnd))}}if(modifier){modifier.modifyRows(table,modifiedRows,rowIndex||0,eventDetail)}table.emit({type:"afterDeleteRows",detail:eventDetail,rowCount:rowCount,rowIndex:rowIndex||0,rows:deletedRows});return deletedRows}emit(e){if(["afterDeleteColumns","afterDeleteRows","afterSetCell","afterSetColumns","afterSetRows"].includes(e.type)){this.versionTag=uniqueKey()}fireEvent(this,e.type,e)}getCell(columnName,rowIndex){const table=this;const column=table.columns[columnName];if(column){return column[rowIndex]}}getCellAsBoolean(columnName,rowIndex){const table=this;const column=table.columns[columnName];return!!(column&&column[rowIndex])}getCellAsNumber(columnName,rowIndex,useNaN){const table=this;const column=table.columns[columnName];let cellValue=column&&column[rowIndex];switch(typeof cellValue){case"boolean":return cellValue?1:0;case"number":return isNaN(cellValue)&&!useNaN?null:cellValue}cellValue=parseFloat(`${cellValue??""}`);return isNaN(cellValue)&&!useNaN?null:cellValue}getCellAsString(columnName,rowIndex){const table=this;const column=table.columns[columnName];return`${column&&column[rowIndex]}`}getColumn(columnName,asReference){return this.getColumns([columnName],asReference)[columnName]}getColumnAsNumbers(columnName,useNaN){const table=this,columns=table.columns;const column=columns[columnName],columnAsNumber=[];if(column){const columnLength=column.length;if(useNaN){for(let i=0;i<columnLength;++i){columnAsNumber.push(table.getCellAsNumber(columnName,i,true))}}else{for(let i=0,cellValue;i<columnLength;++i){cellValue=column[i];if(typeof cellValue==="number"){return column.slice()}if(cellValue!==null&&typeof cellValue!=="undefined"){break}}for(let i=0;i<columnLength;++i){columnAsNumber.push(table.getCellAsNumber(columnName,i))}}}return columnAsNumber}getColumnNames(){const table=this,columnNames=Object.keys(table.columns);return columnNames}getColumns(columnNames,asReference){const table=this,tableColumns=table.columns,columns={};columnNames=columnNames||Object.keys(tableColumns);for(let i=0,iEnd=columnNames.length,column,columnName;i<iEnd;++i){columnName=columnNames[i];column=tableColumns[columnName];if(column){columns[columnName]=asReference?column:column.slice()}}return columns}getLocalRowIndex(originalRowIndex){const{localRowIndexes}=this;if(localRowIndexes){return localRowIndexes[originalRowIndex]}return originalRowIndex}getModifier(){return this.modifier}getOriginalRowIndex(rowIndex){const{originalRowIndexes}=this;if(originalRowIndexes){return originalRowIndexes[rowIndex]}return rowIndex}getRow(rowIndex,columnNames){return this.getRows(rowIndex,1,columnNames)[0]}getRowCount(){return this.rowCount}getRowIndexBy(columnName,cellValue,rowIndexOffset){const table=this;const column=table.columns[columnName];if(column){const rowIndex=column.indexOf(cellValue,rowIndexOffset);if(rowIndex!==-1){return rowIndex}}}getRowObject(rowIndex,columnNames){return this.getRowObjects(rowIndex,1,columnNames)[0]}getRowObjects(rowIndex=0,rowCount=this.rowCount-rowIndex,columnNames){const table=this,columns=table.columns,rows=new Array(rowCount);columnNames=columnNames||Object.keys(columns);for(let i=rowIndex,i2=0,iEnd=Math.min(table.rowCount,rowIndex+rowCount),column,row;i<iEnd;++i,++i2){row=rows[i2]={};for(const columnName of columnNames){column=columns[columnName];row[columnName]=column?column[i]:void 0}}return rows}getRows(rowIndex=0,rowCount=this.rowCount-rowIndex,columnNames){const table=this,columns=table.columns,rows=new Array(rowCount);columnNames=columnNames||Object.keys(columns);for(let i=rowIndex,i2=0,iEnd=Math.min(table.rowCount,rowIndex+rowCount),column,row;i<iEnd;++i,++i2){row=rows[i2]=[];for(const columnName of columnNames){column=columns[columnName];row.push(column?column[i]:void 0)}}return rows}getVersionTag(){return this.versionTag}hasColumns(columnNames){const table=this,columns=table.columns;for(let i=0,iEnd=columnNames.length,columnName;i<iEnd;++i){columnName=columnNames[i];if(!columns[columnName]){return false}}return true}hasRowWith(columnName,cellValue){const table=this;const column=table.columns[columnName];if(column){return column.indexOf(cellValue)!==-1}return false}on(type,callback){return addEvent(this,type,callback)}renameColumn(columnName,newColumnName){const table=this,columns=table.columns;if(columns[columnName]){if(columnName!==newColumnName){columns[newColumnName]=columns[columnName];delete columns[columnName]}return true}return false}setCell(columnName,rowIndex,cellValue,eventDetail){const table=this,columns=table.columns,modifier=table.modifier;let column=columns[columnName];if(column&&column[rowIndex]===cellValue){return}table.emit({type:"setCell",cellValue:cellValue,columnName:columnName,detail:eventDetail,rowIndex:rowIndex});if(!column){column=columns[columnName]=new Array(table.rowCount)}if(rowIndex>=table.rowCount){table.rowCount=rowIndex+1}column[rowIndex]=cellValue;if(modifier){modifier.modifyCell(table,columnName,rowIndex,cellValue)}table.emit({type:"afterSetCell",cellValue:cellValue,columnName:columnName,detail:eventDetail,rowIndex:rowIndex})}setColumns(columns,rowIndex,eventDetail){const table=this,tableColumns=table.columns,tableModifier=table.modifier,columnNames=Object.keys(columns);let rowCount=table.rowCount;table.emit({type:"setColumns",columns:columns,columnNames:columnNames,detail:eventDetail,rowIndex:rowIndex});if(typeof rowIndex==="undefined"){super.setColumns(columns,rowIndex,extend(eventDetail,{silent:true}))}else{for(let i=0,iEnd=columnNames.length,column,columnName;i<iEnd;++i){columnName=columnNames[i];column=columns[columnName];const tableColumn=tableColumns[columnName]?tableColumns[columnName]:tableColumns[columnName]=new Array(table.rowCount);for(let i=rowIndex||0,iEnd=column.length;i<iEnd;++i){tableColumn[i]=column[i]}rowCount=Math.max(rowCount,tableColumn.length)}this.applyRowCount(rowCount)}if(tableModifier){tableModifier.modifyColumns(table,columns,rowIndex||0)}table.emit({type:"afterSetColumns",columns:columns,columnNames:columnNames,detail:eventDetail,rowIndex:rowIndex})}setModifier(modifier,eventDetail){const table=this;let promise;table.emit({type:"setModifier",detail:eventDetail,modifier:modifier,modified:table.modified});table.modified=table;table.modifier=modifier;if(modifier){promise=modifier.modify(table)}else{promise=Promise.resolve(table)}return promise.then(table=>{table.emit({type:"afterSetModifier",detail:eventDetail,modifier:modifier,modified:table.modified});return table})["catch"](error=>{table.emit({type:"setModifierError",error:error,modifier:modifier,modified:table.modified});throw error})}setOriginalRowIndexes(originalRowIndexes,omitLocalRowIndexes=false){this.originalRowIndexes=originalRowIndexes;if(omitLocalRowIndexes){return}const modifiedIndexes=this.localRowIndexes=[];for(let i=0,iEnd=originalRowIndexes.length,originalIndex;i<iEnd;++i){originalIndex=originalRowIndexes[i];if(defined(originalIndex)){modifiedIndexes[originalIndex]=i}}}setRow(row,rowIndex,insert,eventDetail){this.setRows([row],rowIndex,insert,eventDetail)}setRows(rows,rowIndex=this.rowCount,insert,eventDetail){const table=this,columns=table.columns,columnNames=Object.keys(columns),modifier=table.modifier,rowCount=rows.length;table.emit({type:"setRows",detail:eventDetail,rowCount:rowCount,rowIndex:rowIndex,rows:rows});for(let i=0,i2=rowIndex,row;i<rowCount;++i,++i2){row=rows[i];if(row===DataTable.NULL){for(let j=0,jEnd=columnNames.length;j<jEnd;++j){if(insert){columns[columnNames[j]].splice(i2,0,null)}else{columns[columnNames[j]][i2]=null}}}else if(row instanceof Array){for(let j=0,jEnd=columnNames.length;j<jEnd;++j){columns[columnNames[j]][i2]=row[j]}}else{super.setRow(row,i2,void 0,{silent:true})}}const indexRowCount=insert?rowCount+rows.length:rowIndex+rowCount;if(indexRowCount>table.rowCount){table.rowCount=indexRowCount;for(let i=0,iEnd=columnNames.length;i<iEnd;++i){columns[columnNames[i]].length=indexRowCount}}if(modifier){modifier.modifyRows(table,rows,rowIndex)}table.emit({type:"afterSetRows",detail:eventDetail,rowCount:rowCount,rowIndex:rowIndex,rows:rows})}}DataTable.NULL={};DataTable.version="1.0.0";export default DataTable;