"use strict";import Point from"../../../Core/Series/Point.js";import Series from"../../../Core/Series/Series.js";import SeriesRegistry from"../../../Core/Series/SeriesRegistry.js";const{seriesTypes}=SeriesRegistry;import H from"../../../Core/Globals.js";const{doc}=H;import U from"../../../Core/Utilities.js";const{defined,fireEvent}=U;import KeyboardNavigationHandler from"../../KeyboardNavigationHandler.js";import EventProvider from"../../Utils/EventProvider.js";import ChartUtilities from"../../Utils/ChartUtilities.js";const{getPointFromXY,getSeriesFromName,scrollAxisToPoint}=ChartUtilities;function getPointIndex(point){const index=point.index,points=point.series.points;let i=points.length;if(points[index]!==point){while(i--){if(points[i]===point){return i}}}else{return index}}function isSkipSeries(series){const a11yOptions=series.chart.options.accessibility,seriesNavOptions=a11yOptions.keyboardNavigation.seriesNavigation,seriesA11yOptions=series.options.accessibility||{},seriesKbdNavOptions=seriesA11yOptions.keyboardNavigation;return seriesKbdNavOptions&&seriesKbdNavOptions.enabled===false||seriesA11yOptions.enabled===false||series.options.enableMouseTracking===false||!series.visible||seriesNavOptions.pointNavigationEnabledThreshold&&+seriesNavOptions.pointNavigationEnabledThreshold<=series.points.length}function isSkipPoint(point){const a11yOptions=point.series.chart.options.accessibility;const pointA11yDisabled=point.options.accessibility&&point.options.accessibility.enabled===false;return point.isNull&&a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints||point.visible===false||point.isInside===false||pointA11yDisabled||isSkipSeries(point.series)}function getFirstValidPointInSeries(series){const points=series.points||[],len=points.length;for(let i=0;i<len;++i){if(!isSkipPoint(points[i])){return points[i]}}return null}function getFirstValidPointInChart(chart){const series=chart.series||[],len=series.length;for(let i=0;i<len;++i){if(!isSkipSeries(series[i])){const point=getFirstValidPointInSeries(series[i]);if(point){return point}}}return null}function highlightLastValidPointInChart(chart){const numSeries=chart.series.length;let i=numSeries,res=false;while(i--){chart.highlightedPoint=chart.series[i].points[chart.series[i].points.length-1];res=chart.series[i].highlightNextValidPoint();if(res){break}}return res}function updateChartFocusAfterDrilling(chart){const point=getFirstValidPointInChart(chart);if(point){point.highlight(false)}}function highlightFirstValidPointInChart(chart){delete chart.highlightedPoint;const point=getFirstValidPointInChart(chart);return point?point.highlight():false}class SeriesKeyboardNavigation{constructor(chart,keyCodes){this.keyCodes=keyCodes;this.chart=chart}init(){const keyboardNavigation=this,chart=this.chart,e=this.eventProvider=new EventProvider;e.addEvent(Series,"destroy",function(){return keyboardNavigation.onSeriesDestroy(this)});e.addEvent(chart,"afterApplyDrilldown",function(){updateChartFocusAfterDrilling(this)});e.addEvent(chart,"drilldown",function(e){const point=e.point,series=point.series;keyboardNavigation.lastDrilledDownPoint={x:point.x,y:point.y,seriesName:series?series.name:""}});e.addEvent(chart,"drillupall",function(){setTimeout(function(){keyboardNavigation.onDrillupAll()},10)});e.addEvent(Point,"afterSetState",function(){const point=this;const pointEl=point.graphic&&point.graphic.element;const focusedElement=doc.activeElement;const focusedElClassName=focusedElement&&focusedElement.getAttribute("class");const isProxyFocused=focusedElClassName&&focusedElClassName.indexOf("highcharts-a11y-proxy-element")>-1;if(chart.highlightedPoint===point&&focusedElement!==pointEl&&!isProxyFocused&&pointEl&&pointEl.focus){pointEl.focus()}})}onDrillupAll(){const last=this.lastDrilledDownPoint,chart=this.chart,series=last&&getSeriesFromName(chart,last.seriesName);let point;if(last&&series&&defined(last.x)&&defined(last.y)){point=getPointFromXY(series,last.x,last.y)}point=point||getFirstValidPointInChart(chart);if(chart.container){chart.container.focus()}if(point&&point.highlight){point.highlight(false)}}getKeyboardNavigationHandler(){const keyboardNavigation=this,keys=this.keyCodes,chart=this.chart,inverted=chart.inverted;return new KeyboardNavigationHandler(chart,{keyCodeMap:[[inverted?[keys.up,keys.down]:[keys.left,keys.right],function(keyCode){return keyboardNavigation.onKbdSideways(this,keyCode)}],[inverted?[keys.left,keys.right]:[keys.up,keys.down],function(keyCode){return keyboardNavigation.onKbdVertical(this,keyCode)}],[[keys.enter,keys.space],function(keyCode,event){const point=chart.highlightedPoint;if(point){const{plotLeft,plotTop}=this.chart,{plotX=0,plotY=0}=point;event={...event,chartX:plotLeft+plotX,chartY:plotTop+plotY,point:point,target:point.graphic?.element||event.target};fireEvent(point.series,"click",event);point.firePointEvent("click",event)}return this.response.success}],[[keys.home],function(){highlightFirstValidPointInChart(chart);return this.response.success}],[[keys.end],function(){highlightLastValidPointInChart(chart);return this.response.success}],[[keys.pageDown,keys.pageUp],function(keyCode){chart.highlightAdjacentSeries(keyCode===keys.pageDown);return this.response.success}]],init:function(){return keyboardNavigation.onHandlerInit(this)},validate:function(){return!!getFirstValidPointInChart(chart)},terminate:function(){return keyboardNavigation.onHandlerTerminate()}})}onKbdSideways(handler,keyCode){const keys=this.keyCodes,isNext=keyCode===keys.right||keyCode===keys.down;return this.attemptHighlightAdjacentPoint(handler,isNext)}onHandlerInit(handler){const chart=this.chart,kbdNavOptions=chart.options.accessibility.keyboardNavigation;if(kbdNavOptions.seriesNavigation.rememberPointFocus&&chart.highlightedPoint){chart.highlightedPoint.highlight()}else{highlightFirstValidPointInChart(chart)}return handler.response.success}onKbdVertical(handler,keyCode){const chart=this.chart,keys=this.keyCodes,isNext=keyCode===keys.down||keyCode===keys.right,navOptions=chart.options.accessibility.keyboardNavigation.seriesNavigation;if(navOptions.mode&&navOptions.mode==="serialize"){return this.attemptHighlightAdjacentPoint(handler,isNext)}const highlightMethod=chart.highlightedPoint&&chart.highlightedPoint.series.keyboardMoveVertical?"highlightAdjacentPointVertical":"highlightAdjacentSeries";chart[highlightMethod](isNext);return handler.response.success}onHandlerTerminate(){const chart=this.chart,kbdNavOptions=chart.options.accessibility.keyboardNavigation;if(chart.tooltip){chart.tooltip.hide(0)}const hoverSeries=chart.highlightedPoint&&chart.highlightedPoint.series;if(hoverSeries&&hoverSeries.onMouseOut){hoverSeries.onMouseOut()}if(chart.highlightedPoint&&chart.highlightedPoint.onMouseOut){chart.highlightedPoint.onMouseOut()}if(!kbdNavOptions.seriesNavigation.rememberPointFocus){delete chart.highlightedPoint}}attemptHighlightAdjacentPoint(handler,directionIsNext){const chart=this.chart,wrapAround=chart.options.accessibility.keyboardNavigation.wrapAround,highlightSuccessful=chart.highlightAdjacentPoint(directionIsNext);if(!highlightSuccessful){if(wrapAround&&(directionIsNext?highlightFirstValidPointInChart(chart):highlightLastValidPointInChart(chart))){return handler.response.success}return handler.response[directionIsNext?"next":"prev"]}return handler.response.success}onSeriesDestroy(series){const chart=this.chart,currentHighlightedPointDestroyed=chart.highlightedPoint&&chart.highlightedPoint.series===series;if(currentHighlightedPointDestroyed){delete chart.highlightedPoint;if(chart.focusElement){chart.focusElement.removeFocusBorder()}}}destroy(){this.eventProvider.removeAddedEvents()}}(function(SeriesKeyboardNavigation){function chartHighlightAdjacentPoint(next){const chart=this,series=chart.series,curPoint=chart.highlightedPoint,curPointIndex=curPoint&&getPointIndex(curPoint)||0,curPoints=curPoint&&curPoint.series.points||[],lastSeries=chart.series&&chart.series[chart.series.length-1],lastPoint=lastSeries&&lastSeries.points&&lastSeries.points[lastSeries.points.length-1];let newSeries,newPoint;if(!series[0]||!series[0].points){return false}if(!curPoint){newPoint=next?series[0].points[0]:lastPoint}else{newSeries=series[curPoint.series.index+(next?1:-1)];newPoint=curPoints[curPointIndex+(next?1:-1)];if(!newPoint&&newSeries){newPoint=newSeries.points[next?0:newSeries.points.length-1]}if(!newPoint){return false}}if(isSkipPoint(newPoint)){newSeries=newPoint.series;if(isSkipSeries(newSeries)){chart.highlightedPoint=next?newSeries.points[newSeries.points.length-1]:newSeries.points[0]}else{chart.highlightedPoint=newPoint}return chart.highlightAdjacentPoint(next)}return newPoint.highlight()}function chartHighlightAdjacentPointVertical(down){const curPoint=this.highlightedPoint;let minDistance=Infinity,bestPoint;if(!defined(curPoint.plotX)||!defined(curPoint.plotY)){return false}this.series.forEach(series=>{if(isSkipSeries(series)){return}series.points.forEach(point=>{if(!defined(point.plotY)||!defined(point.plotX)||point===curPoint){return}let yDistance=point.plotY-curPoint.plotY;const width=Math.abs(point.plotX-curPoint.plotX),distance=Math.abs(yDistance)*Math.abs(yDistance)+width*width*4;if(series.yAxis&&series.yAxis.reversed){yDistance*=-1}if(yDistance<=0&&down||yDistance>=0&&!down||distance<5||isSkipPoint(point)){return}if(distance<minDistance){minDistance=distance;bestPoint=point}})});return bestPoint?bestPoint.highlight():false}function chartHighlightAdjacentSeries(down){const chart=this,curPoint=chart.highlightedPoint,lastSeries=chart.series&&chart.series[chart.series.length-1],lastPoint=lastSeries&&lastSeries.points&&lastSeries.points[lastSeries.points.length-1];let newSeries,newPoint,adjacentNewPoint;if(!chart.highlightedPoint){newSeries=down?chart.series&&chart.series[0]:lastSeries;newPoint=down?newSeries&&newSeries.points&&newSeries.points[0]:lastPoint;return newPoint?newPoint.highlight():false}newSeries=chart.series[curPoint.series.index+(down?-1:1)];if(!newSeries){return false}newPoint=getClosestPoint(curPoint,newSeries,4);if(!newPoint){return false}if(isSkipSeries(newSeries)){newPoint.highlight();adjacentNewPoint=chart.highlightAdjacentSeries(down);if(!adjacentNewPoint){curPoint.highlight();return false}return adjacentNewPoint}newPoint.highlight();return newPoint.series.highlightNextValidPoint()}function compose(ChartClass,PointClass,SeriesClass){const chartProto=ChartClass.prototype,pointProto=PointClass.prototype,seriesProto=SeriesClass.prototype;if(!chartProto.highlightAdjacentPoint){chartProto.highlightAdjacentPoint=chartHighlightAdjacentPoint;chartProto.highlightAdjacentPointVertical=chartHighlightAdjacentPointVertical;chartProto.highlightAdjacentSeries=chartHighlightAdjacentSeries;pointProto.highlight=pointHighlight;seriesProto.keyboardMoveVertical=true;["column","gantt","pie"].forEach(type=>{if(seriesTypes[type]){seriesTypes[type].prototype.keyboardMoveVertical=false}});seriesProto.highlightNextValidPoint=seriesHighlightNextValidPoint}}SeriesKeyboardNavigation.compose=compose;function getClosestPoint(point,series,xWeight,yWeight){let minDistance=Infinity,dPoint,minIx,distance,i=series.points.length;const hasUndefinedPosition=point=>!(defined(point.plotX)&&defined(point.plotY));if(hasUndefinedPosition(point)){return}while(i--){dPoint=series.points[i];if(hasUndefinedPosition(dPoint)){continue}distance=(point.plotX-dPoint.plotX)*(point.plotX-dPoint.plotX)*(xWeight||1)+(point.plotY-dPoint.plotY)*(point.plotY-dPoint.plotY)*(yWeight||1);if(distance<minDistance){minDistance=distance;minIx=i}}return defined(minIx)?series.points[minIx]:void 0}function pointHighlight(highlightVisually=true){const chart=this.series.chart,tooltipElement=chart.tooltip?.label?.element;if(!this.isNull&&highlightVisually){this.onMouseOver()}else{if(chart.tooltip){chart.tooltip.hide(0)}}scrollAxisToPoint(this);if(this.graphic){chart.setFocusToElement(this.graphic);if(!highlightVisually&&chart.focusElement){chart.focusElement.removeFocusBorder()}}chart.highlightedPoint=this;const tooltipTop=tooltipElement?.getBoundingClientRect().top;if(tooltipElement&&tooltipTop&&tooltipTop<0){const scrollTop=window.scrollY,newScrollTop=scrollTop+tooltipTop;window.scrollTo({behavior:"smooth",top:newScrollTop})}return this}function seriesHighlightNextValidPoint(){const curPoint=this.chart.highlightedPoint,start=(curPoint&&curPoint.series)===this?getPointIndex(curPoint):0,points=this.points,len=points.length;if(points&&len){for(let i=start;i<len;++i){if(!isSkipPoint(points[i])){return points[i].highlight()}}for(let j=start;j>=0;--j){if(!isSkipPoint(points[j])){return points[j].highlight()}}}return false}})(SeriesKeyboardNavigation||(SeriesKeyboardNavigation={}));export default SeriesKeyboardNavigation;