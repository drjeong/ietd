"use strict";import Chart from"../../../Core/Chart/Chart.js";import SeriesRegistry from"../../../Core/Series/SeriesRegistry.js";const{line:LineSeries}=SeriesRegistry.seriesTypes;import U from"../../../Core/Utilities.js";const{addEvent,fireEvent,error,extend,isArray,merge,pick}=U;const tableToMultiYData=(series,processed)=>{const yData=[],pointArrayMap=series.pointArrayMap,table=processed&&series.dataTable.modified||series.dataTable;if(!pointArrayMap){return series.getColumn("y",processed)}const columns=pointArrayMap.map(key=>series.getColumn(key,processed));for(let i=0;i<table.rowCount;i++){const values=pointArrayMap.map((key,colIndex)=>columns[colIndex]?.[i]||0);yData.push(values)}return yData};class SMAIndicator extends LineSeries{destroy(){this.dataEventsToUnbind.forEach(function(unbinder){unbinder()});super.destroy.apply(this,arguments)}getName(){const params=[];let name=this.name;if(!name){(this.nameComponents||[]).forEach(function(component,index){params.push(this.options.params[component]+pick(this.nameSuffixes[index],""))},this);name=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?" ("+params.join(", ")+")":"")}return name}getValues(series,params){const period=params.period,xVal=series.xData||[],yVal=series.yData,yValLen=yVal.length,SMA=[],xData=[],yData=[];let i,index=-1,range=0,SMAPoint,sum=0;if(xVal.length<period){return}if(isArray(yVal[0])){index=params.index?params.index:0}while(range<period-1){sum+=index<0?yVal[range]:yVal[range][index];range++}for(i=range;i<yValLen;i++){sum+=index<0?yVal[i]:yVal[i][index];SMAPoint=[xVal[i],sum/period];SMA.push(SMAPoint);xData.push(SMAPoint[0]);yData.push(SMAPoint[1]);sum-=index<0?yVal[i-range]:yVal[i-range][index]}return{values:SMA,xData:xData,yData:yData}}init(chart,options){const indicator=this;super.init.call(indicator,chart,options);const linkedSeriesUnbiner=addEvent(Chart,"afterLinkSeries",function({isUpdating}){if(isUpdating){return}const hasEvents=!!indicator.dataEventsToUnbind.length;if(indicator.linkedParent){if(!hasEvents){indicator.dataEventsToUnbind.push(addEvent(indicator.linkedParent,"updatedData",function(){indicator.recalculateValues()}));if(indicator.calculateOn.xAxis){indicator.dataEventsToUnbind.push(addEvent(indicator.linkedParent.xAxis,indicator.calculateOn.xAxis,function(){indicator.recalculateValues()}))}}if(indicator.calculateOn.chart==="init"){if(!indicator.closestPointRange){indicator.recalculateValues()}}else if(!hasEvents){const unbinder=addEvent(indicator.chart,indicator.calculateOn.chart,function(){indicator.recalculateValues();unbinder()})}}else{return error("Series "+indicator.options.linkedTo+" not found! Check `linkedTo`.",false,chart)}},{order:0});indicator.dataEventsToUnbind=[];indicator.eventsToUnbind.push(linkedSeriesUnbiner)}recalculateValues(){const croppedDataValues=[],indicator=this,table=this.dataTable,oldData=indicator.points||[],oldDataLength=indicator.dataTable.rowCount,emptySet={values:[],xData:[],yData:[]};let overwriteData=true,oldFirstPointIndex,oldLastPointIndex,min,max;const yData=indicator.linkedParent.yData,processedYData=indicator.linkedParent.processedYData;indicator.linkedParent.xData=indicator.linkedParent.getColumn("x");indicator.linkedParent.yData=tableToMultiYData(indicator.linkedParent);indicator.linkedParent.processedYData=tableToMultiYData(indicator.linkedParent,true);const processedData=indicator.linkedParent.options&&indicator.linkedParent.dataTable.rowCount?indicator.getValues(indicator.linkedParent,indicator.options.params)||emptySet:emptySet;delete indicator.linkedParent.xData;indicator.linkedParent.yData=yData;indicator.linkedParent.processedYData=processedYData;const pointArrayMap=indicator.pointArrayMap||["y"],valueColumns={};processedData.yData.forEach(values=>{pointArrayMap.forEach((key,index)=>{const column=valueColumns[key]||[];column.push(isArray(values)?values[index]:values);if(!valueColumns[key]){valueColumns[key]=column}})});if(oldDataLength&&!indicator.hasGroupedData&&indicator.visible&&indicator.points){if(indicator.cropped){if(indicator.xAxis){min=indicator.xAxis.min;max=indicator.xAxis.max}const croppedData=indicator.cropData(table,min,max);const keys=["x",...indicator.pointArrayMap||["y"]];for(let i=0;i<(croppedData.modified?.rowCount||0);i++){const values=keys.map(key=>this.getColumn(key)[i]||0);croppedDataValues.push(values)}const indicatorXData=indicator.getColumn("x");oldFirstPointIndex=processedData.xData.indexOf(indicatorXData[0]);oldLastPointIndex=processedData.xData.indexOf(indicatorXData[indicatorXData.length-1]);if(oldFirstPointIndex===-1&&oldLastPointIndex===processedData.xData.length-2){if(croppedDataValues[0][0]===oldData[0].x){croppedDataValues.shift()}}indicator.updateData(croppedDataValues)}else if(indicator.updateAllPoints||processedData.xData.length!==oldDataLength-1&&processedData.xData.length!==oldDataLength+1){overwriteData=false;indicator.updateData(processedData.values)}}if(overwriteData){table.setColumns({...valueColumns,x:processedData.xData});indicator.options.data=processedData.values}if(indicator.calculateOn.xAxis&&indicator.getColumn("x",true).length){indicator.isDirty=true;indicator.redraw()}indicator.isDirtyData=!!indicator.linkedSeries.length;fireEvent(indicator,"updatedData")}processData(){const series=this,compareToMain=series.options.compareToMain,linkedParent=series.linkedParent;super.processData.apply(series,arguments);if(series.dataModify&&linkedParent&&linkedParent.dataModify&&linkedParent.dataModify.compareValue&&compareToMain){series.dataModify.compareValue=linkedParent.dataModify.compareValue}return}}SMAIndicator.defaultOptions=merge(LineSeries.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:false,params:{index:3,period:14}});extend(SMAIndicator.prototype,{calculateOn:{chart:"init"},hasDerivedData:true,nameComponents:["period"],nameSuffixes:[],useCommonDataGrouping:true});SeriesRegistry.registerSeriesType("sma",SMAIndicator);export default SMAIndicator;"";