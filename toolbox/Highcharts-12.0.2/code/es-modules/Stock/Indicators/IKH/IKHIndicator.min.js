"use strict";import ApproximationRegistry from"../../../Extensions/DataGrouping/ApproximationRegistry.js";import Color from"../../../Core/Color/Color.js";const{parse:color}=Color;import SeriesRegistry from"../../../Core/Series/SeriesRegistry.js";const{sma:SMAIndicator}=SeriesRegistry.seriesTypes;import U from"../../../Core/Utilities.js";const{defined,extend,isArray,isNumber,getClosestDistance,merge,objectEach}=U;function maxHigh(arr){return arr.reduce(function(max,res){return Math.max(max,res[1])},-Infinity)}function minLow(arr){return arr.reduce(function(min,res){return Math.min(min,res[2])},Infinity)}function highlowLevel(arr){return{high:maxHigh(arr),low:minLow(arr)}}function checkLineIntersection(a1,a2,b1,b2){if(a1&&a2&&b1&&b2){const saX=a2.plotX-a1.plotX,saY=a2.plotY-a1.plotY,sbX=b2.plotX-b1.plotX,sbY=b2.plotY-b1.plotY,sabX=a1.plotX-b1.plotX,sabY=a1.plotY-b1.plotY,u=(-saY*sabX+saX*sabY)/(-sbX*saY+saX*sbY),t=(sbX*sabY-sbY*sabX)/(-sbX*saY+saX*sbY);if(u>=0&&u<=1&&t>=0&&t<=1){return{plotX:a1.plotX+t*saX,plotY:a1.plotY+t*saY}}}}function drawSenkouSpan(opt){const indicator=opt.indicator;indicator.points=opt.points;indicator.nextPoints=opt.nextPoints;indicator.color=opt.color;indicator.options=merge(opt.options.senkouSpan.styles,opt.gap);indicator.graph=opt.graph;indicator.fillGraph=true;SeriesRegistry.seriesTypes.sma.prototype.drawGraph.call(indicator)}function ichimokuAverages(){const ret=[];let isEmptyRange;[].forEach.call(arguments,function(arr,i){ret.push(ApproximationRegistry.average(arr));isEmptyRange=!isEmptyRange&&typeof ret[i]==="undefined"});return isEmptyRange?void 0:ret}class IKHIndicator extends SMAIndicator{constructor(){super(...arguments);this.data=[];this.options={};this.points=[];this.graphCollection=[]}init(){super.init.apply(this,arguments);this.options=merge({tenkanLine:{styles:{lineColor:this.color}},kijunLine:{styles:{lineColor:this.color}},chikouLine:{styles:{lineColor:this.color}},senkouSpanA:{styles:{lineColor:this.color,fill:color(this.color).setOpacity(.5).get()}},senkouSpanB:{styles:{lineColor:this.color,fill:color(this.color).setOpacity(.5).get()}},senkouSpan:{styles:{fill:color(this.color).setOpacity(.2).get()}}},this.options)}toYData(point){return[point.tenkanSen,point.kijunSen,point.chikouSpan,point.senkouSpanA,point.senkouSpanB]}translate(){const indicator=this;SeriesRegistry.seriesTypes.sma.prototype.translate.apply(indicator);for(const point of indicator.points){for(const key of indicator.pointArrayMap){const pointValue=point[key];if(isNumber(pointValue)){point["plot"+key]=indicator.yAxis.toPixels(pointValue,true);point.plotY=point["plot"+key];point.tooltipPos=[point.plotX,point["plot"+key]];point.isNull=false}}}}drawGraph(){const indicator=this,mainLinePoints=indicator.points,mainLineOptions=indicator.options,mainLinePath=indicator.graph,mainColor=indicator.color,gappedExtend={options:{gapSize:mainLineOptions.gapSize}},pointArrayMapLength=indicator.pointArrayMap.length,allIchimokuPoints=[[],[],[],[],[],[]],ikhMap={tenkanLine:allIchimokuPoints[0],kijunLine:allIchimokuPoints[1],chikouLine:allIchimokuPoints[2],senkouSpanA:allIchimokuPoints[3],senkouSpanB:allIchimokuPoints[4],senkouSpan:allIchimokuPoints[5]},intersectIndexColl=[],senkouSpanOptions=indicator.options.senkouSpan,color=senkouSpanOptions.color||senkouSpanOptions.styles.fill,negativeColor=senkouSpanOptions.negativeColor,points=[[],[]],nextPoints=[[],[]];let pointsLength=mainLinePoints.length,lineIndex=0,position,point,i,startIntersect,endIntersect,sectionPoints,sectionNextPoints,pointsPlotYSum,nextPointsPlotYSum,senkouSpanTempColor,concatArrIndex,j,k;indicator.ikhMap=ikhMap;while(pointsLength--){point=mainLinePoints[pointsLength];for(i=0;i<pointArrayMapLength;i++){position=indicator.pointArrayMap[i];if(defined(point[position])){allIchimokuPoints[i].push({plotX:point.plotX,plotY:point["plot"+position],isNull:false})}}if(negativeColor&&pointsLength!==mainLinePoints.length-1){const index=ikhMap.senkouSpanB.length-1,intersect=checkLineIntersection(ikhMap.senkouSpanA[index-1],ikhMap.senkouSpanA[index],ikhMap.senkouSpanB[index-1],ikhMap.senkouSpanB[index]);if(intersect){const intersectPointObj={plotX:intersect.plotX,plotY:intersect.plotY,isNull:false,intersectPoint:true};ikhMap.senkouSpanA.splice(index,0,intersectPointObj);ikhMap.senkouSpanB.splice(index,0,intersectPointObj);intersectIndexColl.push(index)}}}objectEach(ikhMap,(values,lineName)=>{if(mainLineOptions[lineName]&&lineName!=="senkouSpan"){indicator.points=allIchimokuPoints[lineIndex];indicator.options=merge(mainLineOptions[lineName].styles,gappedExtend);indicator.graph=indicator["graph"+lineName];indicator.fillGraph=false;indicator.color=mainColor;SeriesRegistry.seriesTypes.sma.prototype.drawGraph.call(indicator);indicator["graph"+lineName]=indicator.graph}lineIndex++});if(indicator.graphCollection){for(const graphName of indicator.graphCollection){indicator[graphName].destroy();delete indicator[graphName]}}indicator.graphCollection=[];if(negativeColor&&ikhMap.senkouSpanA[0]&&ikhMap.senkouSpanB[0]){intersectIndexColl.unshift(0);intersectIndexColl.push(ikhMap.senkouSpanA.length-1);for(j=0;j<intersectIndexColl.length-1;j++){startIntersect=intersectIndexColl[j];endIntersect=intersectIndexColl[j+1];sectionPoints=ikhMap.senkouSpanB.slice(startIntersect,endIntersect+1);sectionNextPoints=ikhMap.senkouSpanA.slice(startIntersect,endIntersect+1);if(Math.floor(sectionPoints.length/2)>=1){const x=Math.floor(sectionPoints.length/2);if(sectionPoints[x].plotY===sectionNextPoints[x].plotY){pointsPlotYSum=0;nextPointsPlotYSum=0;for(k=0;k<sectionPoints.length;k++){pointsPlotYSum+=sectionPoints[k].plotY;nextPointsPlotYSum+=sectionNextPoints[k].plotY}concatArrIndex=pointsPlotYSum>nextPointsPlotYSum?0:1;points[concatArrIndex]=points[concatArrIndex].concat(sectionPoints);nextPoints[concatArrIndex]=nextPoints[concatArrIndex].concat(sectionNextPoints)}else{concatArrIndex=sectionPoints[x].plotY>sectionNextPoints[x].plotY?0:1;points[concatArrIndex]=points[concatArrIndex].concat(sectionPoints);nextPoints[concatArrIndex]=nextPoints[concatArrIndex].concat(sectionNextPoints)}}else{concatArrIndex=sectionPoints[0].plotY>sectionNextPoints[0].plotY?0:1;points[concatArrIndex]=points[concatArrIndex].concat(sectionPoints);nextPoints[concatArrIndex]=nextPoints[concatArrIndex].concat(sectionNextPoints)}}["graphsenkouSpanColor","graphsenkouSpanNegativeColor"].forEach(function(areaName,i){if(points[i].length&&nextPoints[i].length){senkouSpanTempColor=i===0?color:negativeColor;drawSenkouSpan({indicator:indicator,points:points[i],nextPoints:nextPoints[i],color:senkouSpanTempColor,options:mainLineOptions,gap:gappedExtend,graph:indicator[areaName]});indicator[areaName]=indicator.graph;indicator.graphCollection.push(areaName)}})}else{drawSenkouSpan({indicator:indicator,points:ikhMap.senkouSpanB,nextPoints:ikhMap.senkouSpanA,color:color,options:mainLineOptions,gap:gappedExtend,graph:indicator.graphsenkouSpan});indicator.graphsenkouSpan=indicator.graph}delete indicator.nextPoints;delete indicator.fillGraph;indicator.points=mainLinePoints;indicator.options=mainLineOptions;indicator.graph=mainLinePath;indicator.color=mainColor}getGraphPath(points){const indicator=this;let path=[],spanA,spanAarr=[];points=points||this.points;if(indicator.fillGraph&&indicator.nextPoints){spanA=SeriesRegistry.seriesTypes.sma.prototype.getGraphPath.call(indicator,indicator.nextPoints);if(spanA&&spanA.length){spanA[0][0]="L";path=SeriesRegistry.seriesTypes.sma.prototype.getGraphPath.call(indicator,points);spanAarr=spanA.slice(0,path.length);for(let i=spanAarr.length-1;i>=0;i--){path.push(spanAarr[i])}}}else{path=SeriesRegistry.seriesTypes.sma.prototype.getGraphPath.apply(indicator,arguments)}return path}getValues(series,params){const period=params.period,periodTenkan=params.periodTenkan,periodSenkouSpanB=params.periodSenkouSpanB,xVal=series.xData,yVal=series.yData,xAxis=series.xAxis,yValLen=yVal&&yVal.length||0,closestPointRange=getClosestDistance(xAxis.series.map(s=>s.getColumn("x"))),IKH=[],xData=[];let date,slicedTSY,slicedKSY,slicedSSBY,pointTS,pointKS,pointSSB,i,TS,KS,CS,SSA,SSB;if(xVal.length<=period||!isArray(yVal[0])||yVal[0].length!==4){return}const dateStart=xVal[0]-period*closestPointRange;for(i=0;i<period;i++){xData.push(dateStart+i*closestPointRange)}for(i=0;i<yValLen;i++){if(i>=periodTenkan){slicedTSY=yVal.slice(i-periodTenkan,i);pointTS=highlowLevel(slicedTSY);TS=(pointTS.high+pointTS.low)/2}if(i>=period){slicedKSY=yVal.slice(i-period,i);pointKS=highlowLevel(slicedKSY);KS=(pointKS.high+pointKS.low)/2;SSA=(TS+KS)/2}if(i>=periodSenkouSpanB){slicedSSBY=yVal.slice(i-periodSenkouSpanB,i);pointSSB=highlowLevel(slicedSSBY);SSB=(pointSSB.high+pointSSB.low)/2}CS=yVal[i][3];date=xVal[i];if(typeof IKH[i]==="undefined"){IKH[i]=[]}if(typeof IKH[i+period-1]==="undefined"){IKH[i+period-1]=[]}IKH[i+period-1][0]=TS;IKH[i+period-1][1]=KS;IKH[i+period-1][2]=void 0;if(typeof IKH[i+1]==="undefined"){IKH[i+1]=[]}IKH[i+1][2]=CS;if(i<=period){IKH[i+period-1][3]=void 0;IKH[i+period-1][4]=void 0}if(typeof IKH[i+2*period-2]==="undefined"){IKH[i+2*period-2]=[]}IKH[i+2*period-2][3]=SSA;IKH[i+2*period-2][4]=SSB;xData.push(date)}for(i=1;i<=period;i++){xData.push(date+i*closestPointRange)}return{values:IKH,xData:xData,yData:IKH}}}IKHIndicator.defaultOptions=merge(SMAIndicator.defaultOptions,{params:{index:void 0,period:26,periodTenkan:9,periodSenkouSpanB:52},marker:{enabled:false},tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>'+"TENKAN SEN: {point.tenkanSen:.3f}<br/>"+"KIJUN SEN: {point.kijunSen:.3f}<br/>"+"CHIKOU SPAN: {point.chikouSpan:.3f}<br/>"+"SENKOU SPAN A: {point.senkouSpanA:.3f}<br/>"+"SENKOU SPAN B: {point.senkouSpanB:.3f}<br/>"},tenkanLine:{styles:{lineWidth:1,lineColor:void 0}},kijunLine:{styles:{lineWidth:1,lineColor:void 0}},chikouLine:{styles:{lineWidth:1,lineColor:void 0}},senkouSpanA:{styles:{lineWidth:1,lineColor:void 0}},senkouSpanB:{styles:{lineWidth:1,lineColor:void 0}},senkouSpan:{styles:{fill:"rgba(255, 0, 0, 0.5)"}},dataGrouping:{approximation:"ichimoku-averages"}});extend(IKHIndicator.prototype,{pointArrayMap:["tenkanSen","kijunSen","chikouSpan","senkouSpanA","senkouSpanB"],pointValKey:"tenkanSen",nameComponents:["periodSenkouSpanB","period","periodTenkan"]});ApproximationRegistry["ichimoku-averages"]=ichimokuAverages;SeriesRegistry.registerSeriesType("ikh",IKHIndicator);export default IKHIndicator;"";