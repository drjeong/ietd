"use strict";import Connection from"./Connection.js";import PathfinderAlgorithms from"./PathfinderAlgorithms.js";import PathfinderComposition from"./PathfinderComposition.js";import Point from"../Core/Series/Point.js";import U from"../Core/Utilities.js";const{addEvent,defined,pick,splat}=U;const max=Math.max,min=Math.min;function getPointBB(point){const shapeArgs=point.shapeArgs;if(shapeArgs){return{xMin:shapeArgs.x||0,xMax:(shapeArgs.x||0)+(shapeArgs.width||0),yMin:shapeArgs.y||0,yMax:(shapeArgs.y||0)+(shapeArgs.height||0)}}const bb=point.graphic&&point.graphic.getBBox();return bb?{xMin:point.plotX-bb.width/2,xMax:point.plotX+bb.width/2,yMin:point.plotY-bb.height/2,yMax:point.plotY+bb.height/2}:null}function calculateObstacleDistance(a,b,bbMargin){const margin=pick(bbMargin,10),yOverlap=a.yMax+margin>b.yMin-margin&&a.yMin-margin<b.yMax+margin,xOverlap=a.xMax+margin>b.xMin-margin&&a.xMin-margin<b.xMax+margin,xDistance=yOverlap?a.xMin>b.xMax?a.xMin-b.xMax:b.xMin-a.xMax:Infinity,yDistance=xOverlap?a.yMin>b.yMax?a.yMin-b.yMax:b.yMin-a.yMax:Infinity;if(xOverlap&&yOverlap){return margin?calculateObstacleDistance(a,b,Math.floor(margin/2)):Infinity}return min(xDistance,yDistance)}function calculateObstacleMargin(obstacles){const len=obstacles.length,distances=[];let onstacleDistance;for(let i=0;i<len;++i){for(let j=i+1;j<len;++j){onstacleDistance=calculateObstacleDistance(obstacles[i],obstacles[j]);if(onstacleDistance<80){distances.push(onstacleDistance)}}}distances.push(80);return max(Math.floor(distances.sort(function(a,b){return a-b})[Math.floor(distances.length/10)]/2-1),1)}class Pathfinder{static compose(ChartClass,PointClass){PathfinderComposition.compose(ChartClass,Pathfinder,PointClass)}constructor(chart){this.init(chart)}init(chart){this.chart=chart;this.connections=[];addEvent(chart,"redraw",function(){this.pathfinder.update()})}update(deferRender){const chart=this.chart,pathfinder=this,oldConnections=pathfinder.connections;pathfinder.connections=[];chart.series.forEach(function(series){if(series.visible&&!series.options.isInternal){series.points.forEach(function(point){const ganttPointOptions=point.options;if(ganttPointOptions&&ganttPointOptions.dependency){ganttPointOptions.connect=ganttPointOptions.dependency}const connects=point.options?.connect?splat(point.options.connect):[];let to;if(point.visible&&point.isInside!==false){connects.forEach(connect=>{const toId=typeof connect==="string"?connect:connect.to;if(toId){to=chart.get(toId)}if(to instanceof Point&&to.series.visible&&to.visible&&to.isInside!==false){pathfinder.connections.push(new Connection(point,to,typeof connect==="string"?{}:connect))}})}})}});for(let j=0,k,found,lenOld=oldConnections.length,lenNew=pathfinder.connections.length;j<lenOld;++j){found=false;const oldCon=oldConnections[j];for(k=0;k<lenNew;++k){const newCon=pathfinder.connections[k];if((oldCon.options&&oldCon.options.type)===(newCon.options&&newCon.options.type)&&oldCon.fromPoint===newCon.fromPoint&&oldCon.toPoint===newCon.toPoint){newCon.graphics=oldCon.graphics;found=true;break}}if(!found){oldCon.destroy()}}delete this.chartObstacles;delete this.lineObstacles;pathfinder.renderConnections(deferRender)}renderConnections(deferRender){if(deferRender){this.chart.series.forEach(function(series){const render=function(){const pathfinder=series.chart.pathfinder,conns=pathfinder&&pathfinder.connections||[];conns.forEach(function(connection){if(connection.fromPoint&&connection.fromPoint.series===series){connection.render()}});if(series.pathfinderRemoveRenderEvent){series.pathfinderRemoveRenderEvent();delete series.pathfinderRemoveRenderEvent}};if(series.options.animation===false){render()}else{series.pathfinderRemoveRenderEvent=addEvent(series,"afterAnimate",render)}})}else{this.connections.forEach(function(connection){connection.render()})}}getChartObstacles(options){const series=this.chart.series,margin=pick(options.algorithmMargin,0);let obstacles=[],calculatedMargin;for(let i=0,sLen=series.length;i<sLen;++i){if(series[i].visible&&!series[i].options.isInternal){for(let j=0,pLen=series[i].points.length,bb,point;j<pLen;++j){point=series[i].points[j];if(point.visible){bb=getPointBB(point);if(bb){obstacles.push({xMin:bb.xMin-margin,xMax:bb.xMax+margin,yMin:bb.yMin-margin,yMax:bb.yMax+margin})}}}}}obstacles=obstacles.sort(function(a,b){return a.xMin-b.xMin});if(!defined(options.algorithmMargin)){calculatedMargin=options.algorithmMargin=calculateObstacleMargin(obstacles);obstacles.forEach(function(obstacle){obstacle.xMin-=calculatedMargin;obstacle.xMax+=calculatedMargin;obstacle.yMin-=calculatedMargin;obstacle.yMax+=calculatedMargin})}return obstacles}getObstacleMetrics(obstacles){let maxWidth=0,maxHeight=0,width,height,i=obstacles.length;while(i--){width=obstacles[i].xMax-obstacles[i].xMin;height=obstacles[i].yMax-obstacles[i].yMin;if(maxWidth<width){maxWidth=width}if(maxHeight<height){maxHeight=height}}return{maxHeight:maxHeight,maxWidth:maxWidth}}getAlgorithmStartDirection(markerOptions){const xCenter=markerOptions.align!=="left"&&markerOptions.align!=="right",yCenter=markerOptions.verticalAlign!=="top"&&markerOptions.verticalAlign!=="bottom";return xCenter?yCenter?void 0:false:yCenter?true:void 0}}Pathfinder.prototype.algorithms=PathfinderAlgorithms;export default Pathfinder;"";