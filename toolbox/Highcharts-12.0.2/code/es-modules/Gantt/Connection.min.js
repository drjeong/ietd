"use strict";import H from"../Core/Globals.js";import U from"../Core/Utilities.js";const{defined,error,merge,objectEach}=U;const deg2rad=H.deg2rad,max=Math.max,min=Math.min;class Connection{constructor(from,to,options){this.init(from,to,options)}init(from,to,options){this.fromPoint=from;this.toPoint=to;this.options=options;this.chart=from.series.chart;this.pathfinder=this.chart.pathfinder}renderPath(path,attribs){const connection=this,chart=this.chart,styledMode=chart.styledMode,pathfinder=this.pathfinder,anim={};let pathGraphic=connection.graphics&&connection.graphics.path;if(!pathfinder.group){pathfinder.group=chart.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(chart.seriesGroup)}pathfinder.group.translate(chart.plotLeft,chart.plotTop);if(!(pathGraphic&&pathGraphic.renderer)){pathGraphic=chart.renderer.path().add(pathfinder.group);if(!styledMode){pathGraphic.attr({opacity:0})}}pathGraphic.attr(attribs);anim.d=path;if(!styledMode){anim.opacity=1}pathGraphic.animate(anim);this.graphics=this.graphics||{};this.graphics.path=pathGraphic}addMarker(type,options,path){const connection=this,chart=connection.fromPoint.series.chart,pathfinder=chart.pathfinder,renderer=chart.renderer,point=type==="start"?connection.fromPoint:connection.toPoint,anchor=point.getPathfinderAnchorPoint(options);let markerVector,radians,rotation,box,width,height,pathVector,segment;if(!options.enabled){return}if(type==="start"){segment=path[1]}else{segment=path[path.length-2]}if(segment&&segment[0]==="M"||segment[0]==="L"){pathVector={x:segment[1],y:segment[2]};radians=point.getRadiansToVector(pathVector,anchor);markerVector=point.getMarkerVector(radians,options.radius,anchor);rotation=-radians/deg2rad;if(options.width&&options.height){width=options.width;height=options.height}else{width=height=options.radius*2}connection.graphics=connection.graphics||{};box={x:markerVector.x-width/2,y:markerVector.y-height/2,width:width,height:height,rotation:rotation,rotationOriginX:markerVector.x,rotationOriginY:markerVector.y};if(!connection.graphics[type]){connection.graphics[type]=renderer.symbol(options.symbol).addClass("highcharts-point-connecting-path-"+type+"-marker"+" highcharts-color-"+this.fromPoint.colorIndex).attr(box).add(pathfinder.group);if(!renderer.styledMode){connection.graphics[type].attr({fill:options.color||connection.fromPoint.color,stroke:options.lineColor,"stroke-width":options.lineWidth,opacity:0}).animate({opacity:1},point.series.options.animation)}}else{connection.graphics[type].animate(box)}}}getPath(options){const pathfinder=this.pathfinder,chart=this.chart,algorithm=pathfinder.algorithms[options.type];let chartObstacles=pathfinder.chartObstacles;if(typeof algorithm!=="function"){error('"'+options.type+'" is not a Pathfinder algorithm.');return{path:[],obstacles:[]}}if(algorithm.requiresObstacles&&!chartObstacles){chartObstacles=pathfinder.chartObstacles=pathfinder.getChartObstacles(options);chart.options.connectors.algorithmMargin=options.algorithmMargin;pathfinder.chartObstacleMetrics=pathfinder.getObstacleMetrics(chartObstacles)}return algorithm(this.fromPoint.getPathfinderAnchorPoint(options.startMarker),this.toPoint.getPathfinderAnchorPoint(options.endMarker),merge({chartObstacles:chartObstacles,lineObstacles:pathfinder.lineObstacles||[],obstacleMetrics:pathfinder.chartObstacleMetrics,hardBounds:{xMin:0,xMax:chart.plotWidth,yMin:0,yMax:chart.plotHeight},obstacleOptions:{margin:options.algorithmMargin},startDirectionX:pathfinder.getAlgorithmStartDirection(options.startMarker)},options))}render(){const connection=this,fromPoint=connection.fromPoint,series=fromPoint.series,chart=series.chart,pathfinder=chart.pathfinder,attribs={};let options=merge(chart.options.connectors,series.options.connectors,fromPoint.options.connectors,connection.options);if(!chart.styledMode){attribs.stroke=options.lineColor||fromPoint.color;attribs["stroke-width"]=options.lineWidth;if(options.dashStyle){attribs.dashstyle=options.dashStyle}}attribs["class"]="highcharts-point-connecting-path "+"highcharts-color-"+fromPoint.colorIndex;options=merge(attribs,options);if(!defined(options.marker.radius)){options.marker.radius=min(max(Math.ceil((options.algorithmMargin||8)/2)-1,1),5)}const pathResult=connection.getPath(options),path=pathResult.path;if(pathResult.obstacles){pathfinder.lineObstacles=pathfinder.lineObstacles||[];pathfinder.lineObstacles=pathfinder.lineObstacles.concat(pathResult.obstacles)}connection.renderPath(path,attribs);connection.addMarker("start",merge(options.marker,options.startMarker),path);connection.addMarker("end",merge(options.marker,options.endMarker),path)}destroy(){if(this.graphics){objectEach(this.graphics,function(val){val.destroy()});delete this.graphics}}}export default Connection;"";