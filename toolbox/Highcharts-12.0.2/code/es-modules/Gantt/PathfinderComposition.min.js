"use strict";import ConnectorsDefaults from"./ConnectorsDefaults.js";import D from"../Core/Defaults.js";const{setOptions}=D;import U from"../Core/Utilities.js";const{defined,error,merge}=U;function getPointBB(point){const shapeArgs=point.shapeArgs;if(shapeArgs){return{xMin:shapeArgs.x||0,xMax:(shapeArgs.x||0)+(shapeArgs.width||0),yMin:shapeArgs.y||0,yMax:(shapeArgs.y||0)+(shapeArgs.height||0)}}const bb=point.graphic&&point.graphic.getBBox();return bb?{xMin:point.plotX-bb.width/2,xMax:point.plotX+bb.width/2,yMin:point.plotY-bb.height/2,yMax:point.plotY+bb.height/2}:null}function warnLegacy(chart){if(chart.options.pathfinder||chart.series.reduce(function(acc,series){if(series.options){merge(true,series.options.connectors=series.options.connectors||{},series.options.pathfinder)}return acc||series.options&&series.options.pathfinder},false)){merge(true,chart.options.connectors=chart.options.connectors||{},chart.options.pathfinder);error("WARNING: Pathfinder options have been renamed. "+'Use "chart.connectors" or "series.connectors" instead.')}}var ConnectionComposition;(function(ConnectionComposition){function compose(ChartClass,PathfinderClass,PointClass){const pointProto=PointClass.prototype;if(!pointProto.getPathfinderAnchorPoint){ChartClass.prototype.callbacks.push(function(chart){const options=chart.options;if(options.connectors.enabled!==false){warnLegacy(chart);this.pathfinder=new PathfinderClass(this);this.pathfinder.update(true)}});pointProto.getMarkerVector=pointGetMarkerVector;pointProto.getPathfinderAnchorPoint=pointGetPathfinderAnchorPoint;pointProto.getRadiansToVector=pointGetRadiansToVector;setOptions(ConnectorsDefaults)}}ConnectionComposition.compose=compose;function pointGetPathfinderAnchorPoint(markerOptions){const bb=getPointBB(this);let x,y;switch(markerOptions.align){case"right":x="xMax";break;case"left":x="xMin"}switch(markerOptions.verticalAlign){case"top":y="yMin";break;case"bottom":y="yMax"}return{x:x?bb[x]:(bb.xMin+bb.xMax)/2,y:y?bb[y]:(bb.yMin+bb.yMax)/2}}function pointGetRadiansToVector(v1,v2){let box;if(!defined(v2)){box=getPointBB(this);if(box){v2={x:(box.xMin+box.xMax)/2,y:(box.yMin+box.yMax)/2}}}return Math.atan2(v2.y-v1.y,v1.x-v2.x)}function pointGetMarkerVector(radians,markerRadius,anchor){const twoPI=Math.PI*2,bb=getPointBB(this),rectWidth=bb.xMax-bb.xMin,rectHeight=bb.yMax-bb.yMin,rAtan=Math.atan2(rectHeight,rectWidth),rectHalfWidth=rectWidth/2,rectHalfHeight=rectHeight/2,rectHorizontalCenter=bb.xMin+rectHalfWidth,rectVerticalCenter=bb.yMin+rectHalfHeight,edgePoint={x:rectHorizontalCenter,y:rectVerticalCenter};let theta=radians,tanTheta=1,leftOrRightRegion=false,xFactor=1,yFactor=1;while(theta<-Math.PI){theta+=twoPI}while(theta>Math.PI){theta-=twoPI}tanTheta=Math.tan(theta);if(theta>-rAtan&&theta<=rAtan){yFactor=-1;leftOrRightRegion=true}else if(theta>rAtan&&theta<=Math.PI-rAtan){yFactor=-1}else if(theta>Math.PI-rAtan||theta<=-(Math.PI-rAtan)){xFactor=-1;leftOrRightRegion=true}else{xFactor=-1}if(leftOrRightRegion){edgePoint.x+=xFactor*rectHalfWidth;edgePoint.y+=yFactor*rectHalfWidth*tanTheta}else{edgePoint.x+=xFactor*(rectHeight/(2*tanTheta));edgePoint.y+=yFactor*rectHalfHeight}if(anchor.x!==rectHorizontalCenter){edgePoint.x=anchor.x}if(anchor.y!==rectVerticalCenter){edgePoint.y=anchor.y}return{x:edgePoint.x+markerRadius*Math.cos(theta),y:edgePoint.y-markerRadius*Math.sin(theta)}}})(ConnectionComposition||(ConnectionComposition={}));export default ConnectionComposition;