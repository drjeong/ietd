"use strict";import A from"../Animation/AnimationUtilities.js";const{animObject,setAnimation}=A;import DataTableCore from"../../Data/DataTableCore.js";import D from"../Defaults.js";const{defaultOptions}=D;import F from"../Foundation.js";const{registerEventOptions}=F;import H from"../Globals.js";const{svg,win}=H;import LegendSymbol from"../Legend/LegendSymbol.js";import Point from"./Point.js";import SeriesDefaults from"./SeriesDefaults.js";import SeriesRegistry from"./SeriesRegistry.js";const{seriesTypes}=SeriesRegistry;import SVGElement from"../Renderer/SVG/SVGElement.js";import U from"../Utilities.js";const{arrayMax,arrayMin,clamp,correctFloat,crisp,defined,destroyObjectProperties,diffObjects,erase,error,extend,find,fireEvent,getClosestDistance,getNestedProperty,insertItem,isArray,isNumber,isString,merge,objectEach,pick,removeEvent,syncTimeout}=U;class Series{constructor(){this.zoneAxis="y"}init(chart,userOptions){fireEvent(this,"init",{options:userOptions});this.dataTable??(this.dataTable=new DataTableCore);const series=this,chartSeries=chart.series;this.eventsToUnbind=[];series.chart=chart;series.options=series.setOptions(userOptions);const options=series.options,visible=options.visible!==false;series.linkedSeries=[];series.bindAxes();extend(series,{name:options.name,state:"",visible:visible,selected:options.selected===true});registerEventOptions(this,options);const events=options.events;if(events&&events.click||options.point&&options.point.events&&options.point.events.click||options.allowPointSelect){chart.runTrackerClick=true}series.getColor();series.getSymbol();if(series.isCartesian){chart.hasCartesianSeries=true}let lastSeries;if(chartSeries.length){lastSeries=chartSeries[chartSeries.length-1]}series._i=pick(lastSeries&&lastSeries._i,-1)+1;series.opacity=series.options.opacity;chart.orderItems("series",insertItem(this,chartSeries));if(options.dataSorting&&options.dataSorting.enabled){series.setDataSortingOptions()}else if(!series.points&&!series.data){series.setData(options.data,false)}fireEvent(this,"afterInit")}is(type){return seriesTypes[type]&&this instanceof seriesTypes[type]}bindAxes(){const series=this,seriesOptions=series.options,chart=series.chart;let axisOptions;fireEvent(this,"bindAxes",null,function(){(series.axisTypes||[]).forEach(function(coll){(chart[coll]||[]).forEach(function(axis){axisOptions=axis.options;if(pick(seriesOptions[coll],0)===axis.index||typeof seriesOptions[coll]!=="undefined"&&seriesOptions[coll]===axisOptions.id){insertItem(series,axis.series);series[coll]=axis;axis.isDirty=true}});if(!series[coll]&&series.optionalAxis!==coll){error(18,true,chart)}})});fireEvent(this,"afterBindAxes")}hasData(){return this.visible&&typeof this.dataMax!=="undefined"&&typeof this.dataMin!=="undefined"||this.visible&&this.dataTable.rowCount>0}hasMarkerChanged(options,oldOptions){const marker=options.marker,oldMarker=oldOptions.marker||{};return marker&&(oldMarker.enabled&&!marker.enabled||oldMarker.symbol!==marker.symbol||oldMarker.height!==marker.height||oldMarker.width!==marker.width)}autoIncrement(x){const options=this.options,{pointIntervalUnit,relativeXValue}=this.options,time=this.chart.time,xIncrement=this.xIncrement??time.parse(options.pointStart)??0;let pointInterval;this.pointInterval=pointInterval=pick(this.pointInterval,options.pointInterval,1);if(relativeXValue&&isNumber(x)){pointInterval*=x}if(pointIntervalUnit){const d=time.toParts(xIncrement);if(pointIntervalUnit==="day"){d[2]+=pointInterval}else if(pointIntervalUnit==="month"){d[1]+=pointInterval}else if(pointIntervalUnit==="year"){d[0]+=pointInterval}pointInterval=time.makeTime.apply(time,d)-xIncrement}if(relativeXValue&&isNumber(x)){return xIncrement+pointInterval}this.xIncrement=xIncrement+pointInterval;return xIncrement}setDataSortingOptions(){const options=this.options;extend(this,{requireSorting:false,sorted:false,enabledDataSorting:true,allowDG:false});if(!defined(options.pointRange)){options.pointRange=1}}setOptions(itemOptions){const chart=this.chart,chartOptions=chart.options,plotOptions=chartOptions.plotOptions,userOptions=chart.userOptions||{},seriesUserOptions=merge(itemOptions),styledMode=chart.styledMode,e={plotOptions:plotOptions,userOptions:seriesUserOptions};let zone;fireEvent(this,"setOptions",e);const typeOptions=e.plotOptions[this.type],userPlotOptions=userOptions.plotOptions||{},userPlotOptionsSeries=userPlotOptions.series||{},defaultPlotOptionsType=defaultOptions.plotOptions[this.type]||{},userPlotOptionsType=userPlotOptions[this.type]||{};this.userOptions=e.userOptions;const options=merge(typeOptions,plotOptions.series,userPlotOptionsType,seriesUserOptions);this.tooltipOptions=merge(defaultOptions.tooltip,defaultOptions.plotOptions.series?.tooltip,defaultPlotOptionsType?.tooltip,chart.userOptions.tooltip,userPlotOptions.series?.tooltip,userPlotOptionsType.tooltip,seriesUserOptions.tooltip);this.stickyTracking=pick(seriesUserOptions.stickyTracking,userPlotOptionsType.stickyTracking,userPlotOptionsSeries.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?true:options.stickyTracking);if(typeOptions.marker===null){delete options.marker}this.zoneAxis=options.zoneAxis||"y";const zones=this.zones=(options.zones||[]).map(z=>({...z}));if((options.negativeColor||options.negativeFillColor)&&!options.zones){zone={value:options[this.zoneAxis+"Threshold"]||options.threshold||0,className:"highcharts-negative"};if(!styledMode){zone.color=options.negativeColor;zone.fillColor=options.negativeFillColor}zones.push(zone)}if(zones.length&&defined(zones[zones.length-1].value)){zones.push(styledMode?{}:{color:this.color,fillColor:this.fillColor})}fireEvent(this,"afterSetOptions",{options:options});return options}getName(){return pick(this.options.name,"Series "+(this.index+1))}getCyclic(prop,value,defaults){const chart=this.chart,indexName=`${prop}Index`,counterName=`${prop}Counter`,len=defaults?.length||chart.options.chart.colorCount;let i,setting;if(!value){setting=pick(prop==="color"?this.options.colorIndex:void 0,this[indexName]);if(defined(setting)){i=setting}else{if(!chart.series.length){chart[counterName]=0}i=chart[counterName]%len;chart[counterName]+=1}if(defaults){value=defaults[i]}}if(typeof i!=="undefined"){this[indexName]=i}this[prop]=value}getColor(){if(this.chart.styledMode){this.getCyclic("color")}else if(this.options.colorByPoint){this.color="#cccccc"}else{this.getCyclic("color",this.options.color||defaultOptions.plotOptions[this.type].color,this.chart.options.colors)}}getPointsCollection(){return(this.hasGroupedData?this.points:this.data)||[]}getSymbol(){const seriesMarkerOption=this.options.marker;this.getCyclic("symbol",seriesMarkerOption.symbol,this.chart.options.symbols)}getColumn(columnName,modified){return(modified?this.dataTable.modified:this.dataTable).getColumn(columnName,true)||[]}findPointIndex(optionsObject,fromIndex){const id=optionsObject.id,x=optionsObject.x,oldData=this.points,dataSorting=this.options.dataSorting;let matchingPoint,matchedById,pointIndex;if(id){const item=this.chart.get(id);if(item instanceof Point){matchingPoint=item}}else if(this.linkedParent||this.enabledDataSorting||this.options.relativeXValue){let matcher=oldPoint=>!oldPoint.touched&&oldPoint.index===optionsObject.index;if(dataSorting&&dataSorting.matchByName){matcher=oldPoint=>!oldPoint.touched&&oldPoint.name===optionsObject.name}else if(this.options.relativeXValue){matcher=oldPoint=>!oldPoint.touched&&oldPoint.options.x===optionsObject.x}matchingPoint=find(oldData,matcher);if(!matchingPoint){return void 0}}if(matchingPoint){pointIndex=matchingPoint&&matchingPoint.index;if(typeof pointIndex!=="undefined"){matchedById=true}}if(typeof pointIndex==="undefined"&&isNumber(x)){pointIndex=this.getColumn("x").indexOf(x,fromIndex)}if(pointIndex!==-1&&typeof pointIndex!=="undefined"&&this.cropped){pointIndex=pointIndex>=this.cropStart?pointIndex-this.cropStart:pointIndex}if(!matchedById&&isNumber(pointIndex)&&oldData[pointIndex]&&oldData[pointIndex].touched){pointIndex=void 0}return pointIndex}updateData(data,animation){const options=this.options,dataSorting=options.dataSorting,oldData=this.points,pointsToAdd=[],requireSorting=this.requireSorting,equalLength=data.length===oldData.length;let hasUpdatedByKey,i,point,lastIndex,succeeded=true;this.xIncrement=null;data.forEach(function(pointOptions,i){const optionsObject=defined(pointOptions)&&this.pointClass.prototype.optionsToObject.call({series:this},pointOptions)||{};let pointIndex;const x=optionsObject.x,id=optionsObject.id;if(id||isNumber(x)){pointIndex=this.findPointIndex(optionsObject,lastIndex);if(pointIndex===-1||typeof pointIndex==="undefined"){pointsToAdd.push(pointOptions)}else if(oldData[pointIndex]&&pointOptions!==options.data[pointIndex]){oldData[pointIndex].update(pointOptions,false,null,false);oldData[pointIndex].touched=true;if(requireSorting){lastIndex=pointIndex+1}}else if(oldData[pointIndex]){oldData[pointIndex].touched=true}if(!equalLength||i!==pointIndex||dataSorting&&dataSorting.enabled||this.hasDerivedData){hasUpdatedByKey=true}}else{pointsToAdd.push(pointOptions)}},this);if(hasUpdatedByKey){i=oldData.length;while(i--){point=oldData[i];if(point&&!point.touched&&point.remove){point.remove(false,animation)}}}else if(equalLength&&(!dataSorting||!dataSorting.enabled)){data.forEach(function(point,i){if(point!==oldData[i].y&&!oldData[i].destroyed){oldData[i].update(point,false,null,false)}});pointsToAdd.length=0}else{succeeded=false}oldData.forEach(function(point){if(point){point.touched=false}});if(!succeeded){return false}pointsToAdd.forEach(function(point){this.addPoint(point,false,null,null,false)},this);const xData=this.getColumn("x");if(this.xIncrement===null&&xData.length){this.xIncrement=arrayMax(xData);this.autoIncrement()}return true}dataColumnKeys(){return["x",...this.pointArrayMap||["y"]]}setData(data,redraw=true,animation,updatePoints){const series=this,oldData=series.points,oldDataLength=oldData&&oldData.length||0,options=series.options,chart=series.chart,dataSorting=options.dataSorting,xAxis=series.xAxis,turboThreshold=options.turboThreshold,table=this.dataTable,dataColumnKeys=this.dataColumnKeys(),pointValKey=series.pointValKey||"y",pointArrayMap=series.pointArrayMap||[],valueCount=pointArrayMap.length,keys=options.keys;let i,updatedData,indexOfX=0,indexOfY=1,copiedData;if(!chart.options.chart.allowMutatingData){if(options.data){delete series.options.data}if(series.userOptions.data){delete series.userOptions.data}copiedData=merge(true,data)}data=copiedData||data||[];const dataLength=data.length;if(dataSorting&&dataSorting.enabled){data=this.sortData(data)}if(chart.options.chart.allowMutatingData&&updatePoints!==false&&dataLength&&oldDataLength&&!series.cropped&&!series.hasGroupedData&&series.visible&&!series.boosted){updatedData=this.updateData(data,animation)}if(!updatedData){series.xIncrement=null;series.colorCounter=0;let runTurbo=turboThreshold&&dataLength>turboThreshold;if(runTurbo){const firstPoint=series.getFirstValidPoint(data),lastPoint=series.getFirstValidPoint(data,dataLength-1,-1),isShortArray=a=>Boolean(isArray(a)&&(keys||isNumber(a[0])));if(isNumber(firstPoint)&&isNumber(lastPoint)){const x=[],valueData=[];for(const value of data){x.push(this.autoIncrement());valueData.push(value)}table.setColumns({x:x,[pointValKey]:valueData})}else if(isShortArray(firstPoint)&&isShortArray(lastPoint)){if(valueCount){const autoX=firstPoint.length===valueCount?1:0,colArray=new Array(dataColumnKeys.length).fill(0).map(()=>[]);for(const pt of data){if(autoX){colArray[0].push(this.autoIncrement())}for(let j=autoX;j<=valueCount;j++){colArray[j]?.push(pt[j-autoX])}}table.setColumns(dataColumnKeys.reduce((columns,columnName,i)=>{columns[columnName]=colArray[i];return columns},{}))}else{if(keys){indexOfX=keys.indexOf("x");indexOfY=keys.indexOf("y");indexOfX=indexOfX>=0?indexOfX:0;indexOfY=indexOfY>=0?indexOfY:1}if(firstPoint.length===1){indexOfY=0}const xData=[],valueData=[];if(indexOfX===indexOfY){for(const pt of data){xData.push(this.autoIncrement());valueData.push(pt[indexOfY])}}else{for(const pt of data){xData.push(pt[indexOfX]);valueData.push(pt[indexOfY])}}table.setColumns({x:xData,[pointValKey]:valueData})}}else{runTurbo=false}}if(!runTurbo){const columns=dataColumnKeys.reduce((columns,columnName)=>{columns[columnName]=[];return columns},{});for(i=0;i<dataLength;i++){const pt=series.pointClass.prototype.applyOptions.apply({series:series},[data[i]]);for(const key of dataColumnKeys){columns[key][i]=pt[key]}}table.setColumns(columns)}if(isString(this.getColumn("y")[0])){error(14,true,chart)}series.data=[];series.options.data=series.userOptions.data=data;i=oldDataLength;while(i--){oldData[i]?.destroy()}if(xAxis){xAxis.minRange=xAxis.userMinRange}series.isDirty=chart.isDirtyBox=true;series.isDirtyData=!!oldData;animation=false}if(options.legendType==="point"){this.processData();this.generatePoints()}if(redraw){chart.redraw(animation)}}sortData(data){const series=this,options=series.options,dataSorting=options.dataSorting,sortKey=dataSorting.sortKey||"y",getPointOptionsObject=function(series,pointOptions){return defined(pointOptions)&&series.pointClass.prototype.optionsToObject.call({series:series},pointOptions)||{}};data.forEach(function(pointOptions,i){data[i]=getPointOptionsObject(series,pointOptions);data[i].index=i},this);const sortedData=data.concat().sort((a,b)=>{const aValue=getNestedProperty(sortKey,a);const bValue=getNestedProperty(sortKey,b);return bValue<aValue?-1:bValue>aValue?1:0});sortedData.forEach(function(point,i){point.x=i},this);if(series.linkedSeries){series.linkedSeries.forEach(function(linkedSeries){const options=linkedSeries.options,seriesData=options.data;if((!options.dataSorting||!options.dataSorting.enabled)&&seriesData){seriesData.forEach(function(pointOptions,i){seriesData[i]=getPointOptionsObject(linkedSeries,pointOptions);if(data[i]){seriesData[i].x=data[i].x;seriesData[i].index=i}});linkedSeries.setData(seriesData,false)}})}return data}getProcessedData(forceExtremesFromAll){const series=this,{dataTable:table,isCartesian,options,xAxis}=series,cropThreshold=options.cropThreshold,getExtremesFromAll=forceExtremesFromAll||series.getExtremesFromAll,logarithmic=xAxis?.logarithmic,dataLength=table.rowCount;let croppedData,cropped,cropStart=0,xExtremes,min,max,xData=series.getColumn("x"),modified=table,updatingNames=false;if(xAxis){xExtremes=xAxis.getExtremes();min=xExtremes.min;max=xExtremes.max;updatingNames=!!(xAxis.categories&&!xAxis.names.length);if(isCartesian&&series.sorted&&!getExtremesFromAll&&(!cropThreshold||dataLength>cropThreshold||series.forceCrop)){if(xData[dataLength-1]<min||xData[0]>max){modified=new DataTableCore}else if(series.getColumn(series.pointValKey||"y").length&&(xData[0]<min||xData[dataLength-1]>max)){croppedData=this.cropData(table,min,max);modified=croppedData.modified;cropStart=croppedData.start;cropped=true}}}xData=modified.getColumn("x")||[];const closestPointRange=getClosestDistance([logarithmic?xData.map(logarithmic.log2lin):xData],()=>series.requireSorting&&!updatingNames&&error(15,false,series.chart));return{modified:modified,cropped:cropped,cropStart:cropStart,closestPointRange:closestPointRange}}processData(force){const series=this,xAxis=series.xAxis,table=series.dataTable;if(series.isCartesian&&!series.isDirty&&!xAxis.isDirty&&!series.yAxis.isDirty&&!force){return false}const processedData=series.getProcessedData();table.modified=processedData.modified;series.cropped=processedData.cropped;series.cropStart=processedData.cropStart;series.closestPointRange=series.basePointRange=processedData.closestPointRange;fireEvent(series,"afterProcessData")}cropData(table,min,max){const xData=table.getColumn("x",true)||[],dataLength=xData.length,columns={};let i,j,start=0,end=dataLength;for(i=0;i<dataLength;i++){if(xData[i]>=min){start=Math.max(0,i-1);break}}for(j=i;j<dataLength;j++){if(xData[j]>max){end=j+1;break}}for(const key of this.dataColumnKeys()){const column=table.getColumn(key,true);if(column){columns[key]=column.slice(start,end)}}return{modified:new DataTableCore({columns:columns}),start:start,end:end}}generatePoints(){const series=this,options=series.options,dataOptions=series.processedData||options.data,table=series.dataTable.modified,xData=series.getColumn("x",true),PointClass=series.pointClass,processedDataLength=table.rowCount,cropStart=series.cropStart||0,hasGroupedData=series.hasGroupedData,keys=options.keys,points=[],groupCropStartIndex=options.dataGrouping&&options.dataGrouping.groupAll?cropStart:0,categories=series.xAxis?.categories,pointArrayMap=series.pointArrayMap||["y"],dataColumnKeys=this.dataColumnKeys();let dataLength,cursor,point,i,data=series.data,pOptions;if(!data&&!hasGroupedData){const arr=[];arr.length=dataOptions?.length||0;data=series.data=arr}if(keys&&hasGroupedData){series.options.keys=false}for(i=0;i<processedDataLength;i++){cursor=cropStart+i;if(!hasGroupedData){point=data[cursor];pOptions=dataOptions?dataOptions[cursor]:table.getRow(i,pointArrayMap);if(!point&&pOptions!==void 0){data[cursor]=point=new PointClass(series,pOptions,xData[i])}}else{point=new PointClass(series,table.getRow(i,dataColumnKeys)||[]);point.dataGroup=series.groupMap[groupCropStartIndex+i];if(point.dataGroup?.options){point.options=point.dataGroup.options;extend(point,point.dataGroup.options);delete point.dataLabels}}if(point){point.index=hasGroupedData?groupCropStartIndex+i:cursor;points[i]=point;point.category=categories?.[point.x]??point.x;point.key=point.name??point.category}}series.options.keys=keys;if(data&&(processedDataLength!==(dataLength=data.length)||hasGroupedData)){for(i=0;i<dataLength;i++){if(i===cropStart&&!hasGroupedData){i+=processedDataLength}if(data[i]){data[i].destroyElements();data[i].plotX=void 0}}}series.data=data;series.points=points;fireEvent(this,"afterGeneratePoints")}getXExtremes(xData){return{min:arrayMin(xData),max:arrayMax(xData)}}getExtremes(yData,forceExtremesFromAll){const{xAxis,yAxis}=this,getExtremesFromAll=forceExtremesFromAll||this.getExtremesFromAll||this.options.getExtremesFromAll,table=getExtremesFromAll&&this.cropped?this.dataTable:this.dataTable.modified,rowCount=table.rowCount,customData=yData||this.stackedYData,yAxisData=customData?[customData]:(this.keysAffectYAxis||this.pointArrayMap||["y"])?.map(key=>table.getColumn(key,true)||[])||[],xData=this.getColumn("x",true),activeYData=[],shoulder=this.requireSorting&&!this.is("column")?1:0,positiveValuesOnly=yAxis?yAxis.positiveValuesOnly:false,doAll=getExtremesFromAll||this.cropped||!xAxis;let xExtremes,x,i,xMin=0,xMax=0;if(xAxis){xExtremes=xAxis.getExtremes();xMin=xExtremes.min;xMax=xExtremes.max}for(i=0;i<rowCount;i++){x=xData[i];if(doAll||(xData[i+shoulder]||x)>=xMin&&(xData[i-shoulder]||x)<=xMax){for(const values of yAxisData){const val=values[i];if(isNumber(val)&&(val>0||!positiveValuesOnly)){activeYData.push(val)}}}}const dataExtremes={activeYData:activeYData,dataMin:arrayMin(activeYData),dataMax:arrayMax(activeYData)};fireEvent(this,"afterGetExtremes",{dataExtremes:dataExtremes});return dataExtremes}applyExtremes(){const dataExtremes=this.getExtremes();this.dataMin=dataExtremes.dataMin;this.dataMax=dataExtremes.dataMax;return dataExtremes}getFirstValidPoint(data,start=0,increment=1){const dataLength=data.length;let i=start;while(i>=0&&i<dataLength){if(defined(data[i])){return data[i]}i+=increment}}translate(){this.generatePoints();const series=this,options=series.options,stacking=options.stacking,xAxis=series.xAxis,enabledDataSorting=series.enabledDataSorting,yAxis=series.yAxis,points=series.points,dataLength=points.length,pointPlacement=series.pointPlacementToXValue(),dynamicallyPlaced=Boolean(pointPlacement),threshold=options.threshold,stackThreshold=options.startFromThreshold?threshold:0;let i,plotX,lastPlotX,stackIndicator,closestPointRangePx=Number.MAX_VALUE;function limitedRange(val){return clamp(val,-1e9,1e9)}for(i=0;i<dataLength;i++){const point=points[i],xValue=point.x;let stackItem,stackValues,yValue=point.y,lowValue=point.low;const stacks=stacking&&yAxis.stacking?.stacks[(series.negStacks&&yValue<(stackThreshold?0:threshold)?"-":"")+series.stackKey];plotX=xAxis.translate(xValue,false,false,false,true,pointPlacement);point.plotX=isNumber(plotX)?correctFloat(limitedRange(plotX)):void 0;if(stacking&&series.visible&&stacks&&stacks[xValue]){stackIndicator=series.getStackIndicator(stackIndicator,xValue,series.index);if(!point.isNull&&stackIndicator.key){stackItem=stacks[xValue];stackValues=stackItem.points[stackIndicator.key]}if(stackItem&&isArray(stackValues)){lowValue=stackValues[0];yValue=stackValues[1];if(lowValue===stackThreshold&&stackIndicator.key===stacks[xValue].base){lowValue=pick(isNumber(threshold)?threshold:yAxis.min)}if(yAxis.positiveValuesOnly&&defined(lowValue)&&lowValue<=0){lowValue=void 0}point.total=point.stackTotal=pick(stackItem.total);point.percentage=defined(point.y)&&stackItem.total?point.y/stackItem.total*100:void 0;point.stackY=yValue;if(!series.irregularWidths){stackItem.setOffset(series.pointXOffset||0,series.barW||0,void 0,void 0,void 0,series.xAxis)}}}point.yBottom=defined(lowValue)?limitedRange(yAxis.translate(lowValue,false,true,false,true)):void 0;if(series.dataModify){yValue=series.dataModify.modifyValue(yValue,i)}let plotY;if(isNumber(yValue)&&point.plotX!==void 0){plotY=yAxis.translate(yValue,false,true,false,true);plotY=isNumber(plotY)?limitedRange(plotY):void 0}point.plotY=plotY;point.isInside=this.isPointInside(point);point.clientX=dynamicallyPlaced?correctFloat(xAxis.translate(xValue,false,false,false,true,pointPlacement)):plotX;point.negative=(point.y||0)<(threshold||0);if(!point.isNull&&point.visible!==false){if(typeof lastPlotX!=="undefined"){closestPointRangePx=Math.min(closestPointRangePx,Math.abs(plotX-lastPlotX))}lastPlotX=plotX}point.zone=this.zones.length?point.getZone():void 0;if(!point.graphic&&series.group&&enabledDataSorting){point.isNew=true}}series.closestPointRangePx=closestPointRangePx;fireEvent(this,"afterTranslate")}getValidPoints(points,insideOnly,allowNull){const chart=this.chart;return(points||this.points||[]).filter(function(point){const{plotX,plotY}=point,asNull=!allowNull&&(point.isNull||!isNumber(plotY));if(asNull||insideOnly&&!chart.isInsidePlot(plotX,plotY,{inverted:chart.inverted})){return false}return point.visible!==false})}getClipBox(){const{chart,xAxis,yAxis}=this;let{x,y,width,height}=merge(chart.clipBox);if(xAxis&&xAxis.len!==chart.plotSizeX){width=xAxis.len}if(yAxis&&yAxis.len!==chart.plotSizeY){height=yAxis.len}if(chart.inverted&&!this.invertible){[width,height]=[height,width]}return{x:x,y:y,width:width,height:height}}getSharedClipKey(){this.sharedClipKey=(this.options.xAxis||0)+","+(this.options.yAxis||0);return this.sharedClipKey}setClip(){const{chart,group,markerGroup}=this,sharedClips=chart.sharedClips,renderer=chart.renderer,clipBox=this.getClipBox(),sharedClipKey=this.getSharedClipKey();let clipRect=sharedClips[sharedClipKey];if(!clipRect){sharedClips[sharedClipKey]=clipRect=renderer.clipRect(clipBox)}else{clipRect.animate(clipBox)}if(group){group.clip(this.options.clip===false?void 0:clipRect)}if(markerGroup){markerGroup.clip()}}animate(init){const{chart,group,markerGroup}=this,inverted=chart.inverted,animation=animObject(this.options.animation),animationClipKey=[this.getSharedClipKey(),animation.duration,animation.easing,animation.defer].join(",");let animationClipRect=chart.sharedClips[animationClipKey],markerAnimationClipRect=chart.sharedClips[animationClipKey+"m"];if(init&&group){const clipBox=this.getClipBox();if(!animationClipRect){clipBox.width=0;if(inverted){clipBox.x=chart.plotHeight}animationClipRect=chart.renderer.clipRect(clipBox);chart.sharedClips[animationClipKey]=animationClipRect;const markerClipBox={x:inverted?-99:-99,y:inverted?-99:-99,width:inverted?chart.plotWidth+199:99,height:inverted?99:chart.plotHeight+199};markerAnimationClipRect=chart.renderer.clipRect(markerClipBox);chart.sharedClips[animationClipKey+"m"]=markerAnimationClipRect}else{animationClipRect.attr("height",clipBox.height)}group.clip(animationClipRect);markerGroup?.clip(markerAnimationClipRect)}else if(animationClipRect&&!animationClipRect.hasClass("highcharts-animating")){const finalBox=this.getClipBox(),step=animation.step;if(markerGroup?.element.childNodes.length||chart.series.length>1){animation.step=function(val,fx){if(step){step.apply(fx,arguments)}if(fx.prop==="width"&&markerAnimationClipRect?.element){markerAnimationClipRect.attr(inverted?"height":"width",val+99)}}}animationClipRect.addClass("highcharts-animating").animate(finalBox,animation)}}afterAnimate(){this.setClip();objectEach(this.chart.sharedClips,(clip,key,sharedClips)=>{if(clip&&!this.chart.container.querySelector(`[clip-path="url(#${clip.id})"]`)){clip.destroy();delete sharedClips[key]}});this.finishedAnimating=true;fireEvent(this,"afterAnimate")}drawPoints(points=this.points){const series=this,chart=series.chart,styledMode=chart.styledMode,{colorAxis,options}=series,seriesMarkerOptions=options.marker,markerGroup=series[series.specialGroup||"markerGroup"],xAxis=series.xAxis,globallyEnabled=pick(seriesMarkerOptions.enabled,!xAxis||xAxis.isRadial?true:null,series.closestPointRangePx>=seriesMarkerOptions.enabledThreshold*seriesMarkerOptions.radius);let i,point,graphic,verb,pointMarkerOptions,hasPointMarker,markerAttribs;if(seriesMarkerOptions.enabled!==false||series._hasPointMarkers){for(i=0;i<points.length;i++){point=points[i];graphic=point.graphic;verb=graphic?"animate":"attr";pointMarkerOptions=point.marker||{};hasPointMarker=!!point.marker;const shouldDrawMarker=(globallyEnabled&&typeof pointMarkerOptions.enabled==="undefined"||pointMarkerOptions.enabled)&&!point.isNull&&point.visible!==false;if(shouldDrawMarker){const symbol=pick(pointMarkerOptions.symbol,series.symbol,"rect");markerAttribs=series.markerAttribs(point,point.selected&&"select");if(series.enabledDataSorting){point.startXPos=xAxis.reversed?-(markerAttribs.width||0):xAxis.width}const isInside=point.isInside!==false;if(!graphic&&isInside&&((markerAttribs.width||0)>0||point.hasImage)){point.graphic=graphic=chart.renderer.symbol(symbol,markerAttribs.x,markerAttribs.y,markerAttribs.width,markerAttribs.height,hasPointMarker?pointMarkerOptions:seriesMarkerOptions).add(markerGroup);if(series.enabledDataSorting&&chart.hasRendered){graphic.attr({x:point.startXPos});verb="animate"}}if(graphic&&verb==="animate"){graphic[isInside?"show":"hide"](isInside).animate(markerAttribs)}if(graphic){const pointAttr=series.pointAttribs(point,styledMode||!point.selected?void 0:"select");if(!styledMode){graphic[verb](pointAttr)}else if(colorAxis){graphic["css"]({fill:pointAttr.fill})}}if(graphic){graphic.addClass(point.getClassName(),true)}}else if(graphic){point.graphic=graphic.destroy()}}}}markerAttribs(point,state){const seriesOptions=this.options,seriesMarkerOptions=seriesOptions.marker,pointMarkerOptions=point.marker||{},symbol=pointMarkerOptions.symbol||seriesMarkerOptions.symbol,attribs={};let seriesStateOptions,pointStateOptions,radius=pick(pointMarkerOptions.radius,seriesMarkerOptions&&seriesMarkerOptions.radius);if(state){seriesStateOptions=seriesMarkerOptions.states[state];pointStateOptions=pointMarkerOptions.states&&pointMarkerOptions.states[state];radius=pick(pointStateOptions&&pointStateOptions.radius,seriesStateOptions&&seriesStateOptions.radius,radius&&radius+(seriesStateOptions&&seriesStateOptions.radiusPlus||0))}point.hasImage=symbol&&symbol.indexOf("url")===0;if(point.hasImage){radius=0}const pos=point.pos();if(isNumber(radius)&&pos){if(seriesOptions.crisp){pos[0]=crisp(pos[0],point.hasImage?0:symbol==="rect"?seriesMarkerOptions?.lineWidth||0:1)}attribs.x=pos[0]-radius;attribs.y=pos[1]-radius}if(radius){attribs.width=attribs.height=2*radius}return attribs}pointAttribs(point,state){const seriesMarkerOptions=this.options.marker,pointOptions=point&&point.options,pointMarkerOptions=pointOptions&&pointOptions.marker||{},pointColorOption=pointOptions&&pointOptions.color,pointColor=point&&point.color,zoneColor=point&&point.zone&&point.zone.color;let seriesStateOptions,pointStateOptions,color=this.color,fill,stroke,strokeWidth=pick(pointMarkerOptions.lineWidth,seriesMarkerOptions.lineWidth),opacity=1;color=pointColorOption||zoneColor||pointColor||color;fill=pointMarkerOptions.fillColor||seriesMarkerOptions.fillColor||color;stroke=pointMarkerOptions.lineColor||seriesMarkerOptions.lineColor||color;state=state||"normal";if(state){seriesStateOptions=seriesMarkerOptions.states[state]||{};pointStateOptions=pointMarkerOptions.states&&pointMarkerOptions.states[state]||{};strokeWidth=pick(pointStateOptions.lineWidth,seriesStateOptions.lineWidth,strokeWidth+pick(pointStateOptions.lineWidthPlus,seriesStateOptions.lineWidthPlus,0));fill=pointStateOptions.fillColor||seriesStateOptions.fillColor||fill;stroke=pointStateOptions.lineColor||seriesStateOptions.lineColor||stroke;opacity=pick(pointStateOptions.opacity,seriesStateOptions.opacity,opacity)}return{stroke:stroke,"stroke-width":strokeWidth,fill:fill,opacity:opacity}}destroy(keepEventsForUpdate){const series=this,chart=series.chart,issue134=/AppleWebKit\/533/.test(win.navigator.userAgent),data=series.data||[];let destroy,i,point,axis;fireEvent(series,"destroy",{keepEventsForUpdate:keepEventsForUpdate});this.removeEvents(keepEventsForUpdate);(series.axisTypes||[]).forEach(function(AXIS){axis=series[AXIS];if(axis&&axis.series){erase(axis.series,series);axis.isDirty=axis.forceRedraw=true}});if(series.legendItem){series.chart.legend.destroyItem(series)}i=data.length;while(i--){point=data[i];if(point&&point.destroy){point.destroy()}}for(const zone of series.zones){destroyObjectProperties(zone,void 0,true)}U.clearTimeout(series.animationTimeout);objectEach(series,function(val,prop){if(val instanceof SVGElement&&!val.survive){destroy=issue134&&prop==="group"?"hide":"destroy";val[destroy]()}});if(chart.hoverSeries===series){chart.hoverSeries=void 0}erase(chart.series,series);chart.orderItems("series");objectEach(series,function(val,prop){if(!keepEventsForUpdate||prop!=="hcEvents"){delete series[prop]}})}applyZones(){const series=this,{area,chart,graph,zones,points,xAxis,yAxis,zoneAxis}=series,{inverted,renderer}=chart,axis=this[`${zoneAxis}Axis`],{isXAxis,len=0,minPointOffset=0}=axis||{},halfWidth=(graph?.strokeWidth()||0)/2+1,avoidClose=(zone,plotX=0,plotY=0)=>{if(inverted){plotY=len-plotY}const{translated=0,lineClip}=zone,distance=plotY-translated;lineClip?.push(["L",plotX,Math.abs(distance)<halfWidth?plotY-halfWidth*(distance<=0?-1:1):translated])};if(zones.length&&(graph||area)&&axis&&isNumber(axis.min)){const axisMax=axis.getExtremes().max+minPointOffset,invertPath=path=>{path.forEach((segment,i)=>{if(segment[0]==="M"||segment[0]==="L"){path[i]=[segment[0],isXAxis?len-segment[1]:segment[1],isXAxis?segment[2]:len-segment[2]]}})};zones.forEach(zone=>{zone.lineClip=[];zone.translated=clamp(axis.toPixels(pick(zone.value,axisMax),true)||0,0,len)});if(graph&&!this.showLine){graph.hide()}if(area){area.hide()}if(zoneAxis==="y"&&points.length<xAxis.len){for(const point of points){const{plotX,plotY,zone}=point,zoneBelow=zone&&zones[zones.indexOf(zone)-1];if(zone){avoidClose(zone,plotX,plotY)}if(zoneBelow){avoidClose(zoneBelow,plotX,plotY)}}}let lastLineClip=[],lastTranslated=axis.toPixels(axis.getExtremes().min-minPointOffset,true);zones.forEach(zone=>{const lineClip=zone.lineClip||[],translated=Math.round(zone.translated||0);if(xAxis.reversed){lineClip.reverse()}let{clip,simpleClip}=zone,x1=0,y1=0,x2=xAxis.len,y2=yAxis.len;if(isXAxis){x1=translated;x2=lastTranslated}else{y1=translated;y2=lastTranslated}const simplePath=[["M",x1,y1],["L",x2,y1],["L",x2,y2],["L",x1,y2],["Z"]],adaptivePath=[simplePath[0],...lineClip,simplePath[1],simplePath[2],...lastLineClip,simplePath[3],simplePath[4]];lastLineClip=lineClip.reverse();lastTranslated=translated;if(inverted){invertPath(adaptivePath);if(area){invertPath(simplePath)}}if(clip){clip.animate({d:adaptivePath});simpleClip?.animate({d:simplePath})}else{clip=zone.clip=renderer.path(adaptivePath);if(area){simpleClip=zone.simpleClip=renderer.path(simplePath)}}if(graph){zone.graph?.clip(clip)}if(area){zone.area?.clip(simpleClip)}})}else if(series.visible){if(graph){graph.show()}if(area){area.show()}}}plotGroup(prop,name,visibility,zIndex,parent){let group=this[prop];const isNew=!group,attrs={visibility:visibility,zIndex:zIndex||.1};if(defined(this.opacity)&&!this.chart.styledMode&&this.state!=="inactive"){attrs.opacity=this.opacity}if(!group){this[prop]=group=this.chart.renderer.g().add(parent)}group.addClass("highcharts-"+name+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(defined(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(group.hasClass("highcharts-tracker")?" highcharts-tracker":""),true);group.attr(attrs)[isNew?"attr":"animate"](this.getPlotBox(name));return group}getPlotBox(name){let horAxis=this.xAxis,vertAxis=this.yAxis;const chart=this.chart,inverted=chart.inverted&&!chart.polar&&horAxis&&this.invertible&&name==="series";if(chart.inverted){horAxis=vertAxis;vertAxis=this.xAxis}return{translateX:horAxis?horAxis.left:chart.plotLeft,translateY:vertAxis?vertAxis.top:chart.plotTop,rotation:inverted?90:0,rotationOriginX:inverted?(horAxis.len-vertAxis.len)/2:0,rotationOriginY:inverted?(horAxis.len+vertAxis.len)/2:0,scaleX:inverted?-1:1,scaleY:1}}removeEvents(keepEventsForUpdate){const{eventsToUnbind}=this;if(!keepEventsForUpdate){removeEvent(this)}if(eventsToUnbind.length){eventsToUnbind.forEach(unbind=>{unbind()});eventsToUnbind.length=0}}render(){const series=this,{chart,options,hasRendered}=series,animOptions=animObject(options.animation),visibility=series.visible?"inherit":"hidden",zIndex=options.zIndex,chartSeriesGroup=chart.seriesGroup;let animDuration=series.finishedAnimating?0:animOptions.duration;fireEvent(this,"render");series.plotGroup("group","series",visibility,zIndex,chartSeriesGroup);series.markerGroup=series.plotGroup("markerGroup","markers",visibility,zIndex,chartSeriesGroup);if(options.clip!==false){series.setClip()}if(animDuration){series.animate?.(true)}if(series.drawGraph){series.drawGraph();series.applyZones()}if(series.visible){series.drawPoints()}series.drawDataLabels?.();series.redrawPoints?.();if(options.enableMouseTracking){series.drawTracker?.()}if(animDuration){series.animate?.()}if(!hasRendered){if(animDuration&&animOptions.defer){animDuration+=animOptions.defer}series.animationTimeout=syncTimeout(()=>{series.afterAnimate()},animDuration||0)}series.isDirty=false;series.hasRendered=true;fireEvent(series,"afterRender")}redraw(){const wasDirty=this.isDirty||this.isDirtyData;this.translate();this.render();if(wasDirty){delete this.kdTree}}reserveSpace(){return this.visible||!this.chart.options.chart.ignoreHiddenSeries}searchPoint(e,compareX){const{xAxis,yAxis}=this,inverted=this.chart.inverted;return this.searchKDTree({clientX:inverted?xAxis.len-e.chartY+xAxis.pos:e.chartX-xAxis.pos,plotY:inverted?yAxis.len-e.chartX+yAxis.pos:e.chartY-yAxis.pos},compareX,e)}buildKDTree(e){this.buildingKdTree=true;const series=this,dimensions=series.options.findNearestPointBy.indexOf("y")>-1?2:1;function kdtree(points,depth,dimensions){const length=points?.length;let axis,median;if(length){axis=series.kdAxisArray[depth%dimensions];points.sort((a,b)=>(a[axis]||0)-(b[axis]||0));median=Math.floor(length/2);return{point:points[median],left:kdtree(points.slice(0,median),depth+1,dimensions),right:kdtree(points.slice(median+1),depth+1,dimensions)}}}function startRecursive(){series.kdTree=kdtree(series.getValidPoints(void 0,!series.directTouch),dimensions,dimensions);series.buildingKdTree=false}delete series.kdTree;syncTimeout(startRecursive,series.options.kdNow||e?.type==="touchstart"?0:1)}searchKDTree(point,compareX,e){const series=this,[kdX,kdY]=this.kdAxisArray,kdComparer=compareX?"distX":"dist",kdDimensions=(series.options.findNearestPointBy||"").indexOf("y")>-1?2:1,useRadius=!!series.isBubble;function setDistance(p1,p2){const p1kdX=p1[kdX],p2kdX=p2[kdX],x=defined(p1kdX)&&defined(p2kdX)?p1kdX-p2kdX:null,p1kdY=p1[kdY],p2kdY=p2[kdY],y=defined(p1kdY)&&defined(p2kdY)?p1kdY-p2kdY:0,radius=useRadius?p2.marker?.radius||0:0;p2.dist=Math.sqrt((x&&x*x||0)+y*y)-radius;p2.distX=defined(x)?Math.abs(x)-radius:Number.MAX_VALUE}function doSearch(search,tree,depth,dimensions){const point=tree.point,axis=series.kdAxisArray[depth%dimensions];let nPoint1,nPoint2,ret=point;setDistance(search,point);const tdist=(search[axis]||0)-(point[axis]||0)+(useRadius?point.marker?.radius||0:0),sideA=tdist<0?"left":"right",sideB=tdist<0?"right":"left";if(tree[sideA]){nPoint1=doSearch(search,tree[sideA],depth+1,dimensions);ret=nPoint1[kdComparer]<ret[kdComparer]?nPoint1:point}if(tree[sideB]){if(Math.sqrt(tdist*tdist)<ret[kdComparer]){nPoint2=doSearch(search,tree[sideB],depth+1,dimensions);ret=nPoint2[kdComparer]<ret[kdComparer]?nPoint2:ret}}return ret}if(!this.kdTree&&!this.buildingKdTree){this.buildKDTree(e)}if(this.kdTree){return doSearch(point,this.kdTree,kdDimensions,kdDimensions)}}pointPlacementToXValue(){const{options,xAxis}=this;let factor=options.pointPlacement;if(factor==="between"){factor=xAxis.reversed?-.5:.5}return isNumber(factor)?factor*(options.pointRange||xAxis.pointRange):0}isPointInside(point){const{chart,xAxis,yAxis}=this,{plotX=-1,plotY=-1}=point,isInside=plotY>=0&&plotY<=(yAxis?yAxis.len:chart.plotHeight)&&plotX>=0&&plotX<=(xAxis?xAxis.len:chart.plotWidth);return isInside}drawTracker(){const series=this,options=series.options,trackByArea=options.trackByArea,trackerPath=[].concat((trackByArea?series.areaPath:series.graphPath)||[]),chart=series.chart,pointer=chart.pointer,renderer=chart.renderer,snap=chart.options.tooltip?.snap||0,onMouseOver=()=>{if(options.enableMouseTracking&&chart.hoverSeries!==series){series.onMouseOver()}},TRACKER_FILL="rgba(192,192,192,"+(svg?1e-4:.002)+")";let tracker=series.tracker;if(tracker){tracker.attr({d:trackerPath})}else if(series.graph){series.tracker=tracker=renderer.path(trackerPath).attr({visibility:series.visible?"inherit":"hidden",zIndex:2}).addClass(trackByArea?"highcharts-tracker-area":"highcharts-tracker-line").add(series.group);if(!chart.styledMode){tracker.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:TRACKER_FILL,fill:trackByArea?TRACKER_FILL:"none","stroke-width":series.graph.strokeWidth()+(trackByArea?0:2*snap)})}[series.tracker,series.markerGroup,series.dataLabelsGroup].forEach(tracker=>{if(tracker){tracker.addClass("highcharts-tracker").on("mouseover",onMouseOver).on("mouseout",e=>{pointer?.onTrackerMouseOut(e)});if(options.cursor&&!chart.styledMode){tracker.css({cursor:options.cursor})}tracker.on("touchstart",onMouseOver)}})}fireEvent(this,"afterDrawTracker")}addPoint(options,redraw,shift,animation,withEvent){const series=this,seriesOptions=series.options,{chart,data,dataTable:table,xAxis}=series,names=xAxis&&xAxis.hasNames&&xAxis.names,dataOptions=seriesOptions.data,xData=series.getColumn("x");let isInTheMiddle,i;redraw=pick(redraw,true);const point={series:series};series.pointClass.prototype.applyOptions.apply(point,[options]);const x=point.x;i=xData.length;if(series.requireSorting&&x<xData[i-1]){isInTheMiddle=true;while(i&&xData[i-1]>x){i--}}table.setRow(point,i,true,{addColumns:false});if(names&&point.name){names[x]=point.name}dataOptions?.splice(i,0,options);if(isInTheMiddle||series.processedData){series.data.splice(i,0,null);series.processData()}if(seriesOptions.legendType==="point"){series.generatePoints()}if(shift){if(data[0]&&!!data[0].remove){data[0].remove(false)}else{[data,dataOptions,...Object.values(table.getColumns())].filter(defined).forEach(coll=>{coll.shift()});table.rowCount-=1;fireEvent(table,"afterDeleteRows")}}if(withEvent!==false){fireEvent(series,"addPoint",{point:point})}series.isDirty=true;series.isDirtyData=true;if(redraw){chart.redraw(animation)}}removePoint(i,redraw,animation){const series=this,{chart,data,points,dataTable:table}=series,point=data[i],remove=function(){[points?.length===data.length?points:void 0,data,series.options.data,...Object.values(table.getColumns())].filter(defined).forEach(coll=>{coll.splice(i,1)});table.rowCount-=1;fireEvent(table,"afterDeleteRows");point?.destroy();series.isDirty=true;series.isDirtyData=true;if(redraw){chart.redraw()}};setAnimation(animation,chart);redraw=pick(redraw,true);if(point){point.firePointEvent("remove",null,remove)}else{remove()}}remove(redraw,animation,withEvent,keepEvents){const series=this,chart=series.chart;function remove(){series.destroy(keepEvents);chart.isDirtyLegend=chart.isDirtyBox=true;chart.linkSeries(keepEvents);if(pick(redraw,true)){chart.redraw(animation)}}if(withEvent!==false){fireEvent(series,"remove",null,remove)}else{remove()}}update(options,redraw){options=diffObjects(options,this.userOptions);fireEvent(this,"update",{options:options});const series=this,chart=series.chart,oldOptions=series.userOptions,initialType=series.initialType||series.type,plotOptions=chart.options.plotOptions,initialSeriesProto=seriesTypes[initialType].prototype,groups=["group","markerGroup","dataLabelsGroup","transformGroup"],optionsToCheck=["dataGrouping","pointStart","pointInterval","pointIntervalUnit","keys"],animation=series.finishedAnimating&&{animation:false},kinds={};let seriesOptions,n,preserve=["colorIndex","eventOptions","navigatorSeries","symbolIndex","baseSeries"],newType=options.type||oldOptions.type||chart.options.chart.type;const keepPoints=!(this.hasDerivedData||newType&&newType!==this.type||typeof options.keys!=="undefined"||typeof options.pointStart!=="undefined"||typeof options.pointInterval!=="undefined"||typeof options.relativeXValue!=="undefined"||options.joinBy||options.mapData||optionsToCheck.some(option=>series.hasOptionChanged(option)));newType=newType||initialType;if(keepPoints){preserve.push("data","isDirtyData","isDirtyCanvas","points","dataTable","processedData","xIncrement","cropped","_hasPointMarkers","hasDataLabels","nodes","layout","level","mapMap","mapData","minY","maxY","minX","maxX","transformGroups");if(options.visible!==false){preserve.push("area","graph")}series.parallelArrays.forEach(function(key){preserve.push(key+"Data")});if(options.data){if(options.dataSorting){extend(series.options.dataSorting,options.dataSorting)}this.setData(options.data,false)}}else{this.dataTable.modified=this.dataTable}options=merge(oldOptions,{index:oldOptions.index===void 0?series.index:oldOptions.index,pointStart:plotOptions?.series?.pointStart??oldOptions.pointStart??series.getColumn("x")[0]},!keepPoints&&{data:series.options.data},options,animation);if(keepPoints&&options.data){options.data=series.options.data}preserve=groups.concat(preserve);preserve.forEach(function(prop){preserve[prop]=series[prop];delete series[prop]});let casting=false;if(seriesTypes[newType]){casting=newType!==series.type;series.remove(false,false,false,true);if(casting){chart.propFromSeries();if(Object.setPrototypeOf){Object.setPrototypeOf(series,seriesTypes[newType].prototype)}else{const ownEvents=Object.hasOwnProperty.call(series,"hcEvents")&&series.hcEvents;for(n in initialSeriesProto){series[n]=void 0}extend(series,seriesTypes[newType].prototype);if(ownEvents){series.hcEvents=ownEvents}else{delete series.hcEvents}}}}else{error(17,true,chart,{missingModuleFor:newType})}preserve.forEach(function(prop){series[prop]=preserve[prop]});series.init(chart,options);if(keepPoints&&this.points){seriesOptions=series.options;if(seriesOptions.visible===false){kinds.graphic=1;kinds.dataLabel=1}else{if(this.hasMarkerChanged(seriesOptions,oldOptions)){kinds.graphic=1}if(!series.hasDataLabels?.()){kinds.dataLabel=1}}for(const point of this.points){if(point&&point.series){point.resolveColor();if(Object.keys(kinds).length){point.destroyElements(kinds)}if(seriesOptions.showInLegend===false&&point.legendItem){chart.legend.destroyItem(point)}}}}series.initialType=initialType;chart.linkSeries();chart.setSortedData();if(casting&&series.linkedSeries.length){series.isDirtyData=true}fireEvent(this,"afterUpdate");if(pick(redraw,true)){chart.redraw(keepPoints?void 0:false)}}setName(name){this.name=this.options.name=this.userOptions.name=name;this.chart.isDirtyLegend=true}hasOptionChanged(optionName){const chart=this.chart,option=this.options[optionName],plotOptions=chart.options.plotOptions,oldOption=this.userOptions[optionName],plotOptionsOption=pick(plotOptions?.[this.type]?.[optionName],plotOptions?.series?.[optionName]);if(oldOption&&!defined(plotOptionsOption)){return option!==oldOption}return option!==pick(plotOptionsOption,option)}onMouseOver(){const series=this,chart=series.chart,hoverSeries=chart.hoverSeries,pointer=chart.pointer;pointer?.setHoverChartIndex();if(hoverSeries&&hoverSeries!==series){hoverSeries.onMouseOut()}if(series.options.events.mouseOver){fireEvent(series,"mouseOver")}series.setState("hover");chart.hoverSeries=series}onMouseOut(){const series=this,options=series.options,chart=series.chart,tooltip=chart.tooltip,hoverPoint=chart.hoverPoint;chart.hoverSeries=null;if(hoverPoint){hoverPoint.onMouseOut()}if(series&&options.events.mouseOut){fireEvent(series,"mouseOut")}if(tooltip&&!series.stickyTracking&&(!tooltip.shared||series.noSharedTooltip)){tooltip.hide()}chart.series.forEach(function(s){s.setState("",true)})}setState(state,inherit){const series=this,options=series.options,graph=series.graph,inactiveOtherPoints=options.inactiveOtherPoints,stateOptions=options.states,stateAnimation=pick(stateOptions[state||"normal"]&&stateOptions[state||"normal"].animation,series.chart.options.chart.animation);let lineWidth=options.lineWidth,opacity=options.opacity;state=state||"";if(series.state!==state){[series.group,series.markerGroup,series.dataLabelsGroup].forEach(function(group){if(group){if(series.state){group.removeClass("highcharts-series-"+series.state)}if(state){group.addClass("highcharts-series-"+state)}}});series.state=state;if(!series.chart.styledMode){if(stateOptions[state]&&stateOptions[state].enabled===false){return}if(state){lineWidth=stateOptions[state].lineWidth||lineWidth+(stateOptions[state].lineWidthPlus||0);opacity=pick(stateOptions[state].opacity,opacity)}if(graph&&!graph.dashstyle&&isNumber(lineWidth)){for(const graphElement of[graph,...this.zones.map(zone=>zone.graph)]){graphElement?.animate({"stroke-width":lineWidth},stateAnimation)}}if(!inactiveOtherPoints){[series.group,series.markerGroup,series.dataLabelsGroup,series.labelBySeries].forEach(function(group){if(group){group.animate({opacity:opacity},stateAnimation)}})}}}if(inherit&&inactiveOtherPoints&&series.points){series.setAllPointsToState(state||void 0)}}setAllPointsToState(state){this.points.forEach(function(point){if(point.setState){point.setState(state)}})}setVisible(vis,redraw){const series=this,chart=series.chart,ignoreHiddenSeries=chart.options.chart.ignoreHiddenSeries,oldVisibility=series.visible;series.visible=vis=series.options.visible=series.userOptions.visible=typeof vis==="undefined"?!oldVisibility:vis;const showOrHide=vis?"show":"hide";["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(key=>{series[key]?.[showOrHide]()});if(chart.hoverSeries===series||chart.hoverPoint?.series===series){series.onMouseOut()}if(series.legendItem){chart.legend.colorizeItem(series,vis)}series.isDirty=true;if(series.options.stacking){chart.series.forEach(otherSeries=>{if(otherSeries.options.stacking&&otherSeries.visible){otherSeries.isDirty=true}})}series.linkedSeries.forEach(otherSeries=>{otherSeries.setVisible(vis,false)});if(ignoreHiddenSeries){chart.isDirtyBox=true}fireEvent(series,showOrHide);if(redraw!==false){chart.redraw()}}show(){this.setVisible(true)}hide(){this.setVisible(false)}select(selected){const series=this;series.selected=selected=this.options.selected=typeof selected==="undefined"?!series.selected:selected;if(series.checkbox){series.checkbox.checked=selected}fireEvent(series,selected?"select":"unselect")}shouldShowTooltip(plotX,plotY,options={}){options.series=this;options.visiblePlotOnly=true;return this.chart.isInsidePlot(plotX,plotY,options)}drawLegendSymbol(legend,item){LegendSymbol[this.options.legendSymbol||"rectangle"]?.call(this,legend,item)}}Series.defaultOptions=SeriesDefaults;Series.types=SeriesRegistry.seriesTypes;Series.registerType=SeriesRegistry.registerSeriesType;extend(Series.prototype,{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,directTouch:false,invertible:true,isCartesian:true,kdAxisArray:["clientX","plotY"],parallelArrays:["x","y"],pointClass:Point,requireSorting:true,sorted:true});SeriesRegistry.series=Series;export default Series;"";"";