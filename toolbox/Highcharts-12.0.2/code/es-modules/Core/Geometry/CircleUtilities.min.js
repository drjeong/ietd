"use strict";import Geometry from"./GeometryUtilities.js";const{getAngleBetweenPoints,getCenterOfPoints,getDistanceBetweenPoints}=Geometry;var CircleUtilities;(function(CircleUtilities){function round(x,decimals){const a=Math.pow(10,decimals);return Math.round(x*a)/a}CircleUtilities.round=round;function getAreaOfCircle(r){if(r<=0){throw new Error("radius of circle must be a positive number.")}return Math.PI*r*r}CircleUtilities.getAreaOfCircle=getAreaOfCircle;function getCircularSegmentArea(r,h){return r*r*Math.acos(1-h/r)-(r-h)*Math.sqrt(h*(2*r-h))}CircleUtilities.getCircularSegmentArea=getCircularSegmentArea;function getOverlapBetweenCircles(r1,r2,d){let overlap=0;if(d<r1+r2){if(d<=Math.abs(r2-r1)){overlap=getAreaOfCircle(r1<r2?r1:r2)}else{const d1=(r1*r1-r2*r2+d*d)/(2*d),d2=d-d1;overlap=getCircularSegmentArea(r1,r1-d1)+getCircularSegmentArea(r2,r2-d2)}overlap=round(overlap,14)}return overlap}CircleUtilities.getOverlapBetweenCircles=getOverlapBetweenCircles;function getCircleCircleIntersection(c1,c2){const d=getDistanceBetweenPoints(c1,c2),r1=c1.r,r2=c2.r;let points=[];if(d<r1+r2&&d>Math.abs(r1-r2)){const r1Square=r1*r1,r2Square=r2*r2,x=(r1Square-r2Square+d*d)/(2*d),y=Math.sqrt(r1Square-x*x),x1=c1.x,x2=c2.x,y1=c1.y,y2=c2.y,x0=x1+x*(x2-x1)/d,y0=y1+x*(y2-y1)/d,rx=-(y2-y1)*(y/d),ry=-(x2-x1)*(y/d);points=[{x:round(x0+rx,14),y:round(y0-ry,14)},{x:round(x0-rx,14),y:round(y0+ry,14)}]}return points}CircleUtilities.getCircleCircleIntersection=getCircleCircleIntersection;function getCirclesIntersectionPoints(circles){return circles.reduce((points,c1,i,arr)=>{const additional=arr.slice(i+1).reduce((points,c2,j)=>{const indexes=[i,j+i+1];return points.concat(getCircleCircleIntersection(c1,c2).map(p=>{p.indexes=indexes;return p}))},[]);return points.concat(additional)},[])}CircleUtilities.getCirclesIntersectionPoints=getCirclesIntersectionPoints;function isCircle1CompletelyOverlappingCircle2(circle1,circle2){return getDistanceBetweenPoints(circle1,circle2)+circle2.r<circle1.r+1e-10}CircleUtilities.isCircle1CompletelyOverlappingCircle2=isCircle1CompletelyOverlappingCircle2;function isPointInsideCircle(point,circle){return getDistanceBetweenPoints(point,circle)<=circle.r+1e-10}CircleUtilities.isPointInsideCircle=isPointInsideCircle;function isPointInsideAllCircles(point,circles){return!circles.some(function(circle){return!isPointInsideCircle(point,circle)})}CircleUtilities.isPointInsideAllCircles=isPointInsideAllCircles;function isPointOutsideAllCircles(point,circles){return!circles.some(function(circle){return isPointInsideCircle(point,circle)})}CircleUtilities.isPointOutsideAllCircles=isPointOutsideAllCircles;function getCirclesIntersectionPolygon(circles){return getCirclesIntersectionPoints(circles).filter(function(p){return isPointInsideAllCircles(p,circles)})}CircleUtilities.getCirclesIntersectionPolygon=getCirclesIntersectionPolygon;function getAreaOfIntersectionBetweenCircles(circles){let intersectionPoints=getCirclesIntersectionPolygon(circles),result;if(intersectionPoints.length>1){const center=getCenterOfPoints(intersectionPoints);intersectionPoints=intersectionPoints.map(function(p){p.angle=getAngleBetweenPoints(center,p);return p}).sort(function(a,b){return b.angle-a.angle});const startPoint=intersectionPoints[intersectionPoints.length-1];const arcs=intersectionPoints.reduce(function(data,p1){const{startPoint}=data,midPoint=getCenterOfPoints([startPoint,p1]);const arc=p1.indexes.filter(function(index){return startPoint.indexes.indexOf(index)>-1}).reduce(function(arc,index){const circle=circles[index],angle1=getAngleBetweenPoints(circle,p1),angle2=getAngleBetweenPoints(circle,startPoint),angleDiff=angle2-angle1+(angle2<angle1?2*Math.PI:0),angle=angle2-angleDiff/2;let width=getDistanceBetweenPoints(midPoint,{x:circle.x+circle.r*Math.sin(angle),y:circle.y+circle.r*Math.cos(angle)});const{r}=circle;if(width>r*2){width=r*2}if(!arc||arc.width>width){arc={r:r,largeArc:width>r?1:0,width:width,x:p1.x,y:p1.y}}return arc},null);if(arc){const{r}=arc;data.arcs.push(["A",r,r,0,arc.largeArc,1,arc.x,arc.y]);data.startPoint=p1}return data},{startPoint:startPoint,arcs:[]}).arcs;if(arcs.length===0){}else if(arcs.length===1){}else{arcs.unshift(["M",startPoint.x,startPoint.y]);result={center:center,d:arcs}}}return result}CircleUtilities.getAreaOfIntersectionBetweenCircles=getAreaOfIntersectionBetweenCircles})(CircleUtilities||(CircleUtilities={}));export default CircleUtilities;