"use strict";import Chart from"../Chart/Chart.js";import F from"../Templating.js";const{format}=F;import D from"../Defaults.js";const{getOptions}=D;import NavigatorDefaults from"../../Stock/Navigator/NavigatorDefaults.js";import RangeSelectorDefaults from"../../Stock/RangeSelector/RangeSelectorDefaults.js";import ScrollbarDefaults from"../../Stock/Scrollbar/ScrollbarDefaults.js";import StockUtilities from"../../Stock/Utilities/StockUtilities.js";const{setFixedRange}=StockUtilities;import U from"../Utilities.js";const{addEvent,clamp,crisp,defined,extend,find,isNumber,isString,merge,pick,splat}=U;function getDefaultAxisOptions(coll,options,defaultOptions){if(coll==="xAxis"){return{minPadding:0,maxPadding:0,overscroll:0,ordinal:true}}if(coll==="yAxis"){return{labels:{y:-2},opposite:defaultOptions.opposite??options.opposite??true,showLastLabel:!!(options.categories||options.type==="category"),title:{text:defaultOptions.title?.text!=="Values"?defaultOptions.title?.text:null}}}return{}}function getForcedAxisOptions(type,chartOptions){if(type==="xAxis"){const navigatorEnabled=pick(chartOptions.navigator&&chartOptions.navigator.enabled,NavigatorDefaults.enabled,true);const axisOptions={type:"datetime",categories:void 0};if(navigatorEnabled){axisOptions.startOnTick=false;axisOptions.endOnTick=false}return axisOptions}return{}}class StockChart extends Chart{init(userOptions,callback){const defaultOptions=getOptions(),xAxisOptions=userOptions.xAxis,yAxisOptions=userOptions.yAxis,navigatorEnabled=pick(userOptions.navigator&&userOptions.navigator.enabled,NavigatorDefaults.enabled,true);userOptions.xAxis=userOptions.yAxis=void 0;const options=merge({chart:{panning:{enabled:true,type:"x"},zooming:{pinchType:"x",mouseWheel:{type:"x"}}},navigator:{enabled:navigatorEnabled},scrollbar:{enabled:pick(ScrollbarDefaults.enabled,true)},rangeSelector:{enabled:pick(RangeSelectorDefaults.rangeSelector.enabled,true)},title:{text:null},tooltip:{split:pick(defaultOptions.tooltip&&defaultOptions.tooltip.split,true),crosshairs:true},legend:{enabled:false}},userOptions,{isStock:true});userOptions.xAxis=xAxisOptions;userOptions.yAxis=yAxisOptions;options.xAxis=splat(userOptions.xAxis||{}).map(xAxisOptions=>merge(getDefaultAxisOptions("xAxis",xAxisOptions,defaultOptions.xAxis),xAxisOptions,getForcedAxisOptions("xAxis",userOptions)));options.yAxis=splat(userOptions.yAxis||{}).map(yAxisOptions=>merge(getDefaultAxisOptions("yAxis",yAxisOptions,defaultOptions.yAxis),yAxisOptions));super.init(options,callback)}createAxis(coll,options){options.axis=merge(getDefaultAxisOptions(coll,options.axis,getOptions()[coll]),options.axis,getForcedAxisOptions(coll,this.userOptions));return super.createAxis(coll,options)}}addEvent(Chart,"update",function(e){const chart=this,options=e.options;if("scrollbar"in options&&chart.navigator){merge(true,chart.options.scrollbar,options.scrollbar);chart.navigator.update({enabled:!!chart.navigator.navigatorEnabled});delete options.scrollbar}});(function(StockChart){function compose(ChartClass,AxisClass,SeriesClass,SVGRendererClass){const seriesProto=SeriesClass.prototype;if(!seriesProto.forceCropping){addEvent(AxisClass,"afterDrawCrosshair",onAxisAfterDrawCrosshair);addEvent(AxisClass,"afterHideCrosshair",onAxisAfterHideCrosshair);addEvent(AxisClass,"autoLabelAlign",onAxisAutoLabelAlign);addEvent(AxisClass,"destroy",onAxisDestroy);addEvent(AxisClass,"getPlotLinePath",onAxisGetPlotLinePath);ChartClass.prototype.setFixedRange=setFixedRange;seriesProto.forceCropping=seriesForceCropping;addEvent(SeriesClass,"setOptions",onSeriesSetOptions);SVGRendererClass.prototype.crispPolyLine=svgRendererCrispPolyLine}}StockChart.compose=compose;function onAxisAfterDrawCrosshair(event){const axis=this;if(!(axis.crosshair?.label?.enabled&&axis.cross&&isNumber(axis.min)&&isNumber(axis.max))){return}const chart=axis.chart,log=axis.logarithmic,options=axis.crosshair.label,horiz=axis.horiz,opposite=axis.opposite,left=axis.left,top=axis.top,width=axis.width,tickInside=axis.options.tickPosition==="inside",snap=axis.crosshair.snap!==false,e=event.e||axis.cross?.e,point=event.point;let crossLabel=axis.crossLabel,posx,posy,formatOption=options.format,formatFormat="",limit,offset=0,min=axis.min,max=axis.max;if(log){min=log.lin2log(axis.min);max=log.lin2log(axis.max)}const align=horiz?"center":opposite?axis.labelAlign==="right"?"right":"left":axis.labelAlign==="left"?"left":"center";if(!crossLabel){crossLabel=axis.crossLabel=chart.renderer.label("",0,void 0,options.shape||"callout").addClass("highcharts-crosshair-label highcharts-color-"+(point&&point.series?point.series.colorIndex:axis.series[0]&&this.series[0].colorIndex)).attr({align:options.align||align,padding:pick(options.padding,8),r:pick(options.borderRadius,3),zIndex:2}).add(axis.labelGroup);if(!chart.styledMode){crossLabel.attr({fill:options.backgroundColor||point&&point.series&&point.series.color||"#666666",stroke:options.borderColor||"","stroke-width":options.borderWidth||0}).css(extend({color:"#ffffff",fontWeight:"normal",fontSize:"0.7em",textAlign:"center"},options.style||{}))}}if(horiz){posx=snap?(point.plotX||0)+left:e.chartX;posy=top+(opposite?0:axis.height)}else{posx=left+axis.offset+(opposite?width:0);posy=snap?(point.plotY||0)+top:e.chartY}if(!formatOption&&!options.formatter){if(axis.dateTime){formatFormat="%b %d, %Y"}formatOption="{value"+(formatFormat?":"+formatFormat:"")+"}"}const value=snap?axis.isXAxis?point.x:point.y:axis.toValue(horiz?e.chartX:e.chartY);const isInside=point&&point.series?point.series.isPointInside(point):isNumber(value)&&value>min&&value<max;let text="";if(formatOption){text=format(formatOption,{value:value},chart)}else if(options.formatter&&isNumber(value)){text=options.formatter.call(axis,value)}crossLabel.attr({text:text,x:posx,y:posy,visibility:isInside?"inherit":"hidden"});const crossBox=crossLabel.getBBox();if(isNumber(crossLabel.x)&&!horiz&&!opposite){posx=crossLabel.x-crossBox.width/2}if(isNumber(crossLabel.y)){if(horiz){if(tickInside&&!opposite||!tickInside&&opposite){posy=crossLabel.y-crossBox.height}}else{posy=crossLabel.y-crossBox.height/2}}if(horiz){limit={left:left,right:left+axis.width}}else{limit={left:axis.labelAlign==="left"?left:0,right:axis.labelAlign==="right"?left+axis.width:chart.chartWidth}}const translateX=crossLabel.translateX||0;if(translateX<limit.left){offset=limit.left-translateX}if(translateX+crossBox.width>=limit.right){offset=-(translateX+crossBox.width-limit.right)}crossLabel.attr({x:Math.max(0,posx+offset),y:Math.max(0,posy),anchorX:horiz?posx:axis.opposite?0:chart.chartWidth,anchorY:horiz?axis.opposite?chart.chartHeight:0:posy+crossBox.height/2})}function onAxisAfterHideCrosshair(){const axis=this;if(axis.crossLabel){axis.crossLabel=axis.crossLabel.hide()}}function onAxisAutoLabelAlign(e){const axis=this,chart=axis.chart,options=axis.options,panes=chart._labelPanes=chart._labelPanes||{},labelOptions=options.labels;if(chart.options.isStock&&axis.coll==="yAxis"){const key=options.top+","+options.height;if(!panes[key]&&labelOptions.enabled){if(labelOptions.distance===15&&axis.side===1){labelOptions.distance=0}if(typeof labelOptions.align==="undefined"){labelOptions.align="right"}panes[key]=axis;e.align="right";e.preventDefault()}}}function onAxisDestroy(){const axis=this,chart=axis.chart,key=axis.options&&axis.options.top+","+axis.options.height;if(key&&chart._labelPanes&&chart._labelPanes[key]===axis){delete chart._labelPanes[key]}}function onAxisGetPlotLinePath(e){const axis=this,series=axis.isLinked&&!axis.series&&axis.linkedParent?axis.linkedParent.series:axis.series,chart=axis.chart,renderer=chart.renderer,axisLeft=axis.left,axisTop=axis.top,result=[],translatedValue=e.translatedValue,value=e.value,force=e.force,getAxis=coll=>{const otherColl=coll==="xAxis"?"yAxis":"xAxis",opt=axis.options[otherColl];if(isNumber(opt)){return[chart[otherColl][opt]]}if(isString(opt)){return[chart.get(opt)]}return series.map(s=>s[otherColl])};let x1,y1,x2,y2,axes=[],axes2,uniqueAxes,transVal;if(chart.options.isStock&&e.acrossPanes!==false&&axis.coll==="xAxis"||axis.coll==="yAxis"){e.preventDefault();axes=getAxis(axis.coll);axes2=axis.isXAxis?chart.yAxis:chart.xAxis;for(const A of axes2){if(!A.options.isInternal){const a=A.isXAxis?"yAxis":"xAxis",relatedAxis=defined(A.options[a])?chart[a][A.options[a]]:chart[a][0];if(axis===relatedAxis){axes.push(A)}}}uniqueAxes=axes.length?[]:[axis.isXAxis?chart.yAxis[0]:chart.xAxis[0]];for(const axis2 of axes){if(uniqueAxes.indexOf(axis2)===-1&&!find(uniqueAxes,unique=>unique.pos===axis2.pos&&unique.len===axis2.len)){uniqueAxes.push(axis2)}}transVal=pick(translatedValue,axis.translate(value||0,void 0,void 0,e.old));if(isNumber(transVal)){if(axis.horiz){for(const axis2 of uniqueAxes){let skip;y1=axis2.pos;y2=y1+axis2.len;x1=x2=Math.round(transVal+axis.transB);if(force!=="pass"&&(x1<axisLeft||x1>axisLeft+axis.width)){if(force){x1=x2=clamp(x1,axisLeft,axisLeft+axis.width)}else{skip=true}}if(!skip){result.push(["M",x1,y1],["L",x2,y2])}}}else{for(const axis2 of uniqueAxes){let skip;x1=axis2.pos;x2=x1+axis2.len;y1=y2=Math.round(axisTop+axis.height-transVal);if(force!=="pass"&&(y1<axisTop||y1>axisTop+axis.height)){if(force){y1=y2=clamp(y1,axisTop,axisTop+axis.height)}else{skip=true}}if(!skip){result.push(["M",x1,y1],["L",x2,y2])}}}}e.path=result.length>0?renderer.crispPolyLine(result,e.lineWidth||1):void 0}}function onSeriesSetOptions(e){const series=this;if(series.chart.options.isStock){let overrides;if(series.is("column")||series.is("columnrange")){overrides={borderWidth:0,shadow:false}}else if(!series.is("scatter")&&!series.is("sma")){overrides={marker:{enabled:false,radius:2}}}if(overrides){e.plotOptions[series.type]=merge(e.plotOptions[series.type],overrides)}}}function seriesForceCropping(){const series=this,chart=series.chart,options=series.options,dataGroupingOptions=options.dataGrouping,groupingEnabled=series.allowDG!==false&&dataGroupingOptions&&pick(dataGroupingOptions.enabled,chart.options.isStock);return groupingEnabled}function stockChart(a,b,c){return new StockChart(a,b,c)}StockChart.stockChart=stockChart;function svgRendererCrispPolyLine(points,width){for(let i=0;i<points.length;i=i+2){const start=points[i],end=points[i+1];if(defined(start[1])&&start[1]===end[1]){start[1]=end[1]=crisp(start[1],width)}if(defined(start[2])&&start[2]===end[2]){start[2]=end[2]=crisp(start[2],width)}}return points}})(StockChart||(StockChart={}));export default StockChart;