"use strict";import A from"../../Animation/AnimationUtilities.js";const{animObject}=A;import Color from"../../Color/Color.js";const{parse:color}=Color;import H from"../../Globals.js";const{charts,deg2rad}=H;import Math3D from"../../Math3D.js";const{perspective,shapeArea}=Math3D;import SVGElement3D from"./SVGElement3D.js";import U from"../../Utilities.js";const{defined,extend,merge,pick}=U;const cos=Math.cos,sin=Math.sin,PI=Math.PI,dFactor=4*(Math.sqrt(2)-1)/3/(PI/2);function curveTo(cx,cy,rx,ry,start,end,dx,dy){const arcAngle=end-start;let result=[];if(end>start&&end-start>Math.PI/2+1e-4){result=result.concat(curveTo(cx,cy,rx,ry,start,start+Math.PI/2,dx,dy));result=result.concat(curveTo(cx,cy,rx,ry,start+Math.PI/2,end,dx,dy));return result}if(end<start&&start-end>Math.PI/2+1e-4){result=result.concat(curveTo(cx,cy,rx,ry,start,start-Math.PI/2,dx,dy));result=result.concat(curveTo(cx,cy,rx,ry,start-Math.PI/2,end,dx,dy));return result}return[["C",cx+rx*Math.cos(start)-rx*dFactor*arcAngle*Math.sin(start)+dx,cy+ry*Math.sin(start)+ry*dFactor*arcAngle*Math.cos(start)+dy,cx+rx*Math.cos(end)+rx*dFactor*arcAngle*Math.sin(end)+dx,cy+ry*Math.sin(end)-ry*dFactor*arcAngle*Math.cos(end)+dy,cx+rx*Math.cos(end)+dx,cy+ry*Math.sin(end)+dy]]}var SVGRenderer3D;(function(SVGRenderer3D){function compose(SVGRendererClass){const rendererProto=SVGRendererClass.prototype;if(!rendererProto.element3d){extend(rendererProto,{Element3D:SVGElement3D,arc3d:arc3d,arc3dPath:arc3dPath,cuboid:cuboid,cuboidPath:cuboidPath,element3d:element3d,face3d:face3d,polyhedron:polyhedron,toLinePath:toLinePath,toLineSegments:toLineSegments})}}SVGRenderer3D.compose=compose;function toLinePath(points,closed){const result=[];for(const point of points){result.push(["L",point.x,point.y])}if(points.length){result[0][0]="M";if(closed){result.push(["Z"])}}return result}function toLineSegments(points){const result=[];let m=true;for(const point of points){result.push(m?["M",point.x,point.y]:["L",point.x,point.y]);m=!m}return result}function face3d(args){const renderer=this,elementProto=renderer.Element.prototype,ret=renderer.createElement("path");ret.vertexes=[];ret.insidePlotArea=false;ret.enabled=true;ret.attr=function(hash){if(typeof hash==="object"&&(defined(hash.enabled)||defined(hash.vertexes)||defined(hash.insidePlotArea))){this.enabled=pick(hash.enabled,this.enabled);this.vertexes=pick(hash.vertexes,this.vertexes);this.insidePlotArea=pick(hash.insidePlotArea,this.insidePlotArea);delete hash.enabled;delete hash.vertexes;delete hash.insidePlotArea;const chart=charts[renderer.chartIndex],vertexes2d=perspective(this.vertexes,chart,this.insidePlotArea),path=renderer.toLinePath(vertexes2d,true),area=shapeArea(vertexes2d);hash.d=path;hash.visibility=this.enabled&&area>0?"inherit":"hidden"}return elementProto.attr.apply(this,arguments)};ret.animate=function(params){if(typeof params==="object"&&(defined(params.enabled)||defined(params.vertexes)||defined(params.insidePlotArea))){this.enabled=pick(params.enabled,this.enabled);this.vertexes=pick(params.vertexes,this.vertexes);this.insidePlotArea=pick(params.insidePlotArea,this.insidePlotArea);delete params.enabled;delete params.vertexes;delete params.insidePlotArea;const chart=charts[renderer.chartIndex],vertexes2d=perspective(this.vertexes,chart,this.insidePlotArea),path=renderer.toLinePath(vertexes2d,true),area=shapeArea(vertexes2d),visibility=this.enabled&&area>0?"visible":"hidden";params.d=path;this.attr("visibility",visibility)}return elementProto.animate.apply(this,arguments)};return ret.attr(args)}function polyhedron(args){const renderer=this,elementProto=renderer.Element.prototype,result=renderer.g(),destroy=result.destroy;if(!this.styledMode){result.attr({"stroke-linejoin":"round"})}result.faces=[];result.destroy=function(){for(let i=0;i<result.faces.length;i++){result.faces[i].destroy()}return destroy.call(this)};result.attr=function(hash,val,complete,continueAnimation){if(typeof hash==="object"&&defined(hash.faces)){while(result.faces.length>hash.faces.length){result.faces.pop().destroy()}while(result.faces.length<hash.faces.length){result.faces.push(renderer.face3d().add(result))}for(let i=0;i<hash.faces.length;i++){if(renderer.styledMode){delete hash.faces[i].fill}result.faces[i].attr(hash.faces[i],null,complete,continueAnimation)}delete hash.faces}return elementProto.attr.apply(this,arguments)};result.animate=function(params,duration,complete){if(params&&params.faces){while(result.faces.length>params.faces.length){result.faces.pop().destroy()}while(result.faces.length<params.faces.length){result.faces.push(renderer.face3d().add(result))}for(let i=0;i<params.faces.length;i++){result.faces[i].animate(params.faces[i],duration,complete)}delete params.faces}return elementProto.animate.apply(this,arguments)};return result.attr(args)}function element3d(type,shapeArgs){const elem3d=new SVGElement3D.types[type](this,"g");elem3d.initArgs(shapeArgs);return elem3d}function cuboid(shapeArgs){return this.element3d("cuboid",shapeArgs)}function cuboidPath(shapeArgs){const x=shapeArgs.x||0,y=shapeArgs.y||0,z=shapeArgs.z||0,h=shapeArgs.height||0,w=shapeArgs.width||0,d=shapeArgs.depth||0,chart=charts[this.chartIndex],options3d=chart.options.chart.options3d,alpha=options3d.alpha,incrementX=1e6,incrementY=10,incrementZ=100,forcedSides=[];let shape,zIndex=0,pArr=[{x:x,y:y,z:z},{x:x+w,y:y,z:z},{x:x+w,y:y+h,z:z},{x:x,y:y+h,z:z},{x:x,y:y+h,z:z+d},{x:x+w,y:y+h,z:z+d},{x:x+w,y:y,z:z+d},{x:x,y:y,z:z+d}];pArr=perspective(pArr,chart,shapeArgs.insidePlotArea);const mapSidePath=i=>{if(h===0&&i>1&&i<6){return{x:pArr[i].x,y:pArr[i].y+10,z:pArr[i].z}}if(pArr[0].x===pArr[7].x&&i>=4){return{x:pArr[i].x+10,y:pArr[i].y,z:pArr[i].z}}if(d===0&&i<2||i>5){return{x:pArr[i].x,y:pArr[i].y,z:pArr[i].z+10}}return pArr[i]},mapPath=i=>pArr[i],pickShape=(verticesIndex1,verticesIndex2,side)=>{const face1=verticesIndex1.map(mapPath),face2=verticesIndex2.map(mapPath),dummyFace1=verticesIndex1.map(mapSidePath),dummyFace2=verticesIndex2.map(mapSidePath);let ret=[[],-1];if(shapeArea(face1)<0){ret=[face1,0]}else if(shapeArea(face2)<0){ret=[face2,1]}else if(side){forcedSides.push(side);if(shapeArea(dummyFace1)<0){ret=[face1,0]}else if(shapeArea(dummyFace2)<0){ret=[face2,1]}else{ret=[face1,0]}}return ret};const front=[3,2,1,0],back=[7,6,5,4];shape=pickShape(front,back,"front");const path1=shape[0],isFront=shape[1];const top=[1,6,7,0],bottom=[4,5,2,3];shape=pickShape(top,bottom,"top");const path2=shape[0],isTop=shape[1];const right=[1,2,5,6],left=[0,7,4,3];shape=pickShape(right,left,"side");const path3=shape[0],isRight=shape[1];if(isRight===1){zIndex+=incrementX*(chart.plotWidth-x)}else if(!isRight){zIndex+=incrementX*x}zIndex+=incrementY*(!isTop||(alpha>=0&&alpha<=180||alpha<360&&alpha>357.5)?chart.plotHeight-y:10+y);if(isFront===1){zIndex+=incrementZ*z}else if(!isFront){zIndex+=incrementZ*(1e3-z)}return{front:this.toLinePath(path1,true),top:this.toLinePath(path2,true),side:this.toLinePath(path3,true),zIndexes:{group:Math.round(zIndex)},forcedSides:forcedSides,isFront:isFront,isTop:isTop}}function arc3d(attribs){const renderer=this,wrapper=renderer.g(),elementProto=renderer.Element.prototype,customAttribs=["alpha","beta","x","y","r","innerR","start","end","depth"];function extractCustom(params){const ca={};params=merge(params);let key;for(key in params){if(customAttribs.indexOf(key)!==-1){ca[key]=params[key];delete params[key]}}return Object.keys(ca).length?[ca,params]:false}attribs=merge(attribs);attribs.alpha=(attribs.alpha||0)*deg2rad;attribs.beta=(attribs.beta||0)*deg2rad;wrapper.top=renderer.path();wrapper.side1=renderer.path();wrapper.side2=renderer.path();wrapper.inn=renderer.path();wrapper.out=renderer.path();wrapper.onAdd=function(){const parent=wrapper.parentGroup,className=wrapper.attr("class");wrapper.top.add(wrapper);for(const face of["out","inn","side1","side2"]){wrapper[face].attr({class:className+" highcharts-3d-side"}).add(parent)}};for(const fn of["addClass","removeClass"]){wrapper[fn]=function(){const args=arguments;for(const face of["top","out","inn","side1","side2"]){wrapper[face][fn].apply(wrapper[face],args)}}}wrapper.setPaths=function(attribs){const paths=wrapper.renderer.arc3dPath(attribs),zIndex=paths.zTop*100;wrapper.attribs=attribs;wrapper.top.attr({d:paths.top,zIndex:paths.zTop});wrapper.inn.attr({d:paths.inn,zIndex:paths.zInn});wrapper.out.attr({d:paths.out,zIndex:paths.zOut});wrapper.side1.attr({d:paths.side1,zIndex:paths.zSide1});wrapper.side2.attr({d:paths.side2,zIndex:paths.zSide2});wrapper.zIndex=zIndex;wrapper.attr({zIndex:zIndex});if(attribs.center){wrapper.top.setRadialReference(attribs.center);delete attribs.center}};wrapper.setPaths(attribs);wrapper.fillSetter=function(value){const darker=color(value).brighten(-.1).get();this.fill=value;this.side1.attr({fill:darker});this.side2.attr({fill:darker});this.inn.attr({fill:darker});this.out.attr({fill:darker});this.top.attr({fill:value});return this};for(const setter of["opacity","translateX","translateY","visibility"]){wrapper[setter+"Setter"]=function(value,key){wrapper[key]=value;for(const el of["out","inn","side1","side2","top"]){wrapper[el].attr(key,value)}}}wrapper.attr=function(params){if(typeof params==="object"){const paramArr=extractCustom(params);if(paramArr){const ca=paramArr[0];arguments[0]=paramArr[1];if(ca.alpha!==void 0){ca.alpha*=deg2rad}if(ca.beta!==void 0){ca.beta*=deg2rad}extend(wrapper.attribs,ca);if(wrapper.attribs){wrapper.setPaths(wrapper.attribs)}}}return elementProto.attr.apply(wrapper,arguments)};wrapper.animate=function(params,animation,complete){const from=this.attribs,randomProp="data-"+Math.random().toString(26).substring(2,9);delete params.center;delete params.z;const anim=animObject(pick(animation,this.renderer.globalAnimation));if(anim.duration){const paramArr=extractCustom(params);wrapper[randomProp]=0;params[randomProp]=1;wrapper[randomProp+"Setter"]=H.noop;if(paramArr){const to=paramArr[0],interpolate=(key,pos)=>from[key]+(pick(to[key],from[key])-from[key])*pos;anim.step=function(a,fx){if(fx.prop===randomProp){fx.elem.setPaths(merge(from,{x:interpolate("x",fx.pos),y:interpolate("y",fx.pos),r:interpolate("r",fx.pos),innerR:interpolate("innerR",fx.pos),start:interpolate("start",fx.pos),end:interpolate("end",fx.pos),depth:interpolate("depth",fx.pos)}))}}}animation=anim}return elementProto.animate.call(this,params,animation,complete)};wrapper.destroy=function(){this.top.destroy();this.out.destroy();this.inn.destroy();this.side1.destroy();this.side2.destroy();return elementProto.destroy.call(this)};wrapper.hide=function(){this.top.hide();this.out.hide();this.inn.hide();this.side1.hide();this.side2.hide()};wrapper.show=function(inherit){this.top.show(inherit);this.out.show(inherit);this.inn.show(inherit);this.side1.show(inherit);this.side2.show(inherit)};return wrapper}function arc3dPath(shapeArgs){const cx=shapeArgs.x||0,cy=shapeArgs.y||0,start=shapeArgs.start||0,end=(shapeArgs.end||0)-1e-5,r=shapeArgs.r||0,ir=shapeArgs.innerR||0,d=shapeArgs.depth||0,alpha=shapeArgs.alpha||0,beta=shapeArgs.beta||0;const cs=Math.cos(start),ss=Math.sin(start),ce=Math.cos(end),se=Math.sin(end),rx=r*Math.cos(beta),ry=r*Math.cos(alpha),irx=ir*Math.cos(beta),iry=ir*Math.cos(alpha),dx=d*Math.sin(beta),dy=d*Math.sin(alpha);let top=[["M",cx+rx*cs,cy+ry*ss]];top=top.concat(curveTo(cx,cy,rx,ry,start,end,0,0));top.push(["L",cx+irx*ce,cy+iry*se]);top=top.concat(curveTo(cx,cy,irx,iry,end,start,0,0));top.push(["Z"]);const b=beta>0?Math.PI/2:0,a=alpha>0?0:Math.PI/2;const start2=start>-b?start:end>-b?-b:start,end2=end<PI-a?end:start<PI-a?PI-a:end,midEnd=2*PI-a;let out=[["M",cx+rx*cos(start2),cy+ry*sin(start2)]];out=out.concat(curveTo(cx,cy,rx,ry,start2,end2,0,0));if(end>midEnd&&start<midEnd){out.push(["L",cx+rx*cos(end2)+dx,cy+ry*sin(end2)+dy]);out=out.concat(curveTo(cx,cy,rx,ry,end2,midEnd,dx,dy));out.push(["L",cx+rx*cos(midEnd),cy+ry*sin(midEnd)]);out=out.concat(curveTo(cx,cy,rx,ry,midEnd,end,0,0));out.push(["L",cx+rx*cos(end)+dx,cy+ry*sin(end)+dy]);out=out.concat(curveTo(cx,cy,rx,ry,end,midEnd,dx,dy));out.push(["L",cx+rx*cos(midEnd),cy+ry*sin(midEnd)]);out=out.concat(curveTo(cx,cy,rx,ry,midEnd,end2,0,0))}else if(end>PI-a&&start<PI-a){out.push(["L",cx+rx*Math.cos(end2)+dx,cy+ry*Math.sin(end2)+dy]);out=out.concat(curveTo(cx,cy,rx,ry,end2,end,dx,dy));out.push(["L",cx+rx*Math.cos(end),cy+ry*Math.sin(end)]);out=out.concat(curveTo(cx,cy,rx,ry,end,end2,0,0))}out.push(["L",cx+rx*Math.cos(end2)+dx,cy+ry*Math.sin(end2)+dy]);out=out.concat(curveTo(cx,cy,rx,ry,end2,start2,dx,dy));out.push(["Z"]);let inn=[["M",cx+irx*cs,cy+iry*ss]];inn=inn.concat(curveTo(cx,cy,irx,iry,start,end,0,0));inn.push(["L",cx+irx*Math.cos(end)+dx,cy+iry*Math.sin(end)+dy]);inn=inn.concat(curveTo(cx,cy,irx,iry,end,start,dx,dy));inn.push(["Z"]);const side1=[["M",cx+rx*cs,cy+ry*ss],["L",cx+rx*cs+dx,cy+ry*ss+dy],["L",cx+irx*cs+dx,cy+iry*ss+dy],["L",cx+irx*cs,cy+iry*ss],["Z"]];const side2=[["M",cx+rx*ce,cy+ry*se],["L",cx+rx*ce+dx,cy+ry*se+dy],["L",cx+irx*ce+dx,cy+iry*se+dy],["L",cx+irx*ce,cy+iry*se],["Z"]];const angleCorr=Math.atan2(dy,-dx);let angleEnd=Math.abs(end+angleCorr),angleStart=Math.abs(start+angleCorr),angleMid=Math.abs((start+end)/2+angleCorr);function toZeroPIRange(angle){angle=angle%(2*Math.PI);if(angle>Math.PI){angle=2*Math.PI-angle}return angle}angleEnd=toZeroPIRange(angleEnd);angleStart=toZeroPIRange(angleStart);angleMid=toZeroPIRange(angleMid);const incPrecision=1e5,a1=angleMid*incPrecision,a2=angleStart*incPrecision,a3=angleEnd*incPrecision;return{top:top,zTop:Math.PI*incPrecision+1,out:out,zOut:Math.max(a1,a2,a3),inn:inn,zInn:Math.max(a1,a2,a3),side1:side1,zSide1:a3*.99,side2:side2,zSide2:a2*.99}}})(SVGRenderer3D||(SVGRenderer3D={}));export default SVGRenderer3D;