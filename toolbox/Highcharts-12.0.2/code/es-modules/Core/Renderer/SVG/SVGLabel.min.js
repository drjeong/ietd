import SVGElement from"./SVGElement.js";import U from"../../Utilities.js";const{defined,extend,getAlignFactor,isNumber,merge,pick,removeEvent}=U;class SVGLabel extends SVGElement{constructor(renderer,str,x,y,shape,anchorX,anchorY,useHTML,baseline,className){super(renderer,"g");this.paddingLeftSetter=this.paddingSetter;this.paddingRightSetter=this.paddingSetter;this.doUpdate=false;this.textStr=str;this.x=x;this.y=y;this.anchorX=anchorX;this.anchorY=anchorY;this.baseline=baseline;this.className=className;this.addClass(className==="button"?"highcharts-no-tooltip":"highcharts-label");if(className){this.addClass("highcharts-"+className)}this.text=renderer.text(void 0,0,0,useHTML).attr({zIndex:1});let hasBGImage;if(typeof shape==="string"){hasBGImage=/^url\((.*?)\)$/.test(shape);if(hasBGImage||this.renderer.symbols[shape]){this.symbolKey=shape}}this.bBox=SVGLabel.emptyBBox;this.padding=3;this.baselineOffset=0;this.needsBox=renderer.styledMode||hasBGImage;this.deferredAttr={};this.alignFactor=0}alignSetter(value){const alignFactor=getAlignFactor(value);if(alignFactor!==this.alignFactor){this.alignFactor=alignFactor;if(this.bBox&&isNumber(this.xSetting)){this.attr({x:this.xSetting})}}}anchorXSetter(value,key){this.anchorX=value;this.boxAttr(key,Math.round(value)-this.getCrispAdjust()-this.xSetting)}anchorYSetter(value,key){this.anchorY=value;this.boxAttr(key,value-this.ySetting)}boxAttr(key,value){if(this.box){this.box.attr(key,value)}else{this.deferredAttr[key]=value}}css(styles){if(styles){const textStyles={};styles=merge(styles);SVGLabel.textProps.forEach(prop=>{if(typeof styles[prop]!=="undefined"){textStyles[prop]=styles[prop];delete styles[prop]}});this.text.css(textStyles);if("fontSize"in textStyles||"fontWeight"in textStyles){this.updateTextPadding()}else if("width"in textStyles||"textOverflow"in textStyles){this.updateBoxSize()}}return SVGElement.prototype.css.call(this,styles)}destroy(){removeEvent(this.element,"mouseenter");removeEvent(this.element,"mouseleave");if(this.text){this.text.destroy()}if(this.box){this.box=this.box.destroy()}SVGElement.prototype.destroy.call(this);return void 0}fillSetter(value,key){if(value){this.needsBox=true}this.fill=value;this.boxAttr(key,value)}getBBox(reload,rot){if(this.textStr&&this.bBox.width===0&&this.bBox.height===0){this.updateBoxSize()}const{padding,height=0,translateX=0,translateY=0,width=0}=this,paddingLeft=pick(this.paddingLeft,padding),rotation=rot??(this.rotation||0);let bBox={width:width,height:height,x:translateX+this.bBox.x-paddingLeft,y:translateY+this.bBox.y-padding+this.baselineOffset};if(rotation){bBox=this.getRotatedBox(bBox,rotation)}return bBox}getCrispAdjust(){return(this.renderer.styledMode&&this.box?this.box.strokeWidth():this["stroke-width"]?parseInt(this["stroke-width"],10):0)%2/2}heightSetter(value){this.heightSetting=value;this.doUpdate=true}afterSetters(){super.afterSetters();if(this.doUpdate){this.updateBoxSize();this.doUpdate=false}}onAdd(){this.text.add(this);this.attr({text:pick(this.textStr,""),x:this.x||0,y:this.y||0});if(this.box&&defined(this.anchorX)){this.attr({anchorX:this.anchorX,anchorY:this.anchorY})}}paddingSetter(value,key){if(!isNumber(value)){this[key]=void 0}else if(value!==this[key]){this[key]=value;this.updateTextPadding()}}rSetter(value,key){this.boxAttr(key,value)}strokeSetter(value,key){this.stroke=value;this.boxAttr(key,value)}"stroke-widthSetter"(value,key){if(value){this.needsBox=true}this["stroke-width"]=value;this.boxAttr(key,value)}"text-alignSetter"(value){this.textAlign=value}textSetter(text){if(typeof text!=="undefined"){this.text.attr({text:text})}this.updateTextPadding();this.reAlign()}updateBoxSize(){const text=this.text,attribs={},padding=this.padding,bBox=this.bBox=(!isNumber(this.widthSetting)||!isNumber(this.heightSetting)||this.textAlign)&&defined(text.textStr)?text.getBBox(void 0,0):SVGLabel.emptyBBox;let crispAdjust;this.width=this.getPaddedWidth();this.height=(this.heightSetting||bBox.height||0)+2*padding;const metrics=this.renderer.fontMetrics(text);this.baselineOffset=padding+Math.min((this.text.firstLineMetrics||metrics).b,bBox.height||Infinity);if(this.heightSetting){this.baselineOffset+=(this.heightSetting-metrics.h)/2}if(this.needsBox&&!text.textPath){if(!this.box){const box=this.box=this.symbolKey?this.renderer.symbol(this.symbolKey):this.renderer.rect();box.addClass((this.className==="button"?"":"highcharts-label-box")+(this.className?" highcharts-"+this.className+"-box":""));box.add(this)}crispAdjust=this.getCrispAdjust();attribs.x=crispAdjust;attribs.y=(this.baseline?-this.baselineOffset:0)+crispAdjust;attribs.width=Math.round(this.width);attribs.height=Math.round(this.height);this.box.attr(extend(attribs,this.deferredAttr));this.deferredAttr={}}}updateTextPadding(){const text=this.text;if(!text.textPath){this.updateBoxSize();const textY=this.baseline?0:this.baselineOffset,textX=(this.paddingLeft??this.padding)+(defined(this.widthSetting)&&this.bBox?getAlignFactor(this.textAlign)*(this.widthSetting-this.bBox.width):0);if(textX!==text.x||textY!==text.y){text.attr("x",textX);if(text.hasBoxWidthChanged){this.bBox=text.getBBox(true)}if(typeof textY!=="undefined"){text.attr("y",textY)}}text.x=textX;text.y=textY}}widthSetter(value){this.widthSetting=isNumber(value)?value:void 0;this.doUpdate=true}getPaddedWidth(){const padding=this.padding;const paddingLeft=pick(this.paddingLeft,padding);const paddingRight=pick(this.paddingRight,padding);return(this.widthSetting||this.bBox.width||0)+paddingLeft+paddingRight}xSetter(value){this.x=value;if(this.alignFactor){value-=this.alignFactor*this.getPaddedWidth();this["forceAnimate:x"]=true}this.xSetting=Math.round(value);this.attr("translateX",this.xSetting)}ySetter(value){this.ySetting=this.y=Math.round(value);this.attr("translateY",this.ySetting)}}SVGLabel.emptyBBox={width:0,height:0,x:0,y:0};SVGLabel.textProps=["color","direction","fontFamily","fontSize","fontStyle","fontWeight","lineClamp","lineHeight","textAlign","textDecoration","textOutline","textOverflow","whiteSpace","width"];export default SVGLabel;