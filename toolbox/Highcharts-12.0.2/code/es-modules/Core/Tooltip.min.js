"use strict";import A from"./Animation/AnimationUtilities.js";const{animObject}=A;import F from"./Templating.js";const{format}=F;import H from"./Globals.js";const{composed,dateFormats,doc,isSafari}=H;import R from"./Renderer/RendererUtilities.js";const{distribute}=R;import RendererRegistry from"./Renderer/RendererRegistry.js";import U from"./Utilities.js";const{addEvent,clamp,css,discardElement,extend,fireEvent,isArray,isNumber,isObject,isString,merge,pick,pushUnique,splat,syncTimeout}=U;class Tooltip{constructor(chart,options,pointer){this.allowShared=true;this.crosshairs=[];this.distance=0;this.isHidden=true;this.isSticky=false;this.options={};this.outside=false;this.chart=chart;this.init(chart,options);this.pointer=pointer}bodyFormatter(points){return points.map(point=>{const tooltipOptions=point.series.tooltipOptions,formatPrefix=point.formatPrefix||"point";return(tooltipOptions[formatPrefix+"Formatter"]||point.tooltipFormatter).call(point,tooltipOptions[formatPrefix+"Format"]||"")})}cleanSplit(force){this.chart.series.forEach(function(series){const tt=series&&series.tt;if(tt){if(!tt.isActive||force){series.tt=tt.destroy()}else{tt.isActive=false}}})}defaultFormatter(tooltip){const hoverPoints=this.points||splat(this);let s;s=[tooltip.headerFooterFormatter(hoverPoints[0])];s=s.concat(tooltip.bodyFormatter(hoverPoints));s.push(tooltip.headerFooterFormatter(hoverPoints[0],true));return s}destroy(){if(this.label){this.label=this.label.destroy()}if(this.split){this.cleanSplit(true);if(this.tt){this.tt=this.tt.destroy()}}if(this.renderer){this.renderer=this.renderer.destroy();discardElement(this.container)}U.clearTimeout(this.hideTimer)}getAnchor(points,mouseEvent){const{chart,pointer}=this,inverted=chart.inverted,plotTop=chart.plotTop,plotLeft=chart.plotLeft;let ret;points=splat(points);if(points[0].series&&points[0].series.yAxis&&!points[0].series.yAxis.options.reversedStacks){points=points.slice().reverse()}if(this.followPointer&&mouseEvent){if(typeof mouseEvent.chartX==="undefined"){mouseEvent=pointer.normalize(mouseEvent)}ret=[mouseEvent.chartX-plotLeft,mouseEvent.chartY-plotTop]}else if(points[0].tooltipPos){ret=points[0].tooltipPos}else{let chartX=0,chartY=0;points.forEach(function(point){const pos=point.pos(true);if(pos){chartX+=pos[0];chartY+=pos[1]}});chartX/=points.length;chartY/=points.length;if(this.shared&&points.length>1&&mouseEvent){if(inverted){chartX=mouseEvent.chartX}else{chartY=mouseEvent.chartY}}ret=[chartX-plotLeft,chartY-plotTop]}return ret.map(Math.round)}getClassName(point,isSplit,isHeader){const options=this.options,series=point.series,seriesOptions=series.options;return[options.className,"highcharts-label",isHeader&&"highcharts-tooltip-header",isSplit?"highcharts-tooltip-box":"highcharts-tooltip",!isHeader&&"highcharts-color-"+pick(point.colorIndex,series.colorIndex),seriesOptions&&seriesOptions.className].filter(isString).join(" ")}getLabel({anchorX,anchorY}={anchorX:0,anchorY:0}){const tooltip=this,styledMode=this.chart.styledMode,options=this.options,doSplit=this.split&&this.allowShared;let container=this.container,renderer=this.chart.renderer;if(this.label){const wasSplit=!this.label.hasClass("highcharts-label");if(!doSplit&&wasSplit||doSplit&&!wasSplit){this.destroy()}}if(!this.label){if(this.outside){const chart=this.chart,chartStyle=chart.options.chart.style,Renderer=RendererRegistry.getRendererType();this.container=container=H.doc.createElement("div");container.className="highcharts-tooltip-container "+(chart.renderTo.className.match(/(highcharts[a-zA-Z0-9-]+)\s?/gm)||[].join(" "));css(container,{position:"absolute",top:"1px",pointerEvents:"none",zIndex:Math.max(this.options.style.zIndex||0,(chartStyle&&chartStyle.zIndex||0)+3)});this.renderer=renderer=new Renderer(container,0,0,chartStyle,void 0,void 0,renderer.styledMode)}if(doSplit){this.label=renderer.g("tooltip")}else{this.label=renderer.label("",anchorX,anchorY,options.shape,void 0,void 0,options.useHTML,void 0,"tooltip").attr({padding:options.padding,r:options.borderRadius});if(!styledMode){this.label.attr({fill:options.backgroundColor,"stroke-width":options.borderWidth||0}).css(options.style).css({pointerEvents:options.style.pointerEvents||(this.shouldStickOnContact()?"auto":"none")})}}if(tooltip.outside){const label=this.label;[label.xSetter,label.ySetter].forEach((setter,i)=>{label[i?"ySetter":"xSetter"]=value=>{setter.call(label,tooltip.distance);label[i?"y":"x"]=value;if(container){container.style[i?"top":"left"]=`${value}px`}}})}this.label.attr({zIndex:8}).shadow(options.shadow).add()}if(container&&!container.parentElement){H.doc.body.appendChild(container)}return this.label}getPlayingField(){const{body,documentElement}=doc,{chart,distance,outside}=this;return{width:outside?Math.max(body.scrollWidth,documentElement.scrollWidth,body.offsetWidth,documentElement.offsetWidth,documentElement.clientWidth)-2*distance-2:chart.chartWidth,height:outside?Math.max(body.scrollHeight,documentElement.scrollHeight,body.offsetHeight,documentElement.offsetHeight,documentElement.clientHeight):chart.chartHeight}}getPosition(boxWidth,boxHeight,point){const{distance,chart,outside,pointer}=this,{inverted,plotLeft,plotTop,polar}=chart,{plotX=0,plotY=0}=point,ret={},h=inverted&&point.h||0,{height:outerHeight,width:outerWidth}=this.getPlayingField(),chartPosition=pointer.getChartPosition(),scaleX=val=>val*chartPosition.scaleX,scaleY=val=>val*chartPosition.scaleY,buildDimensionArray=dim=>{const isX=dim==="x";return[dim,isX?outerWidth:outerHeight,isX?boxWidth:boxHeight].concat(outside?[isX?scaleX(boxWidth):scaleY(boxHeight),isX?chartPosition.left-distance+scaleX(plotX+plotLeft):chartPosition.top-distance+scaleY(plotY+plotTop),0,isX?outerWidth:outerHeight]:[isX?boxWidth:boxHeight,isX?plotX+plotLeft:plotY+plotTop,isX?plotLeft:plotTop,isX?plotLeft+chart.plotWidth:plotTop+chart.plotHeight])};let first=buildDimensionArray("y"),second=buildDimensionArray("x"),swapped;let flipped=!!point.negative;if(!polar&&chart.hoverSeries?.yAxis?.reversed){flipped=!flipped}const preferFarSide=!this.followPointer&&pick(point.ttBelow,polar?false:!inverted===flipped),firstDimension=function(dim,outerSize,innerSize,scaledInnerSize,point,min,max){const scaledDist=outside?dim==="y"?scaleY(distance):scaleX(distance):distance,scaleDiff=(innerSize-scaledInnerSize)/2,roomLeft=scaledInnerSize<point-distance,roomRight=point+distance+scaledInnerSize<outerSize,alignedLeft=point-scaledDist-innerSize+scaleDiff,alignedRight=point+scaledDist-scaleDiff;if(preferFarSide&&roomRight){ret[dim]=alignedRight}else if(!preferFarSide&&roomLeft){ret[dim]=alignedLeft}else if(roomLeft){ret[dim]=Math.min(max-scaledInnerSize,alignedLeft-h<0?alignedLeft:alignedLeft-h)}else if(roomRight){ret[dim]=Math.max(min,alignedRight+h+innerSize>outerSize?alignedRight:alignedRight+h)}else{return false}},secondDimension=function(dim,outerSize,innerSize,scaledInnerSize,point){if(point<distance||point>outerSize-distance){return false}if(point<innerSize/2){ret[dim]=1}else if(point>outerSize-scaledInnerSize/2){ret[dim]=outerSize-scaledInnerSize-2}else{ret[dim]=point-innerSize/2}},swap=function(count){[first,second]=[second,first];swapped=count},run=()=>{if(firstDimension.apply(0,first)!==false){if(secondDimension.apply(0,second)===false&&!swapped){swap(true);run()}}else if(!swapped){swap(true);run()}else{ret.x=ret.y=0}};if(inverted&&!polar||this.len>1){swap()}run();return ret}hide(delay){const tooltip=this;U.clearTimeout(this.hideTimer);delay=pick(delay,this.options.hideDelay);if(!this.isHidden){this.hideTimer=syncTimeout(function(){const label=tooltip.getLabel();tooltip.getLabel().animate({opacity:0},{duration:delay?150:delay,complete:()=>{label.hide();if(tooltip.container){tooltip.container.remove()}}});tooltip.isHidden=true},delay)}}init(chart,options){this.chart=chart;this.options=options;this.crosshairs=[];this.isHidden=true;this.split=options.split&&!chart.inverted&&!chart.polar;this.shared=options.shared||this.split;this.outside=pick(options.outside,Boolean(chart.scrollablePixelsX||chart.scrollablePixelsY))}shouldStickOnContact(pointerEvent){return!!(!this.followPointer&&this.options.stickOnContact&&(!pointerEvent||this.pointer.inClass(pointerEvent.target,"highcharts-tooltip")))}move(x,y,anchorX,anchorY){const tooltip=this,animation=animObject(!tooltip.isHidden&&tooltip.options.animation),skipAnchor=tooltip.followPointer||(tooltip.len||0)>1,attr={x:x,y:y};if(!skipAnchor){attr.anchorX=anchorX;attr.anchorY=anchorY}animation.step=()=>tooltip.drawTracker();tooltip.getLabel().animate(attr,animation)}refresh(pointOrPoints,mouseEvent){const tooltip=this,{chart,options,pointer,shared}=this,points=splat(pointOrPoints),point=points[0],formatString=options.format,formatter=options.formatter||tooltip.defaultFormatter,styledMode=chart.styledMode;let wasShared=tooltip.allowShared;if(!options.enabled||!point.series){return}U.clearTimeout(this.hideTimer);tooltip.allowShared=!(!isArray(pointOrPoints)&&pointOrPoints.series&&pointOrPoints.series.noSharedTooltip);wasShared=wasShared&&!tooltip.allowShared;tooltip.followPointer=!tooltip.split&&point.series.tooltipOptions.followPointer;const anchor=tooltip.getAnchor(pointOrPoints,mouseEvent),x=anchor[0],y=anchor[1];if(shared&&tooltip.allowShared){pointer.applyInactiveState(points);points.forEach(item=>item.setState("hover"));point.points=points}this.len=points.length;const text=isString(formatString)?format(formatString,point,chart):formatter.call(point,tooltip);point.points=void 0;const currentSeries=point.series;this.distance=pick(currentSeries.tooltipOptions.distance,16);if(text===false){this.hide()}else{if(tooltip.split&&tooltip.allowShared){this.renderSplit(text,points)}else{let checkX=x;let checkY=y;if(mouseEvent&&pointer.isDirectTouch){checkX=mouseEvent.chartX-chart.plotLeft;checkY=mouseEvent.chartY-chart.plotTop}if(chart.polar||currentSeries.options.clip===false||points.some(p=>pointer.isDirectTouch||p.series.shouldShowTooltip(checkX,checkY))){const label=tooltip.getLabel(wasShared&&tooltip.tt||{});if(!options.style.width||styledMode){label.css({width:(this.outside?this.getPlayingField():chart.spacingBox).width+"px"})}label.attr({class:tooltip.getClassName(point),text:text&&text.join?text.join(""):text});if(this.outside){label.attr({x:clamp(label.x||0,0,this.getPlayingField().width-(label.width||0)-1)})}if(!styledMode){label.attr({stroke:options.borderColor||point.color||currentSeries.color||"#666666"})}tooltip.updatePosition({plotX:x,plotY:y,negative:point.negative,ttBelow:point.ttBelow,h:anchor[2]||0})}else{tooltip.hide();return}}if(tooltip.isHidden&&tooltip.label){tooltip.label.attr({opacity:1}).show()}tooltip.isHidden=false}fireEvent(this,"refresh")}renderSplit(labels,points){const tooltip=this;const{chart,chart:{chartWidth,chartHeight,plotHeight,plotLeft,plotTop,scrollablePixelsY=0,scrollablePixelsX,styledMode},distance,options,options:{positioner},pointer}=tooltip;const{scrollLeft=0,scrollTop=0}=chart.scrollablePlotArea?.scrollingContainer||{};const bounds=tooltip.outside&&typeof scrollablePixelsX!=="number"?doc.documentElement.getBoundingClientRect():{left:scrollLeft,right:scrollLeft+chartWidth,top:scrollTop,bottom:scrollTop+chartHeight};const tooltipLabel=tooltip.getLabel();const ren=this.renderer||chart.renderer;const headerTop=Boolean(chart.xAxis[0]&&chart.xAxis[0].opposite);const{left:chartLeft,top:chartTop}=pointer.getChartPosition();let distributionBoxTop=plotTop+scrollTop;let headerHeight=0;let adjustedPlotHeight=plotHeight-scrollablePixelsY;function getAnchor(point){const{isHeader,plotX=0,plotY=0,series}=point;let anchorX;let anchorY;if(isHeader){anchorX=Math.max(plotLeft+plotX,plotLeft);anchorY=plotTop+plotHeight/2}else{const{xAxis,yAxis}=series;anchorX=xAxis.pos+clamp(plotX,-distance,xAxis.len+distance);if(series.shouldShowTooltip(0,yAxis.pos-plotTop+plotY,{ignoreX:true})){anchorY=yAxis.pos+plotY}}anchorX=clamp(anchorX,bounds.left-distance,bounds.right+distance);return{anchorX:anchorX,anchorY:anchorY}}function defaultPositioner(anchorX,anchorY,isHeader,boxWidth,alignedLeft=true){let y;let x;if(isHeader){y=headerTop?0:adjustedPlotHeight;x=clamp(anchorX-boxWidth/2,bounds.left,bounds.right-boxWidth-(tooltip.outside?chartLeft:0))}else{y=anchorY-distributionBoxTop;x=alignedLeft?anchorX-boxWidth-distance:anchorX+distance;x=clamp(x,alignedLeft?x:bounds.left,bounds.right)}return{x:x,y:y}}function updatePartialTooltip(partialTooltip,point,str){let tt=partialTooltip;const{isHeader,series}=point;if(!tt){const attribs={padding:options.padding,r:options.borderRadius};if(!styledMode){attribs.fill=options.backgroundColor;attribs["stroke-width"]=options.borderWidth??1}tt=ren.label("",0,0,options[isHeader?"headerShape":"shape"],void 0,void 0,options.useHTML).addClass(tooltip.getClassName(point,true,isHeader)).attr(attribs).add(tooltipLabel)}tt.isActive=true;tt.attr({text:str});if(!styledMode){tt.css(options.style).attr({stroke:options.borderColor||point.color||series.color||"#333333"})}return tt}if(isString(labels)){labels=[false,labels]}let boxes=labels.slice(0,points.length+1).reduce(function(boxes,str,i){if(str!==false&&str!==""){const point=points[i-1]||{isHeader:true,plotX:points[0].plotX,plotY:plotHeight,series:{}};const isHeader=point.isHeader;const owner=isHeader?tooltip:point.series;const tt=owner.tt=updatePartialTooltip(owner.tt,point,str.toString());const bBox=tt.getBBox();const boxWidth=bBox.width+tt.strokeWidth();if(isHeader){headerHeight=bBox.height;adjustedPlotHeight+=headerHeight;if(headerTop){distributionBoxTop-=headerHeight}}const{anchorX,anchorY}=getAnchor(point);if(typeof anchorY==="number"){const size=bBox.height+1;const boxPosition=positioner?positioner.call(tooltip,boxWidth,size,point):defaultPositioner(anchorX,anchorY,isHeader,boxWidth);boxes.push({align:positioner?0:void 0,anchorX:anchorX,anchorY:anchorY,boxWidth:boxWidth,point:point,rank:pick(boxPosition.rank,isHeader?1:0),size:size,target:boxPosition.y,tt:tt,x:boxPosition.x})}else{tt.isActive=false}}return boxes},[]);if(!positioner&&boxes.some(box=>{const{outside}=tooltip;const boxStart=(outside?chartLeft:0)+box.anchorX;if(boxStart<bounds.left&&boxStart+box.boxWidth<bounds.right){return true}return boxStart<chartLeft-bounds.left+box.boxWidth&&bounds.right-boxStart>boxStart})){boxes=boxes.map(box=>{const{x,y}=defaultPositioner(box.anchorX,box.anchorY,box.point.isHeader,box.boxWidth,false);return extend(box,{target:y,x:x})})}tooltip.cleanSplit();distribute(boxes,adjustedPlotHeight);const boxExtremes={left:chartLeft,right:chartLeft};boxes.forEach(function(box){const{x,boxWidth,isHeader}=box;if(!isHeader){if(tooltip.outside&&chartLeft+x<boxExtremes.left){boxExtremes.left=chartLeft+x}if(!isHeader&&tooltip.outside&&boxExtremes.left+boxWidth>boxExtremes.right){boxExtremes.right=chartLeft+x}}});boxes.forEach(function(box){const{x,anchorX,anchorY,pos,point:{isHeader}}=box;const attributes={visibility:typeof pos==="undefined"?"hidden":"inherit",x:x,y:(pos||0)+distributionBoxTop,anchorX:anchorX,anchorY:anchorY};if(tooltip.outside&&x<anchorX){const offset=chartLeft-boxExtremes.left;if(offset>0){if(!isHeader){attributes.x=x+offset;attributes.anchorX=anchorX+offset}if(isHeader){attributes.x=(boxExtremes.right-boxExtremes.left)/2;attributes.anchorX=anchorX+offset}}}box.tt.attr(attributes)});const{container,outside,renderer}=tooltip;if(outside&&container&&renderer){const{width,height,x,y}=tooltipLabel.getBBox();renderer.setSize(width+x,height+y,false);container.style.left=boxExtremes.left+"px";container.style.top=chartTop+"px"}if(isSafari){tooltipLabel.attr({opacity:tooltipLabel.opacity===1?.999:1})}}drawTracker(){const tooltip=this;if(!this.shouldStickOnContact()){if(tooltip.tracker){tooltip.tracker=tooltip.tracker.destroy()}return}const chart=tooltip.chart;const label=tooltip.label;const points=tooltip.shared?chart.hoverPoints:chart.hoverPoint;if(!label||!points){return}const box={x:0,y:0,width:0,height:0};const anchorPos=this.getAnchor(points);const labelBBox=label.getBBox();anchorPos[0]+=chart.plotLeft-(label.translateX||0);anchorPos[1]+=chart.plotTop-(label.translateY||0);box.x=Math.min(0,anchorPos[0]);box.y=Math.min(0,anchorPos[1]);box.width=anchorPos[0]<0?Math.max(Math.abs(anchorPos[0]),labelBBox.width-anchorPos[0]):Math.max(Math.abs(anchorPos[0]),labelBBox.width);box.height=anchorPos[1]<0?Math.max(Math.abs(anchorPos[1]),labelBBox.height-Math.abs(anchorPos[1])):Math.max(Math.abs(anchorPos[1]),labelBBox.height);if(tooltip.tracker){tooltip.tracker.attr(box)}else{tooltip.tracker=label.renderer.rect(box).addClass("highcharts-tracker").add(label);if(!chart.styledMode){tooltip.tracker.attr({fill:"rgba(0,0,0,0)"})}}}styledModeFormat(formatString){return formatString.replace('style="font-size: 0.8em"','class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g,'class="highcharts-color-{$1.colorIndex} '+"{series.options.className} "+'{point.options.className}"')}headerFooterFormatter(point,isFooter){const series=point.series,tooltipOptions=series.tooltipOptions,xAxis=series.xAxis,dateTime=xAxis&&xAxis.dateTime,e={isFooter:isFooter,point:point};let xDateFormat=tooltipOptions.xDateFormat||"",formatString=tooltipOptions[isFooter?"footerFormat":"headerFormat"];fireEvent(this,"headerFormatter",e,function(e){if(dateTime&&!xDateFormat&&isNumber(point.key)){xDateFormat=dateTime.getXDateFormat(point.key,tooltipOptions.dateTimeLabelFormats)}if(dateTime&&xDateFormat){if(isObject(xDateFormat)){const format=xDateFormat;dateFormats[0]=timestamp=>series.chart.time.dateFormat(format,timestamp);xDateFormat="%0"}(point.tooltipDateKeys||["key"]).forEach(key=>{formatString=formatString.replace(new RegExp("point\\."+key+"([ \\)}])",""),`(point.${key}:${xDateFormat})$1`)})}if(series.chart.styledMode){formatString=this.styledModeFormat(formatString)}e.text=format(formatString,point,this.chart)});return e.text||""}update(options){this.destroy();this.init(this.chart,merge(true,this.options,options))}updatePosition(point){const{chart,container,distance,options,pointer,renderer}=this,{height=0,width=0}=this.getLabel(),{left,top,scaleX,scaleY}=pointer.getChartPosition(),pos=(options.positioner||this.getPosition).call(this,width,height,point),doc=H.doc;let anchorX=(point.plotX||0)+chart.plotLeft,anchorY=(point.plotY||0)+chart.plotTop,pad;if(renderer&&container){if(options.positioner){pos.x+=left-distance;pos.y+=top-distance}pad=(options.borderWidth||0)+2*distance+2;renderer.setSize(clamp(width+pad,0,doc.documentElement.clientWidth)-1,height+pad,false);if(scaleX!==1||scaleY!==1){css(container,{transform:`scale(${scaleX}, ${scaleY})`});anchorX*=scaleX;anchorY*=scaleY}anchorX+=left-pos.x;anchorY+=top-pos.y}this.move(Math.round(pos.x),Math.round(pos.y||0),anchorX,anchorY)}}(function(Tooltip){function compose(PointerClass){if(pushUnique(composed,"Core.Tooltip")){addEvent(PointerClass,"afterInit",function(){const chart=this.chart;if(chart.options.tooltip){chart.tooltip=new Tooltip(chart,chart.options.tooltip,this)}})}}Tooltip.compose=compose})(Tooltip||(Tooltip={}));export default Tooltip;"";