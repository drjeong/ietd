"use strict";import Color from"./Color/Color.js";const{parse:color}=Color;import H from"./Globals.js";const{charts,composed,isTouchDevice}=H;import U from"./Utilities.js";const{addEvent,attr,css,extend,find,fireEvent,isNumber,isObject,objectEach,offset,pick,pushUnique,splat}=U;class Pointer{applyInactiveState(points){let activeSeries=[],series;(points||[]).forEach(function(item){series=item.series;activeSeries.push(series);if(series.linkedParent){activeSeries.push(series.linkedParent)}if(series.linkedSeries){activeSeries=activeSeries.concat(series.linkedSeries)}if(series.navigatorSeries){activeSeries.push(series.navigatorSeries)}});this.chart.series.forEach(function(inactiveSeries){if(activeSeries.indexOf(inactiveSeries)===-1){inactiveSeries.setState("inactive",true)}else if(inactiveSeries.options.inactiveOtherPoints){inactiveSeries.setAllPointsToState("inactive")}})}destroy(){const pointer=this;this.eventsToUnbind.forEach(unbind=>unbind());this.eventsToUnbind=[];if(!H.chartCount){Pointer.unbindDocumentMouseUp.forEach(el=>el.unbind());Pointer.unbindDocumentMouseUp.length=0;if(Pointer.unbindDocumentTouchEnd){Pointer.unbindDocumentTouchEnd=Pointer.unbindDocumentTouchEnd()}}clearInterval(pointer.tooltipTimeout);objectEach(pointer,function(_val,prop){pointer[prop]=void 0})}getSelectionMarkerAttrs(chartX,chartY){const e={args:{chartX:chartX,chartY:chartY},attrs:{},shapeType:"rect"};fireEvent(this,"getSelectionMarkerAttrs",e,e=>{const{chart,zoomHor,zoomVert}=this,{mouseDownX=0,mouseDownY=0}=chart,attrs=e.attrs;let size;attrs.x=chart.plotLeft;attrs.y=chart.plotTop;attrs.width=zoomHor?1:chart.plotWidth;attrs.height=zoomVert?1:chart.plotHeight;if(zoomHor){size=chartX-mouseDownX;attrs.width=Math.max(1,Math.abs(size));attrs.x=(size>0?0:size)+mouseDownX}if(zoomVert){size=chartY-mouseDownY;attrs.height=Math.max(1,Math.abs(size));attrs.y=(size>0?0:size)+mouseDownY}});return e}drag(e){const{chart}=this,{mouseDownX=0,mouseDownY=0}=chart,{panning,panKey,selectionMarkerFill}=chart.options.chart,plotLeft=chart.plotLeft,plotTop=chart.plotTop,plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,panningEnabled=isObject(panning)?panning.enabled:panning,panKeyPressed=panKey&&e[`${panKey}Key`];let chartX=e.chartX,chartY=e.chartY,clickedInside,selectionMarker=this.selectionMarker;if(selectionMarker&&selectionMarker.touch){return}if(chartX<plotLeft){chartX=plotLeft}else if(chartX>plotLeft+plotWidth){chartX=plotLeft+plotWidth}if(chartY<plotTop){chartY=plotTop}else if(chartY>plotTop+plotHeight){chartY=plotTop+plotHeight}this.hasDragged=Math.sqrt(Math.pow(mouseDownX-chartX,2)+Math.pow(mouseDownY-chartY,2));if(this.hasDragged>10){clickedInside=chart.isInsidePlot(mouseDownX-plotLeft,mouseDownY-plotTop,{visiblePlotOnly:true});const{shapeType,attrs}=this.getSelectionMarkerAttrs(chartX,chartY);if((chart.hasCartesianSeries||chart.mapView)&&this.hasZoom&&clickedInside&&!panKeyPressed){if(!selectionMarker){this.selectionMarker=selectionMarker=chart.renderer[shapeType]();selectionMarker.attr({class:"highcharts-selection-marker",zIndex:7}).add();if(!chart.styledMode){selectionMarker.attr({fill:selectionMarkerFill||color("#334eff").setOpacity(.25).get()})}}}if(selectionMarker){selectionMarker.attr(attrs)}if(clickedInside&&!selectionMarker&&panningEnabled){chart.pan(e,panning)}}}dragStart(e){const chart=this.chart;chart.mouseIsDown=e.type;chart.cancelClick=false;chart.mouseDownX=e.chartX;chart.mouseDownY=e.chartY}getSelectionBox(marker){const e={args:{marker:marker},result:marker.getBBox()};fireEvent(this,"getSelectionBox",e);return e.result}drop(e){const{chart,selectionMarker}=this;let redraw;for(const axis of chart.axes){if(axis.isPanning){axis.isPanning=false;if(axis.options.startOnTick||axis.options.endOnTick||axis.series.some(s=>s.boosted)){axis.forceRedraw=true;axis.setExtremes(axis.userMin,axis.userMax,false);redraw=true}}}if(redraw){chart.redraw()}if(selectionMarker&&e){if(this.hasDragged){const from=this.getSelectionBox(selectionMarker);chart.transform({axes:chart.axes.filter(a=>a.zoomEnabled&&(a.coll==="xAxis"&&this.zoomX||a.coll==="yAxis"&&this.zoomY)),selection:{originalEvent:e,xAxis:[],yAxis:[],...from},from:from})}if(isNumber(chart.index)){this.selectionMarker=selectionMarker.destroy()}}if(chart&&isNumber(chart.index)){css(chart.container,{cursor:chart._cursor});chart.cancelClick=this.hasDragged>10;chart.mouseIsDown=false;this.hasDragged=0;this.pinchDown=[]}}findNearestKDPoint(series,shared,e){let closest;function sort(p1,p2){const isCloserX=p1.distX-p2.distX,isCloser=p1.dist-p2.dist,isAbove=p2.series.group?.zIndex-p1.series.group?.zIndex;let result;if(isCloserX!==0&&shared){result=isCloserX}else if(isCloser!==0){result=isCloser}else if(isAbove!==0){result=isAbove}else{result=p1.series.index>p2.series.index?-1:1}return result}series.forEach(function(s){const noSharedTooltip=s.noSharedTooltip&&shared,compareX=!noSharedTooltip&&s.options.findNearestPointBy.indexOf("y")<0,point=s.searchPoint(e,compareX);if(isObject(point,true)&&point.series&&(!isObject(closest,true)||sort(closest,point)>0)){closest=point}});return closest}getChartCoordinatesFromPoint(point,inverted){const{xAxis,yAxis}=point.series,shapeArgs=point.shapeArgs;if(xAxis&&yAxis){let x=point.clientX??point.plotX??0,y=point.plotY||0;if(point.isNode&&shapeArgs&&isNumber(shapeArgs.x)&&isNumber(shapeArgs.y)){x=shapeArgs.x;y=shapeArgs.y}return inverted?{chartX:yAxis.len+yAxis.pos-y,chartY:xAxis.len+xAxis.pos-x}:{chartX:x+xAxis.pos,chartY:y+yAxis.pos}}if(shapeArgs&&shapeArgs.x&&shapeArgs.y){return{chartX:shapeArgs.x,chartY:shapeArgs.y}}}getChartPosition(){if(this.chartPosition){return this.chartPosition}const{container}=this.chart;const pos=offset(container);this.chartPosition={left:pos.left,top:pos.top,scaleX:1,scaleY:1};const{offsetHeight,offsetWidth}=container;if(offsetWidth>2&&offsetHeight>2){this.chartPosition.scaleX=pos.width/offsetWidth;this.chartPosition.scaleY=pos.height/offsetHeight}return this.chartPosition}getCoordinates(e){const coordinates={xAxis:[],yAxis:[]};for(const axis of this.chart.axes){coordinates[axis.isXAxis?"xAxis":"yAxis"].push({axis:axis,value:axis.toValue(e[axis.horiz?"chartX":"chartY"])})}return coordinates}getHoverData(existingHoverPoint,existingHoverSeries,series,isDirectTouch,shared,e){const hoverPoints=[],useExisting=!!(isDirectTouch&&existingHoverPoint),filter=function(s){return s.visible&&!(!shared&&s.directTouch)&&pick(s.options.enableMouseTracking,true)};let hoverSeries=existingHoverSeries,searchSeries,eventArgs={chartX:e?e.chartX:void 0,chartY:e?e.chartY:void 0,shared:shared};fireEvent(this,"beforeGetHoverData",eventArgs);const notSticky=hoverSeries&&!hoverSeries.stickyTracking;searchSeries=notSticky?[hoverSeries]:series.filter(s=>s.stickyTracking&&(eventArgs.filter||filter)(s));const hoverPoint=useExisting||!e?existingHoverPoint:this.findNearestKDPoint(searchSeries,shared,e);hoverSeries=hoverPoint&&hoverPoint.series;if(hoverPoint){if(shared&&!hoverSeries.noSharedTooltip){searchSeries=series.filter(function(s){return eventArgs.filter?eventArgs.filter(s):filter(s)&&!s.noSharedTooltip});searchSeries.forEach(function(s){let point=find(s.points,function(p){return p.x===hoverPoint.x&&!p.isNull});if(isObject(point)){if(s.boosted&&s.boost){point=s.boost.getPoint(point)}hoverPoints.push(point)}})}else{hoverPoints.push(hoverPoint)}}eventArgs={hoverPoint:hoverPoint};fireEvent(this,"afterGetHoverData",eventArgs);return{hoverPoint:eventArgs.hoverPoint,hoverSeries:hoverSeries,hoverPoints:hoverPoints}}getPointFromEvent(e){let target=e.target,point;while(target&&!point){point=target.point;target=target.parentNode}return point}onTrackerMouseOut(e){const chart=this.chart;const relatedTarget=e.relatedTarget;const series=chart.hoverSeries;this.isDirectTouch=false;if(series&&relatedTarget&&!series.stickyTracking&&!this.inClass(relatedTarget,"highcharts-tooltip")&&(!this.inClass(relatedTarget,"highcharts-series-"+series.index)||!this.inClass(relatedTarget,"highcharts-tracker"))){series.onMouseOut()}}inClass(element,className){let elem=element,elemClassName;while(elem){elemClassName=attr(elem,"class");if(elemClassName){if(elemClassName.indexOf(className)!==-1){return true}if(elemClassName.indexOf("highcharts-container")!==-1){return false}}elem=elem.parentElement}}constructor(chart,options){this.hasDragged=0;this.pointerCaptureEventsToUnbind=[];this.eventsToUnbind=[];this.options=options;this.chart=chart;this.runChartClick=Boolean(options.chart.events?.click);this.pinchDown=[];this.setDOMEvents();fireEvent(this,"afterInit")}normalize(e,chartPosition){const touches=e.touches;const ePos=touches?touches.length?touches.item(0):pick(touches.changedTouches,e.changedTouches)[0]:e;if(!chartPosition){chartPosition=this.getChartPosition()}let chartX=ePos.pageX-chartPosition.left,chartY=ePos.pageY-chartPosition.top;chartX/=chartPosition.scaleX;chartY/=chartPosition.scaleY;return extend(e,{chartX:Math.round(chartX),chartY:Math.round(chartY)})}onContainerClick(e){const chart=this.chart;const hoverPoint=chart.hoverPoint;const pEvt=this.normalize(e);const plotLeft=chart.plotLeft;const plotTop=chart.plotTop;if(!chart.cancelClick){if(hoverPoint&&this.inClass(pEvt.target,"highcharts-tracker")){fireEvent(hoverPoint.series,"click",extend(pEvt,{point:hoverPoint}));if(chart.hoverPoint){hoverPoint.firePointEvent("click",pEvt)}}else{extend(pEvt,this.getCoordinates(pEvt));if(chart.isInsidePlot(pEvt.chartX-plotLeft,pEvt.chartY-plotTop,{visiblePlotOnly:true})){fireEvent(chart,"click",pEvt)}}}}onContainerMouseDown(e){const isPrimaryButton=((e.buttons||e.button)&1)===1;e=this.normalize(e);if(H.isFirefox&&e.button!==0){this.onContainerMouseMove(e)}if(typeof e.button==="undefined"||isPrimaryButton){this.zoomOption(e);if(isPrimaryButton){e.preventDefault?.()}this.dragStart(e)}}onContainerMouseLeave(e){const{pointer}=charts[pick(Pointer.hoverChartIndex,-1)]||{};e=this.normalize(e);this.onContainerMouseMove(e);if(pointer&&!this.inClass(e.relatedTarget,"highcharts-tooltip")){pointer.reset();pointer.chartPosition=void 0}}onContainerMouseEnter(){delete this.chartPosition}onContainerMouseMove(e){const chart=this.chart,tooltip=chart.tooltip,pEvt=this.normalize(e);this.setHoverChartIndex(e);if(chart.mouseIsDown==="mousedown"||this.touchSelect(pEvt)){this.drag(pEvt)}if(!chart.openMenu&&(this.inClass(pEvt.target,"highcharts-tracker")||chart.isInsidePlot(pEvt.chartX-chart.plotLeft,pEvt.chartY-chart.plotTop,{visiblePlotOnly:true}))&&!(tooltip&&tooltip.shouldStickOnContact(pEvt))){if(this.inClass(pEvt.target,"highcharts-no-tooltip")){this.reset(false,0)}else{this.runPointActions(pEvt)}}}onDocumentTouchEnd(e){this.onDocumentMouseUp(e)}onContainerTouchMove(e){if(this.touchSelect(e)){this.onContainerMouseMove(e)}else{this.touch(e)}}onContainerTouchStart(e){if(this.touchSelect(e)){this.onContainerMouseDown(e)}else{this.zoomOption(e);this.touch(e,true)}}onDocumentMouseMove(e){const chart=this.chart;const tooltip=chart.tooltip;const chartPosition=this.chartPosition;const pEvt=this.normalize(e,chartPosition);if(chartPosition&&!chart.isInsidePlot(pEvt.chartX-chart.plotLeft,pEvt.chartY-chart.plotTop,{visiblePlotOnly:true})&&!(tooltip&&tooltip.shouldStickOnContact(pEvt))&&(pEvt.target===chart.container.ownerDocument||!this.inClass(pEvt.target,"highcharts-tracker"))){this.reset()}}onDocumentMouseUp(e){charts[pick(Pointer.hoverChartIndex,-1)]?.pointer?.drop(e)}pinch(e){const pointer=this,{chart,hasZoom,lastTouches}=pointer,touches=[].map.call(e.touches||[],touch=>pointer.normalize(touch)),touchesLength=touches.length,fireClickEvent=touchesLength===1&&(pointer.inClass(e.target,"highcharts-tracker")&&chart.runTrackerClick||pointer.runChartClick),tooltip=chart.tooltip,followTouchMove=touchesLength===1&&pick(tooltip?.options.followTouchMove,true);if(touchesLength>1){pointer.initiated=true}else if(followTouchMove){pointer.initiated=false}if(hasZoom&&pointer.initiated&&!fireClickEvent&&e.cancelable!==false){e.preventDefault()}if(e.type==="touchstart"){pointer.pinchDown=touches;pointer.res=true;chart.mouseDownX=e.chartX}else if(followTouchMove){this.runPointActions(pointer.normalize(e))}else if(lastTouches){fireEvent(chart,"touchpan",{originalEvent:e,touches:touches},()=>{const boxFromTouches=touches=>{const finger0=touches[0],finger1=touches[1]||finger0;return{x:finger0.chartX,y:finger0.chartY,width:finger1.chartX-finger0.chartX,height:finger1.chartY-finger0.chartY}};chart.transform({axes:chart.axes.filter(axis=>axis.zoomEnabled&&(this.zoomHor&&axis.horiz||this.zoomVert&&!axis.horiz)),to:boxFromTouches(touches),from:boxFromTouches(lastTouches),trigger:e.type})});if(pointer.res){pointer.res=false;this.reset(false,0)}}pointer.lastTouches=touches}reset(allowMove,delay){const pointer=this,chart=pointer.chart,hoverSeries=chart.hoverSeries,hoverPoint=chart.hoverPoint,hoverPoints=chart.hoverPoints,tooltip=chart.tooltip,tooltipPoints=tooltip&&tooltip.shared?hoverPoints:hoverPoint;if(allowMove&&tooltipPoints){splat(tooltipPoints).forEach(function(point){if(point.series.isCartesian&&typeof point.plotX==="undefined"){allowMove=false}})}if(allowMove){if(tooltip&&tooltipPoints&&splat(tooltipPoints).length){tooltip.refresh(tooltipPoints);if(tooltip.shared&&hoverPoints){hoverPoints.forEach(function(point){point.setState(point.state,true);if(point.series.isCartesian){if(point.series.xAxis.crosshair){point.series.xAxis.drawCrosshair(null,point)}if(point.series.yAxis.crosshair){point.series.yAxis.drawCrosshair(null,point)}}})}else if(hoverPoint){hoverPoint.setState(hoverPoint.state,true);chart.axes.forEach(function(axis){if(axis.crosshair&&hoverPoint.series[axis.coll]===axis){axis.drawCrosshair(null,hoverPoint)}})}}}else{if(hoverPoint){hoverPoint.onMouseOut()}if(hoverPoints){hoverPoints.forEach(function(point){point.setState()})}if(hoverSeries){hoverSeries.onMouseOut()}if(tooltip){tooltip.hide(delay)}if(pointer.unDocMouseMove){pointer.unDocMouseMove=pointer.unDocMouseMove()}chart.axes.forEach(function(axis){axis.hideCrosshair()});chart.hoverPoints=chart.hoverPoint=void 0}}runPointActions(e,p,force){const pointer=this,chart=pointer.chart,series=chart.series,tooltip=chart.tooltip&&chart.tooltip.options.enabled?chart.tooltip:void 0,shared=tooltip?tooltip.shared:false;let hoverPoint=p||chart.hoverPoint,hoverSeries=hoverPoint&&hoverPoint.series||chart.hoverSeries;const isDirectTouch=(!e||e.type!=="touchmove")&&(!!p||hoverSeries&&hoverSeries.directTouch&&pointer.isDirectTouch),hoverData=this.getHoverData(hoverPoint,hoverSeries,series,isDirectTouch,shared,e);hoverPoint=hoverData.hoverPoint;hoverSeries=hoverData.hoverSeries;const points=hoverData.hoverPoints,followPointer=hoverSeries&&hoverSeries.tooltipOptions.followPointer&&!hoverSeries.tooltipOptions.split,useSharedTooltip=shared&&hoverSeries&&!hoverSeries.noSharedTooltip;if(hoverPoint&&(force||hoverPoint!==chart.hoverPoint||tooltip&&tooltip.isHidden)){(chart.hoverPoints||[]).forEach(function(p){if(points.indexOf(p)===-1){p.setState()}});if(chart.hoverSeries!==hoverSeries){hoverSeries.onMouseOver()}pointer.applyInactiveState(points);(points||[]).forEach(function(p){p.setState("hover")});if(chart.hoverPoint){chart.hoverPoint.firePointEvent("mouseOut")}if(!hoverPoint.series){return}chart.hoverPoints=points;chart.hoverPoint=hoverPoint;hoverPoint.firePointEvent("mouseOver",void 0,()=>{if(tooltip&&hoverPoint){tooltip.refresh(useSharedTooltip?points:hoverPoint,e)}})}else if(followPointer&&tooltip&&!tooltip.isHidden){const anchor=tooltip.getAnchor([{}],e);if(chart.isInsidePlot(anchor[0],anchor[1],{visiblePlotOnly:true})){tooltip.updatePosition({plotX:anchor[0],plotY:anchor[1]})}}if(!pointer.unDocMouseMove){pointer.unDocMouseMove=addEvent(chart.container.ownerDocument,"mousemove",e=>charts[Pointer.hoverChartIndex??-1]?.pointer?.onDocumentMouseMove(e));pointer.eventsToUnbind.push(pointer.unDocMouseMove)}chart.axes.forEach(function drawAxisCrosshair(axis){const snap=pick((axis.crosshair||{}).snap,true);let point;if(snap){point=chart.hoverPoint;if(!point||point.series[axis.coll]!==axis){point=find(points,p=>p.series&&p.series[axis.coll]===axis)}}if(point||!snap){axis.drawCrosshair(e,point)}else{axis.hideCrosshair()}})}setDOMEvents(){const container=this.chart.container,ownerDoc=container.ownerDocument;container.onmousedown=this.onContainerMouseDown.bind(this);container.onmousemove=this.onContainerMouseMove.bind(this);container.onclick=this.onContainerClick.bind(this);this.eventsToUnbind.push(addEvent(container,"mouseenter",this.onContainerMouseEnter.bind(this)),addEvent(container,"mouseleave",this.onContainerMouseLeave.bind(this)));if(!Pointer.unbindDocumentMouseUp.some(el=>el.doc===ownerDoc)){Pointer.unbindDocumentMouseUp.push({doc:ownerDoc,unbind:addEvent(ownerDoc,"mouseup",this.onDocumentMouseUp.bind(this))})}let parent=this.chart.renderTo.parentElement;while(parent&&parent.tagName!=="BODY"){this.eventsToUnbind.push(addEvent(parent,"scroll",()=>{delete this.chartPosition}));parent=parent.parentElement}this.eventsToUnbind.push(addEvent(container,"touchstart",this.onContainerTouchStart.bind(this),{passive:false}),addEvent(container,"touchmove",this.onContainerTouchMove.bind(this),{passive:false}));if(!Pointer.unbindDocumentTouchEnd){Pointer.unbindDocumentTouchEnd=addEvent(ownerDoc,"touchend",this.onDocumentTouchEnd.bind(this),{passive:false})}this.setPointerCapture();addEvent(this.chart,"redraw",this.setPointerCapture.bind(this))}setPointerCapture(){if(!isTouchDevice){return}const pointer=this,events=pointer.pointerCaptureEventsToUnbind,chart=pointer.chart,container=chart.container,followTouchMove=pick(chart.options.tooltip?.followTouchMove,true),shouldHave=followTouchMove&&chart.series.some(series=>series.options.findNearestPointBy.indexOf("y")>-1);if(!pointer.hasPointerCapture&&shouldHave){events.push(addEvent(container,"pointerdown",e=>{if(e.target?.hasPointerCapture(e.pointerId)){e.target?.releasePointerCapture(e.pointerId)}}),addEvent(container,"pointermove",e=>{chart.pointer?.getPointFromEvent(e)?.onMouseOver(e)}));if(!chart.styledMode){css(container,{"touch-action":"none"})}container.className+=" highcharts-no-touch-action";pointer.hasPointerCapture=true}else if(pointer.hasPointerCapture&&!shouldHave){events.forEach(e=>e());events.length=0;if(!chart.styledMode){css(container,{"touch-action":pick(chart.options.chart.style?.["touch-action"],"manipulation")})}container.className=container.className.replace(" highcharts-no-touch-action","");pointer.hasPointerCapture=false}}setHoverChartIndex(e){const chart=this.chart;const hoverChart=H.charts[pick(Pointer.hoverChartIndex,-1)];if(hoverChart&&hoverChart!==chart){const relatedTargetObj={relatedTarget:chart.container};if(e&&!e?.relatedTarget){e={...relatedTargetObj,...e}}hoverChart.pointer?.onContainerMouseLeave(e||relatedTargetObj)}if(!hoverChart||!hoverChart.mouseIsDown){Pointer.hoverChartIndex=chart.index}}touch(e,start){const{chart,pinchDown=[]}=this;let hasMoved,isInside;this.setHoverChartIndex();e=this.normalize(e);if(e.touches.length===1){isInside=chart.isInsidePlot(e.chartX-chart.plotLeft,e.chartY-chart.plotTop,{visiblePlotOnly:true});if(isInside&&!chart.openMenu){if(start){this.runPointActions(e)}if(e.type==="touchmove"){hasMoved=pinchDown[0]?Math.pow(pinchDown[0].chartX-e.chartX,2)+Math.pow(pinchDown[0].chartY-e.chartY,2)>=16:false}if(pick(hasMoved,true)){this.pinch(e)}}else if(start){this.reset()}}else if(e.touches.length===2){this.pinch(e)}}touchSelect(e){return Boolean(this.chart.zooming.singleTouch&&e.touches&&e.touches.length===1)}zoomOption(e){const chart=this.chart,inverted=chart.inverted;let zoomType=chart.zooming.type||"",zoomX,zoomY;if(/touch/.test(e.type)){zoomType=pick(chart.zooming.pinchType,zoomType)}this.zoomX=zoomX=/x/.test(zoomType);this.zoomY=zoomY=/y/.test(zoomType);this.zoomHor=zoomX&&!inverted||zoomY&&inverted;this.zoomVert=zoomY&&!inverted||zoomX&&inverted;this.hasZoom=zoomX||zoomY}}Pointer.unbindDocumentMouseUp=[];(function(Pointer){function compose(ChartClass){if(pushUnique(composed,"Core.Pointer")){addEvent(ChartClass,"beforeRender",function(){this.pointer=new Pointer(this,this.options)})}}Pointer.compose=compose})(Pointer||(Pointer={}));export default Pointer;"";