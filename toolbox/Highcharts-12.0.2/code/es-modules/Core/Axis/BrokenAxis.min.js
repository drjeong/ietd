"use strict";import StackItem from"./Stacking/StackItem.js";import U from"../Utilities.js";const{addEvent,find,fireEvent,isArray,isNumber,pick}=U;var BrokenAxis;(function(BrokenAxis){function compose(AxisClass,SeriesClass){if(!AxisClass.keepProps.includes("brokenAxis")){AxisClass.keepProps.push("brokenAxis");addEvent(AxisClass,"init",onAxisInit);addEvent(AxisClass,"afterInit",onAxisAfterInit);addEvent(AxisClass,"afterSetTickPositions",onAxisAfterSetTickPositions);addEvent(AxisClass,"afterSetOptions",onAxisAfterSetOptions);const seriesProto=SeriesClass.prototype;seriesProto.drawBreaks=seriesDrawBreaks;seriesProto.gappedPath=seriesGappedPath;addEvent(SeriesClass,"afterGeneratePoints",onSeriesAfterGeneratePoints);addEvent(SeriesClass,"afterRender",onSeriesAfterRender)}return AxisClass}BrokenAxis.compose=compose;function onAxisAfterInit(){if(typeof this.brokenAxis!=="undefined"){this.brokenAxis.setBreaks(this.options.breaks,false)}}function onAxisAfterSetOptions(){const axis=this;if(axis.brokenAxis?.hasBreaks){axis.options.ordinal=false}}function onAxisAfterSetTickPositions(){const axis=this,brokenAxis=axis.brokenAxis;if(brokenAxis?.hasBreaks){const tickPositions=axis.tickPositions,info=axis.tickPositions.info,newPositions=[];for(let i=0;i<tickPositions.length;i++){if(!brokenAxis.isInAnyBreak(tickPositions[i])){newPositions.push(tickPositions[i])}}axis.tickPositions=newPositions;axis.tickPositions.info=info}}function onAxisInit(){const axis=this;if(!axis.brokenAxis){axis.brokenAxis=new Additions(axis)}}function onSeriesAfterGeneratePoints(){const{isDirty,options:{connectNulls},points,xAxis,yAxis}=this;if(isDirty){let i=points.length;while(i--){const point=points[i];const nullGap=point.y===null&&connectNulls===false;const isPointInBreak=!nullGap&&(xAxis?.brokenAxis?.isInAnyBreak(point.x,true)||yAxis?.brokenAxis?.isInAnyBreak(point.y,true));point.visible=isPointInBreak?false:point.options.visible!==false}}}function onSeriesAfterRender(){this.drawBreaks(this.xAxis,["x"]);this.drawBreaks(this.yAxis,pick(this.pointArrayMap,["y"]))}function seriesDrawBreaks(axis,keys){const series=this,points=series.points;let breaks,threshold,y;if(axis?.brokenAxis?.hasBreaks){const brokenAxis=axis.brokenAxis;keys.forEach(function(key){breaks=brokenAxis?.breakArray||[];threshold=axis.isXAxis?axis.min:pick(series.options.threshold,axis.min);const breaksOutOfRange=axis?.options?.breaks?.filter(function(brk){let isOut=true;for(let i=0;i<breaks.length;i++){const otherBreak=breaks[i];if(otherBreak.from===brk.from&&otherBreak.to===brk.to){isOut=false;break}}return isOut});points.forEach(function(point){y=pick(point["stack"+key.toUpperCase()],point[key]);breaks.forEach(function(brk){if(isNumber(threshold)&&isNumber(y)){let eventName="";if(threshold<brk.from&&y>brk.to||threshold>brk.from&&y<brk.from){eventName="pointBreak"}else if(threshold<brk.from&&y>brk.from&&y<brk.to||threshold>brk.from&&y>brk.to&&y<brk.from){eventName="pointInBreak"}if(eventName){fireEvent(axis,eventName,{point:point,brk:brk})}}});breaksOutOfRange?.forEach(function(brk){fireEvent(axis,"pointOutsideOfBreak",{point:point,brk:brk})})})})}}function seriesGappedPath(){const currentDataGrouping=this.currentDataGrouping,groupingSize=currentDataGrouping?.gapSize,points=this.points.slice(),yAxis=this.yAxis;let gapSize=this.options.gapSize,i=points.length-1,stack;if(gapSize&&i>0){if(this.options.gapUnit!=="value"){gapSize*=this.basePointRange}if(groupingSize&&groupingSize>gapSize&&groupingSize>=this.basePointRange){gapSize=groupingSize}let current,next;while(i--){if(!(next&&next.visible!==false)){next=points[i+1]}current=points[i];if(next.visible===false||current.visible===false){continue}if(next.x-current.x>gapSize){const xRange=(current.x+next.x)/2;points.splice(i+1,0,{isNull:true,x:xRange});if(yAxis.stacking&&this.options.stacking){stack=yAxis.stacking.stacks[this.stackKey][xRange]=new StackItem(yAxis,yAxis.options.stackLabels,false,xRange,this.stack);stack.total=0}}next=current}}return this.getGraphPath(points)}class Additions{static isInBreak(brk,val){const repeat=brk.repeat||Infinity,from=brk.from,length=brk.to-brk.from,test=val>=from?(val-from)%repeat:repeat-(from-val)%repeat;let ret;if(!brk.inclusive){ret=test<length&&test!==0}else{ret=test<=length}return ret}static lin2Val(val){const axis=this;const brokenAxis=axis.brokenAxis;const breakArray=brokenAxis&&brokenAxis.breakArray;if(!breakArray||!isNumber(val)){return val}let nval=val,brk,i;for(i=0;i<breakArray.length;i++){brk=breakArray[i];if(brk.from>=nval){break}else if(brk.to<nval){nval+=brk.len}else if(Additions.isInBreak(brk,nval)){nval+=brk.len}}return nval}static val2Lin(val){const axis=this;const brokenAxis=axis.brokenAxis;const breakArray=brokenAxis&&brokenAxis.breakArray;if(!breakArray||!isNumber(val)){return val}let nval=val,brk,i;for(i=0;i<breakArray.length;i++){brk=breakArray[i];if(brk.to<=val){nval-=brk.len}else if(brk.from>=val){break}else if(Additions.isInBreak(brk,val)){nval-=val-brk.from;break}}return nval}constructor(axis){this.hasBreaks=false;this.axis=axis}findBreakAt(x,breaks){return find(breaks,function(b){return b.from<x&&x<b.to})}isInAnyBreak(val,testKeep){const brokenAxis=this,axis=brokenAxis.axis,breaks=axis.options.breaks||[];let i=breaks.length,inbrk,keep,ret;if(i&&isNumber(val)){while(i--){if(Additions.isInBreak(breaks[i],val)){inbrk=true;if(!keep){keep=pick(breaks[i].showPoints,!axis.isXAxis)}}}if(inbrk&&testKeep){ret=inbrk&&!keep}else{ret=inbrk}}return ret}setBreaks(breaks,redraw){const brokenAxis=this,axis=brokenAxis.axis,time=axis.chart.time,hasBreaks=isArray(breaks)&&!!breaks.length&&!!Object.keys(breaks[0]).length;axis.isDirty=brokenAxis.hasBreaks!==hasBreaks;brokenAxis.hasBreaks=hasBreaks;breaks?.forEach(brk=>{brk.from=time.parse(brk.from)||0;brk.to=time.parse(brk.to)||0});if(breaks!==axis.options.breaks){axis.options.breaks=axis.userOptions.breaks=breaks}axis.forceRedraw=true;axis.series.forEach(function(series){series.isDirty=true});if(!hasBreaks&&axis.val2lin===Additions.val2Lin){delete axis.val2lin;delete axis.lin2val}if(hasBreaks){axis.userOptions.ordinal=false;axis.lin2val=Additions.lin2Val;axis.val2lin=Additions.val2Lin;axis.setExtremes=function(newMin,newMax,redraw,animation,eventArguments){if(brokenAxis.hasBreaks){const breaks=this.options.breaks||[];let axisBreak;while(axisBreak=brokenAxis.findBreakAt(newMin,breaks)){newMin=axisBreak.to}while(axisBreak=brokenAxis.findBreakAt(newMax,breaks)){newMax=axisBreak.from}if(newMax<newMin){newMax=newMin}}axis.constructor.prototype.setExtremes.call(this,newMin,newMax,redraw,animation,eventArguments)};axis.setAxisTranslation=function(){axis.constructor.prototype.setAxisTranslation.call(this);brokenAxis.unitLength=void 0;if(brokenAxis.hasBreaks){const breaks=axis.options.breaks||[],breakArrayT=[],breakArray=[],pointRangePadding=pick(axis.pointRangePadding,0);let length=0,inBrk,repeat,min=axis.userMin||axis.min,max=axis.userMax||axis.max,start,i;breaks.forEach(function(brk){repeat=brk.repeat||Infinity;if(isNumber(min)&&isNumber(max)){if(Additions.isInBreak(brk,min)){min+=brk.to%repeat-min%repeat}if(Additions.isInBreak(brk,max)){max-=max%repeat-brk.from%repeat}}});breaks.forEach(function(brk){start=brk.from;repeat=brk.repeat||Infinity;if(isNumber(min)&&isNumber(max)){while(start-repeat>min){start-=repeat}while(start<min){start+=repeat}for(i=start;i<max;i+=repeat){breakArrayT.push({value:i,move:"in"});breakArrayT.push({value:i+brk.to-brk.from,move:"out",size:brk.breakSize})}}});breakArrayT.sort(function(a,b){return a.value===b.value?(a.move==="in"?0:1)-(b.move==="in"?0:1):a.value-b.value});inBrk=0;start=min;breakArrayT.forEach(function(brk){inBrk+=brk.move==="in"?1:-1;if(inBrk===1&&brk.move==="in"){start=brk.value}if(inBrk===0&&isNumber(start)){breakArray.push({from:start,to:brk.value,len:brk.value-start-(brk.size||0)});length+=brk.value-start-(brk.size||0)}});brokenAxis.breakArray=breakArray;if(isNumber(min)&&isNumber(max)&&isNumber(axis.min)){brokenAxis.unitLength=max-min-length+pointRangePadding;fireEvent(axis,"afterBreaks");if(axis.staticScale){axis.transA=axis.staticScale}else if(brokenAxis.unitLength){axis.transA*=(max-axis.min+pointRangePadding)/brokenAxis.unitLength}if(pointRangePadding){axis.minPixelPadding=axis.transA*(axis.minPointOffset||0)}axis.min=min;axis.max=max}}}}if(pick(redraw,true)){axis.chart.redraw()}}}BrokenAxis.Additions=Additions})(BrokenAxis||(BrokenAxis={}));export default BrokenAxis;