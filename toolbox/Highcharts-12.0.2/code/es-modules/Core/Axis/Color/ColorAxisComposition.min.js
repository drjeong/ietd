"use strict";import Color from"../../Color/Color.js";const{parse:color}=Color;import U from"../../Utilities.js";const{addEvent,extend,merge,pick,splat}=U;var ColorAxisComposition;(function(ColorAxisComposition){let ColorAxisConstructor;function compose(ColorAxisClass,ChartClass,FxClass,LegendClass,SeriesClass){const chartProto=ChartClass.prototype,fxProto=FxClass.prototype,seriesProto=SeriesClass.prototype;if(!chartProto.collectionsWithUpdate.includes("colorAxis")){ColorAxisConstructor=ColorAxisClass;chartProto.collectionsWithUpdate.push("colorAxis");chartProto.collectionsWithInit.colorAxis=[chartProto.addColorAxis];addEvent(ChartClass,"afterCreateAxes",onChartAfterCreateAxes);wrapChartCreateAxis(ChartClass);fxProto.fillSetter=wrapFxFillSetter;fxProto.strokeSetter=wrapFxStrokeSetter;addEvent(LegendClass,"afterGetAllItems",onLegendAfterGetAllItems);addEvent(LegendClass,"afterColorizeItem",onLegendAfterColorizeItem);addEvent(LegendClass,"afterUpdate",onLegendAfterUpdate);extend(seriesProto,{optionalAxis:"colorAxis",translateColors:seriesTranslateColors});extend(seriesProto.pointClass.prototype,{setVisible:pointSetVisible});addEvent(SeriesClass,"afterTranslate",onSeriesAfterTranslate,{order:1});addEvent(SeriesClass,"bindAxes",onSeriesBindAxes)}}ColorAxisComposition.compose=compose;function onChartAfterCreateAxes(){const{userOptions}=this;this.colorAxis=[];if(userOptions.colorAxis){userOptions.colorAxis=splat(userOptions.colorAxis);userOptions.colorAxis.map(axisOptions=>new ColorAxisConstructor(this,axisOptions))}}function onLegendAfterGetAllItems(e){const colorAxes=this.chart.colorAxis||[],destroyItem=item=>{const i=e.allItems.indexOf(item);if(i!==-1){this.destroyItem(e.allItems[i]);e.allItems.splice(i,1)}};let colorAxisItems=[],options,i;colorAxes.forEach(function(colorAxis){options=colorAxis.options;if(options&&options.showInLegend){if(options.dataClasses&&options.visible){colorAxisItems=colorAxisItems.concat(colorAxis.getDataClassLegendSymbols())}else if(options.visible){colorAxisItems.push(colorAxis)}colorAxis.series.forEach(function(series){if(!series.options.showInLegend||options.dataClasses){if(series.options.legendType==="point"){series.points.forEach(function(point){destroyItem(point)})}else{destroyItem(series)}}})}});i=colorAxisItems.length;while(i--){e.allItems.unshift(colorAxisItems[i])}}function onLegendAfterColorizeItem(e){if(e.visible&&e.item.legendColor){e.item.legendItem.symbol.attr({fill:e.item.legendColor})}}function onLegendAfterUpdate(e){this.chart.colorAxis?.forEach(colorAxis=>{colorAxis.update({},e.redraw)})}function onSeriesAfterTranslate(){if(this.chart.colorAxis&&this.chart.colorAxis.length||this.colorAttribs){this.translateColors()}}function onSeriesBindAxes(){const axisTypes=this.axisTypes;if(!axisTypes){this.axisTypes=["colorAxis"]}else if(axisTypes.indexOf("colorAxis")===-1){axisTypes.push("colorAxis")}}function pointSetVisible(vis){const point=this,method=vis?"show":"hide";point.visible=point.options.visible=Boolean(vis);["graphic","dataLabel"].forEach(function(key){if(point[key]){point[key][method]()}});this.series.buildKDTree()}ColorAxisComposition.pointSetVisible=pointSetVisible;function seriesTranslateColors(){const series=this,points=this.getPointsCollection(),nullColor=this.options.nullColor,colorAxis=this.colorAxis,colorKey=this.colorKey;points.forEach(point=>{const value=point.getNestedProperty(colorKey),color=point.options.color||(point.isNull||point.value===null?nullColor:colorAxis&&typeof value!=="undefined"?colorAxis.toColor(value,point):point.color||series.color);if(color&&point.color!==color){point.color=color;if(series.options.legendType==="point"&&point.legendItem&&point.legendItem.label){series.chart.legend.colorizeItem(point,point.visible)}}})}function wrapChartCreateAxis(ChartClass){const superCreateAxis=ChartClass.prototype.createAxis;ChartClass.prototype.createAxis=function(type,options){const chart=this;if(type!=="colorAxis"){return superCreateAxis.apply(chart,arguments)}const axis=new ColorAxisConstructor(chart,merge(options.axis,{index:chart[type].length,isX:false}));chart.isDirtyLegend=true;chart.axes.forEach(axis=>{axis.series=[]});chart.series.forEach(series=>{series.bindAxes();series.isDirtyData=true});if(pick(options.redraw,true)){chart.redraw(options.animation)}return axis}}function wrapFxFillSetter(){this.elem.attr("fill",color(this.start).tweenTo(color(this.end),this.pos),void 0,true)}function wrapFxStrokeSetter(){this.elem.attr("stroke",color(this.start).tweenTo(color(this.end),this.pos),void 0,true)}})(ColorAxisComposition||(ColorAxisComposition={}));export default ColorAxisComposition;