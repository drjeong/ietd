"use strict";import U from"../../Utilities.js";const{addEvent,removeEvent,isObject,isNumber,pick,wrap}=U;function onTickInit(){const tick=this;if(!tick.treeGrid){tick.treeGrid=new TreeGridTickAdditions(tick)}}function onTickHover(label){label.addClass("highcharts-treegrid-node-active");if(!label.renderer.styledMode){label.css({textDecoration:"underline"})}}function onTickHoverExit(label,options){const css=isObject(options.style)?options.style:{};label.removeClass("highcharts-treegrid-node-active");if(!label.renderer.styledMode){label.css({textDecoration:css.textDecoration||"none"})}}function renderLabelIcon(tick,params){const treeGrid=tick.treeGrid,isNew=!treeGrid.labelIcon,renderer=params.renderer,labelBox=params.xy,options=params.options,width=options.width||0,height=options.height||0,padding=options.padding??tick.axis.linkedParent?0:5,iconCenter={x:labelBox.x-width/2-padding,y:labelBox.y-height/2},rotation=params.collapsed?90:180,shouldRender=params.show&&isNumber(iconCenter.y);let icon=treeGrid.labelIcon;if(!icon){treeGrid.labelIcon=icon=renderer.path(renderer.symbols[options.type](options.x||0,options.y||0,width,height)).addClass("highcharts-label-icon").add(params.group)}icon[shouldRender?"show":"hide"]();if(!renderer.styledMode){icon.attr({cursor:"pointer",fill:pick(params.color,"#666666"),"stroke-width":1,stroke:options.lineColor,strokeWidth:options.lineWidth||0})}icon[isNew?"attr":"animate"]({translateX:iconCenter.x,translateY:iconCenter.y,rotation:rotation})}function wrapGetLabelPosition(proceed,x,y,label,horiz,labelOptions,tickmarkOffset,index,step){const tick=this,lbOptions=pick(tick.options&&tick.options.labels,labelOptions),pos=tick.pos,axis=tick.axis,isTreeGrid=axis.type==="treegrid",result=proceed.apply(tick,[x,y,label,horiz,lbOptions,tickmarkOffset,index,step]);let mapOfPosToGridNode,node,level;if(isTreeGrid){const{width=0,padding=axis.linkedParent?0:5}=lbOptions&&isObject(lbOptions.symbol,true)?lbOptions.symbol:{},indentation=lbOptions&&isNumber(lbOptions.indentation)?lbOptions.indentation:0;mapOfPosToGridNode=axis.treeGrid.mapOfPosToGridNode;node=mapOfPosToGridNode&&mapOfPosToGridNode[pos];level=node&&node.depth||1;result.x+=width+padding*2+(level-1)*indentation}return result}function wrapRenderLabel(proceed){const tick=this,{pos,axis,label,treeGrid:tickGrid,options:tickOptions}=tick,icon=tickGrid?.labelIcon,labelElement=label?.element,{treeGrid:axisGrid,options:axisOptions,chart,tickPositions}=axis,mapOfPosToGridNode=axisGrid.mapOfPosToGridNode,labelOptions=pick(tickOptions?.labels,axisOptions?.labels),symbolOptions=labelOptions&&isObject(labelOptions.symbol,true)?labelOptions.symbol:{},node=mapOfPosToGridNode&&mapOfPosToGridNode[pos],{descendants,depth}=node||{},hasDescendants=node&&descendants&&descendants>0,level=depth,isTreeGridElement=axis.type==="treegrid"&&labelElement,shouldRender=tickPositions.indexOf(pos)>-1,prefixClassName="highcharts-treegrid-node-",prefixLevelClass=prefixClassName+"level-",styledMode=chart.styledMode;let collapsed,addClassName,removeClassName;if(isTreeGridElement&&node){label.removeClass(new RegExp(prefixLevelClass+".*")).addClass(prefixLevelClass+level)}proceed.apply(tick,Array.prototype.slice.call(arguments,1));if(isTreeGridElement&&hasDescendants){collapsed=axisGrid.isCollapsed(node);renderLabelIcon(tick,{color:!styledMode&&label.styles.color||"",collapsed:collapsed,group:label.parentGroup,options:symbolOptions,renderer:label.renderer,show:shouldRender,xy:label.xy});addClassName=prefixClassName+(collapsed?"collapsed":"expanded");removeClassName=prefixClassName+(collapsed?"expanded":"collapsed");label.addClass(addClassName).removeClass(removeClassName);if(!styledMode){label.css({cursor:"pointer"})}[label,icon].forEach(object=>{if(object&&!object.attachedTreeGridEvents){addEvent(object.element,"mouseover",function(){onTickHover(label)});addEvent(object.element,"mouseout",function(){onTickHoverExit(label,labelOptions)});addEvent(object.element,"click",function(){tickGrid.toggleCollapse()});object.attachedTreeGridEvents=true}})}else if(icon){removeEvent(labelElement);label?.css({cursor:"default"});icon.destroy()}}class TreeGridTickAdditions{static compose(TickClass){const tickProto=TickClass.prototype;if(!tickProto.toggleCollapse){addEvent(TickClass,"init",onTickInit);wrap(tickProto,"getLabelPosition",wrapGetLabelPosition);wrap(tickProto,"renderLabel",wrapRenderLabel);tickProto.collapse=function(redraw){this.treeGrid.collapse(redraw)};tickProto.expand=function(redraw){this.treeGrid.expand(redraw)};tickProto.toggleCollapse=function(redraw){this.treeGrid.toggleCollapse(redraw)}}}constructor(tick){this.tick=tick}collapse(redraw){const tick=this.tick,axis=tick.axis,brokenAxis=axis.brokenAxis;if(brokenAxis&&axis.treeGrid.mapOfPosToGridNode){const pos=tick.pos,node=axis.treeGrid.mapOfPosToGridNode[pos],breaks=axis.treeGrid.collapse(node);brokenAxis.setBreaks(breaks,pick(redraw,true))}}destroy(){if(this.labelIcon){this.labelIcon.destroy()}}expand(redraw){const{pos,axis}=this.tick,{treeGrid,brokenAxis}=axis,posMappedNodes=treeGrid.mapOfPosToGridNode;if(brokenAxis&&posMappedNodes){const node=posMappedNodes[pos],breaks=treeGrid.expand(node);brokenAxis.setBreaks(breaks,pick(redraw,true))}}toggleCollapse(redraw){const tick=this.tick,axis=tick.axis,brokenAxis=axis.brokenAxis;if(brokenAxis&&axis.treeGrid.mapOfPosToGridNode){const pos=tick.pos,node=axis.treeGrid.mapOfPosToGridNode[pos],breaks=axis.treeGrid.toggleCollapse(node);brokenAxis.setBreaks(breaks,pick(redraw,true))}}}export default TreeGridTickAdditions;