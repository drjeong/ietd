"use strict";import A from"../../Animation/AnimationUtilities.js";const{getDeferredAnimation}=A;import Axis from"../Axis.js";import SeriesRegistry from"../../Series/SeriesRegistry.js";const{series:{prototype:seriesProto}}=SeriesRegistry;import StackItem from"./StackItem.js";import U from"../../Utilities.js";const{addEvent,correctFloat,defined,destroyObjectProperties,fireEvent,isNumber,objectEach,pick}=U;function chartGetStacks(){const chart=this,inverted=chart.inverted;chart.axes.forEach(axis=>{if(axis.stacking&&axis.stacking.stacks&&axis.hasVisibleSeries){axis.stacking.oldStacks=axis.stacking.stacks}});chart.series.forEach(series=>{const xAxisOptions=series.xAxis&&series.xAxis.options||{};if(series.options.stacking&&series.reserveSpace()){series.stackKey=[series.type,pick(series.options.stack,""),inverted?xAxisOptions.top:xAxisOptions.left,inverted?xAxisOptions.height:xAxisOptions.width].join(",")}})}function onAxisDestroy(){const stacking=this.stacking;if(stacking){const stacks=stacking.stacks;objectEach(stacks,(stack,stackKey)=>{destroyObjectProperties(stack);delete stacks[stackKey]});stacking.stackTotalGroup?.destroy()}}function onAxisInit(){if(!this.stacking){this.stacking=new AxisAdditions(this)}}function seriesGetStackIndicator(stackIndicator,x,index,key){if(!defined(stackIndicator)||stackIndicator.x!==x||key&&stackIndicator.stackKey!==key){stackIndicator={x:x,index:0,key:key,stackKey:key}}else{stackIndicator.index++}stackIndicator.key=[index,x,stackIndicator.index].join(",");return stackIndicator}function seriesModifyStacks(){const series=this,yAxis=series.yAxis,stackKey=series.stackKey||"",stacks=yAxis.stacking.stacks,processedXData=series.getColumn("x",true),stacking=series.options.stacking,stacker=series[stacking+"Stacker"];let stackIndicator;if(stacker){[stackKey,"-"+stackKey].forEach(key=>{let i=processedXData.length,x,stackItem,pointExtremes;while(i--){x=processedXData[i];stackIndicator=series.getStackIndicator(stackIndicator,x,series.index,key);stackItem=stacks[key]?.[x];pointExtremes=stackItem?.points[stackIndicator.key||""];if(pointExtremes){stacker.call(series,pointExtremes,stackItem,i)}}})}}function seriesPercentStacker(pointExtremes,stack,i){const totalFactor=stack.total?100/stack.total:0;pointExtremes[0]=correctFloat(pointExtremes[0]*totalFactor);pointExtremes[1]=correctFloat(pointExtremes[1]*totalFactor);this.stackedYData[i]=pointExtremes[1]}function seriesSetGroupedPoints(axis){if(this.is("column")||this.is("columnrange")){if(this.options.centerInCategory&&this.chart.series.length>1){seriesProto.setStackedPoints.call(this,axis,"group")}else{axis.stacking.resetStacks()}}}function seriesSetStackedPoints(axis,stackingParam){const type=stackingParam||this.options.stacking;if(!type||!this.reserveSpace()||({group:"xAxis"}[type]||"yAxis")!==axis.coll){return}const series=this,xData=series.getColumn("x",true),yData=series.getColumn(series.pointValKey||"y",true),stackedYData=[],yDataLength=yData.length,seriesOptions=series.options,threshold=seriesOptions.threshold||0,stackThreshold=seriesOptions.startFromThreshold?threshold:0,stackOption=seriesOptions.stack,stackKey=stackingParam?`${series.type},${type}`:series.stackKey||"",negKey="-"+stackKey,negStacks=series.negStacks,stacking=axis.stacking,stacks=stacking.stacks,oldStacks=stacking.oldStacks;let stackIndicator,isNegative,stack,other,key,pointKey,i;stacking.stacksTouched+=1;for(i=0;i<yDataLength;i++){const x=xData[i]||0,y=yData[i],yNumber=isNumber(y)&&y||0;stackIndicator=series.getStackIndicator(stackIndicator,x,series.index);pointKey=stackIndicator.key||"";isNegative=negStacks&&yNumber<(stackThreshold?0:threshold);key=isNegative?negKey:stackKey;if(!stacks[key]){stacks[key]={}}if(!stacks[key][x]){if(oldStacks[key]?.[x]){stacks[key][x]=oldStacks[key][x];stacks[key][x].total=null}else{stacks[key][x]=new StackItem(axis,axis.options.stackLabels,!!isNegative,x,stackOption)}}stack=stacks[key][x];if(y!==null){stack.points[pointKey]=stack.points[series.index]=[pick(stack.cumulative,stackThreshold)];if(!defined(stack.cumulative)){stack.base=pointKey}stack.touched=stacking.stacksTouched;if(stackIndicator.index>0&&series.singleStacks===false){stack.points[pointKey][0]=stack.points[series.index+","+x+",0"][0]}}else{delete stack.points[pointKey];delete stack.points[series.index]}let total=stack.total||0;if(type==="percent"){other=isNegative?stackKey:negKey;if(negStacks&&stacks[other]?.[x]){other=stacks[other][x];total=other.total=Math.max(other.total||0,total)+Math.abs(yNumber)}else{total=correctFloat(total+Math.abs(yNumber))}}else if(type==="group"){if(isNumber(y)){total++}}else{total=correctFloat(total+yNumber)}if(type==="group"){stack.cumulative=(total||1)-1}else{stack.cumulative=correctFloat(pick(stack.cumulative,stackThreshold)+yNumber)}stack.total=total;if(y!==null){stack.points[pointKey].push(stack.cumulative);stackedYData[i]=stack.cumulative;stack.hasValidPoints=true}}if(type==="percent"){stacking.usePercentage=true}if(type!=="group"){this.stackedYData=stackedYData}stacking.oldStacks={}}class AxisAdditions{constructor(axis){this.oldStacks={};this.stacks={};this.stacksTouched=0;this.axis=axis}buildStacks(){const stacking=this,axis=stacking.axis,axisSeries=axis.series,isXAxis=axis.coll==="xAxis",reversedStacks=axis.options.reversedStacks,len=axisSeries.length;let actualSeries,i;this.resetStacks();stacking.usePercentage=false;i=len;while(i--){actualSeries=axisSeries[reversedStacks?i:len-i-1];if(isXAxis){actualSeries.setGroupedPoints(axis)}actualSeries.setStackedPoints(axis)}if(!isXAxis){for(i=0;i<len;i++){axisSeries[i].modifyStacks()}}fireEvent(axis,"afterBuildStacks")}cleanStacks(){if(this.oldStacks){this.stacks=this.oldStacks;objectEach(this.stacks,type=>{objectEach(type,stack=>{stack.cumulative=stack.total})})}}resetStacks(){objectEach(this.stacks,type=>{objectEach(type,(stack,x)=>{if(isNumber(stack.touched)&&stack.touched<this.stacksTouched){stack.destroy();delete type[x]}else{stack.total=null;stack.cumulative=null}})})}renderStackTotals(){const stacking=this,axis=stacking.axis,chart=axis.chart,renderer=chart.renderer,stacks=stacking.stacks,stackLabelsAnim=axis.options.stackLabels?.animation,animationConfig=getDeferredAnimation(chart,stackLabelsAnim||false),stackTotalGroup=stacking.stackTotalGroup=stacking.stackTotalGroup||renderer.g("stack-labels").attr({zIndex:6,opacity:0}).add();stackTotalGroup.translate(chart.plotLeft,chart.plotTop);objectEach(stacks,type=>{objectEach(type,stack=>{stack.render(stackTotalGroup)})});stackTotalGroup.animate({opacity:1},animationConfig)}}var StackingAxis;(function(StackingAxis){function compose(AxisClass,ChartClass,SeriesClass){const chartProto=ChartClass.prototype,seriesProto=SeriesClass.prototype;if(!chartProto.getStacks){addEvent(AxisClass,"init",onAxisInit);addEvent(AxisClass,"destroy",onAxisDestroy);chartProto.getStacks=chartGetStacks;seriesProto.getStackIndicator=seriesGetStackIndicator;seriesProto.modifyStacks=seriesModifyStacks;seriesProto.percentStacker=seriesPercentStacker;seriesProto.setGroupedPoints=seriesSetGroupedPoints;seriesProto.setStackedPoints=seriesSetStackedPoints}}StackingAxis.compose=compose})(StackingAxis||(StackingAxis={}));export default StackingAxis;