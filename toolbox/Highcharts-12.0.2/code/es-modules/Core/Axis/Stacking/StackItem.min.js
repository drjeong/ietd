"use strict";import T from"../../Templating.js";const{format}=T;import SeriesRegistry from"../../Series/SeriesRegistry.js";const{series:Series}=SeriesRegistry;import U from"../../Utilities.js";const{destroyObjectProperties,fireEvent,getAlignFactor,isNumber,pick}=U;class StackItem{constructor(axis,options,negativeValue,x,stackOption){const inverted=axis.chart.inverted,reversed=axis.reversed;this.axis=axis;const isNegative=this.isNegative=!!negativeValue!==!!reversed;this.options=options=options||{};this.x=x;this.total=null;this.cumulative=null;this.points={};this.hasValidPoints=false;this.stack=stackOption;this.leftCliff=0;this.rightCliff=0;this.alignOptions={align:options.align||(inverted?isNegative?"left":"right":"center"),verticalAlign:options.verticalAlign||(inverted?"middle":isNegative?"bottom":"top"),y:options.y,x:options.x};this.textAlign=options.textAlign||(inverted?!isNegative?"left":"right":"center")}destroy(){destroyObjectProperties(this,this.axis)}render(group){const chart=this.axis.chart,options=this.options,formatOption=options.format,str=formatOption?format(formatOption,this,chart):options.formatter.call(this);if(this.label){this.label.attr({text:str,visibility:"hidden"})}else{this.label=chart.renderer.label(str,null,void 0,options.shape,void 0,void 0,options.useHTML,false,"stack-labels");const attr={r:options.borderRadius||0,text:str,padding:pick(options.padding,5),visibility:"hidden"};if(!chart.styledMode){attr.fill=options.backgroundColor;attr.stroke=options.borderColor;attr["stroke-width"]=options.borderWidth;this.label.css(options.style||{})}this.label.attr(attr);if(!this.label.added){this.label.add(group)}}this.label.labelrank=chart.plotSizeY;fireEvent(this,"afterRender")}setOffset(xOffset,width,boxBottom,boxTop,defaultX,xAxis){const{alignOptions,axis,label,options,textAlign}=this,chart=axis.chart,stackBox=this.getStackBox({xOffset:xOffset,width:width,boxBottom:boxBottom,boxTop:boxTop,defaultX:defaultX,xAxis:xAxis}),{verticalAlign}=alignOptions;if(label&&stackBox){const labelBox=label.getBBox(void 0,0),padding=label.padding;let isJustify=pick(options.overflow,"justify")==="justify",visible;alignOptions.x=options.x||0;alignOptions.y=options.y||0;const{x,y}=this.adjustStackPosition({labelBox:labelBox,verticalAlign:verticalAlign,textAlign:textAlign});stackBox.x-=x;stackBox.y-=y;label.align(alignOptions,false,stackBox);visible=chart.isInsidePlot(label.alignAttr.x+alignOptions.x+x,label.alignAttr.y+alignOptions.y+y);if(!visible){isJustify=false}if(isJustify){Series.prototype.justifyDataLabel.call(axis,label,alignOptions,label.alignAttr,labelBox,stackBox)}label.attr({x:label.alignAttr.x,y:label.alignAttr.y,rotation:options.rotation,rotationOriginX:labelBox.width*getAlignFactor(options.textAlign||"center"),rotationOriginY:labelBox.height/2});if(pick(!isJustify&&options.crop,true)){visible=isNumber(label.x)&&isNumber(label.y)&&chart.isInsidePlot(label.x-padding+(label.width||0),label.y)&&chart.isInsidePlot(label.x+padding,label.y)}label[visible?"show":"hide"]()}fireEvent(this,"afterSetOffset",{xOffset:xOffset,width:width})}adjustStackPosition({labelBox,verticalAlign,textAlign}){return{x:labelBox.width/2+labelBox.width/2*(2*getAlignFactor(textAlign)-1),y:labelBox.height/2*2*(1-getAlignFactor(verticalAlign))}}getStackBox(stackBoxProps){const stackItem=this,axis=this.axis,chart=axis.chart,{boxTop,defaultX,xOffset,width,boxBottom}=stackBoxProps,totalStackValue=axis.stacking.usePercentage?100:pick(boxTop,this.total,0),y=axis.toPixels(totalStackValue),xAxis=stackBoxProps.xAxis||chart.xAxis[0],x=pick(defaultX,xAxis.translate(this.x))+xOffset,yZero=axis.toPixels(boxBottom||isNumber(axis.min)&&axis.logarithmic&&axis.logarithmic.lin2log(axis.min)||0),height=Math.abs(y-yZero),inverted=chart.inverted,neg=stackItem.isNegative;return inverted?{x:(neg?y:y-height)-chart.plotLeft,y:xAxis.height-x-width+xAxis.top-chart.plotTop,width:height,height:width}:{x:x+xAxis.transB-chart.plotLeft,y:(neg?y-height:y)-chart.plotTop,width:width,height:height}}}export default StackItem;"";