"use strict";import RadialAxisDefaults from"./RadialAxisDefaults.js";import D from"../Defaults.js";const{defaultOptions}=D;import H from"../Globals.js";const{composed,noop}=H;import U from"../Utilities.js";const{addEvent,correctFloat,defined,extend,fireEvent,isObject,merge,pick,pushUnique,relativeLength,wrap}=U;var RadialAxis;(function(RadialAxis){RadialAxis.radialDefaultOptions=merge(RadialAxisDefaults);function beforeSetTickPositions(){this.autoConnect=this.isCircular&&typeof pick(this.userMax,this.options.max)==="undefined"&&correctFloat(this.endAngleRad-this.startAngleRad)===correctFloat(2*Math.PI);if(!this.isCircular&&this.chart.inverted){this.max++}if(this.autoConnect){this.max+=this.categories&&1||this.pointRange||this.closestPointRange||0}}function compose(AxisClass,TickClass){if(pushUnique(composed,"Axis.Radial")){addEvent(AxisClass,"afterInit",onAxisAfterInit);addEvent(AxisClass,"autoLabelAlign",onAxisAutoLabelAlign);addEvent(AxisClass,"destroy",onAxisDestroy);addEvent(AxisClass,"init",onAxisInit);addEvent(AxisClass,"initialAxisTranslation",onAxisInitialAxisTranslation);addEvent(TickClass,"afterGetLabelPosition",onTickAfterGetLabelPosition);addEvent(TickClass,"afterGetPosition",onTickAfterGetPosition);addEvent(H,"setOptions",onGlobalSetOptions);wrap(TickClass.prototype,"getMarkPath",wrapTickGetMarkPath)}return AxisClass}RadialAxis.compose=compose;function createLabelCollector(){return()=>{if(this.isRadial&&this.tickPositions&&this.options.labels&&this.options.labels.allowOverlap!==true){return this.tickPositions.map(pos=>this.ticks[pos]&&this.ticks[pos].label).filter(label=>Boolean(label))}}}function createLabelCollectorHidden(){return noop}function getCrosshairPosition(options,x1,y1){const center=this.pane.center;let value=options.value,shapeArgs,end,x2,y2;if(this.isCircular){if(!defined(value)){x2=options.chartX||0;y2=options.chartY||0;value=this.translate(Math.atan2(y2-y1,x2-x1)-this.startAngleRad,true)}else if(options.point){shapeArgs=options.point.shapeArgs||{};if(shapeArgs.start){value=this.chart.inverted?this.translate(options.point.rectPlotY,true):options.point.x}}end=this.getPosition(value);x2=end.x;y2=end.y}else{if(!defined(value)){x2=options.chartX;y2=options.chartY}if(defined(x2)&&defined(y2)){y1=center[1]+this.chart.plotTop;value=this.translate(Math.min(Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2)),center[2]/2)-center[3]/2,true)}}return[value,x2||0,y2||0]}function getLinePath(_lineWidth,radius,innerRadius){const center=this.pane.center,chart=this.chart,left=this.left||0,top=this.top||0;let end,r=pick(radius,center[2]/2-this.offset),path;if(typeof innerRadius==="undefined"){innerRadius=this.horiz?0:this.center&&-this.center[3]/2}if(innerRadius){r+=innerRadius}if(this.isCircular||typeof radius!=="undefined"){path=this.chart.renderer.symbols.arc(left+center[0],top+center[1],r,r,{start:this.startAngleRad,end:this.endAngleRad,open:true,innerR:0});path.xBounds=[left+center[0]];path.yBounds=[top+center[1]-r]}else{end=this.postTranslate(this.angleRad,r);path=[["M",this.center[0]+chart.plotLeft,this.center[1]+chart.plotTop],["L",end.x,end.y]]}return path}function getOffset(){const axisProto=this.constructor.prototype;axisProto.getOffset.call(this);this.chart.axisOffset[this.side]=0}function getPlotBandPath(from,to,options){const chart=this.chart,radiusToPixels=radius=>{if(typeof radius==="string"){let r=parseInt(radius,10);if(percentRegex.test(radius)){r=r*fullRadius/100}return r}return radius},center=this.center,startAngleRad=this.startAngleRad,fullRadius=center[2]/2,offset=Math.min(this.offset,0),left=this.left||0,top=this.top||0,percentRegex=/%$/,isCircular=this.isCircular;let start,end,angle,xOnPerimeter,open,path,outerRadius=pick(radiusToPixels(options.outerRadius),fullRadius),innerRadius=radiusToPixels(options.innerRadius),thickness=pick(radiusToPixels(options.thickness),10);if(this.options.gridLineInterpolation==="polygon"){path=this.getPlotLinePath({value:from}).concat(this.getPlotLinePath({value:to,reverse:true}))}else{from=Math.max(from,this.min);to=Math.min(to,this.max);const transFrom=this.translate(from),transTo=this.translate(to);if(!isCircular){outerRadius=transFrom||0;innerRadius=transTo||0}if(options.shape==="circle"||!isCircular){start=-Math.PI/2;end=Math.PI*1.5;open=true}else{start=startAngleRad+(transFrom||0);end=startAngleRad+(transTo||0)}outerRadius-=offset;thickness-=offset;path=chart.renderer.symbols.arc(left+center[0],top+center[1],outerRadius,outerRadius,{start:Math.min(start,end),end:Math.max(start,end),innerR:pick(innerRadius,outerRadius-thickness),open:open,borderRadius:options.borderRadius});if(isCircular){angle=(end+start)/2;xOnPerimeter=left+center[0]+center[2]/2*Math.cos(angle);path.xBounds=angle>-Math.PI/2&&angle<Math.PI/2?[xOnPerimeter,chart.plotWidth]:[0,xOnPerimeter];path.yBounds=[top+center[1]+center[2]/2*Math.sin(angle)];path.yBounds[0]+=angle>-Math.PI&&angle<0||angle>Math.PI?-10:10}}return path}function getPlotLinePath(options){const center=this.pane.center,chart=this.chart,inverted=chart.inverted,reverse=options.reverse,background=this.pane.options.background?this.pane.options.background[0]||this.pane.options.background:{},innerRadius=background.innerRadius||"0%",outerRadius=background.outerRadius||"100%",x1=center[0]+chart.plotLeft,y1=center[1]+chart.plotTop,height=this.height,isCrosshair=options.isCrosshair,paneInnerR=center[3]/2;let value=options.value,innerRatio,distance,a,b,otherAxis,xy,tickPositions,crossPos,path;const end=this.getPosition(value);let x2=end.x,y2=end.y;if(isCrosshair){crossPos=this.getCrosshairPosition(options,x1,y1);value=crossPos[0];x2=crossPos[1];y2=crossPos[2]}if(this.isCircular){distance=Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));a=typeof innerRadius==="string"?relativeLength(innerRadius,1):innerRadius/distance;b=typeof outerRadius==="string"?relativeLength(outerRadius,1):outerRadius/distance;if(center&&paneInnerR){innerRatio=paneInnerR/distance;if(a<innerRatio){a=innerRatio}if(b<innerRatio){b=innerRatio}}path=[["M",x1+a*(x2-x1),y1-a*(y1-y2)],["L",x2-(1-b)*(x2-x1),y2+(1-b)*(y1-y2)]]}else{value=this.translate(value);if(value){if(value<0||value>height){value=0}}if(this.options.gridLineInterpolation==="circle"){path=this.getLinePath(0,value,paneInnerR)}else{path=[];chart[inverted?"yAxis":"xAxis"].forEach(a=>{if(a.pane===this.pane){otherAxis=a}});if(otherAxis){tickPositions=otherAxis.tickPositions;if(otherAxis.autoConnect){tickPositions=tickPositions.concat([tickPositions[0]])}if(reverse){tickPositions=tickPositions.slice().reverse()}if(value){value+=paneInnerR}for(let i=0;i<tickPositions.length;i++){xy=otherAxis.getPosition(tickPositions[i],value);path.push(i?["L",xy.x,xy.y]:["M",xy.x,xy.y])}}}}return path}function getPosition(value,length){const translatedVal=this.translate(value);return this.postTranslate(this.isCircular?translatedVal:this.angleRad,pick(this.isCircular?length:translatedVal<0?0:translatedVal,this.center[2]/2)-this.offset)}function getTitlePosition(){const center=this.center,chart=this.chart,titleOptions=this.options.title;return{x:chart.plotLeft+center[0]+(titleOptions.x||0),y:chart.plotTop+center[1]-{high:.5,middle:.25,low:0}[titleOptions.align]*center[2]+(titleOptions.y||0)}}function modify(axis){axis.beforeSetTickPositions=beforeSetTickPositions;axis.createLabelCollector=createLabelCollector;axis.getCrosshairPosition=getCrosshairPosition;axis.getLinePath=getLinePath;axis.getOffset=getOffset;axis.getPlotBandPath=getPlotBandPath;axis.getPlotLinePath=getPlotLinePath;axis.getPosition=getPosition;axis.getTitlePosition=getTitlePosition;axis.postTranslate=postTranslate;axis.setAxisSize=setAxisSize;axis.setAxisTranslation=setAxisTranslation;axis.setOptions=setOptions}function modifyAsHidden(radialAxis){radialAxis.isHidden=true;radialAxis.createLabelCollector=createLabelCollectorHidden;radialAxis.getOffset=noop;radialAxis.redraw=renderHidden;radialAxis.render=renderHidden;radialAxis.setScale=noop;radialAxis.setCategories=noop;radialAxis.setTitle=noop}function onAxisAfterInit(){const chart=this.chart,options=this.options,isHidden=chart.angular&&this.isXAxis,pane=this.pane,paneOptions=pane&&pane.options;if(!isHidden&&pane&&(chart.angular||chart.polar)){const fullCircle=Math.PI*2,start=(pick(paneOptions.startAngle,0)-90)*Math.PI/180,end=(pick(paneOptions.endAngle,pick(paneOptions.startAngle,0)+360)-90)*Math.PI/180;this.angleRad=(options.angle||0)*Math.PI/180;this.startAngleRad=start;this.endAngleRad=end;this.offset=options.offset||0;let normalizedStart=(start%fullCircle+fullCircle)%fullCircle,normalizedEnd=(end%fullCircle+fullCircle)%fullCircle;if(normalizedStart>Math.PI){normalizedStart-=fullCircle}if(normalizedEnd>Math.PI){normalizedEnd-=fullCircle}this.normalizedStartAngleRad=normalizedStart;this.normalizedEndAngleRad=normalizedEnd}}function onAxisAutoLabelAlign(e){if(this.isRadial){e.align=void 0;e.preventDefault()}}function onAxisDestroy(){if(this.chart&&this.chart.labelCollectors){const index=this.labelCollector?this.chart.labelCollectors.indexOf(this.labelCollector):-1;if(index>=0){this.chart.labelCollectors.splice(index,1)}}}function onAxisInit(e){const chart=this.chart,angular=chart.angular,polar=chart.polar,isX=this.isXAxis,coll=this.coll,isHidden=angular&&isX,paneIndex=e.userOptions.pane||0,pane=this.pane=chart.pane&&chart.pane[paneIndex];let isCircular;if(coll==="colorAxis"){this.isRadial=false;return}if(angular){if(isHidden){modifyAsHidden(this)}else{modify(this)}isCircular=!isX}else if(polar){modify(this);isCircular=this.horiz}if(angular||polar){this.isRadial=true;if(!this.labelCollector){this.labelCollector=this.createLabelCollector()}if(this.labelCollector){chart.labelCollectors.push(this.labelCollector)}}else{this.isRadial=false}if(pane&&isCircular){pane.axis=this}this.isCircular=isCircular}function onAxisInitialAxisTranslation(){if(this.isRadial){this.beforeSetTickPositions()}}function onTickAfterGetLabelPosition(e){const label=this.label;if(!label){return}const axis=this.axis,labelBBox=label.getBBox(),labelOptions=axis.options.labels,angle=(axis.translate(this.pos)+axis.startAngleRad+Math.PI/2)/Math.PI*180%360,correctAngle=Math.round(angle),labelYPosCorrection=!defined(labelOptions.y)?-labelBBox.height*.3:0;let optionsY=labelOptions.y,ret,centerSlot=20,align=labelOptions.align,labelDir="end",reducedAngle1=correctAngle<0?correctAngle+360:correctAngle,reducedAngle2=reducedAngle1,translateY=0,translateX=0;if(axis.isRadial){ret=axis.getPosition(this.pos,axis.center[2]/2+relativeLength(pick(labelOptions.distance,-25),axis.center[2]/2,-axis.center[2]/2));if(labelOptions.rotation==="auto"){label.attr({rotation:angle})}else if(!defined(optionsY)){optionsY=axis.chart.renderer.fontMetrics(label).b-labelBBox.height/2}if(!defined(align)){if(axis.isCircular){if(labelBBox.width>axis.len*axis.tickInterval/(axis.max-axis.min)){centerSlot=0}if(angle>centerSlot&&angle<180-centerSlot){align="left"}else if(angle>180+centerSlot&&angle<360-centerSlot){align="right"}else{align="center"}}else{align="center"}label.attr({align:align})}if(align==="auto"&&axis.tickPositions.length===2&&axis.isCircular){if(reducedAngle1>90&&reducedAngle1<180){reducedAngle1=180-reducedAngle1}else if(reducedAngle1>270&&reducedAngle1<=360){reducedAngle1=540-reducedAngle1}if(reducedAngle2>180&&reducedAngle2<=360){reducedAngle2=360-reducedAngle2}if(axis.pane.options.startAngle===correctAngle||axis.pane.options.startAngle===correctAngle+360||axis.pane.options.startAngle===correctAngle-360){labelDir="start"}if(correctAngle>=-90&&correctAngle<=90||correctAngle>=-360&&correctAngle<=-270||correctAngle>=270&&correctAngle<=360){align=labelDir==="start"?"right":"left"}else{align=labelDir==="start"?"left":"right"}if(reducedAngle2>70&&reducedAngle2<110){align="center"}if(reducedAngle1<15||reducedAngle1>=180&&reducedAngle1<195){translateY=labelBBox.height*.3}else if(reducedAngle1>=15&&reducedAngle1<=35){translateY=labelDir==="start"?0:labelBBox.height*.75}else if(reducedAngle1>=195&&reducedAngle1<=215){translateY=labelDir==="start"?labelBBox.height*.75:0}else if(reducedAngle1>35&&reducedAngle1<=90){translateY=labelDir==="start"?-labelBBox.height*.25:labelBBox.height}else if(reducedAngle1>215&&reducedAngle1<=270){translateY=labelDir==="start"?labelBBox.height:-labelBBox.height*.25}if(reducedAngle2<15){translateX=labelDir==="start"?-labelBBox.height*.15:labelBBox.height*.15}else if(reducedAngle2>165&&reducedAngle2<=180){translateX=labelDir==="start"?labelBBox.height*.15:-labelBBox.height*.15}label.attr({align:align});label.translate(translateX,translateY+labelYPosCorrection)}e.pos.x=ret.x+(labelOptions.x||0);e.pos.y=ret.y+(optionsY||0)}}function onTickAfterGetPosition(e){if(this.axis.getPosition){extend(e.pos,this.axis.getPosition(this.pos))}}function onGlobalSetOptions({options}){if(options.xAxis){merge(true,RadialAxis.radialDefaultOptions.circular,options.xAxis)}if(options.yAxis){merge(true,RadialAxis.radialDefaultOptions.radialGauge,options.yAxis)}}function postTranslate(angle,radius){const chart=this.chart,center=this.center;angle=this.startAngleRad+angle;return{x:chart.plotLeft+center[0]+Math.cos(angle)*radius,y:chart.plotTop+center[1]+Math.sin(angle)*radius}}function renderHidden(){this.isDirty=false}function setAxisSize(){const axisProto=this.constructor.prototype;let center,start;axisProto.setAxisSize.call(this);if(this.isRadial){this.pane.updateCenter(this);center=this.center=this.pane.center.slice();if(this.isCircular){this.sector=this.endAngleRad-this.startAngleRad}else{start=this.postTranslate(this.angleRad,center[3]/2);center[0]=start.x-this.chart.plotLeft;center[1]=start.y-this.chart.plotTop}this.len=this.width=this.height=(center[2]-center[3])*pick(this.sector,1)/2}}function setAxisTranslation(){const axisProto=this.constructor.prototype;axisProto.setAxisTranslation.call(this);if(this.center){if(this.isCircular){this.transA=(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1)}else{this.transA=(this.center[2]-this.center[3])/2/(this.max-this.min||1)}if(this.isXAxis){this.minPixelPadding=this.transA*this.minPointOffset}else{this.minPixelPadding=0}}}function setOptions(userOptions){const{coll}=this;const{angular,inverted,polar}=this.chart;let defaultPolarOptions={};if(angular){if(!this.isXAxis){defaultPolarOptions=merge(defaultOptions.yAxis,RadialAxis.radialDefaultOptions.radialGauge)}}else if(polar){defaultPolarOptions=this.horiz?merge(defaultOptions.xAxis,RadialAxis.radialDefaultOptions.circular):merge(coll==="xAxis"?defaultOptions.xAxis:defaultOptions.yAxis,RadialAxis.radialDefaultOptions.radial)}if(inverted&&coll==="yAxis"){defaultPolarOptions.stackLabels=isObject(defaultOptions.yAxis,true)?defaultOptions.yAxis.stackLabels:{};defaultPolarOptions.reversedStacks=true}const options=this.options=merge(defaultPolarOptions,userOptions);if(!options.plotBands){options.plotBands=[]}fireEvent(this,"afterSetOptions")}function wrapTickGetMarkPath(proceed,x,y,tickLength,tickWidth,horiz,renderer){const axis=this.axis;let endPoint,ret;if(axis.isRadial){endPoint=axis.getPosition(this.pos,axis.center[2]/2+tickLength);ret=["M",x,y,"L",endPoint.x,endPoint.y]}else{ret=proceed.call(this,x,y,tickLength,tickWidth,horiz,renderer)}return ret}})(RadialAxis||(RadialAxis={}));export default RadialAxis;