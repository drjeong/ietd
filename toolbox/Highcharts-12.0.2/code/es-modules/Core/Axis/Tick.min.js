"use strict";import F from"../Templating.js";import H from"../Globals.js";const{deg2rad}=H;import U from"../Utilities.js";const{clamp,correctFloat,defined,destroyObjectProperties,extend,fireEvent,getAlignFactor,isNumber,merge,objectEach,pick}=U;class Tick{constructor(axis,pos,type,noLabel,parameters){this.isNew=true;this.isNewLabel=true;this.axis=axis;this.pos=pos;this.type=type||"";this.parameters=parameters||{};this.tickmarkOffset=this.parameters.tickmarkOffset;this.options=this.parameters.options;fireEvent(this,"init");if(!type&&!noLabel){this.addLabel()}}addLabel(){const tick=this,axis=tick.axis,options=axis.options,chart=axis.chart,categories=axis.categories,log=axis.logarithmic,names=axis.names,pos=tick.pos,labelOptions=pick(tick.options&&tick.options.labels,options.labels),tickPositions=axis.tickPositions,isFirst=pos===tickPositions[0],isLast=pos===tickPositions[tickPositions.length-1],animateLabels=(!labelOptions.step||labelOptions.step===1)&&axis.tickInterval===1,tickPositionInfo=tickPositions.info;let label=tick.label,dateTimeLabelFormat,dateTimeLabelFormats,i;let value=this.parameters.category||(categories?pick(categories[pos],names[pos],pos):pos);if(log&&isNumber(value)){value=correctFloat(log.lin2log(value))}if(axis.dateTime){if(tickPositionInfo){dateTimeLabelFormats=chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid&&tickPositionInfo.higherRanks[pos]||tickPositionInfo.unitName]);dateTimeLabelFormat=dateTimeLabelFormats.main}else if(isNumber(value)){dateTimeLabelFormat=axis.dateTime.getXDateFormat(value,options.dateTimeLabelFormats||{})}}tick.isFirst=isFirst;tick.isLast=isLast;const ctx={axis:axis,chart:chart,dateTimeLabelFormat:dateTimeLabelFormat,isFirst:isFirst,isLast:isLast,pos:pos,tick:tick,tickPositionInfo:tickPositionInfo,value:value};fireEvent(this,"labelFormat",ctx);const labelFormatter=ctx=>{if(labelOptions.formatter){return labelOptions.formatter.call(ctx,ctx)}if(labelOptions.format){ctx.text=axis.defaultLabelFormatter.call(ctx);return F.format(labelOptions.format,ctx,chart)}return axis.defaultLabelFormatter.call(ctx)};const str=labelFormatter.call(ctx,ctx);const list=dateTimeLabelFormats&&dateTimeLabelFormats.list;if(list){tick.shortenLabel=function(){for(i=0;i<list.length;i++){extend(ctx,{dateTimeLabelFormat:list[i]});label.attr({text:labelFormatter.call(ctx,ctx)});if(label.getBBox().width<axis.getSlotWidth(tick)-2*(labelOptions.padding||0)){return}}label.attr({text:""})}}else{tick.shortenLabel=void 0}if(animateLabels&&axis._addedPlotLB){tick.moveLabel(str,labelOptions)}if(!defined(label)&&!tick.movedLabel){tick.label=label=tick.createLabel(str,labelOptions);tick.rotation=0}else if(label&&label.textStr!==str&&!animateLabels){if(label.textWidth&&!labelOptions.style.width&&!label.styles.width){label.css({width:null})}label.attr({text:str});label.textPxLength=label.getBBox().width}}createLabel(str,labelOptions,xy){const axis=this.axis,{renderer,styledMode}=axis.chart,label=defined(str)&&labelOptions.enabled?renderer.text(str,xy?.x,xy?.y,labelOptions.useHTML).add(axis.labelGroup):void 0;if(label){const whiteSpace=labelOptions.style.whiteSpace||"normal";if(!styledMode){label.css(merge(labelOptions.style,{whiteSpace:"nowrap"}))}label.textPxLength=label.getBBox().width;if(!styledMode){label.css({whiteSpace:whiteSpace})}}return label}destroy(){destroyObjectProperties(this,this.axis)}getPosition(horiz,tickPos,tickmarkOffset,old){const axis=this.axis,chart=axis.chart,cHeight=old&&chart.oldChartHeight||chart.chartHeight,pos={x:horiz?correctFloat(axis.translate(tickPos+tickmarkOffset,void 0,void 0,old)+axis.transB):axis.left+axis.offset+(axis.opposite?(old&&chart.oldChartWidth||chart.chartWidth)-axis.right-axis.left:0),y:horiz?cHeight-axis.bottom+axis.offset-(axis.opposite?axis.height:0):correctFloat(cHeight-axis.translate(tickPos+tickmarkOffset,void 0,void 0,old)-axis.transB)};pos.y=clamp(pos.y,-1e9,1e9);fireEvent(this,"afterGetPosition",{pos:pos});return pos}getLabelPosition(x,y,label,horiz,labelOptions,tickmarkOffset,index,step){const axis=this.axis,transA=axis.transA,reversed=axis.isLinked&&axis.linkedParent?axis.linkedParent.reversed:axis.reversed,staggerLines=axis.staggerLines,rotCorr=axis.tickRotCorr||{x:0,y:0},labelOffsetCorrection=!horiz&&!axis.reserveSpaceDefault?-axis.labelOffset*(axis.labelAlign==="center"?.5:1):0,distance=labelOptions.distance,pos={};let yOffset,line;if(axis.side===0){yOffset=label.rotation?-distance:-label.getBBox().height}else if(axis.side===2){yOffset=rotCorr.y+distance}else{yOffset=Math.cos(label.rotation*deg2rad)*(rotCorr.y-label.getBBox(false,0).height/2)}if(defined(labelOptions.y)){yOffset=axis.side===0&&axis.horiz?labelOptions.y+yOffset:labelOptions.y}x=x+pick(labelOptions.x,[0,1,0,-1][axis.side]*distance)+labelOffsetCorrection+rotCorr.x-(tickmarkOffset&&horiz?tickmarkOffset*transA*(reversed?-1:1):0);y=y+yOffset-(tickmarkOffset&&!horiz?tickmarkOffset*transA*(reversed?1:-1):0);if(staggerLines){line=index/(step||1)%staggerLines;if(axis.opposite){line=staggerLines-line-1}y+=line*(axis.labelOffset/staggerLines)}pos.x=x;pos.y=Math.round(y);fireEvent(this,"afterGetLabelPosition",{pos:pos,tickmarkOffset:tickmarkOffset,index:index});return pos}getLabelSize(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0}getMarkPath(x,y,tickLength,tickWidth,horiz=false,renderer){return renderer.crispLine([["M",x,y],["L",x+(horiz?0:-tickLength),y+(horiz?tickLength:0)]],tickWidth)}handleOverflow(xy){const tick=this,axis=this.axis,labelOptions=axis.options.labels,pxPos=xy.x,chartWidth=axis.chart.chartWidth,spacing=axis.chart.spacing,leftBound=pick(axis.labelLeft,Math.min(axis.pos,spacing[3])),rightBound=pick(axis.labelRight,Math.max(!axis.isRadial?axis.pos+axis.len:0,chartWidth-spacing[1])),label=this.label,rotation=this.rotation,factor=getAlignFactor(axis.labelAlign||label.attr("align")),labelWidth=label.getBBox().width,slotWidth=axis.getSlotWidth(tick),xCorrection=factor,css={};let modifiedSlotWidth=slotWidth,goRight=1,leftPos,rightPos,textWidth;if(!rotation&&labelOptions.overflow==="justify"){leftPos=pxPos-factor*labelWidth;rightPos=pxPos+(1-factor)*labelWidth;if(leftPos<leftBound){modifiedSlotWidth=xy.x+modifiedSlotWidth*(1-factor)-leftBound}else if(rightPos>rightBound){modifiedSlotWidth=rightBound-xy.x+modifiedSlotWidth*factor;goRight=-1}modifiedSlotWidth=Math.min(slotWidth,modifiedSlotWidth);if(modifiedSlotWidth<slotWidth&&axis.labelAlign==="center"){xy.x+=goRight*(slotWidth-modifiedSlotWidth-xCorrection*(slotWidth-Math.min(labelWidth,modifiedSlotWidth)))}if(labelWidth>modifiedSlotWidth||axis.autoRotation&&(label.styles||{}).width){textWidth=modifiedSlotWidth}}else if(rotation<0&&pxPos-factor*labelWidth<leftBound){textWidth=Math.round(pxPos/Math.cos(rotation*deg2rad)-leftBound)}else if(rotation>0&&pxPos+factor*labelWidth>rightBound){textWidth=Math.round((chartWidth-pxPos)/Math.cos(rotation*deg2rad))}if(textWidth&&label){if(tick.shortenLabel){tick.shortenLabel()}else{label.css(extend(css,{width:Math.floor(textWidth)+"px",lineClamp:axis.isRadial?0:1}))}}}moveLabel(str,labelOptions){const tick=this,label=tick.label,axis=tick.axis;let moved=false,labelPos;if(label&&label.textStr===str){tick.movedLabel=label;moved=true;delete tick.label}else{objectEach(axis.ticks,function(currentTick){if(!moved&&!currentTick.isNew&&currentTick!==tick&&currentTick.label&&currentTick.label.textStr===str){tick.movedLabel=currentTick.label;moved=true;currentTick.labelPos=tick.movedLabel.xy;delete currentTick.label}})}if(!moved&&(tick.labelPos||label)){labelPos=tick.labelPos||label.xy;tick.movedLabel=tick.createLabel(str,labelOptions,labelPos);if(tick.movedLabel){tick.movedLabel.attr({opacity:0})}}}render(index,old,opacity){const tick=this,axis=tick.axis,horiz=axis.horiz,pos=tick.pos,tickmarkOffset=pick(tick.tickmarkOffset,axis.tickmarkOffset),xy=tick.getPosition(horiz,pos,tickmarkOffset,old),x=xy.x,y=xy.y,axisStart=axis.pos,axisEnd=axisStart+axis.len,pxPos=horiz?x:y;if(!axis.chart.polar&&tick.isNew&&(correctFloat(pxPos)<axisStart||pxPos>axisEnd)){opacity=0}const labelOpacity=pick(opacity,tick.label&&tick.label.newOpacity,1);opacity=pick(opacity,1);this.isActive=true;this.renderGridLine(old,opacity);this.renderMark(xy,opacity);this.renderLabel(xy,old,labelOpacity,index);tick.isNew=false;fireEvent(this,"afterRender")}renderGridLine(old,opacity){const tick=this,axis=tick.axis,options=axis.options,attribs={},pos=tick.pos,type=tick.type,tickmarkOffset=pick(tick.tickmarkOffset,axis.tickmarkOffset),renderer=axis.chart.renderer;let gridLine=tick.gridLine,gridLinePath,gridLineWidth=options.gridLineWidth,gridLineColor=options.gridLineColor,dashStyle=options.gridLineDashStyle;if(tick.type==="minor"){gridLineWidth=options.minorGridLineWidth;gridLineColor=options.minorGridLineColor;dashStyle=options.minorGridLineDashStyle}if(!gridLine){if(!axis.chart.styledMode){attribs.stroke=gridLineColor;attribs["stroke-width"]=gridLineWidth||0;attribs.dashstyle=dashStyle}if(!type){attribs.zIndex=1}if(old){opacity=0}tick.gridLine=gridLine=renderer.path().attr(attribs).addClass("highcharts-"+(type?type+"-":"")+"grid-line").add(axis.gridGroup)}if(gridLine){gridLinePath=axis.getPlotLinePath({value:pos+tickmarkOffset,lineWidth:gridLine.strokeWidth(),force:"pass",old:old,acrossPanes:false});if(gridLinePath){gridLine[old||tick.isNew?"attr":"animate"]({d:gridLinePath,opacity:opacity})}}}renderMark(xy,opacity){const tick=this,axis=tick.axis,options=axis.options,renderer=axis.chart.renderer,type=tick.type,tickSize=axis.tickSize(type?type+"Tick":"tick"),x=xy.x,y=xy.y,tickWidth=pick(options[type!=="minor"?"tickWidth":"minorTickWidth"],!type&&axis.isXAxis?1:0),tickColor=options[type!=="minor"?"tickColor":"minorTickColor"];let mark=tick.mark;const isNewMark=!mark;if(tickSize){if(axis.opposite){tickSize[0]=-tickSize[0]}if(!mark){tick.mark=mark=renderer.path().addClass("highcharts-"+(type?type+"-":"")+"tick").add(axis.axisGroup);if(!axis.chart.styledMode){mark.attr({stroke:tickColor,"stroke-width":tickWidth})}}mark[isNewMark?"attr":"animate"]({d:tick.getMarkPath(x,y,tickSize[0],mark.strokeWidth(),axis.horiz,renderer),opacity:opacity})}}renderLabel(xy,old,opacity,index){const tick=this,axis=tick.axis,horiz=axis.horiz,options=axis.options,label=tick.label,labelOptions=options.labels,step=labelOptions.step,tickmarkOffset=pick(tick.tickmarkOffset,axis.tickmarkOffset),x=xy.x,y=xy.y;let show=true;if(label&&isNumber(x)){label.xy=xy=tick.getLabelPosition(x,y,label,horiz,labelOptions,tickmarkOffset,index,step);if(tick.isFirst&&!tick.isLast&&!options.showFirstLabel||tick.isLast&&!tick.isFirst&&!options.showLastLabel){show=false}else if(horiz&&!labelOptions.step&&!labelOptions.rotation&&!old&&opacity!==0){tick.handleOverflow(xy)}if(step&&index%step){show=false}if(show&&isNumber(xy.y)){xy.opacity=opacity;label[tick.isNewLabel?"attr":"animate"](xy).show(true);tick.isNewLabel=false}else{label.hide();tick.isNewLabel=true}}}replaceMovedLabel(){const tick=this,label=tick.label,axis=tick.axis;if(label&&!tick.isNew){label.animate({opacity:0},void 0,label.destroy);delete tick.label}axis.isDirty=true;tick.label=tick.movedLabel;delete tick.movedLabel}}export default Tick;"";