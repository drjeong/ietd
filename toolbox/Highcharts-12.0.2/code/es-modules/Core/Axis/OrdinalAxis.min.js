"use strict";import Axis from"./Axis.js";import DataTableCore from"../../Data/DataTableCore.js";import H from"../Globals.js";import U from"../Utilities.js";const{addEvent,correctFloat,css,defined,error,isNumber,pick,timeUnits,isString}=U;var OrdinalAxis;(function(OrdinalAxis){function compose(AxisClass,SeriesClass,ChartClass){const axisProto=AxisClass.prototype;if(!axisProto.ordinal2lin){axisProto.getTimeTicks=getTimeTicks;axisProto.index2val=index2val;axisProto.lin2val=lin2val;axisProto.val2lin=val2lin;axisProto.ordinal2lin=axisProto.val2lin;addEvent(AxisClass,"afterInit",onAxisAfterInit);addEvent(AxisClass,"foundExtremes",onAxisFoundExtremes);addEvent(AxisClass,"afterSetScale",onAxisAfterSetScale);addEvent(AxisClass,"initialAxisTranslation",onAxisInitialAxisTranslation);addEvent(ChartClass,"pan",onChartPan);addEvent(ChartClass,"touchpan",onChartPan);addEvent(SeriesClass,"updatedData",onSeriesUpdatedData)}return AxisClass}OrdinalAxis.compose=compose;function getTimeTicks(normalizedInterval,min,max,startOfWeek,positions=[],closestDistance=0,findHigherRanks){const higherRanks={},tickPixelIntervalOption=this.options.tickPixelInterval,time=this.chart.time,segmentStarts=[];let end,segmentPositions,hasCrossedHigherRank,info,outsideMax,start=0,groupPositions=[],lastGroupPosition=-Number.MAX_VALUE;if(!this.options.ordinal&&!this.options.breaks||!positions||positions.length<3||typeof min==="undefined"){return time.getTimeTicks.apply(time,arguments)}const posLength=positions.length;for(end=0;end<posLength;end++){outsideMax=end&&positions[end-1]>max;if(positions[end]<min){start=end}if(end===posLength-1||positions[end+1]-positions[end]>closestDistance*5||outsideMax){if(positions[end]>lastGroupPosition){segmentPositions=time.getTimeTicks(normalizedInterval,positions[start],positions[end],startOfWeek);while(segmentPositions.length&&segmentPositions[0]<=lastGroupPosition){segmentPositions.shift()}if(segmentPositions.length){lastGroupPosition=segmentPositions[segmentPositions.length-1]}segmentStarts.push(groupPositions.length);groupPositions=groupPositions.concat(segmentPositions)}start=end+1}if(outsideMax){break}}if(segmentPositions){info=segmentPositions.info;if(findHigherRanks&&info.unitRange<=timeUnits.hour){end=groupPositions.length-1;for(start=1;start<end;start++){if(time.dateFormat("%d",groupPositions[start])!==time.dateFormat("%d",groupPositions[start-1])){higherRanks[groupPositions[start]]="day";hasCrossedHigherRank=true}}if(hasCrossedHigherRank){higherRanks[groupPositions[0]]="day"}info.higherRanks=higherRanks}info.segmentStarts=segmentStarts;groupPositions.info=info}else{error(12,false,this.chart)}if(findHigherRanks&&defined(tickPixelIntervalOption)){const length=groupPositions.length,translatedArr=[],distances=[];let itemToRemove,translated,lastTranslated,medianDistance,distance,i=length;while(i--){translated=this.translate(groupPositions[i]);if(lastTranslated){distances[i]=lastTranslated-translated}translatedArr[i]=lastTranslated=translated}distances.sort((a,b)=>a-b);medianDistance=distances[Math.floor(distances.length/2)];if(medianDistance<tickPixelIntervalOption*.6){medianDistance=null}i=groupPositions[length-1]>max?length-1:length;lastTranslated=void 0;while(i--){translated=translatedArr[i];distance=Math.abs(lastTranslated-translated);if(lastTranslated&&distance<tickPixelIntervalOption*.8&&(medianDistance===null||distance<medianDistance*.8)){if(higherRanks[groupPositions[i]]&&!higherRanks[groupPositions[i+1]]){itemToRemove=i+1;lastTranslated=translated}else{itemToRemove=i}groupPositions.splice(itemToRemove,1)}else{lastTranslated=translated}}}return groupPositions}function index2val(index){const axis=this,ordinal=axis.ordinal,ordinalPositions=ordinal.positions;if(!ordinalPositions){return index}let i=ordinalPositions.length-1,distance;if(index<0){index=ordinalPositions[0]}else if(index>i){index=ordinalPositions[i]}else{i=Math.floor(index);distance=index-i}if(typeof distance!=="undefined"&&typeof ordinalPositions[i]!=="undefined"){return ordinalPositions[i]+(distance?distance*(ordinalPositions[i+1]-ordinalPositions[i]):0)}return index}function lin2val(val){const axis=this,ordinal=axis.ordinal,localMin=axis.old?axis.old.min:axis.min,localA=axis.old?axis.old.transA:axis.transA;const positions=ordinal.getExtendedPositions();if(positions?.length){const pixelVal=correctFloat((val-localMin)*localA+axis.minPixelPadding),index=correctFloat(ordinal.getIndexOfPoint(pixelVal,positions)),mantissa=correctFloat(index%1);if(index>=0&&index<=positions.length-1){const leftNeighbour=positions[Math.floor(index)],rightNeighbour=positions[Math.ceil(index)],distance=rightNeighbour-leftNeighbour;return positions[Math.floor(index)]+mantissa*distance}}return val}function getIndexInArray(ordinalPositions,val){const index=OrdinalAxis.Additions.findIndexOf(ordinalPositions,val,true);if(ordinalPositions[index]===val){return index}const percent=(val-ordinalPositions[index])/(ordinalPositions[index+1]-ordinalPositions[index]);return index+percent}function onAxisAfterInit(){const axis=this;if(!axis.ordinal){axis.ordinal=new OrdinalAxis.Additions(axis)}}function onAxisFoundExtremes(){const axis=this,{eventArgs,options}=axis;if(axis.isXAxis&&defined(options.overscroll)&&options.overscroll!==0&&isNumber(axis.max)&&isNumber(axis.min)){if(axis.options.ordinal&&!axis.ordinal.originalOrdinalRange){axis.ordinal.getExtendedPositions(false)}if(axis.max===axis.dataMax&&(eventArgs?.trigger!=="pan"||axis.isInternal)&&eventArgs?.trigger!=="navigator"){const overscroll=axis.ordinal.convertOverscroll(options.overscroll);axis.max+=overscroll;if(!axis.isInternal&&defined(axis.userMin)&&eventArgs?.trigger!=="mousewheel"){axis.min+=overscroll}}}}function onAxisAfterSetScale(){const axis=this;if(axis.horiz&&!axis.isDirty){axis.isDirty=axis.isOrdinal&&axis.chart.navigator&&!axis.chart.navigator.adaptToUpdatedData}}function onAxisInitialAxisTranslation(){const axis=this;if(axis.ordinal){axis.ordinal.beforeSetTickPositions();axis.tickInterval=axis.ordinal.postProcessTickInterval(axis.tickInterval)}}function onChartPan(e){const chart=this,xAxis=chart.xAxis[0],overscroll=xAxis.ordinal.convertOverscroll(xAxis.options.overscroll),chartX=e.originalEvent.chartX,panning=chart.options.chart.panning;let runBase=false;if(panning&&panning.type!=="y"&&xAxis.options.ordinal&&xAxis.series.length&&(!e.touches||e.touches.length<=1)){const mouseDownX=chart.mouseDownX,extremes=xAxis.getExtremes(),dataMin=extremes.dataMin,dataMax=extremes.dataMax,min=extremes.min,max=extremes.max,hoverPoints=chart.hoverPoints,closestPointRange=xAxis.closestPointRange||xAxis.ordinal&&xAxis.ordinal.overscrollPointsRange,pointPixelWidth=xAxis.translationSlope*(xAxis.ordinal.slope||closestPointRange),movedUnits=Math.round((mouseDownX-chartX)/pointPixelWidth),extendedOrdinalPositions=xAxis.ordinal.getExtendedPositions(),extendedAxis={ordinal:{positions:extendedOrdinalPositions,extendedOrdinalPositions:extendedOrdinalPositions}},index2val=xAxis.index2val,val2lin=xAxis.val2lin;let trimmedRange,ordinalPositions;if(min<=dataMin&&movedUnits<0||max+overscroll>=dataMax&&movedUnits>0){return}if(!extendedAxis.ordinal.positions){runBase=true}else if(Math.abs(movedUnits)>1){if(hoverPoints){hoverPoints.forEach(function(point){point.setState()})}ordinalPositions=extendedAxis.ordinal.positions;if(dataMax>ordinalPositions[ordinalPositions.length-1]){ordinalPositions.push(dataMax)}chart.setFixedRange(max-min);trimmedRange=xAxis.navigatorAxis.toFixedRange(void 0,void 0,index2val.apply(extendedAxis,[val2lin.apply(extendedAxis,[min,true])+movedUnits]),index2val.apply(extendedAxis,[val2lin.apply(extendedAxis,[max,true])+movedUnits]));if(trimmedRange.min>=Math.min(ordinalPositions[0],min)&&trimmedRange.max<=Math.max(ordinalPositions[ordinalPositions.length-1],max)+overscroll){xAxis.setExtremes(trimmedRange.min,trimmedRange.max,true,false,{trigger:"pan"})}chart.mouseDownX=chartX;css(chart.container,{cursor:"move"})}}else{runBase=true}if(runBase||panning&&/y/.test(panning.type)){if(overscroll){xAxis.max=xAxis.dataMax+overscroll}}else{e.preventDefault()}}function onSeriesUpdatedData(){const xAxis=this.xAxis;if(xAxis&&xAxis.options.ordinal){delete xAxis.ordinal.index;delete xAxis.ordinal.originalOrdinalRange}}function val2lin(val,toIndex){const axis=this,ordinal=axis.ordinal,ordinalPositions=ordinal.positions;let slope=ordinal.slope,extendedOrdinalPositions;if(!ordinalPositions){return val}const ordinalLength=ordinalPositions.length;let ordinalIndex;if(ordinalPositions[0]<=val&&ordinalPositions[ordinalLength-1]>=val){ordinalIndex=getIndexInArray(ordinalPositions,val)}else{extendedOrdinalPositions=ordinal.getExtendedPositions&&ordinal.getExtendedPositions();if(!(extendedOrdinalPositions&&extendedOrdinalPositions.length)){return val}const length=extendedOrdinalPositions.length;if(!slope){slope=(extendedOrdinalPositions[length-1]-extendedOrdinalPositions[0])/length}const originalPositionsReference=getIndexInArray(extendedOrdinalPositions,ordinalPositions[0]);if(val>=extendedOrdinalPositions[0]&&val<=extendedOrdinalPositions[length-1]){ordinalIndex=getIndexInArray(extendedOrdinalPositions,val)-originalPositionsReference}else{if(!toIndex){return val}if(val<extendedOrdinalPositions[0]){const diff=extendedOrdinalPositions[0]-val,approximateIndexOffset=diff/slope;ordinalIndex=-originalPositionsReference-approximateIndexOffset}else{const diff=val-extendedOrdinalPositions[length-1],approximateIndexOffset=diff/slope;ordinalIndex=approximateIndexOffset+length-originalPositionsReference}}}return toIndex?ordinalIndex:slope*(ordinalIndex||0)+ordinal.offset}class Additions{constructor(axis){this.index={};this.axis=axis}beforeSetTickPositions(){const axis=this.axis,ordinal=axis.ordinal,extremes=axis.getExtremes(),min=extremes.min,max=extremes.max,hasBreaks=axis.brokenAxis?.hasBreaks,isOrdinal=axis.options.ordinal;let len,uniqueOrdinalPositions,dist,minIndex,maxIndex,slope,i,ordinalPositions=[],overscrollPointsRange=Number.MAX_VALUE,useOrdinal=false,adjustOrdinalExtremesPoints=false,isBoosted=false;if(isOrdinal||hasBreaks){let distanceBetweenPoint=0;axis.series.forEach(function(series,i){const xData=series.getColumn("x",true);uniqueOrdinalPositions=[];if(i>0&&series.options.id!=="highcharts-navigator-series"&&xData.length>1){adjustOrdinalExtremesPoints=distanceBetweenPoint!==xData[1]-xData[0]}distanceBetweenPoint=xData[1]-xData[0];if(series.boosted){isBoosted=series.boosted}if(series.reserveSpace()&&(series.takeOrdinalPosition!==false||hasBreaks)){ordinalPositions=ordinalPositions.concat(xData);len=ordinalPositions.length;ordinalPositions.sort(function(a,b){return a-b});overscrollPointsRange=Math.min(overscrollPointsRange,pick(series.closestPointRange,overscrollPointsRange));if(len){i=0;while(i<len-1){if(ordinalPositions[i]!==ordinalPositions[i+1]){uniqueOrdinalPositions.push(ordinalPositions[i+1])}i++}if(uniqueOrdinalPositions[0]!==ordinalPositions[0]){uniqueOrdinalPositions.unshift(ordinalPositions[0])}ordinalPositions=uniqueOrdinalPositions}}});if(!axis.ordinal.originalOrdinalRange){axis.ordinal.originalOrdinalRange=(ordinalPositions.length-1)*overscrollPointsRange}if(adjustOrdinalExtremesPoints&&isBoosted){ordinalPositions.pop();ordinalPositions.shift()}len=ordinalPositions.length;if(len>2){dist=ordinalPositions[1]-ordinalPositions[0];i=len-1;while(i--&&!useOrdinal){if(ordinalPositions[i+1]-ordinalPositions[i]!==dist){useOrdinal=true}}if(!axis.options.keepOrdinalPadding&&(ordinalPositions[0]-min>dist||max-ordinalPositions[ordinalPositions.length-1]>dist)){useOrdinal=true}}else if(axis.options.overscroll){if(len===2){overscrollPointsRange=ordinalPositions[1]-ordinalPositions[0]}else if(len===1){overscrollPointsRange=axis.ordinal.convertOverscroll(axis.options.overscroll);ordinalPositions=[ordinalPositions[0],ordinalPositions[0]+overscrollPointsRange]}else{overscrollPointsRange=ordinal.overscrollPointsRange}}if(useOrdinal||axis.forceOrdinal){if(axis.options.overscroll){ordinal.overscrollPointsRange=overscrollPointsRange;ordinalPositions=ordinalPositions.concat(ordinal.getOverscrollPositions())}ordinal.positions=ordinalPositions;minIndex=axis.ordinal2lin(Math.max(min,ordinalPositions[0]),true);maxIndex=Math.max(axis.ordinal2lin(Math.min(max,ordinalPositions[ordinalPositions.length-1]),true),1);ordinal.slope=slope=(max-min)/(maxIndex-minIndex);ordinal.offset=min-minIndex*slope}else{ordinal.overscrollPointsRange=pick(axis.closestPointRange,ordinal.overscrollPointsRange);ordinal.positions=axis.ordinal.slope=ordinal.offset=void 0}}axis.isOrdinal=isOrdinal&&useOrdinal;ordinal.groupIntervalFactor=null}static findIndexOf(sortedArray,key,indirectSearch){let start=0,end=sortedArray.length-1,middle;while(start<end){middle=Math.ceil((start+end)/2);if(sortedArray[middle]<=key){start=middle}else{end=middle-1}}if(sortedArray[start]===key){return start}return!indirectSearch?-1:start}getExtendedPositions(withOverscroll=true){const ordinal=this,axis=ordinal.axis,axisProto=axis.constructor.prototype,chart=axis.chart,key=axis.series.reduce((k,series)=>{const grouping=series.currentDataGrouping;return k+(grouping?grouping.count+grouping.unitName:"raw")},""),overscroll=withOverscroll?axis.ordinal.convertOverscroll(axis.options.overscroll):0,extremes=axis.getExtremes();let fakeAxis,fakeSeries=void 0,ordinalIndex=ordinal.index;if(!ordinalIndex){ordinalIndex=ordinal.index={}}if(!ordinalIndex[key]){fakeAxis={series:[],chart:chart,forceOrdinal:false,getExtremes:function(){return{min:extremes.dataMin,max:extremes.dataMax+overscroll}},applyGrouping:axisProto.applyGrouping,getGroupPixelWidth:axisProto.getGroupPixelWidth,getTimeTicks:axisProto.getTimeTicks,options:{ordinal:true},ordinal:{getGroupIntervalFactor:this.getGroupIntervalFactor},ordinal2lin:axisProto.ordinal2lin,getIndexOfPoint:axisProto.getIndexOfPoint,val2lin:axisProto.val2lin};fakeAxis.ordinal.axis=fakeAxis;axis.series.forEach(series=>{fakeSeries={xAxis:fakeAxis,chart:chart,groupPixelWidth:series.groupPixelWidth,destroyGroupedData:H.noop,getColumn:series.getColumn,applyGrouping:series.applyGrouping,getProcessedData:series.getProcessedData,reserveSpace:series.reserveSpace,visible:series.visible};const xData=series.getColumn("x").concat(withOverscroll?ordinal.getOverscrollPositions():[]);fakeSeries.dataTable=new DataTableCore({columns:{x:xData}});fakeSeries.options={...series.options,dataGrouping:series.currentDataGrouping?{firstAnchor:series.options.dataGrouping?.firstAnchor,anchor:series.options.dataGrouping?.anchor,lastAnchor:series.options.dataGrouping?.firstAnchor,enabled:true,forced:true,approximation:"open",units:[[series.currentDataGrouping.unitName,[series.currentDataGrouping.count]]]}:{enabled:false}};fakeAxis.series.push(fakeSeries);series.processData.apply(fakeSeries)});fakeAxis.applyGrouping({hasExtremesChanged:true});if(fakeSeries?.closestPointRange!==fakeSeries?.basePointRange&&fakeSeries.currentDataGrouping){fakeAxis.forceOrdinal=true}axis.ordinal.beforeSetTickPositions.apply({axis:fakeAxis});if(!axis.ordinal.originalOrdinalRange&&fakeAxis.ordinal.originalOrdinalRange){axis.ordinal.originalOrdinalRange=fakeAxis.ordinal.originalOrdinalRange}if(fakeAxis.ordinal.positions){ordinalIndex[key]=fakeAxis.ordinal.positions}}return ordinalIndex[key]}getGroupIntervalFactor(xMin,xMax,series){const ordinal=this,processedXData=series.getColumn("x",true),len=processedXData.length,distances=[];let median,i,groupIntervalFactor=ordinal.groupIntervalFactor;if(!groupIntervalFactor){for(i=0;i<len-1;i++){distances[i]=processedXData[i+1]-processedXData[i]}distances.sort(function(a,b){return a-b});median=distances[Math.floor(len/2)];xMin=Math.max(xMin,processedXData[0]);xMax=Math.min(xMax,processedXData[len-1]);ordinal.groupIntervalFactor=groupIntervalFactor=len*median/(xMax-xMin)}return groupIntervalFactor}getIndexOfPoint(pixelVal,ordinalArray){const ordinal=this,axis=ordinal.axis,min=axis.min,minX=axis.minPixelPadding,indexOfMin=getIndexInArray(ordinalArray,min);const ordinalPointPixelInterval=axis.translationSlope*(ordinal.slope||axis.closestPointRange||ordinal.overscrollPointsRange);const shiftIndex=correctFloat((pixelVal-minX)/ordinalPointPixelInterval);return indexOfMin+shiftIndex}getOverscrollPositions(){const ordinal=this,axis=ordinal.axis,extraRange=ordinal.convertOverscroll(axis.options.overscroll),distance=ordinal.overscrollPointsRange,positions=[];let max=axis.dataMax;if(defined(distance)){while(max<axis.dataMax+extraRange){max+=distance;positions.push(max)}}return positions}postProcessTickInterval(tickInterval){const ordinal=this,axis=ordinal.axis,ordinalSlope=ordinal.slope,closestPointRange=axis.closestPointRange;let ret;if(ordinalSlope&&closestPointRange){if(!axis.options.breaks){ret=tickInterval/(ordinalSlope/closestPointRange)}else{ret=closestPointRange||tickInterval}}else{ret=tickInterval}return ret}convertOverscroll(overscroll=0){const ordinal=this,axis=ordinal.axis,calculateOverscroll=function(overscrollPercentage){return pick(ordinal.originalOrdinalRange,defined(axis.dataMax)&&defined(axis.dataMin)?axis.dataMax-axis.dataMin:0)*overscrollPercentage};if(isString(overscroll)){const overscrollValue=parseInt(overscroll,10);if(/%$/.test(overscroll)){return calculateOverscroll(overscrollValue/100)}if(/px/.test(overscroll)){const limitedOverscrollValue=Math.min(overscrollValue,axis.len*.9),pixelToPercent=limitedOverscrollValue/axis.len;return calculateOverscroll(pixelToPercent/(1-pixelToPercent))}return 0}return overscroll}}OrdinalAxis.Additions=Additions})(OrdinalAxis||(OrdinalAxis={}));export default OrdinalAxis;