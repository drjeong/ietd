"use strict";import A from"../Animation/AnimationUtilities.js";const{animObject}=A;import AxisDefaults from"./AxisDefaults.js";const{xAxis,yAxis}=AxisDefaults;import Color from"../Color/Color.js";import D from"../Defaults.js";const{defaultOptions}=D;import F from"../Foundation.js";const{registerEventOptions}=F;import H from"../Globals.js";const{deg2rad}=H;import Tick from"./Tick.js";import U from"../Utilities.js";const{arrayMax,arrayMin,clamp,correctFloat,defined,destroyObjectProperties,erase,error,extend,fireEvent,getClosestDistance,insertItem,isArray,isNumber,isString,merge,normalizeTickInterval,objectEach,pick,relativeLength,removeEvent,splat,syncTimeout}=U;const getNormalizedTickInterval=(axis,tickInterval)=>normalizeTickInterval(tickInterval,void 0,void 0,pick(axis.options.allowDecimals,tickInterval<.5||axis.tickAmount!==void 0),!!axis.tickAmount);extend(defaultOptions,{xAxis:xAxis,yAxis:merge(xAxis,yAxis)});class Axis{constructor(chart,userOptions,coll){this.init(chart,userOptions,coll)}init(chart,userOptions,coll=this.coll){const isXAxis=coll==="xAxis",axis=this,horiz=axis.isZAxis||(chart.inverted?!isXAxis:isXAxis);axis.chart=chart;axis.horiz=horiz;axis.isXAxis=isXAxis;axis.coll=coll;fireEvent(this,"init",{userOptions:userOptions});axis.opposite=pick(userOptions.opposite,axis.opposite);axis.side=pick(userOptions.side,axis.side,horiz?axis.opposite?0:2:axis.opposite?1:3);axis.setOptions(userOptions);const options=axis.options,labelsOptions=options.labels;axis.type??(axis.type=options.type||"linear");axis.uniqueNames??(axis.uniqueNames=options.uniqueNames??true);fireEvent(axis,"afterSetType");axis.userOptions=userOptions;axis.minPixelPadding=0;axis.reversed=pick(options.reversed,axis.reversed);axis.visible=options.visible;axis.zoomEnabled=options.zoomEnabled;axis.hasNames=this.type==="category"||options.categories===true;axis.categories=isArray(options.categories)&&options.categories||(axis.hasNames?[]:void 0);if(!axis.names){axis.names=[];axis.names.keys={}}axis.plotLinesAndBandsGroups={};axis.positiveValuesOnly=!!axis.logarithmic;axis.isLinked=defined(options.linkedTo);axis.ticks={};axis.labelEdge=[];axis.minorTicks={};axis.plotLinesAndBands=[];axis.alternateBands={};axis.len??(axis.len=0);axis.minRange=axis.userMinRange=options.minRange||options.maxZoom;axis.range=options.range;axis.offset=options.offset||0;axis.max=void 0;axis.min=void 0;const crosshair=pick(options.crosshair,splat(chart.options.tooltip.crosshairs)[isXAxis?0:1]);axis.crosshair=crosshair===true?{}:crosshair;if(chart.axes.indexOf(axis)===-1){if(isXAxis){chart.axes.splice(chart.xAxis.length,0,axis)}else{chart.axes.push(axis)}insertItem(this,chart[this.coll])}chart.orderItems(axis.coll);axis.series=axis.series||[];if(chart.inverted&&!axis.isZAxis&&isXAxis&&!defined(axis.reversed)){axis.reversed=true}axis.labelRotation=isNumber(labelsOptions.rotation)?labelsOptions.rotation:void 0;registerEventOptions(axis,options);fireEvent(this,"afterInit")}setOptions(userOptions){const sideSpecific=this.horiz?{labels:{autoRotation:[-45],padding:3},margin:15}:{labels:{padding:1},title:{rotation:90*this.side}};this.options=merge(sideSpecific,defaultOptions[this.coll],userOptions);fireEvent(this,"afterSetOptions",{userOptions:userOptions})}defaultLabelFormatter(){const axis=this.axis,chart=this.chart,{numberFormatter}=chart,value=isNumber(this.value)?this.value:NaN,time=axis.chart.time,categories=axis.categories,dateTimeLabelFormat=this.dateTimeLabelFormat,lang=defaultOptions.lang,numericSymbols=lang.numericSymbols,numSymMagnitude=lang.numericSymbolMagnitude||1e3,numericSymbolDetector=axis.logarithmic?Math.abs(value):axis.tickInterval;let i=numericSymbols&&numericSymbols.length,multi,ret;if(categories){ret=`${this.value}`}else if(dateTimeLabelFormat){ret=time.dateFormat(dateTimeLabelFormat,value,true)}else if(i&&numericSymbols&&numericSymbolDetector>=1e3){while(i--&&typeof ret==="undefined"){multi=Math.pow(numSymMagnitude,i+1);if(numericSymbolDetector>=multi&&value*10%multi===0&&numericSymbols[i]!==null&&value!==0){ret=numberFormatter(value/multi,-1)+numericSymbols[i]}}}if(typeof ret==="undefined"){if(Math.abs(value)>=1e4){ret=numberFormatter(value,-1)}else{ret=numberFormatter(value,-1,void 0,"")}}return ret}getSeriesExtremes(){const axis=this;let xExtremes;fireEvent(this,"getSeriesExtremes",null,function(){axis.hasVisibleSeries=false;axis.dataMin=axis.dataMax=axis.threshold=void 0;axis.softThreshold=!axis.isXAxis;axis.series.forEach(series=>{if(series.reserveSpace()){const seriesOptions=series.options;let xData,threshold=seriesOptions.threshold,seriesDataMin,seriesDataMax;axis.hasVisibleSeries=true;if(axis.positiveValuesOnly&&(threshold||0)<=0){threshold=void 0}if(axis.isXAxis){xData=series.getColumn("x");if(xData.length){xData=axis.logarithmic?xData.filter(x=>x>0):xData;xExtremes=series.getXExtremes(xData);seriesDataMin=xExtremes.min;seriesDataMax=xExtremes.max;if(!isNumber(seriesDataMin)&&!(seriesDataMin instanceof Date)){xData=xData.filter(isNumber);xExtremes=series.getXExtremes(xData);seriesDataMin=xExtremes.min;seriesDataMax=xExtremes.max}if(xData.length){axis.dataMin=Math.min(pick(axis.dataMin,seriesDataMin),seriesDataMin);axis.dataMax=Math.max(pick(axis.dataMax,seriesDataMax),seriesDataMax)}}}else{const dataExtremes=series.applyExtremes();if(isNumber(dataExtremes.dataMin)){seriesDataMin=dataExtremes.dataMin;axis.dataMin=Math.min(pick(axis.dataMin,seriesDataMin),seriesDataMin)}if(isNumber(dataExtremes.dataMax)){seriesDataMax=dataExtremes.dataMax;axis.dataMax=Math.max(pick(axis.dataMax,seriesDataMax),seriesDataMax)}if(defined(threshold)){axis.threshold=threshold}if(!seriesOptions.softThreshold||axis.positiveValuesOnly){axis.softThreshold=false}}}})});fireEvent(this,"afterGetSeriesExtremes")}translate(val,backwards,cvsCoord,old,handleLog,pointPlacement){const axis=this.linkedParent||this,localMin=old&&axis.old?axis.old.min:axis.min;if(!isNumber(localMin)){return NaN}const minPixelPadding=axis.minPixelPadding,doPostTranslate=(axis.isOrdinal||axis.brokenAxis?.hasBreaks||axis.logarithmic&&handleLog)&&axis.lin2val;let sign=1,cvsOffset=0,localA=old&&axis.old?axis.old.transA:axis.transA,returnValue=0;if(!localA){localA=axis.transA}if(cvsCoord){sign*=-1;cvsOffset=axis.len}if(axis.reversed){sign*=-1;cvsOffset-=sign*(axis.sector||axis.len)}if(backwards){val=val*sign+cvsOffset;val-=minPixelPadding;returnValue=val/localA+localMin;if(doPostTranslate){returnValue=axis.lin2val(returnValue)}}else{if(doPostTranslate){val=axis.val2lin(val)}const value=sign*(val-localMin)*localA;returnValue=value+cvsOffset+sign*minPixelPadding+(isNumber(pointPlacement)?localA*pointPlacement:0);if(!axis.isRadial){returnValue=correctFloat(returnValue)}}return returnValue}toPixels(value,paneCoordinates){return this.translate(this.chart?.time.parse(value)??NaN,false,!this.horiz,void 0,true)+(paneCoordinates?0:this.pos)}toValue(pixel,paneCoordinates){return this.translate(pixel-(paneCoordinates?0:this.pos),true,!this.horiz,void 0,true)}getPlotLinePath(options){const axis=this,chart=axis.chart,axisLeft=axis.left,axisTop=axis.top,old=options.old,value=options.value,lineWidth=options.lineWidth,cHeight=old&&chart.oldChartHeight||chart.chartHeight,cWidth=old&&chart.oldChartWidth||chart.chartWidth,transB=axis.transB;let translatedValue=options.translatedValue,force=options.force,x1,y1,x2,y2,skip;function between(x,a,b){if(force!=="pass"&&(x<a||x>b)){if(force){x=clamp(x,a,b)}else{skip=true}}return x}const evt={value:value,lineWidth:lineWidth,old:old,force:force,acrossPanes:options.acrossPanes,translatedValue:translatedValue};fireEvent(this,"getPlotLinePath",evt,function(e){translatedValue=pick(translatedValue,axis.translate(value,void 0,void 0,old));translatedValue=clamp(translatedValue,-1e9,1e9);x1=x2=translatedValue+transB;y1=y2=cHeight-translatedValue-transB;if(!isNumber(translatedValue)){skip=true;force=false}else if(axis.horiz){y1=axisTop;y2=cHeight-axis.bottom+(axis.options.isInternal?0:chart.scrollablePixelsY||0);x1=x2=between(x1,axisLeft,axisLeft+axis.width)}else{x1=axisLeft;x2=cWidth-axis.right+(chart.scrollablePixelsX||0);y1=y2=between(y1,axisTop,axisTop+axis.height)}e.path=skip&&!force?void 0:chart.renderer.crispLine([["M",x1,y1],["L",x2,y2]],lineWidth||1)});return evt.path}getLinearTickPositions(tickInterval,min,max){const roundedMin=correctFloat(Math.floor(min/tickInterval)*tickInterval),roundedMax=correctFloat(Math.ceil(max/tickInterval)*tickInterval),tickPositions=[];let pos,lastPos,precision;if(correctFloat(roundedMin+tickInterval)===roundedMin){precision=20}if(this.single){return[min]}pos=roundedMin;while(pos<=roundedMax){tickPositions.push(pos);pos=correctFloat(pos+tickInterval,precision);if(pos===lastPos){break}lastPos=pos}return tickPositions}getMinorTickInterval(){const{minorTicks,minorTickInterval}=this.options;if(minorTicks===true){return pick(minorTickInterval,"auto")}if(minorTicks===false){return}return minorTickInterval}getMinorTickPositions(){const axis=this,options=axis.options,tickPositions=axis.tickPositions,minorTickInterval=axis.minorTickInterval,pointRangePadding=axis.pointRangePadding||0,min=(axis.min||0)-pointRangePadding,max=(axis.max||0)+pointRangePadding,range=axis.brokenAxis?.hasBreaks?axis.brokenAxis.unitLength:max-min;let minorTickPositions=[],pos;if(range&&range/minorTickInterval<axis.len/3){const logarithmic=axis.logarithmic;if(logarithmic){this.paddedTicks.forEach(function(_pos,i,paddedTicks){if(i){minorTickPositions.push.apply(minorTickPositions,logarithmic.getLogTickPositions(minorTickInterval,paddedTicks[i-1],paddedTicks[i],true))}})}else if(axis.dateTime&&this.getMinorTickInterval()==="auto"){minorTickPositions=minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval),min,max,options.startOfWeek))}else{for(pos=min+(tickPositions[0]-min)%minorTickInterval;pos<=max;pos+=minorTickInterval){if(pos===minorTickPositions[0]){break}minorTickPositions.push(pos)}}}if(minorTickPositions.length!==0){axis.trimTicks(minorTickPositions)}return minorTickPositions}adjustForMinRange(){const axis=this,options=axis.options,logarithmic=axis.logarithmic,time=axis.chart.time;let{max,min,minRange}=axis,zoomOffset,spaceAvailable,closestDataRange,minArgs,maxArgs;if(axis.isXAxis&&typeof minRange==="undefined"&&!logarithmic){if(defined(options.min)||defined(options.max)||defined(options.floor)||defined(options.ceiling)){minRange=null}else{closestDataRange=getClosestDistance(axis.series.map(s=>{const xData=s.getColumn("x");return s.xIncrement?xData.slice(0,2):xData}))||0;minRange=Math.min(closestDataRange*5,axis.dataMax-axis.dataMin)}}if(isNumber(max)&&isNumber(min)&&isNumber(minRange)&&max-min<minRange){spaceAvailable=axis.dataMax-axis.dataMin>=minRange;zoomOffset=(minRange-max+min)/2;minArgs=[min-zoomOffset,time.parse(options.min)??min-zoomOffset];if(spaceAvailable){minArgs[2]=logarithmic?logarithmic.log2lin(axis.dataMin):axis.dataMin}min=arrayMax(minArgs);maxArgs=[min+minRange,time.parse(options.max)??min+minRange];if(spaceAvailable){maxArgs[2]=logarithmic?logarithmic.log2lin(axis.dataMax):axis.dataMax}max=arrayMin(maxArgs);if(max-min<minRange){minArgs[0]=max-minRange;minArgs[1]=time.parse(options.min)??max-minRange;min=arrayMax(minArgs)}}axis.minRange=minRange;axis.min=min;axis.max=max}getClosest(){let closestSingleDistance,closestDistance;if(this.categories){closestDistance=1}else{const singleXs=[];this.series.forEach(function(series){const seriesClosest=series.closestPointRange,xData=series.getColumn("x");if(xData.length===1){singleXs.push(xData[0])}else if(series.sorted&&defined(seriesClosest)&&series.reserveSpace()){closestDistance=defined(closestDistance)?Math.min(closestDistance,seriesClosest):seriesClosest}});if(singleXs.length){singleXs.sort((a,b)=>a-b);closestSingleDistance=getClosestDistance([singleXs])}}if(closestSingleDistance&&closestDistance){return Math.min(closestSingleDistance,closestDistance)}return closestSingleDistance||closestDistance}nameToX(point){const explicitCategories=isArray(this.options.categories),names=explicitCategories?this.categories:this.names;let nameX=point.options.x,x;point.series.requireSorting=false;if(!defined(nameX)){nameX=this.uniqueNames&&names?explicitCategories?names.indexOf(point.name):pick(names.keys[point.name],-1):point.series.autoIncrement()}if(nameX===-1){if(!explicitCategories&&names){x=names.length}}else if(isNumber(nameX)){x=nameX}if(typeof x!=="undefined"){this.names[x]=point.name;this.names.keys[point.name]=x}else if(point.x){x=point.x}return x}updateNames(){const axis=this,names=this.names,i=names.length;if(i>0){Object.keys(names.keys).forEach(function(key){delete names.keys[key]});names.length=0;this.minRange=this.userMinRange;(this.series||[]).forEach(series=>{series.xIncrement=null;if(!series.points||series.isDirtyData){axis.max=Math.max(axis.max||0,series.dataTable.rowCount-1);series.processData();series.generatePoints()}const xData=series.getColumn("x").slice();series.data.forEach((point,i)=>{let x=xData[i];if(point?.options&&typeof point.name!=="undefined"){x=axis.nameToX(point);if(typeof x!=="undefined"&&x!==point.x){xData[i]=point.x=x}}});series.dataTable.setColumn("x",xData)})}}setAxisTranslation(){const axis=this,range=axis.max-axis.min,linkedParent=axis.linkedParent,hasCategories=!!axis.categories,isXAxis=axis.isXAxis;let pointRange=axis.axisPointRange||0,closestPointRange,minPointOffset=0,pointRangePadding=0,ordinalCorrection,transA=axis.transA;if(isXAxis||hasCategories||pointRange){closestPointRange=axis.getClosest();if(linkedParent){minPointOffset=linkedParent.minPointOffset;pointRangePadding=linkedParent.pointRangePadding}else{axis.series.forEach(function(series){const seriesPointRange=hasCategories?1:isXAxis?pick(series.options.pointRange,closestPointRange,0):axis.axisPointRange||0,pointPlacement=series.options.pointPlacement;pointRange=Math.max(pointRange,seriesPointRange);if(!axis.single||hasCategories){const isPointPlacementAxis=series.is("xrange")?!isXAxis:isXAxis;minPointOffset=Math.max(minPointOffset,isPointPlacementAxis&&isString(pointPlacement)?0:seriesPointRange/2);pointRangePadding=Math.max(pointRangePadding,isPointPlacementAxis&&pointPlacement==="on"?0:seriesPointRange)}})}ordinalCorrection=axis.ordinal&&axis.ordinal.slope&&closestPointRange?axis.ordinal.slope/closestPointRange:1;axis.minPointOffset=minPointOffset=minPointOffset*ordinalCorrection;axis.pointRangePadding=pointRangePadding=pointRangePadding*ordinalCorrection;axis.pointRange=Math.min(pointRange,axis.single&&hasCategories?1:range);if(isXAxis&&closestPointRange){axis.closestPointRange=closestPointRange}}axis.translationSlope=axis.transA=transA=axis.staticScale||axis.len/(range+pointRangePadding||1);axis.transB=axis.horiz?axis.left:axis.bottom;axis.minPixelPadding=transA*minPointOffset;fireEvent(this,"afterSetAxisTranslation")}minFromRange(){const{max,min}=this;return isNumber(max)&&isNumber(min)&&max-min||void 0}setTickInterval(secondPass){const axis=this,{categories,chart,dataMax,dataMin,dateTime,isXAxis,logarithmic,options,softThreshold}=axis,time=chart.time,threshold=isNumber(axis.threshold)?axis.threshold:void 0,minRange=axis.minRange||0,{ceiling,floor,linkedTo,softMax,softMin}=options,linkedParent=isNumber(linkedTo)&&chart[axis.coll]?.[linkedTo],tickPixelIntervalOption=options.tickPixelInterval;let maxPadding=options.maxPadding,minPadding=options.minPadding,range=0,linkedParentExtremes,tickIntervalOption=isNumber(options.tickInterval)&&options.tickInterval>=0?options.tickInterval:void 0,thresholdMin,thresholdMax,hardMin,hardMax;if(!dateTime&&!categories&&!linkedParent){this.getTickAmount()}hardMin=pick(axis.userMin,time.parse(options.min));hardMax=pick(axis.userMax,time.parse(options.max));if(linkedParent){axis.linkedParent=linkedParent;linkedParentExtremes=linkedParent.getExtremes();axis.min=pick(linkedParentExtremes.min,linkedParentExtremes.dataMin);axis.max=pick(linkedParentExtremes.max,linkedParentExtremes.dataMax);if(this.type!==linkedParent.type){error(11,true,chart)}}else{if(softThreshold&&defined(threshold)&&isNumber(dataMax)&&isNumber(dataMin)){if(dataMin>=threshold){thresholdMin=threshold;minPadding=0}else if(dataMax<=threshold){thresholdMax=threshold;maxPadding=0}}axis.min=pick(hardMin,thresholdMin,dataMin);axis.max=pick(hardMax,thresholdMax,dataMax)}if(isNumber(axis.max)&&isNumber(axis.min)){if(logarithmic){if(axis.positiveValuesOnly&&!secondPass&&Math.min(axis.min,pick(dataMin,axis.min))<=0){error(10,true,chart)}axis.min=correctFloat(logarithmic.log2lin(axis.min),16);axis.max=correctFloat(logarithmic.log2lin(axis.max),16)}if(axis.range&&isNumber(dataMin)){axis.userMin=axis.min=hardMin=Math.max(dataMin,axis.minFromRange()||0);axis.userMax=hardMax=axis.max;axis.range=void 0}}fireEvent(axis,"foundExtremes");axis.adjustForMinRange();if(isNumber(axis.min)&&isNumber(axis.max)){if(!isNumber(axis.userMin)&&isNumber(softMin)&&softMin<axis.min){axis.min=hardMin=softMin}if(!isNumber(axis.userMax)&&isNumber(softMax)&&softMax>axis.max){axis.max=hardMax=softMax}if(!categories&&!axis.axisPointRange&&!axis.stacking?.usePercentage&&!linkedParent){range=axis.max-axis.min;if(range){if(!defined(hardMin)&&minPadding){axis.min-=range*minPadding}if(!defined(hardMax)&&maxPadding){axis.max+=range*maxPadding}}}if(!isNumber(axis.userMin)&&isNumber(floor)){axis.min=Math.max(axis.min,floor)}if(!isNumber(axis.userMax)&&isNumber(ceiling)){axis.max=Math.min(axis.max,ceiling)}if(softThreshold&&isNumber(dataMin)&&isNumber(dataMax)){const numThreshold=threshold||0;if(!defined(hardMin)&&axis.min<numThreshold&&dataMin>=numThreshold){axis.min=options.minRange?Math.min(numThreshold,axis.max-minRange):numThreshold}else if(!defined(hardMax)&&axis.max>numThreshold&&dataMax<=numThreshold){axis.max=options.minRange?Math.max(numThreshold,axis.min+minRange):numThreshold}}if(!chart.polar&&axis.min>axis.max){if(defined(options.min)){axis.max=axis.min}else if(defined(options.max)){axis.min=axis.max}}range=axis.max-axis.min}if(axis.min===axis.max||!isNumber(axis.min)||!isNumber(axis.max)){axis.tickInterval=1}else if(linkedParent&&!tickIntervalOption&&tickPixelIntervalOption===linkedParent.options.tickPixelInterval){axis.tickInterval=tickIntervalOption=linkedParent.tickInterval}else{axis.tickInterval=pick(tickIntervalOption,this.tickAmount?range/Math.max(this.tickAmount-1,1):void 0,categories?1:range*tickPixelIntervalOption/Math.max(axis.len,tickPixelIntervalOption))}if(isXAxis&&!secondPass){const hasExtremesChanged=axis.min!==axis.old?.min||axis.max!==axis.old?.max;axis.series.forEach(function(series){series.forceCrop=series.forceCropping?.();series.processData(hasExtremesChanged)});fireEvent(this,"postProcessData",{hasExtremesChanged:hasExtremesChanged})}axis.setAxisTranslation();fireEvent(this,"initialAxisTranslation");if(axis.pointRange&&!tickIntervalOption){axis.tickInterval=Math.max(axis.pointRange,axis.tickInterval)}const minTickInterval=pick(options.minTickInterval,dateTime&&!axis.series.some(s=>!s.sorted)?axis.closestPointRange:0);if(!tickIntervalOption&&axis.tickInterval<minTickInterval){axis.tickInterval=minTickInterval}if(!dateTime&&!logarithmic&&!tickIntervalOption){axis.tickInterval=getNormalizedTickInterval(axis,axis.tickInterval)}if(!this.tickAmount){axis.tickInterval=axis.unsquish()}this.setTickPositions()}setTickPositions(){const axis=this,options=this.options,tickPositionsOption=options.tickPositions,tickPositioner=options.tickPositioner,minorTickIntervalOption=this.getMinorTickInterval(),allowEndOnTick=!this.isPanning,startOnTick=allowEndOnTick&&options.startOnTick,endOnTick=allowEndOnTick&&options.endOnTick;let tickPositions=[],tickPositionerResult;this.tickmarkOffset=this.categories&&options.tickmarkPlacement==="between"&&this.tickInterval===1?.5:0;this.single=this.min===this.max&&defined(this.min)&&!this.tickAmount&&(this.min%1===0||options.allowDecimals!==false);if(tickPositionsOption){tickPositions=tickPositionsOption.slice()}else if(isNumber(this.min)&&isNumber(this.max)){if(!axis.ordinal?.positions&&(this.max-this.min)/this.tickInterval>Math.max(2*this.len,200)){tickPositions=[this.min,this.max];error(19,false,this.chart)}else if(axis.dateTime){tickPositions=axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval,options.units),this.min,this.max,options.startOfWeek,axis.ordinal?.positions,this.closestPointRange,true)}else if(axis.logarithmic){tickPositions=axis.logarithmic.getLogTickPositions(this.tickInterval,this.min,this.max)}else{const startingTickInterval=this.tickInterval;let adjustedTickInterval=startingTickInterval;while(adjustedTickInterval<=startingTickInterval*2){tickPositions=this.getLinearTickPositions(this.tickInterval,this.min,this.max);if(this.tickAmount&&tickPositions.length>this.tickAmount){this.tickInterval=getNormalizedTickInterval(this,adjustedTickInterval*=1.1)}else{break}}}if(tickPositions.length>this.len){tickPositions=[tickPositions[0],tickPositions[tickPositions.length-1]];if(tickPositions[0]===tickPositions[1]){tickPositions.length=1}}if(tickPositioner){this.tickPositions=tickPositions;tickPositionerResult=tickPositioner.apply(axis,[this.min,this.max]);if(tickPositionerResult){tickPositions=tickPositionerResult}}}this.tickPositions=tickPositions;this.minorTickInterval=minorTickIntervalOption==="auto"&&this.tickInterval?this.tickInterval/options.minorTicksPerMajor:minorTickIntervalOption;this.paddedTicks=tickPositions.slice(0);this.trimTicks(tickPositions,startOnTick,endOnTick);if(!this.isLinked&&isNumber(this.min)&&isNumber(this.max)){if(this.single&&tickPositions.length<2&&!this.categories&&!this.series.some(s=>s.is("heatmap")&&s.options.pointPlacement==="between")){this.min-=.5;this.max+=.5}if(!tickPositionsOption&&!tickPositionerResult){this.adjustTickAmount()}}fireEvent(this,"afterSetTickPositions")}trimTicks(tickPositions,startOnTick,endOnTick){const roundedMin=tickPositions[0],roundedMax=tickPositions[tickPositions.length-1],minPointOffset=!this.isOrdinal&&this.minPointOffset||0;fireEvent(this,"trimTicks");if(!this.isLinked){if(startOnTick&&roundedMin!==-Infinity){this.min=roundedMin}else{while(this.min-minPointOffset>tickPositions[0]){tickPositions.shift()}}if(endOnTick){this.max=roundedMax}else{while(this.max+minPointOffset<tickPositions[tickPositions.length-1]){tickPositions.pop()}}if(tickPositions.length===0&&defined(roundedMin)&&!this.options.tickPositions){tickPositions.push((roundedMax+roundedMin)/2)}}}alignToOthers(){const axis=this,chart=axis.chart,alignedAxes=[this],options=axis.options,chartOptions=chart.options.chart,alignThresholds=this.coll==="yAxis"&&chartOptions.alignThresholds,thresholdAlignments=[];let hasOther;axis.thresholdAlignment=void 0;if((chartOptions.alignTicks!==false&&options.alignTicks||alignThresholds)&&options.startOnTick!==false&&options.endOnTick!==false&&!axis.logarithmic){const getKey=axis=>{const{horiz,options}=axis;return[horiz?options.left:options.top,options.width,options.height,options.pane].join(",")};const thisKey=getKey(this);chart[this.coll].forEach(function(otherAxis){const{series}=otherAxis;if(series.length&&series.some(s=>s.visible)&&otherAxis!==axis&&getKey(otherAxis)===thisKey){hasOther=true;alignedAxes.push(otherAxis)}})}if(hasOther&&alignThresholds){alignedAxes.forEach(otherAxis=>{const threshAlign=otherAxis.getThresholdAlignment(axis);if(isNumber(threshAlign)){thresholdAlignments.push(threshAlign)}});const thresholdAlignment=thresholdAlignments.length>1?thresholdAlignments.reduce((sum,n)=>sum+=n,0)/thresholdAlignments.length:void 0;alignedAxes.forEach(axis=>{axis.thresholdAlignment=thresholdAlignment})}return hasOther}getThresholdAlignment(callerAxis){if(!isNumber(this.dataMin)||this!==callerAxis&&this.series.some(s=>s.isDirty||s.isDirtyData)){this.getSeriesExtremes()}if(isNumber(this.threshold)){let thresholdAlignment=clamp((this.threshold-(this.dataMin||0))/((this.dataMax||0)-(this.dataMin||0)),0,1);if(this.options.reversed){thresholdAlignment=1-thresholdAlignment}return thresholdAlignment}}getTickAmount(){const axis=this,options=this.options,tickPixelInterval=options.tickPixelInterval;let tickAmount=options.tickAmount;if(!defined(options.tickInterval)&&!tickAmount&&this.len<tickPixelInterval&&!this.isRadial&&!axis.logarithmic&&options.startOnTick&&options.endOnTick){tickAmount=2}if(!tickAmount&&this.alignToOthers()){tickAmount=Math.ceil(this.len/tickPixelInterval)+1}if(tickAmount<4){this.finalTickAmt=tickAmount;tickAmount=5}this.tickAmount=tickAmount}adjustTickAmount(){const axis=this,{finalTickAmt,max,min,options,tickPositions,tickAmount,thresholdAlignment}=axis,currentTickAmount=tickPositions?.length,threshold=pick(axis.threshold,axis.softThreshold?0:null);let len,i,tickInterval=axis.tickInterval,thresholdTickIndex;const append=()=>tickPositions.push(correctFloat(tickPositions[tickPositions.length-1]+tickInterval)),prepend=()=>tickPositions.unshift(correctFloat(tickPositions[0]-tickInterval));if(isNumber(thresholdAlignment)){thresholdTickIndex=thresholdAlignment<.5?Math.ceil(thresholdAlignment*(tickAmount-1)):Math.floor(thresholdAlignment*(tickAmount-1));if(options.reversed){thresholdTickIndex=tickAmount-1-thresholdTickIndex}}if(axis.hasData()&&isNumber(min)&&isNumber(max)){const adjustExtremes=()=>{axis.transA*=(currentTickAmount-1)/(tickAmount-1);axis.min=options.startOnTick?tickPositions[0]:Math.min(min,tickPositions[0]);axis.max=options.endOnTick?tickPositions[tickPositions.length-1]:Math.max(max,tickPositions[tickPositions.length-1])};if(isNumber(thresholdTickIndex)&&isNumber(axis.threshold)){while(tickPositions[thresholdTickIndex]!==threshold||tickPositions.length!==tickAmount||tickPositions[0]>min||tickPositions[tickPositions.length-1]<max){tickPositions.length=0;tickPositions.push(axis.threshold);while(tickPositions.length<tickAmount){if(tickPositions[thresholdTickIndex]===void 0||tickPositions[thresholdTickIndex]>axis.threshold){prepend()}else{append()}}if(tickInterval>axis.tickInterval*8){break}tickInterval*=2}adjustExtremes()}else if(currentTickAmount<tickAmount){while(tickPositions.length<tickAmount){if(tickPositions.length%2||min===threshold){append()}else{prepend()}}adjustExtremes()}if(defined(finalTickAmt)){i=len=tickPositions.length;while(i--){if(finalTickAmt===3&&i%2===1||finalTickAmt<=2&&i>0&&i<len-1){tickPositions.splice(i,1)}}axis.finalTickAmt=void 0}}}setScale(){const axis=this,{coll,stacking}=axis;let isDirtyData=false,isXAxisDirty=false;axis.series.forEach(series=>{isDirtyData=isDirtyData||series.isDirtyData||series.isDirty;isXAxisDirty=isXAxisDirty||series.xAxis&&series.xAxis.isDirty||false});axis.setAxisSize();const isDirtyAxisLength=axis.len!==(axis.old&&axis.old.len);if(isDirtyAxisLength||isDirtyData||isXAxisDirty||axis.isLinked||axis.forceRedraw||axis.userMin!==(axis.old&&axis.old.userMin)||axis.userMax!==(axis.old&&axis.old.userMax)||axis.alignToOthers()){if(stacking&&coll==="yAxis"){stacking.buildStacks()}axis.forceRedraw=false;if(!axis.userMinRange){axis.minRange=void 0}axis.getSeriesExtremes();axis.setTickInterval();if(stacking&&coll==="xAxis"){stacking.buildStacks()}if(!axis.isDirty){axis.isDirty=isDirtyAxisLength||axis.min!==axis.old?.min||axis.max!==axis.old?.max}}else if(stacking){stacking.cleanStacks()}if(isDirtyData){delete axis.allExtremes}fireEvent(this,"afterSetScale")}setExtremes(min,max,redraw=true,animation,eventArguments){const chart=this.chart;this.series.forEach(serie=>{delete serie.kdTree});min=chart.time.parse(min);max=chart.time.parse(max);eventArguments=extend(eventArguments,{min:min,max:max});fireEvent(this,"setExtremes",eventArguments,e=>{this.userMin=e.min;this.userMax=e.max;this.eventArgs=e;if(redraw){chart.redraw(animation)}})}setAxisSize(){const chart=this.chart,options=this.options,offsets=options.offsets||[0,0,0,0],horiz=this.horiz,width=this.width=Math.round(relativeLength(pick(options.width,chart.plotWidth-offsets[3]+offsets[1]),chart.plotWidth)),height=this.height=Math.round(relativeLength(pick(options.height,chart.plotHeight-offsets[0]+offsets[2]),chart.plotHeight)),top=this.top=Math.round(relativeLength(pick(options.top,chart.plotTop+offsets[0]),chart.plotHeight,chart.plotTop)),left=this.left=Math.round(relativeLength(pick(options.left,chart.plotLeft+offsets[3]),chart.plotWidth,chart.plotLeft));this.bottom=chart.chartHeight-height-top;this.right=chart.chartWidth-width-left;this.len=Math.max(horiz?width:height,0);this.pos=horiz?left:top}getExtremes(){const axis=this,log=axis.logarithmic;return{min:log?correctFloat(log.lin2log(axis.min)):axis.min,max:log?correctFloat(log.lin2log(axis.max)):axis.max,dataMin:axis.dataMin,dataMax:axis.dataMax,userMin:axis.userMin,userMax:axis.userMax}}getThreshold(threshold){const axis=this,log=axis.logarithmic,realMin=log?log.lin2log(axis.min):axis.min,realMax=log?log.lin2log(axis.max):axis.max;if(threshold===null||threshold===-Infinity){threshold=realMin}else if(threshold===Infinity){threshold=realMax}else if(realMin>threshold){threshold=realMin}else if(realMax<threshold){threshold=realMax}return axis.translate(threshold,0,1,0,1)}autoLabelAlign(rotation){const angle=(pick(rotation,0)-this.side*90+720)%360,evt={align:"center"};fireEvent(this,"autoLabelAlign",evt,function(e){if(angle>15&&angle<165){e.align="right"}else if(angle>195&&angle<345){e.align="left"}});return evt.align}tickSize(prefix){const options=this.options,tickWidth=pick(options[prefix==="tick"?"tickWidth":"minorTickWidth"],prefix==="tick"&&this.isXAxis&&!this.categories?1:0);let tickLength=options[prefix==="tick"?"tickLength":"minorTickLength"],tickSize;if(tickWidth&&tickLength){if(options[prefix+"Position"]==="inside"){tickLength=-tickLength}tickSize=[tickLength,tickWidth]}const e={tickSize:tickSize};fireEvent(this,"afterTickSize",e);return e.tickSize}labelMetrics(){const renderer=this.chart.renderer,ticks=this.ticks,tick=ticks[Object.keys(ticks)[0]]||{};return this.chart.renderer.fontMetrics(tick.label||tick.movedLabel||renderer.box)}unsquish(){const labelOptions=this.options.labels,padding=labelOptions.padding||0,horiz=this.horiz,tickInterval=this.tickInterval,slotSize=this.len/(((this.categories?1:0)+this.max-this.min)/tickInterval),rotationOption=labelOptions.rotation,lineHeight=correctFloat(this.labelMetrics().h*.8),range=Math.max(this.max-this.min,0),getStep=function(spaceNeeded){let step=(spaceNeeded+2*padding)/(slotSize||1);step=step>1?Math.ceil(step):1;if(step*tickInterval>range&&spaceNeeded!==Infinity&&slotSize!==Infinity&&range){step=Math.ceil(range/tickInterval)}return correctFloat(step*tickInterval)};let newTickInterval=tickInterval,rotation,bestScore=Number.MAX_VALUE,autoRotation;if(horiz){if(!labelOptions.staggerLines){if(isNumber(rotationOption)){autoRotation=[rotationOption]}else if(slotSize<labelOptions.autoRotationLimit){autoRotation=labelOptions.autoRotation}}if(autoRotation){let step,score;for(const rot of autoRotation){if(rot===rotationOption||rot&&rot>=-90&&rot<=90){step=getStep(Math.abs(lineHeight/Math.sin(deg2rad*rot)));score=step+Math.abs(rot/360);if(score<bestScore){bestScore=score;rotation=rot;newTickInterval=step}}}}}else{newTickInterval=getStep(lineHeight*.75)}this.autoRotation=autoRotation;this.labelRotation=pick(rotation,isNumber(rotationOption)?rotationOption:0);return labelOptions.step?tickInterval:newTickInterval}getSlotWidth(tick){const chart=this.chart,horiz=this.horiz,labelOptions=this.options.labels,slotCount=Math.max(this.tickPositions.length-(this.categories?0:1),1),marginLeft=chart.margin[3];if(tick&&isNumber(tick.slotWidth)){return tick.slotWidth}if(horiz&&labelOptions.step<2&&!this.isRadial){if(labelOptions.rotation){return 0}return(this.staggerLines||1)*this.len/slotCount}if(!horiz){const cssWidth=labelOptions.style.width;if(cssWidth!==void 0){return parseInt(String(cssWidth),10)}if(marginLeft){return marginLeft-chart.spacing[3]}}return chart.chartWidth*.33}renderUnsquish(){const chart=this.chart,renderer=chart.renderer,tickPositions=this.tickPositions,ticks=this.ticks,labelOptions=this.options.labels,labelStyleOptions=labelOptions.style,horiz=this.horiz,slotWidth=this.getSlotWidth(),innerWidth=Math.max(1,Math.round(slotWidth-(horiz?2*(labelOptions.padding||0):labelOptions.distance||0))),attr={},labelMetrics=this.labelMetrics(),lineClampOption=labelStyleOptions.lineClamp;let commonWidth,lineClamp=lineClampOption??(Math.floor(this.len/(tickPositions.length*labelMetrics.h))||1),maxLabelLength=0;if(!isString(labelOptions.rotation)){attr.rotation=labelOptions.rotation||0}tickPositions.forEach(function(tickPosition){const tick=ticks[tickPosition];if(tick.movedLabel){tick.replaceMovedLabel()}const textPxLength=tick.label?.textPxLength||0;if(textPxLength>maxLabelLength){maxLabelLength=textPxLength}});this.maxLabelLength=maxLabelLength;if(this.autoRotation){if(maxLabelLength>innerWidth&&maxLabelLength>labelMetrics.h){attr.rotation=this.labelRotation}else{this.labelRotation=0}}else if(slotWidth){commonWidth=innerWidth}if(attr.rotation){commonWidth=maxLabelLength>chart.chartHeight*.5?chart.chartHeight*.33:maxLabelLength;if(!lineClampOption){lineClamp=1}}this.labelAlign=labelOptions.align||this.autoLabelAlign(this.labelRotation);if(this.labelAlign){attr.align=this.labelAlign}tickPositions.forEach(function(pos){const tick=ticks[pos],label=tick&&tick.label,widthOption=labelStyleOptions.width,css={};if(label){label.attr(attr);if(tick.shortenLabel){tick.shortenLabel()}else if(commonWidth&&!widthOption&&labelStyleOptions.whiteSpace!=="nowrap"&&(commonWidth<(label.textPxLength||0)||label.element.tagName==="SPAN")){label.css(extend(css,{width:`${commonWidth}px`,lineClamp:lineClamp}))}else if(label.styles.width&&!css.width&&!widthOption){label.css({width:"auto"})}tick.rotation=attr.rotation}},this);this.tickRotCorr=renderer.rotCorr(labelMetrics.b,this.labelRotation||0,this.side!==0)}hasData(){return this.series.some(function(s){return s.hasData()})||this.options.showEmpty&&defined(this.min)&&defined(this.max)}addTitle(display){const axis=this,renderer=axis.chart.renderer,horiz=axis.horiz,opposite=axis.opposite,options=axis.options,axisTitleOptions=options.title,styledMode=axis.chart.styledMode;let textAlign;if(!axis.axisTitle){textAlign=axisTitleOptions.textAlign;if(!textAlign){textAlign=(horiz?{low:"left",middle:"center",high:"right"}:{low:opposite?"right":"left",middle:"center",high:opposite?"left":"right"})[axisTitleOptions.align]}axis.axisTitle=renderer.text(axisTitleOptions.text||"",0,0,axisTitleOptions.useHTML).attr({zIndex:7,rotation:axisTitleOptions.rotation||0,align:textAlign}).addClass("highcharts-axis-title");if(!styledMode){axis.axisTitle.css(merge(axisTitleOptions.style))}axis.axisTitle.add(axis.axisGroup);axis.axisTitle.isNew=true}if(!styledMode&&!axisTitleOptions.style.width&&!axis.isRadial){axis.axisTitle.css({width:axis.len+"px"})}axis.axisTitle[display?"show":"hide"](display)}generateTick(pos){const axis=this,ticks=axis.ticks;if(!ticks[pos]){ticks[pos]=new Tick(axis,pos)}else{ticks[pos].addLabel()}}createGroups(){const{axisParent,chart,coll,options}=this,renderer=chart.renderer;const createGroup=(name,suffix,zIndex)=>renderer.g(name).attr({zIndex:zIndex}).addClass(`highcharts-${coll.toLowerCase()}${suffix} `+(this.isRadial?`highcharts-radial-axis${suffix} `:"")+(options.className||"")).add(axisParent);if(!this.axisGroup){this.gridGroup=createGroup("grid","-grid",options.gridZIndex);this.axisGroup=createGroup("axis","",options.zIndex);this.labelGroup=createGroup("axis-labels","-labels",options.labels.zIndex)}}getOffset(){const axis=this,{chart,horiz,options,side,ticks,tickPositions,coll}=axis,invertedSide=chart.inverted&&!axis.isZAxis?[1,0,3,2][side]:side,hasData=axis.hasData(),axisTitleOptions=options.title,labelOptions=options.labels,hasCrossing=isNumber(options.crossing),axisOffset=chart.axisOffset,clipOffset=chart.clipOffset,directionFactor=[-1,1,1,-1][side];let showAxis,titleOffset=0,titleOffsetOption,titleMargin=0,labelOffset=0,labelOffsetPadded,lineHeightCorrection;axis.showAxis=showAxis=hasData||options.showEmpty;axis.staggerLines=axis.horiz&&labelOptions.staggerLines||void 0;axis.createGroups();if(hasData||axis.isLinked){tickPositions.forEach(function(pos){axis.generateTick(pos)});axis.renderUnsquish();axis.reserveSpaceDefault=side===0||side===2||{1:"left",3:"right"}[side]===axis.labelAlign;if(pick(labelOptions.reserveSpace,hasCrossing?false:null,axis.labelAlign==="center"?true:null,axis.reserveSpaceDefault)){tickPositions.forEach(function(pos){labelOffset=Math.max(ticks[pos].getLabelSize(),labelOffset)})}if(axis.staggerLines){labelOffset*=axis.staggerLines}axis.labelOffset=labelOffset*(axis.opposite?-1:1)}else{objectEach(ticks,function(tick,n){tick.destroy();delete ticks[n]})}if(axisTitleOptions?.text&&axisTitleOptions.enabled!==false){axis.addTitle(showAxis);if(showAxis&&!hasCrossing&&axisTitleOptions.reserveSpace!==false){axis.titleOffset=titleOffset=axis.axisTitle.getBBox()[horiz?"height":"width"];titleOffsetOption=axisTitleOptions.offset;titleMargin=defined(titleOffsetOption)?0:pick(axisTitleOptions.margin,horiz?5:10)}}axis.renderLine();axis.offset=directionFactor*pick(options.offset,axisOffset[side]?axisOffset[side]+(options.margin||0):0);axis.tickRotCorr=axis.tickRotCorr||{x:0,y:0};if(side===0){lineHeightCorrection=-axis.labelMetrics().h}else if(side===2){lineHeightCorrection=axis.tickRotCorr.y}else{lineHeightCorrection=0}labelOffsetPadded=Math.abs(labelOffset)+titleMargin;if(labelOffset){labelOffsetPadded-=lineHeightCorrection;labelOffsetPadded+=directionFactor*(horiz?pick(labelOptions.y,axis.tickRotCorr.y+directionFactor*labelOptions.distance):pick(labelOptions.x,directionFactor*labelOptions.distance))}axis.axisTitleMargin=pick(titleOffsetOption,labelOffsetPadded);if(axis.getMaxLabelDimensions){axis.maxLabelDimensions=axis.getMaxLabelDimensions(ticks,tickPositions)}if(coll!=="colorAxis"&&clipOffset){const tickSize=this.tickSize("tick");axisOffset[side]=Math.max(axisOffset[side],(axis.axisTitleMargin||0)+titleOffset+directionFactor*axis.offset,labelOffsetPadded,tickPositions&&tickPositions.length&&tickSize?tickSize[0]+directionFactor*axis.offset:0);const clip=!axis.axisLine||options.offset?0:axis.axisLine.strokeWidth()/2;clipOffset[invertedSide]=Math.max(clipOffset[invertedSide],clip)}fireEvent(this,"afterGetOffset")}getLinePath(lineWidth){const chart=this.chart,opposite=this.opposite,offset=this.offset,horiz=this.horiz,lineLeft=this.left+(opposite?this.width:0)+offset,lineTop=chart.chartHeight-this.bottom-(opposite?this.height:0)+offset;if(opposite){lineWidth*=-1}return chart.renderer.crispLine([["M",horiz?this.left:lineLeft,horiz?lineTop:this.top],["L",horiz?chart.chartWidth-this.right:lineLeft,horiz?lineTop:chart.chartHeight-this.bottom]],lineWidth)}renderLine(){if(!this.axisLine){this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);if(!this.chart.styledMode){this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7})}}}getTitlePosition(axisTitle){const horiz=this.horiz,axisLeft=this.left,axisTop=this.top,axisLength=this.len,axisTitleOptions=this.options.title,margin=horiz?axisLeft:axisTop,opposite=this.opposite,offset=this.offset,xOption=axisTitleOptions.x,yOption=axisTitleOptions.y,fontMetrics=this.chart.renderer.fontMetrics(axisTitle),textHeightOvershoot=axisTitle?Math.max(axisTitle.getBBox(false,0).height-fontMetrics.h-1,0):0,alongAxis={low:margin+(horiz?0:axisLength),middle:margin+axisLength/2,high:margin+(horiz?axisLength:0)}[axisTitleOptions.align],offAxis=(horiz?axisTop+this.height:axisLeft)+(horiz?1:-1)*(opposite?-1:1)*(this.axisTitleMargin||0)+[-textHeightOvershoot,textHeightOvershoot,fontMetrics.f,-textHeightOvershoot][this.side],titlePosition={x:horiz?alongAxis+xOption:offAxis+(opposite?this.width:0)+offset+xOption,y:horiz?offAxis+yOption-(opposite?this.height:0)+offset:alongAxis+yOption};fireEvent(this,"afterGetTitlePosition",{titlePosition:titlePosition});return titlePosition}renderMinorTick(pos,slideIn){const axis=this;const minorTicks=axis.minorTicks;if(!minorTicks[pos]){minorTicks[pos]=new Tick(axis,pos,"minor")}if(slideIn&&minorTicks[pos].isNew){minorTicks[pos].render(null,true)}minorTicks[pos].render(null,false,1)}renderTick(pos,i,slideIn){const axis=this,isLinked=axis.isLinked,ticks=axis.ticks;if(!isLinked||pos>=axis.min&&pos<=axis.max||axis.grid&&axis.grid.isColumn){if(!ticks[pos]){ticks[pos]=new Tick(axis,pos)}if(slideIn&&ticks[pos].isNew){ticks[pos].render(i,true,-1)}ticks[pos].render(i)}}render(){const axis=this,chart=axis.chart,log=axis.logarithmic,renderer=chart.renderer,options=axis.options,isLinked=axis.isLinked,tickPositions=axis.tickPositions,axisTitle=axis.axisTitle,ticks=axis.ticks,minorTicks=axis.minorTicks,alternateBands=axis.alternateBands,stackLabelOptions=options.stackLabels,alternateGridColor=options.alternateGridColor,crossing=options.crossing,tickmarkOffset=axis.tickmarkOffset,axisLine=axis.axisLine,showAxis=axis.showAxis,animation=animObject(renderer.globalAnimation);let from,to;axis.labelEdge.length=0;axis.overlap=false;[ticks,minorTicks,alternateBands].forEach(function(coll){objectEach(coll,function(tick){tick.isActive=false})});if(isNumber(crossing)){const otherAxis=this.isXAxis?chart.yAxis[0]:chart.xAxis[0],directionFactor=[1,-1,-1,1][this.side];if(otherAxis){let px=otherAxis.toPixels(crossing,true);if(axis.horiz){px=otherAxis.len-px}axis.offset=directionFactor*px}}if(axis.hasData()||isLinked){const slideInTicks=axis.chart.hasRendered&&axis.old&&isNumber(axis.old.min);if(axis.minorTickInterval&&!axis.categories){axis.getMinorTickPositions().forEach(function(pos){axis.renderMinorTick(pos,slideInTicks)})}if(tickPositions.length){tickPositions.forEach(function(pos,i){axis.renderTick(pos,i,slideInTicks)});if(tickmarkOffset&&(axis.min===0||axis.single)){if(!ticks[-1]){ticks[-1]=new Tick(axis,-1,null,true)}ticks[-1].render(-1)}}if(alternateGridColor){tickPositions.forEach(function(pos,i){to=typeof tickPositions[i+1]!=="undefined"?tickPositions[i+1]+tickmarkOffset:axis.max-tickmarkOffset;if(i%2===0&&pos<axis.max&&to<=axis.max+(chart.polar?-tickmarkOffset:tickmarkOffset)){if(!alternateBands[pos]){alternateBands[pos]=new H.PlotLineOrBand(axis,{})}from=pos+tickmarkOffset;alternateBands[pos].options={from:log?log.lin2log(from):from,to:log?log.lin2log(to):to,color:alternateGridColor,className:"highcharts-alternate-grid"};alternateBands[pos].render();alternateBands[pos].isActive=true}})}if(!axis._addedPlotLB){axis._addedPlotLB=true;(options.plotLines||[]).concat(options.plotBands||[]).forEach(function(plotLineOptions){axis.addPlotBandOrLine(plotLineOptions)})}}[ticks,minorTicks,alternateBands].forEach(function(coll){const forDestruction=[],delay=animation.duration,destroyInactiveItems=function(){let i=forDestruction.length;while(i--){if(coll[forDestruction[i]]&&!coll[forDestruction[i]].isActive){coll[forDestruction[i]].destroy();delete coll[forDestruction[i]]}}};objectEach(coll,function(tick,pos){if(!tick.isActive){tick.render(pos,false,0);tick.isActive=false;forDestruction.push(pos)}});syncTimeout(destroyInactiveItems,coll===alternateBands||!chart.hasRendered||!delay?0:delay)});if(axisLine){axisLine[axisLine.isPlaced?"animate":"attr"]({d:this.getLinePath(axisLine.strokeWidth())});axisLine.isPlaced=true;axisLine[showAxis?"show":"hide"](showAxis)}if(axisTitle&&showAxis){axisTitle[axisTitle.isNew?"attr":"animate"](axis.getTitlePosition(axisTitle));axisTitle.isNew=false}if(stackLabelOptions&&stackLabelOptions.enabled&&axis.stacking){axis.stacking.renderStackTotals()}axis.old={len:axis.len,max:axis.max,min:axis.min,transA:axis.transA,userMax:axis.userMax,userMin:axis.userMin};axis.isDirty=false;fireEvent(this,"afterRender")}redraw(){if(this.visible){this.render();this.plotLinesAndBands.forEach(function(plotLine){plotLine.render()})}this.series.forEach(function(series){series.isDirty=true})}getKeepProps(){return this.keepProps||Axis.keepProps}destroy(keepEvents){const axis=this,plotLinesAndBands=axis.plotLinesAndBands,eventOptions=this.eventOptions;fireEvent(this,"destroy",{keepEvents:keepEvents});if(!keepEvents){removeEvent(axis)}[axis.ticks,axis.minorTicks,axis.alternateBands].forEach(function(coll){destroyObjectProperties(coll)});if(plotLinesAndBands){let i=plotLinesAndBands.length;while(i--){plotLinesAndBands[i].destroy()}}["axisLine","axisTitle","axisGroup","gridGroup","labelGroup","cross","scrollbar"].forEach(function(prop){if(axis[prop]){axis[prop]=axis[prop].destroy()}});for(const plotGroup in axis.plotLinesAndBandsGroups){axis.plotLinesAndBandsGroups[plotGroup]=axis.plotLinesAndBandsGroups[plotGroup].destroy()}objectEach(axis,function(val,key){if(axis.getKeepProps().indexOf(key)===-1){delete axis[key]}});this.eventOptions=eventOptions}drawCrosshair(e,point){const options=this.crosshair,snap=pick(options&&options.snap,true),chart=this.chart;let path,pos,categorized,graphic=this.cross,crossOptions;fireEvent(this,"drawCrosshair",{e:e,point:point});if(!e){e=this.cross&&this.cross.e}if(!options||(defined(point)||!snap)===false){this.hideCrosshair()}else{if(!snap){pos=e&&(this.horiz?e.chartX-this.pos:this.len-e.chartY+this.pos)}else if(defined(point)){pos=pick(this.coll!=="colorAxis"?point.crosshairPos:null,this.isXAxis?point.plotX:this.len-point.plotY)}if(defined(pos)){crossOptions={value:point&&(this.isXAxis?point.x:pick(point.stackY,point.y)),translatedValue:pos};if(chart.polar){extend(crossOptions,{isCrosshair:true,chartX:e&&e.chartX,chartY:e&&e.chartY,point:point})}path=this.getPlotLinePath(crossOptions)||null}if(!defined(path)){this.hideCrosshair();return}categorized=this.categories&&!this.isRadial;if(!graphic){this.cross=graphic=chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(categorized?"category ":"thin ")+(options.className||"")).attr({zIndex:pick(options.zIndex,2)}).add();if(!chart.styledMode){graphic.attr({stroke:options.color||(categorized?Color.parse("#ccd3ff").setOpacity(.25).get():"#cccccc"),"stroke-width":pick(options.width,1)}).css({"pointer-events":"none"});if(options.dashStyle){graphic.attr({dashstyle:options.dashStyle})}}}graphic.show().attr({d:path});if(categorized&&!options.width){graphic.attr({"stroke-width":this.transA})}this.cross.e=e}fireEvent(this,"afterDrawCrosshair",{e:e,point:point})}hideCrosshair(){if(this.cross){this.cross.hide()}fireEvent(this,"afterHideCrosshair")}update(options,redraw){const chart=this.chart;options=merge(this.userOptions,options);this.destroy(true);this.init(chart,options);chart.isDirtyBox=true;if(pick(redraw,true)){chart.redraw()}}remove(redraw){const chart=this.chart,coll=this.coll,axisSeries=this.series;let i=axisSeries.length;while(i--){if(axisSeries[i]){axisSeries[i].remove(false)}}erase(chart.axes,this);erase(chart[coll]||[],this);chart.orderItems(coll);this.destroy();chart.isDirtyBox=true;if(pick(redraw,true)){chart.redraw()}}setTitle(titleOptions,redraw){this.update({title:titleOptions},redraw)}setCategories(categories,redraw){this.update({categories:categories},redraw)}}Axis.keepProps=["coll","extKey","hcEvents","len","names","series","userMax","userMin"];export default Axis;"";