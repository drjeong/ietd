"use strict";import H from"../../Core/Globals.js";const{composed,noop}=H;import Color from"../../Core/Color/Color.js";const{parse:color}=Color;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{addEvent,clamp,crisp,defined,extend,find,isNumber,isObject,merge,pick,pushUnique,relativeLength}=U;import XRangeSeriesDefaults from"./XRangeSeriesDefaults.js";import XRangePoint from"./XRangePoint.js";function onAxisAfterGetSeriesExtremes(){let dataMax,modMax;if(this.isXAxis){dataMax=pick(this.dataMax,-Number.MAX_VALUE);for(const series of this.series){const column=series.dataTable.getColumn("x2",true)||series.dataTable.getColumn("end",true);if(column){for(const val of column){if(isNumber(val)&&val>dataMax){dataMax=val;modMax=true}}}}if(modMax){this.dataMax=dataMax}}}class XRangeSeries extends ColumnSeries{static compose(AxisClass){if(pushUnique(composed,"Series.XRange")){addEvent(AxisClass,"afterGetSeriesExtremes",onAxisAfterGetSeriesExtremes)}}init(){super.init.apply(this,arguments);this.options.stacking=void 0}getColumnMetrics(){const swapAxes=()=>{for(const series of this.chart.series){const xAxis=series.xAxis;series.xAxis=series.yAxis;series.yAxis=xAxis}};swapAxes();const metrics=super.getColumnMetrics();swapAxes();return metrics}cropData(table,min,max){const xData=table.getColumn("x")||[],x2Data=table.getColumn("x2");table.setColumn("x",x2Data,void 0,{silent:true});const croppedData=super.cropData(table,min,max);table.setColumn("x",xData.slice(croppedData.start,croppedData.end),void 0,{silent:true});return croppedData}findPointIndex(options){const{cropStart,points}=this;const{id}=options;let pointIndex;if(id){const point=find(points,point=>point.id===id);pointIndex=point?point.index:void 0}if(typeof pointIndex==="undefined"){const point=find(points,point=>point.x===options.x&&point.x2===options.x2&&!point.touched);pointIndex=point?point.index:void 0}if(this.cropped&&isNumber(pointIndex)&&isNumber(cropStart)&&pointIndex>=cropStart){pointIndex-=cropStart}return pointIndex}alignDataLabel(point){const oldPlotX=point.plotX;point.plotX=pick(point.dlBox&&point.dlBox.centerX,point.plotX);if(point.dataLabel&&point.shapeArgs?.width){point.dataLabel.css({width:`${point.shapeArgs.width}px`})}super.alignDataLabel.apply(this,arguments);point.plotX=oldPlotX}translatePoint(point){const xAxis=this.xAxis,yAxis=this.yAxis,metrics=this.columnMetrics,options=this.options,minPointLength=options.minPointLength||0,oldColWidth=(point.shapeArgs&&point.shapeArgs.width||0)/2,seriesXOffset=this.pointXOffset=metrics.offset,posX=pick(point.x2,point.x+(point.len||0)),borderRadius=options.borderRadius,plotTop=this.chart.plotTop,plotLeft=this.chart.plotLeft;let plotX=point.plotX,plotX2=xAxis.translate(posX,0,0,0,1);const length=Math.abs(plotX2-plotX),inverted=this.chart.inverted,borderWidth=pick(options.borderWidth,1);let widthDifference,partialFill,yOffset=metrics.offset,pointHeight=Math.round(metrics.width),dlLeft,dlRight,dlWidth,clipRectWidth;if(minPointLength){widthDifference=minPointLength-length;if(widthDifference<0){widthDifference=0}plotX-=widthDifference/2;plotX2+=widthDifference/2}plotX=Math.max(plotX,-10);plotX2=clamp(plotX2,-10,xAxis.len+10);if(defined(point.options.pointWidth)){yOffset-=(Math.ceil(point.options.pointWidth)-pointHeight)/2;pointHeight=Math.ceil(point.options.pointWidth)}if(options.pointPlacement&&isNumber(point.plotY)&&yAxis.categories){point.plotY=yAxis.translate(point.y,0,1,0,1,options.pointPlacement)}const x=crisp(Math.min(plotX,plotX2),borderWidth),x2=crisp(Math.max(plotX,plotX2),borderWidth),width=x2-x;const r=Math.min(relativeLength(typeof borderRadius==="object"?borderRadius.radius:borderRadius||0,pointHeight),Math.min(width,pointHeight)/2);const shapeArgs={x:x,y:crisp((point.plotY||0)+yOffset,borderWidth),width:width,height:pointHeight,r:r};point.shapeArgs=shapeArgs;if(!inverted){point.tooltipPos[0]-=oldColWidth+seriesXOffset-shapeArgs.width/2}else{point.tooltipPos[1]+=seriesXOffset+oldColWidth}dlLeft=shapeArgs.x;dlRight=dlLeft+shapeArgs.width;if(dlLeft<0||dlRight>xAxis.len){dlLeft=clamp(dlLeft,0,xAxis.len);dlRight=clamp(dlRight,0,xAxis.len);dlWidth=dlRight-dlLeft;point.dlBox=merge(shapeArgs,{x:dlLeft,width:dlRight-dlLeft,centerX:dlWidth?dlWidth/2:null})}else{point.dlBox=null}const tooltipPos=point.tooltipPos;const xIndex=!inverted?0:1;const yIndex=!inverted?1:0;const tooltipYOffset=this.columnMetrics?this.columnMetrics.offset:-metrics.width/2;if(inverted){tooltipPos[xIndex]+=shapeArgs.width/2}else{tooltipPos[xIndex]=clamp(tooltipPos[xIndex]+(xAxis.reversed?-1:0)*shapeArgs.width,xAxis.left-plotLeft,xAxis.left+xAxis.len-plotLeft-1)}tooltipPos[yIndex]=clamp(tooltipPos[yIndex]+(inverted?-1:1)*tooltipYOffset,yAxis.top-plotTop,yAxis.top+yAxis.len-plotTop-1);partialFill=point.partialFill;if(partialFill){if(isObject(partialFill)){partialFill=partialFill.amount}if(!isNumber(partialFill)){partialFill=0}point.partShapeArgs=merge(shapeArgs);clipRectWidth=Math.max(Math.round(length*partialFill+point.plotX-plotX),0);point.clipRectArgs={x:xAxis.reversed?shapeArgs.x+length-clipRectWidth:shapeArgs.x,y:shapeArgs.y,width:clipRectWidth,height:shapeArgs.height}}point.key=point.category||point.name;point.yCategory=yAxis.categories?.[point.y??-1]}translate(){super.translate.apply(this,arguments);for(const point of this.points){this.translatePoint(point)}}drawPoint(point,verb){const seriesOpts=this.options,renderer=this.chart.renderer,type=point.shapeType,shapeArgs=point.shapeArgs,partShapeArgs=point.partShapeArgs,clipRectArgs=point.clipRectArgs,pointState=point.state,stateOpts=seriesOpts.states[pointState||"normal"]||{},pointStateVerb=typeof pointState==="undefined"?"attr":verb,pointAttr=this.pointAttribs(point,pointState),animation=pick(this.chart.options.chart.animation,stateOpts.animation);let graphic=point.graphic,pfOptions=point.partialFill;if(!point.isNull&&point.visible!==false){if(graphic){graphic.rect[verb](shapeArgs)}else{point.graphic=graphic=renderer.g("point").addClass(point.getClassName()).add(point.group||this.group);graphic.rect=renderer[type](merge(shapeArgs)).addClass(point.getClassName()).addClass("highcharts-partfill-original").add(graphic)}if(partShapeArgs){if(graphic.partRect){graphic.partRect[verb](merge(partShapeArgs));graphic.partialClipRect[verb](merge(clipRectArgs))}else{graphic.partialClipRect=renderer.clipRect(clipRectArgs.x,clipRectArgs.y,clipRectArgs.width,clipRectArgs.height);graphic.partRect=renderer[type](partShapeArgs).addClass("highcharts-partfill-overlay").add(graphic).clip(graphic.partialClipRect)}}if(!this.chart.styledMode){graphic.rect[verb](pointAttr,animation).shadow(seriesOpts.shadow);if(partShapeArgs){if(!isObject(pfOptions)){pfOptions={}}if(isObject(seriesOpts.partialFill)){pfOptions=merge(seriesOpts.partialFill,pfOptions)}const fill=pfOptions.fill||color(pointAttr.fill).brighten(-.3).get()||color(point.color||this.color).brighten(-.3).get();pointAttr.fill=fill;graphic.partRect[pointStateVerb](pointAttr,animation).shadow(seriesOpts.shadow)}}}else if(graphic){point.graphic=graphic.destroy()}}drawPoints(){const verb=this.getAnimationVerb();for(const point of this.points){this.drawPoint(point,verb)}}getAnimationVerb(){return this.chart.pointCount<(this.options.animationLimit||250)?"animate":"attr"}isPointInside(point){const shapeArgs=point.shapeArgs,plotX=point.plotX,plotY=point.plotY;if(!shapeArgs){return super.isPointInside.apply(this,arguments)}const isInside=typeof plotX!=="undefined"&&typeof plotY!=="undefined"&&plotY>=0&&plotY<=this.yAxis.len&&(shapeArgs.x||0)+(shapeArgs.width||0)>=0&&plotX<=this.xAxis.len;return isInside}}XRangeSeries.defaultOptions=merge(ColumnSeries.defaultOptions,XRangeSeriesDefaults);extend(XRangeSeries.prototype,{pointClass:XRangePoint,pointArrayMap:["x2","y"],getExtremesFromAll:true,keysAffectYAxis:["y"],parallelArrays:["x","x2","y"],requireSorting:false,type:"xrange",animate:SeriesRegistry.series.prototype.animate,autoIncrement:noop,buildKDTree:noop});SeriesRegistry.registerSeriesType("xrange",XRangeSeries);export default XRangeSeries;