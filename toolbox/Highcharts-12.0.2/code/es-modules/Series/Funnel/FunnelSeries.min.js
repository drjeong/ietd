"use strict";import FunnelSeriesDefaults from"./FunnelSeriesDefaults.js";import H from"../../Core/Globals.js";const{composed,noop}=H;import BorderRadius from"../../Extensions/BorderRadius.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,pie:PieSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{addEvent,correctFloat,extend,fireEvent,isArray,merge,pick,pushUnique,relativeLength,splat}=U;const baseAlignDataLabel=SeriesRegistry.series.prototype.alignDataLabel;function getLength(length,relativeTo){return/%$/.test(length)?relativeTo*parseInt(length,10)/100:parseInt(length,10)}class FunnelSeries extends PieSeries{alignDataLabel(point,dataLabel,options,alignTo,isNew){const series=point.series,reversed=series.options.reversed,dlBox=point.dlBox||point.shapeArgs,{align,padding=0,verticalAlign}=options,inside=((series.options||{}).dataLabels||{}).inside,centerY=series.center[1],plotY=point.plotY||0,pointPlotY=reversed?2*centerY-plotY:plotY,dataLabelHeight=dataLabel.height??dataLabel.getBBox().height,widthAtLabel=series.getWidthAt(pointPlotY-dlBox.height/2+dataLabelHeight),offset=verticalAlign==="middle"?(dlBox.topWidth-dlBox.bottomWidth)/4:(widthAtLabel-dlBox.bottomWidth)/2;let y=dlBox.y,x=dlBox.x;if(verticalAlign==="middle"){y=dlBox.y-dlBox.height/2+dataLabelHeight/2}else if(verticalAlign==="top"){y=dlBox.y-dlBox.height+dataLabelHeight+padding}if(verticalAlign==="top"&&!reversed||verticalAlign==="bottom"&&reversed||verticalAlign==="middle"){if(align==="right"){x=dlBox.x-padding+offset}else if(align==="left"){x=dlBox.x+padding-offset}}alignTo={x:x,y:reversed?y-dlBox.height:y,width:dlBox.bottomWidth,height:dlBox.height};options.verticalAlign="bottom";if(inside){options.distance=void 0}if(inside&&point.visible){baseAlignDataLabel.call(series,point,dataLabel,options,alignTo,isNew)}if(inside){if(!point.visible&&point.dataLabel){point.dataLabel.placed=false}if(point.contrastColor){dataLabel.css({color:point.contrastColor})}}}drawDataLabels(){(splat(this.options.dataLabels||{})[0].inside?ColumnSeries:PieSeries).prototype.drawDataLabels.call(this)}getDataLabelPosition(point,distance){const y=point.plotY||0,sign=point.half?1:-1,x=this.getX(y,!!point.half,point);return{distance:distance,natural:{x:0,y:y},computed:{},alignment:point.half?"right":"left",connectorPosition:{breakAt:{x:x+(distance-5)*sign,y:y},touchingSliceAt:{x:x+distance*sign,y:y}}}}translate(){const series=this,chart=series.chart,options=series.options,reversed=options.reversed,ignoreHiddenPoint=options.ignoreHiddenPoint,borderRadiusObject=BorderRadius.optionsToObject(options.borderRadius),plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,center=options.center,centerX=getLength(center[0],plotWidth),centerY=getLength(center[1],plotHeight),width=getLength(options.width,plotWidth),height=getLength(options.height,plotHeight),neckWidth=getLength(options.neckWidth,plotWidth),neckHeight=getLength(options.neckHeight,plotHeight),neckY=centerY-height/2+height-neckHeight,points=series.points,borderRadius=relativeLength(borderRadiusObject.radius,width),radiusScope=borderRadiusObject.scope,half=options.dataLabels.position==="left"?1:0,roundingFactors=angle=>{const tan=Math.tan(angle/2),cosA=Math.cos(alpha),sinA=Math.sin(alpha);let r=borderRadius,t=r/tan,k=Math.tan((Math.PI-angle)/3.2104);if(t>maxT){t=maxT;r=t*tan}k*=r;return{dx:[t*cosA,(t-k)*cosA,t-k,t],dy:[t*sinA,(t-k)*sinA,t-k,t].map(i=>reversed?-i:i)}};let sum=0,cumulative=0,tempWidth,path,fraction,alpha,maxT,x1,y1,x2,x3,y3,x4,y5;series.getWidthAt=function(y){const top=centerY-height/2;return y>neckY||height===neckHeight?neckWidth:neckWidth+(width-neckWidth)*(1-(y-top)/(height-neckHeight))};series.getX=function(y,half,point){return centerX+(half?-1:1)*(series.getWidthAt(reversed?2*centerY-y:y)/2+(point.dataLabel?.dataLabelPosition?.distance??relativeLength(this.options.dataLabels?.distance||0,width)))};series.center=[centerX,centerY,height];series.centerX=centerX;for(const point of points){if(point.y&&point.isValid()&&(!ignoreHiddenPoint||point.visible!==false)){sum+=point.y}}for(const point of points){y5=null;fraction=sum?point.y/sum:0;y1=centerY-height/2+cumulative*height;y3=y1+fraction*height;tempWidth=series.getWidthAt(y1);x1=centerX-tempWidth/2;x2=x1+tempWidth;tempWidth=series.getWidthAt(y3);x3=centerX-tempWidth/2;x4=x3+tempWidth;if(correctFloat(y1)>=neckY){x1=x3=centerX-neckWidth/2;x2=x4=centerX+neckWidth/2}else if(y3>neckY){y5=y3;tempWidth=series.getWidthAt(neckY);x3=centerX-tempWidth/2;x4=x3+tempWidth;y3=neckY}if(reversed){y1=2*centerY-y1;y3=2*centerY-y3;if(y5!==null){y5=2*centerY-y5}}if(borderRadius&&(radiusScope==="point"||point.index===0||point.index===points.length-1||y5!==null)){const h=Math.abs(y3-y1),xSide=x2-x4,lBase=x4-x3,lSide=Math.sqrt(xSide*xSide+h*h);alpha=Math.atan(xSide!==0?h/xSide:Infinity);maxT=lSide/2;if(y5!==null){maxT=Math.min(maxT,Math.abs(y5-y3)/2)}if(lBase>=1){maxT=Math.min(maxT,lBase/2)}let f=roundingFactors(alpha);if(radiusScope==="stack"&&point.index!==0){path=[["M",x1,y1],["L",x2,y1]]}else{path=[["M",x1+f.dx[0],y1+f.dy[0]],["C",x1+f.dx[1],y1+f.dy[1],x1+f.dx[2],y1,x1+f.dx[3],y1],["L",x2-f.dx[3],y1],["C",x2-f.dx[2],y1,x2-f.dx[1],y1+f.dy[1],x2-f.dx[0],y1+f.dy[0]]]}if(y5!==null){const fr=roundingFactors(Math.PI/2);f=roundingFactors(Math.PI/2+alpha);path.push(["L",x4+f.dx[0],y3-f.dy[0]],["C",x4+f.dx[1],y3-f.dy[1],x4,y3+f.dy[2],x4,y3+f.dy[3]]);if(radiusScope==="stack"&&point.index!==points.length-1){path.push(["L",x4,y5],["L",x3,y5])}else{path.push(["L",x4,y5-fr.dy[3]],["C",x4,y5-fr.dy[2],x4-fr.dx[2],y5,x4-fr.dx[3],y5],["L",x3+fr.dx[3],y5],["C",x3+fr.dx[2],y5,x3,y5-fr.dy[2],x3,y5-fr.dy[3]])}path.push(["L",x3,y3+f.dy[3]],["C",x3,y3+f.dy[2],x3-f.dx[1],y3-f.dy[1],x3-f.dx[0],y3-f.dy[0]])}else if(lBase>=1){f=roundingFactors(Math.PI-alpha);if(radiusScope==="stack"&&point.index===0){path.push(["L",x4,y3],["L",x3,y3])}else{path.push(["L",x4+f.dx[0],y3-f.dy[0]],["C",x4+f.dx[1],y3-f.dy[1],x4-f.dx[2],y3,x4-f.dx[3],y3],["L",x3+f.dx[3],y3],["C",x3+f.dx[2],y3,x3-f.dx[1],y3-f.dy[1],x3-f.dx[0],y3-f.dy[0]])}}else{f=roundingFactors(Math.PI-alpha*2);path.push(["L",x3+f.dx[0],y3-f.dy[0]],["C",x3+f.dx[1],y3-f.dy[1],x3-f.dx[1],y3-f.dy[1],x3-f.dx[0],y3-f.dy[0]])}}else{path=[["M",x1,y1],["L",x2,y1],["L",x4,y3]];if(y5!==null){path.push(["L",x4,y5],["L",x3,y5])}path.push(["L",x3,y3])}path.push(["Z"]);point.shapeType="path";point.shapeArgs={d:path};point.percentage=fraction*100;point.plotX=centerX;point.plotY=(y1+(y5||y3))/2;point.tooltipPos=[centerX,point.plotY];point.dlBox={x:x3,y:y1,topWidth:x2-x1,bottomWidth:x4-x3,height:Math.abs(pick(y5,y3)-y1),width:NaN};point.slice=noop;point.half=half;if(point.isValid()&&(!ignoreHiddenPoint||point.visible!==false)){cumulative+=fraction}}fireEvent(series,"afterTranslate")}sortByAngle(points){points.sort((a,b)=>a.plotY-b.plotY)}}FunnelSeries.defaultOptions=merge(PieSeries.defaultOptions,FunnelSeriesDefaults);extend(FunnelSeries.prototype,{animate:noop});(function(FunnelSeries){function compose(ChartClass){if(pushUnique(composed,"FunnelSeries")){addEvent(ChartClass,"afterHideAllOverlappingLabels",onChartAfterHideAllOverlappingLabels)}}FunnelSeries.compose=compose;function onChartAfterHideAllOverlappingLabels(){for(const series of this.series){let dataLabelsOptions=series.options&&series.options.dataLabels;if(isArray(dataLabelsOptions)){dataLabelsOptions=dataLabelsOptions[0]}if(series.is("pie")&&series.placeDataLabels&&dataLabelsOptions&&!dataLabelsOptions.inside){series.placeDataLabels()}}}})(FunnelSeries||(FunnelSeries={}));SeriesRegistry.registerSeriesType("funnel",FunnelSeries);export default FunnelSeries;