"use strict";import TreegraphNode from"./TreegraphNode.js";class TreegraphLayout{static createDummyNode(parent,child,gapSize){const dummyNode=new TreegraphNode;dummyNode.id=parent.id+"-"+gapSize;dummyNode.ancestor=parent;dummyNode.children.push(child);dummyNode.parent=parent.id;dummyNode.parentNode=parent;dummyNode.point=child.point;dummyNode.level=child.level-gapSize;dummyNode.relativeXPosition=child.relativeXPosition;dummyNode.visible=child.visible;parent.children[child.relativeXPosition]=dummyNode;child.oldParentNode=parent;child.relativeXPosition=0;child.parentNode=dummyNode;child.parent=dummyNode.id;return dummyNode}calculatePositions(series){const treeLayout=this;const nodes=series.nodeList;this.resetValues(nodes);const root=series.tree;if(root){treeLayout.calculateRelativeX(root,0);treeLayout.beforeLayout(nodes);treeLayout.firstWalk(root);treeLayout.secondWalk(root,-root.preX);treeLayout.afterLayout(nodes)}}beforeLayout(nodes){for(const node of nodes){for(let child of node.children){if(child&&child.level-node.level>1){let gapSize=child.level-node.level-1;while(gapSize>0){child=TreegraphLayout.createDummyNode(node,child,gapSize);gapSize--}}}}}resetValues(nodes){for(const node of nodes){node.mod=0;node.ancestor=node;node.shift=0;node.thread=void 0;node.change=0;node.preX=0}}calculateRelativeX(node,index){const treeLayout=this,children=node.children;for(let i=0,iEnd=children.length;i<iEnd;++i){treeLayout.calculateRelativeX(children[i],i)}node.relativeXPosition=index}firstWalk(node){const treeLayout=this,siblingDistance=1;let leftSibling;if(!node.hasChildren()){leftSibling=node.getLeftSibling();if(leftSibling){node.preX=leftSibling.preX+siblingDistance;node.mod=node.preX}else{node.preX=0}}else{let defaultAncestor=node.getLeftMostChild();for(const child of node.children){treeLayout.firstWalk(child);defaultAncestor=treeLayout.apportion(child,defaultAncestor)}treeLayout.executeShifts(node);const leftChild=node.getLeftMostChild(),rightChild=node.getRightMostChild(),midPoint=(leftChild.preX+rightChild.preX)/2;leftSibling=node.getLeftSibling();if(leftSibling){node.preX=leftSibling.preX+siblingDistance;node.mod=node.preX-midPoint}else{node.preX=midPoint}}}secondWalk(node,modSum){const treeLayout=this;node.yPosition=node.preX+modSum;node.xPosition=node.level;for(const child of node.children){treeLayout.secondWalk(child,modSum+node.mod)}}executeShifts(node){let shift=0,change=0;for(let i=node.children.length-1;i>=0;i--){const childNode=node.children[i];childNode.preX+=shift;childNode.mod+=shift;change+=childNode.change;shift+=childNode.shift+change}}apportion(node,defaultAncestor){const treeLayout=this,leftSibling=node.getLeftSibling();if(leftSibling){let rightIntNode=node,rightOutNode=node,leftIntNode=leftSibling,leftOutNode=rightIntNode.getLeftMostSibling(),rightIntMod=rightIntNode.mod,rightOutMod=rightOutNode.mod,leftIntMod=leftIntNode.mod,leftOutMod=leftOutNode.mod;while(leftIntNode&&leftIntNode.nextRight()&&rightIntNode&&rightIntNode.nextLeft()){leftIntNode=leftIntNode.nextRight();leftOutNode=leftOutNode.nextLeft();rightIntNode=rightIntNode.nextLeft();rightOutNode=rightOutNode.nextRight();rightOutNode.ancestor=node;const siblingDistance=1,shift=leftIntNode.preX+leftIntMod-(rightIntNode.preX+rightIntMod)+siblingDistance;if(shift>0){treeLayout.moveSubtree(node.getAncestor(leftIntNode,defaultAncestor),node,shift);rightIntMod+=shift;rightOutMod+=shift}leftIntMod+=leftIntNode.mod;rightIntMod+=rightIntNode.mod;leftOutMod+=leftOutNode.mod;rightOutMod+=rightOutNode.mod}if(leftIntNode&&leftIntNode.nextRight()&&!rightOutNode.nextRight()){rightOutNode.thread=leftIntNode.nextRight();rightOutNode.mod+=leftIntMod-rightOutMod}if(rightIntNode&&rightIntNode.nextLeft()&&!leftOutNode.nextLeft()){leftOutNode.thread=rightIntNode.nextLeft();leftOutNode.mod+=rightIntMod-leftOutMod}defaultAncestor=node}return defaultAncestor}moveSubtree(leftNode,rightNode,shift){const subtrees=rightNode.relativeXPosition-leftNode.relativeXPosition;rightNode.change-=shift/subtrees;rightNode.shift+=shift;rightNode.preX+=shift;rightNode.mod+=shift;leftNode.change+=shift/subtrees}afterLayout(nodes){for(const node of nodes){if(node.oldParentNode){node.relativeXPosition=node.parentNode.relativeXPosition;node.parent=node.oldParentNode.parent;node.parentNode=node.oldParentNode;delete node.oldParentNode.children[node.relativeXPosition];node.oldParentNode.children[node.relativeXPosition]=node;node.oldParentNode=void 0}}}}export default TreegraphLayout;