"use strict";import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import U from"../../Core/Utilities.js";const{defined,merge,isObject}=U;class LineSeries extends Series{drawGraph(){const options=this.options,graphPath=(this.gappedPath||this.getGraphPath).call(this),styledMode=this.chart.styledMode;[this,...this.zones].forEach((owner,i)=>{let attribs,graph=owner.graph;const verb=graph?"animate":"attr",dashStyle=owner.dashStyle||options.dashStyle;if(graph){graph.endX=this.preventGraphAnimation?null:graphPath.xMap;graph.animate({d:graphPath})}else if(graphPath.length){owner.graph=graph=this.chart.renderer.path(graphPath).addClass("highcharts-graph"+(i?` highcharts-zone-graph-${i-1} `:" ")+(i&&owner.className||"")).attr({zIndex:1}).add(this.group)}if(graph&&!styledMode){attribs={stroke:!i&&options.lineColor||owner.color||this.color||"#cccccc","stroke-width":options.lineWidth||0,fill:this.fillGraph&&this.color||"none"};if(dashStyle){attribs.dashstyle=dashStyle}else if(options.linecap!=="square"){attribs["stroke-linecap"]=attribs["stroke-linejoin"]="round"}graph[verb](attribs).shadow(options.shadow&&merge({filterUnits:"userSpaceOnUse"},isObject(options.shadow)?options.shadow:{}))}if(graph){graph.startX=graphPath.xMap;graph.isArea=graphPath.isArea}})}getGraphPath(points,nullsAsZeroes,connectCliffs){const series=this,options=series.options,graphPath=[],xMap=[];let gap,step=options.step;points=points||series.points;const reversed=points.reversed;if(reversed){points.reverse()}step={right:1,center:2}[step]||step&&3;if(step&&reversed){step=4-step}points=this.getValidPoints(points,false,!(options.connectNulls&&!nullsAsZeroes&&!connectCliffs));points.forEach(function(point,i){const plotX=point.plotX,plotY=point.plotY,lastPoint=points[i-1],isNull=point.isNull||typeof plotY!=="number";let pathToPoint;if((point.leftCliff||lastPoint&&lastPoint.rightCliff)&&!connectCliffs){gap=true}if(isNull&&!defined(nullsAsZeroes)&&i>0){gap=!options.connectNulls}else if(isNull&&!nullsAsZeroes){gap=true}else{if(i===0||gap){pathToPoint=[["M",point.plotX,point.plotY]]}else if(series.getPointSpline){pathToPoint=[series.getPointSpline(points,point,i)]}else if(step){if(step===1){pathToPoint=[["L",lastPoint.plotX,plotY]]}else if(step===2){pathToPoint=[["L",(lastPoint.plotX+plotX)/2,lastPoint.plotY],["L",(lastPoint.plotX+plotX)/2,plotY]]}else{pathToPoint=[["L",plotX,lastPoint.plotY]]}pathToPoint.push(["L",plotX,plotY])}else{pathToPoint=[["L",plotX,plotY]]}xMap.push(point.x);if(step){xMap.push(point.x);if(step===2){xMap.push(point.x)}}graphPath.push.apply(graphPath,pathToPoint);gap=false}});graphPath.xMap=xMap;series.graphPath=graphPath;return graphPath}}LineSeries.defaultOptions=merge(Series.defaultOptions,{legendSymbol:"lineMarker"});SeriesRegistry.registerSeriesType("line",LineSeries);export default LineSeries;"";