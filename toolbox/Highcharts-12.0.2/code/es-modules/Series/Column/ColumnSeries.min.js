"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{animObject}=A;import Color from"../../Core/Color/Color.js";const{parse:color}=Color;import ColumnSeriesDefaults from"./ColumnSeriesDefaults.js";import H from"../../Core/Globals.js";const{noop}=H;import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import U from"../../Core/Utilities.js";const{clamp,crisp,defined,extend,fireEvent,isArray,isNumber,merge,pick,objectEach}=U;class ColumnSeries extends Series{animate(init){const series=this,yAxis=this.yAxis,yAxisPos=yAxis.pos,reversed=yAxis.reversed,options=series.options,{clipOffset,inverted}=this.chart,attr={},translateProp=inverted?"translateX":"translateY";let translateStart,translatedThreshold;if(init&&clipOffset){attr.scaleY=.001;translatedThreshold=clamp(yAxis.toPixels(options.threshold||0),yAxisPos,yAxisPos+yAxis.len);if(inverted){translatedThreshold+=reversed?-Math.floor(clipOffset[0]):Math.ceil(clipOffset[2]);attr.translateX=translatedThreshold-yAxis.len}else{translatedThreshold+=reversed?Math.ceil(clipOffset[0]):-Math.floor(clipOffset[2]);attr.translateY=translatedThreshold}if(series.clipBox){series.setClip()}series.group.attr(attr)}else{translateStart=Number(series.group.attr(translateProp));series.group.animate({scaleY:1},extend(animObject(series.options.animation),{step:function(val,fx){if(series.group){attr[translateProp]=translateStart+fx.pos*(yAxisPos-translateStart);series.group.attr(attr)}}}))}}init(chart,options){super.init.apply(this,arguments);const series=this;chart=series.chart;if(chart.hasRendered){chart.series.forEach(function(otherSeries){if(otherSeries.type===series.type){otherSeries.isDirty=true}})}}getColumnMetrics(){const series=this,options=series.options,xAxis=series.xAxis,yAxis=series.yAxis,reversedStacks=xAxis.options.reversedStacks,reverseStacks=xAxis.reversed&&!reversedStacks||!xAxis.reversed&&reversedStacks,stackGroups={};let stackKey,columnCount=0;if(options.grouping===false){columnCount=1}else{series.chart.series.forEach(function(otherSeries){const otherYAxis=otherSeries.yAxis,otherOptions=otherSeries.options;let columnIndex;if(otherSeries.type===series.type&&otherSeries.reserveSpace()&&yAxis.len===otherYAxis.len&&yAxis.pos===otherYAxis.pos){if(otherOptions.stacking&&otherOptions.stacking!=="group"){stackKey=otherSeries.stackKey;if(typeof stackGroups[stackKey]==="undefined"){stackGroups[stackKey]=columnCount++}columnIndex=stackGroups[stackKey]}else if(otherOptions.grouping!==false){columnIndex=columnCount++}otherSeries.columnIndex=columnIndex}})}const categoryWidth=Math.min(Math.abs(xAxis.transA)*(!xAxis.brokenAxis?.hasBreaks&&xAxis.ordinal?.slope||options.pointRange||xAxis.closestPointRange||xAxis.tickInterval||1),xAxis.len),groupPadding=categoryWidth*options.groupPadding,groupWidth=categoryWidth-2*groupPadding,pointOffsetWidth=groupWidth/(columnCount||1),pointWidth=Math.min(options.maxPointWidth||xAxis.len,pick(options.pointWidth,pointOffsetWidth*(1-2*options.pointPadding))),pointPadding=(pointOffsetWidth-pointWidth)/2,colIndex=(series.columnIndex||0)+(reverseStacks?1:0),pointXOffset=pointPadding+(groupPadding+colIndex*pointOffsetWidth-categoryWidth/2)*(reverseStacks?-1:1);series.columnMetrics={width:pointWidth,offset:pointXOffset,paddedWidth:pointOffsetWidth,columnCount:columnCount};return series.columnMetrics}crispCol(x,y,width,height){const borderWidth=this.borderWidth,inverted=this.chart.inverted,bottom=crisp(y+height,borderWidth,inverted);y=crisp(y,borderWidth,inverted);height=bottom-y;if(this.options.crisp){const right=crisp(x+width,borderWidth);x=crisp(x,borderWidth);width=right-x}return{x:x,y:y,width:width,height:height}}adjustForMissingColumns(x,pointWidth,point,metrics){if(!point.isNull&&metrics.columnCount>1){const visibleSeries=this.xAxis.series.filter(s=>s.visible).map(s=>s.index);let indexInCategory=0,totalInCategory=0;objectEach(this.xAxis.stacking?.stacks,stack=>{const points=typeof point.x==="number"?stack[point.x.toString()]?.points:void 0,pointValues=points?.[this.index],yStackMap={};if(points&&isArray(pointValues)){let baseIndex=this.index;const seriesIndexes=Object.keys(points).filter(pointKey=>!pointKey.match(",")&&points[pointKey]&&points[pointKey].length>1).map(parseFloat).filter(index=>visibleSeries.indexOf(index)!==-1).filter(index=>{const otherOptions=this.chart.series[index].options,yStack=otherOptions.stacking&&otherOptions.stack;if(defined(yStack)){if(isNumber(yStackMap[yStack])){if(baseIndex===index){baseIndex=yStackMap[yStack]}return false}yStackMap[yStack]=index}return true}).sort((a,b)=>b-a);indexInCategory=seriesIndexes.indexOf(baseIndex);totalInCategory=seriesIndexes.length}});indexInCategory=this.xAxis.reversed?totalInCategory-1-indexInCategory:indexInCategory;const boxWidth=(totalInCategory-1)*metrics.paddedWidth+pointWidth;x=(point.plotX||0)+boxWidth/2-pointWidth-indexInCategory*metrics.paddedWidth}return x}translate(){const series=this,chart=series.chart,options=series.options,dense=series.dense=series.closestPointRange*series.xAxis.transA<2,borderWidth=series.borderWidth=pick(options.borderWidth,dense?0:1),xAxis=series.xAxis,yAxis=series.yAxis,threshold=options.threshold,minPointLength=pick(options.minPointLength,5),metrics=series.getColumnMetrics(),seriesPointWidth=metrics.width,seriesXOffset=series.pointXOffset=metrics.offset,dataMin=series.dataMin,dataMax=series.dataMax,translatedThreshold=series.translatedThreshold=yAxis.getThreshold(threshold);let seriesBarW=series.barW=Math.max(seriesPointWidth,1+2*borderWidth);if(options.pointPadding&&options.crisp){seriesBarW=Math.ceil(seriesBarW)}Series.prototype.translate.apply(series);series.points.forEach(function(point){const yBottom=pick(point.yBottom,translatedThreshold),safeDistance=999+Math.abs(yBottom),plotX=point.plotX||0,plotY=clamp(point.plotY,-safeDistance,yAxis.len+safeDistance);let up,barY=Math.min(plotY,yBottom),barH=Math.max(plotY,yBottom)-barY,pointWidth=seriesPointWidth,barX=plotX+seriesXOffset,barW=seriesBarW;if(minPointLength&&Math.abs(barH)<minPointLength){barH=minPointLength;up=!yAxis.reversed&&!point.negative||yAxis.reversed&&point.negative;if(isNumber(threshold)&&isNumber(dataMax)&&point.y===threshold&&dataMax<=threshold&&(yAxis.min||0)<threshold&&(dataMin!==dataMax||(yAxis.max||0)<=threshold)){up=!up;point.negative=!point.negative}barY=Math.abs(barY-translatedThreshold)>minPointLength?yBottom-minPointLength:translatedThreshold-(up?minPointLength:0)}if(defined(point.options.pointWidth)){pointWidth=barW=Math.ceil(point.options.pointWidth);barX-=Math.round((pointWidth-seriesPointWidth)/2)}if(options.centerInCategory){barX=series.adjustForMissingColumns(barX,pointWidth,point,metrics)}point.barX=barX;point.pointWidth=pointWidth;point.tooltipPos=chart.inverted?[clamp(yAxis.len+yAxis.pos-chart.plotLeft-plotY,yAxis.pos-chart.plotLeft,yAxis.len+yAxis.pos-chart.plotLeft),xAxis.len+xAxis.pos-chart.plotTop-barX-barW/2,barH]:[xAxis.left-chart.plotLeft+barX+barW/2,clamp(plotY+yAxis.pos-chart.plotTop,yAxis.pos-chart.plotTop,yAxis.len+yAxis.pos-chart.plotTop),barH];point.shapeType=series.pointClass.prototype.shapeType||"roundedRect";point.shapeArgs=series.crispCol(barX,point.isNull?translatedThreshold:barY,barW,point.isNull?0:barH)});fireEvent(this,"afterColumnTranslate")}drawGraph(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")}pointAttribs(point,state){const options=this.options,p2o=this.pointAttrToOptions||{},strokeOption=p2o.stroke||"borderColor",strokeWidthOption=p2o["stroke-width"]||"borderWidth";let stateOptions,zone,brightness,fill=point&&point.color||this.color,stroke=point&&point[strokeOption]||options[strokeOption]||fill,dashstyle=point&&point.options.dashStyle||options.dashStyle,strokeWidth=point&&point[strokeWidthOption]||options[strokeWidthOption]||this[strokeWidthOption]||0,opacity=pick(point&&point.opacity,options.opacity,1);if(point&&this.zones.length){zone=point.getZone();fill=point.options.color||zone&&(zone.color||point.nonZonedColor)||this.color;if(zone){stroke=zone.borderColor||stroke;dashstyle=zone.dashStyle||dashstyle;strokeWidth=zone.borderWidth||strokeWidth}}if(state&&point){stateOptions=merge(options.states[state],point.options.states&&point.options.states[state]||{});brightness=stateOptions.brightness;fill=stateOptions.color||typeof brightness!=="undefined"&&color(fill).brighten(stateOptions.brightness).get()||fill;stroke=stateOptions[strokeOption]||stroke;strokeWidth=stateOptions[strokeWidthOption]||strokeWidth;dashstyle=stateOptions.dashStyle||dashstyle;opacity=pick(stateOptions.opacity,opacity)}const ret={fill:fill,stroke:stroke,"stroke-width":strokeWidth,opacity:opacity};if(dashstyle){ret.dashstyle=dashstyle}return ret}drawPoints(points=this.points){const series=this,chart=this.chart,options=series.options,renderer=chart.renderer,animationLimit=options.animationLimit||250;let shapeArgs;points.forEach(function(point){const plotY=point.plotY;let graphic=point.graphic,hasGraphic=!!graphic,verb=graphic&&chart.pointCount<animationLimit?"animate":"attr";if(isNumber(plotY)&&point.y!==null){shapeArgs=point.shapeArgs;if(graphic&&point.hasNewShapeType()){graphic=graphic.destroy()}if(series.enabledDataSorting){point.startXPos=series.xAxis.reversed?-(shapeArgs?shapeArgs.width||0:0):series.xAxis.width}if(!graphic){point.graphic=graphic=renderer[point.shapeType](shapeArgs).add(point.group||series.group);if(graphic&&series.enabledDataSorting&&chart.hasRendered&&chart.pointCount<animationLimit){graphic.attr({x:point.startXPos});hasGraphic=true;verb="animate"}}if(graphic&&hasGraphic){graphic[verb](merge(shapeArgs))}if(!chart.styledMode){graphic[verb](series.pointAttribs(point,point.selected&&"select")).shadow(point.allowShadow!==false&&options.shadow)}if(graphic){graphic.addClass(point.getClassName(),true);graphic.attr({visibility:point.visible?"inherit":"hidden"})}}else if(graphic){point.graphic=graphic.destroy()}})}drawTracker(points=this.points){const series=this,chart=series.chart,pointer=chart.pointer,onMouseOver=function(e){pointer?.normalize(e);const point=pointer?.getPointFromEvent(e),isInsidePlot=chart.scrollablePlotArea?chart.isInsidePlot(e.chartX-chart.plotLeft,e.chartY-chart.plotTop,{visiblePlotOnly:true}):true;if(pointer&&point&&series.options.enableMouseTracking&&isInsidePlot){pointer.isDirectTouch=true;point.onMouseOver(e)}};let dataLabels;points.forEach(function(point){dataLabels=isArray(point.dataLabels)?point.dataLabels:point.dataLabel?[point.dataLabel]:[];if(point.graphic){point.graphic.element.point=point}dataLabels.forEach(function(dataLabel){(dataLabel.div||dataLabel.element).point=point})});if(!series._hasTracking){series.trackerGroups.forEach(function(key){if(series[key]){series[key].addClass("highcharts-tracker").on("mouseover",onMouseOver).on("mouseout",function(e){pointer?.onTrackerMouseOut(e)}).on("touchstart",onMouseOver);if(!chart.styledMode&&series.options.cursor){series[key].css({cursor:series.options.cursor})}}});series._hasTracking=true}fireEvent(this,"afterDrawTracker")}remove(){const series=this,chart=series.chart;if(chart.hasRendered){chart.series.forEach(function(otherSeries){if(otherSeries.type===series.type){otherSeries.isDirty=true}})}Series.prototype.remove.apply(series,arguments)}}ColumnSeries.defaultOptions=merge(Series.defaultOptions,ColumnSeriesDefaults);extend(ColumnSeries.prototype,{directTouch:true,getSymbol:noop,negStacks:true,trackerGroups:["group","dataLabelsGroup"]});SeriesRegistry.registerSeriesType("column",ColumnSeries);export default ColumnSeries;"";