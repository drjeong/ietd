"use strict";import DataLabel from"../../Core/Series/DataLabel.js";import H from"../../Core/Globals.js";const{composed,noop}=H;import R from"../../Core/Renderer/RendererUtilities.js";const{distribute}=R;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series}=SeriesRegistry;import U from"../../Core/Utilities.js";const{arrayMax,clamp,defined,pick,pushUnique,relativeLength}=U;var ColumnDataLabel;(function(ColumnDataLabel){const dataLabelPositioners={radialDistributionY:function(point,dataLabel){return(dataLabel.dataLabelPosition?.top||0)+point.distributeBox.pos},radialDistributionX:function(series,point,y,naturalY,dataLabel){const pos=dataLabel.dataLabelPosition;return series.getX(y<(pos?.top||0)+2||y>(pos?.bottom||0)-2?naturalY:y,point.half,point,dataLabel)},justify:function(point,dataLabel,radius,seriesCenter){return seriesCenter[0]+(point.half?-1:1)*(radius+(dataLabel.dataLabelPosition?.distance||0))},alignToPlotEdges:function(dataLabel,half,plotWidth,plotLeft){const dataLabelWidth=dataLabel.getBBox().width;return half?dataLabelWidth+plotLeft:plotWidth-dataLabelWidth-plotLeft},alignToConnectors:function(points,half,plotWidth,plotLeft){let maxDataLabelWidth=0,dataLabelWidth;points.forEach(function(point){dataLabelWidth=point.dataLabel.getBBox().width;if(dataLabelWidth>maxDataLabelWidth){maxDataLabelWidth=dataLabelWidth}});return half?maxDataLabelWidth+plotLeft:plotWidth-maxDataLabelWidth-plotLeft}};function compose(PieSeriesClass){DataLabel.compose(Series);if(pushUnique(composed,"PieDataLabel")){const pieProto=PieSeriesClass.prototype;pieProto.dataLabelPositioners=dataLabelPositioners;pieProto.alignDataLabel=noop;pieProto.drawDataLabels=drawDataLabels;pieProto.getDataLabelPosition=getDataLabelPosition;pieProto.placeDataLabels=placeDataLabels;pieProto.verifyDataLabelOverflow=verifyDataLabelOverflow}}ColumnDataLabel.compose=compose;function getDataLabelPosition(point,distance){const halfPI=Math.PI/2,{start=0,end=0}=point.shapeArgs||{};let angle=point.angle||0;if(distance>0&&start<halfPI&&end>halfPI&&angle>halfPI/2&&angle<halfPI*1.5){angle=angle<=halfPI?Math.max(halfPI/2,(start+halfPI)/2):Math.min(halfPI*1.5,(halfPI+end)/2)}const{center,options}=this,r=center[2]/2,cosAngle=Math.cos(angle),sinAngle=Math.sin(angle),x=center[0]+cosAngle*r,y=center[1]+sinAngle*r,finalConnectorOffset=Math.min((options.slicedOffset||0)+(options.borderWidth||0),distance/5);return{natural:{x:x+cosAngle*distance,y:y+sinAngle*distance},computed:{},alignment:distance<0?"center":point.half?"right":"left",connectorPosition:{angle:angle,breakAt:{x:x+cosAngle*finalConnectorOffset,y:y+sinAngle*finalConnectorOffset},touchingSliceAt:{x:x,y:y}},distance:distance}}function drawDataLabels(){const series=this,points=series.points,chart=series.chart,plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,plotLeft=chart.plotLeft,maxWidth=Math.round(chart.chartWidth/3),seriesCenter=series.center,radius=seriesCenter[2]/2,centerY=seriesCenter[1],halves=[[],[]],overflow=[0,0,0,0],dataLabelPositioners=series.dataLabelPositioners;let connector,dataLabelWidth,labelHeight,maxLabelDistance=0;if(!series.visible||!series.hasDataLabels?.()){return}points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{if(dataLabel.shortened){dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"});dataLabel.shortened=false}})});Series.prototype.drawDataLabels.apply(series);points.forEach(point=>{(point.dataLabels||[]).forEach((dataLabel,i)=>{const r=seriesCenter[2]/2,dataLabelOptions=dataLabel.options,distance=relativeLength(dataLabelOptions?.distance||0,r);if(i===0){halves[point.half].push(point)}if(!defined(dataLabelOptions?.style?.width)){if(dataLabel.getBBox().width>maxWidth){dataLabel.css({width:Math.round(maxWidth*.7)+"px"});dataLabel.shortened=true}}dataLabel.dataLabelPosition=this.getDataLabelPosition(point,distance);maxLabelDistance=Math.max(maxLabelDistance,distance)})});halves.forEach((points,halfIdx)=>{const length=points.length,positions=[];let top,bottom,size=0,distributionLength;if(!length){return}series.sortByAngle(points,halfIdx-.5);if(maxLabelDistance>0){top=Math.max(0,centerY-radius-maxLabelDistance);bottom=Math.min(centerY+radius+maxLabelDistance,chart.plotHeight);points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const labelPosition=dataLabel.dataLabelPosition;if(labelPosition&&labelPosition.distance>0){labelPosition.top=Math.max(0,centerY-radius-labelPosition.distance);labelPosition.bottom=Math.min(centerY+radius+labelPosition.distance,chart.plotHeight);size=dataLabel.getBBox().height||21;dataLabel.lineHeight=chart.renderer.fontMetrics(dataLabel.text||dataLabel).h+2*dataLabel.padding;point.distributeBox={target:(dataLabel.dataLabelPosition?.natural.y||0)-labelPosition.top+dataLabel.lineHeight/2,size:size,rank:point.y};positions.push(point.distributeBox)}})});distributionLength=bottom+size-top;distribute(positions,distributionLength,distributionLength/5)}points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const dataLabelOptions=dataLabel.options||{},distributeBox=point.distributeBox,labelPosition=dataLabel.dataLabelPosition,naturalY=labelPosition?.natural.y||0,connectorPadding=dataLabelOptions.connectorPadding||0,lineHeight=dataLabel.lineHeight||21,bBox=dataLabel.getBBox(),topOffset=(lineHeight-bBox.height)/2;let x=0,y=naturalY,visibility="inherit";if(labelPosition){if(positions&&defined(distributeBox)&&labelPosition.distance>0){if(typeof distributeBox.pos==="undefined"){visibility="hidden"}else{labelHeight=distributeBox.size;y=dataLabelPositioners.radialDistributionY(point,dataLabel)}}if(dataLabelOptions.justify){x=dataLabelPositioners.justify(point,dataLabel,radius,seriesCenter)}else{switch(dataLabelOptions.alignTo){case"connectors":x=dataLabelPositioners.alignToConnectors(points,halfIdx,plotWidth,plotLeft);break;case"plotEdges":x=dataLabelPositioners.alignToPlotEdges(dataLabel,halfIdx,plotWidth,plotLeft);break;default:x=dataLabelPositioners.radialDistributionX(series,point,y-topOffset,naturalY,dataLabel)}}labelPosition.attribs={visibility:visibility,align:labelPosition.alignment};labelPosition.posAttribs={x:x+(dataLabelOptions.x||0)+({left:connectorPadding,right:-connectorPadding}[labelPosition.alignment]||0),y:y+(dataLabelOptions.y||0)-lineHeight/2};labelPosition.computed.x=x;labelPosition.computed.y=y-topOffset;if(pick(dataLabelOptions.crop,true)){dataLabelWidth=dataLabel.getBBox().width;let sideOverflow;if(x-dataLabelWidth<connectorPadding&&halfIdx===1){sideOverflow=Math.round(dataLabelWidth-x+connectorPadding);overflow[3]=Math.max(sideOverflow,overflow[3])}else if(x+dataLabelWidth>plotWidth-connectorPadding&&halfIdx===0){sideOverflow=Math.round(x+dataLabelWidth-plotWidth+connectorPadding);overflow[1]=Math.max(sideOverflow,overflow[1])}if(y-labelHeight/2<0){overflow[0]=Math.max(Math.round(-y+labelHeight/2),overflow[0])}else if(y+labelHeight/2>plotHeight){overflow[2]=Math.max(Math.round(y+labelHeight/2-plotHeight),overflow[2])}labelPosition.sideOverflow=sideOverflow}}})})});if(arrayMax(overflow)===0||this.verifyDataLabelOverflow(overflow)){this.placeDataLabels();this.points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const{connectorColor,connectorWidth=1}=dataLabel.options||{},labelPosition=dataLabel.dataLabelPosition;if(connectorWidth){let isNew;connector=dataLabel.connector;if(labelPosition&&labelPosition.distance>0){isNew=!connector;if(!connector){dataLabel.connector=connector=chart.renderer.path().addClass("highcharts-data-label-connector "+" highcharts-color-"+point.colorIndex+(point.className?" "+point.className:"")).add(series.dataLabelsGroup)}if(!chart.styledMode){connector.attr({"stroke-width":connectorWidth,stroke:connectorColor||point.color||"#666666"})}connector[isNew?"attr":"animate"]({d:point.getConnectorPath(dataLabel)});connector.attr({visibility:labelPosition.attribs?.visibility})}else if(connector){dataLabel.connector=connector.destroy()}}})})}}function placeDataLabels(){this.points.forEach(point=>{(point.dataLabels||[]).forEach(dataLabel=>{const labelPosition=dataLabel.dataLabelPosition;if(labelPosition){if(labelPosition.sideOverflow){dataLabel.css({width:Math.max(dataLabel.getBBox().width-labelPosition.sideOverflow,0)+"px",textOverflow:(dataLabel.options?.style||{}).textOverflow||"ellipsis"});dataLabel.shortened=true}dataLabel.attr(labelPosition.attribs);dataLabel[dataLabel.moved?"animate":"attr"](labelPosition.posAttribs);dataLabel.moved=true}else if(dataLabel){dataLabel.attr({y:-9999})}});delete point.distributeBox},this)}function verifyDataLabelOverflow(overflow){const center=this.center,options=this.options,centerOption=options.center,minSize=options.minSize||80;let newSize=minSize,ret=options.size!==null;if(!ret){if(centerOption[0]!==null){newSize=Math.max(center[2]-Math.max(overflow[1],overflow[3]),minSize)}else{newSize=Math.max(center[2]-overflow[1]-overflow[3],minSize);center[0]+=(overflow[3]-overflow[1])/2}if(centerOption[1]!==null){newSize=clamp(newSize,minSize,center[2]-Math.max(overflow[0],overflow[2]))}else{newSize=clamp(newSize,minSize,center[2]-overflow[0]-overflow[2]);center[1]+=(overflow[0]-overflow[2])/2}if(newSize<center[2]){center[2]=newSize;center[3]=Math.min(options.thickness?Math.max(0,newSize-options.thickness*2):Math.max(0,relativeLength(options.innerSize||0,newSize)),newSize);this.translate(center);if(this.drawDataLabels){this.drawDataLabels()}}else{ret=true}}return ret}})(ColumnDataLabel||(ColumnDataLabel={}));export default ColumnDataLabel;