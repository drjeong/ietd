"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{setAnimation}=A;import Point from"../../Core/Series/Point.js";import U from"../../Core/Utilities.js";const{addEvent,defined,extend,isNumber,pick,relativeLength}=U;class PiePoint extends Point{getConnectorPath(dataLabel){const labelPosition=dataLabel.dataLabelPosition,options=dataLabel.options||{},connectorShape=options.connectorShape,shapeFunc=this.connectorShapes[connectorShape]||connectorShape;return labelPosition&&shapeFunc.call(this,{...labelPosition.computed,alignment:labelPosition.alignment},labelPosition.connectorPosition,options)||[]}getTranslate(){return this.sliced&&this.slicedTranslation||{translateX:0,translateY:0}}haloPath(size){const shapeArgs=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(shapeArgs.x,shapeArgs.y,shapeArgs.r+size,shapeArgs.r+size,{innerR:shapeArgs.r-1,start:shapeArgs.start,end:shapeArgs.end,borderRadius:shapeArgs.borderRadius})}constructor(series,options,x){super(series,options,x);this.half=0;this.name??(this.name="Slice");const toggleSlice=e=>{this.slice(e.type==="select")};addEvent(this,"select",toggleSlice);addEvent(this,"unselect",toggleSlice)}isValid(){return isNumber(this.y)&&this.y>=0}setVisible(vis,redraw=true){if(vis!==this.visible){this.update({visible:vis??!this.visible},redraw,void 0,false)}}slice(sliced,redraw,animation){const series=this.series,chart=series.chart;setAnimation(animation,chart);redraw=pick(redraw,true);this.sliced=this.options.sliced=sliced=defined(sliced)?sliced:!this.sliced;series.options.data[series.data.indexOf(this)]=this.options;if(this.graphic){this.graphic.animate(this.getTranslate())}}}extend(PiePoint.prototype,{connectorShapes:{fixedOffset:function(labelPosition,connectorPosition,options){const breakAt=connectorPosition.breakAt,touchingSliceAt=connectorPosition.touchingSliceAt,lineSegment=options.softConnector?["C",labelPosition.x+(labelPosition.alignment==="left"?-5:5),labelPosition.y,2*breakAt.x-touchingSliceAt.x,2*breakAt.y-touchingSliceAt.y,breakAt.x,breakAt.y]:["L",breakAt.x,breakAt.y];return[["M",labelPosition.x,labelPosition.y],lineSegment,["L",touchingSliceAt.x,touchingSliceAt.y]]},straight:function(labelPosition,connectorPosition){const touchingSliceAt=connectorPosition.touchingSliceAt;return[["M",labelPosition.x,labelPosition.y],["L",touchingSliceAt.x,touchingSliceAt.y]]},crookedLine:function(labelPosition,connectorPosition,options){const{angle=this.angle||0,breakAt,touchingSliceAt}=connectorPosition,{series}=this,[cx,cy,diameter]=series.center,r=diameter/2,{plotLeft,plotWidth}=series.chart,leftAligned=labelPosition.alignment==="left",{x,y}=labelPosition;let crookX=breakAt.x;if(options.crookDistance){const crookDistance=relativeLength(options.crookDistance,1);crookX=leftAligned?cx+r+(plotWidth+plotLeft-cx-r)*(1-crookDistance):plotLeft+(cx-r)*crookDistance}else{crookX=cx+(cy-y)*Math.tan(angle-Math.PI/2)}const path=[["M",x,y]];if(leftAligned?crookX<=x&&crookX>=breakAt.x:crookX>=x&&crookX<=breakAt.x){path.push(["L",crookX,y])}path.push(["L",breakAt.x,breakAt.y],["L",touchingSliceAt.x,touchingSliceAt.y]);return path}}});export default PiePoint;