"use strict";function attractive(link,force,distanceXY,distanceR){const massFactor=link.getMass(),translatedX=distanceXY.x/distanceR*force,translatedY=distanceXY.y/distanceR*force;if(!link.fromNode.fixedPosition){link.fromNode.dispX-=translatedX*massFactor.fromNode/link.fromNode.degree;link.fromNode.dispY-=translatedY*massFactor.fromNode/link.fromNode.degree}if(!link.toNode.fixedPosition){link.toNode.dispX+=translatedX*massFactor.toNode/link.toNode.degree;link.toNode.dispY+=translatedY*massFactor.toNode/link.toNode.degree}}function attractiveForceFunction(d,k){return d*d/k}function barycenter(){const gravitationalConstant=this.options.gravitationalConstant,xFactor=this.barycenter.xFactor,yFactor=this.barycenter.yFactor;this.nodes.forEach(function(node){if(!node.fixedPosition){const degree=node.getDegree(),phi=degree*(1+degree/2);node.dispX+=(xFactor-node.plotX)*gravitationalConstant*phi/node.degree;node.dispY+=(yFactor-node.plotY)*gravitationalConstant*phi/node.degree}})}function getK(layout){return Math.pow(layout.box.width*layout.box.height/layout.nodes.length,.3)}function integrate(layout,node){node.dispX+=node.dispX*layout.options.friction;node.dispY+=node.dispY*layout.options.friction;const distanceR=node.temperature=layout.vectorLength({x:node.dispX,y:node.dispY});if(distanceR!==0){node.plotX+=node.dispX/distanceR*Math.min(Math.abs(node.dispX),layout.temperature);node.plotY+=node.dispY/distanceR*Math.min(Math.abs(node.dispY),layout.temperature)}}function repulsive(node,force,distanceXY,distanceR){node.dispX+=distanceXY.x/distanceR*force/node.degree;node.dispY+=distanceXY.y/distanceR*force/node.degree}function repulsiveForceFunction(d,k){return k*k/d}const EulerIntegration={attractive:attractive,attractiveForceFunction:attractiveForceFunction,barycenter:barycenter,getK:getK,integrate:integrate,repulsive:repulsive,repulsiveForceFunction:repulsiveForceFunction};export default EulerIntegration;