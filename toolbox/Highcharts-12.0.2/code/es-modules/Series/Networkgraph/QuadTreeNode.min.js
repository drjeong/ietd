"use strict";class QuadTreeNode{constructor(box){this.body=false;this.isEmpty=false;this.isInternal=false;this.nodes=[];this.box=box;this.boxSize=Math.min(box.width,box.height)}divideBox(){const halfWidth=this.box.width/2,halfHeight=this.box.height/2;this.nodes[0]=new QuadTreeNode({left:this.box.left,top:this.box.top,width:halfWidth,height:halfHeight});this.nodes[1]=new QuadTreeNode({left:this.box.left+halfWidth,top:this.box.top,width:halfWidth,height:halfHeight});this.nodes[2]=new QuadTreeNode({left:this.box.left+halfWidth,top:this.box.top+halfHeight,width:halfWidth,height:halfHeight});this.nodes[3]=new QuadTreeNode({left:this.box.left,top:this.box.top+halfHeight,width:halfWidth,height:halfHeight})}getBoxPosition(point){const left=point.plotX<this.box.left+this.box.width/2,top=point.plotY<this.box.top+this.box.height/2;let index;if(left){if(top){index=0}else{index=3}}else{if(top){index=1}else{index=2}}return index}insert(point,depth){let newQuadTreeNode;if(this.isInternal){this.nodes[this.getBoxPosition(point)].insert(point,depth-1)}else{this.isEmpty=false;if(!this.body){this.isInternal=false;this.body=point}else{if(depth){this.isInternal=true;this.divideBox();if(this.body!==true){this.nodes[this.getBoxPosition(this.body)].insert(this.body,depth-1);this.body=true}this.nodes[this.getBoxPosition(point)].insert(point,depth-1)}else{newQuadTreeNode=new QuadTreeNode({top:point.plotX||NaN,left:point.plotY||NaN,width:.1,height:.1});newQuadTreeNode.body=point;newQuadTreeNode.isInternal=false;this.nodes.push(newQuadTreeNode)}}}}updateMassAndCenter(){let mass=0,plotX=0,plotY=0;if(this.isInternal){for(const pointMass of this.nodes){if(!pointMass.isEmpty){mass+=pointMass.mass;plotX+=pointMass.plotX*pointMass.mass;plotY+=pointMass.plotY*pointMass.mass}}plotX/=mass;plotY/=mass}else if(this.body){mass=this.body.mass;plotX=this.body.plotX;plotY=this.body.plotY}this.mass=mass;this.plotX=plotX;this.plotY=plotY}}export default QuadTreeNode;