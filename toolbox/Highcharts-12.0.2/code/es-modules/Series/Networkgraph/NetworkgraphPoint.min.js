"use strict";import NodesComposition from"../NodesComposition.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto,prototype:{pointClass:Point}}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{addEvent,css,defined,extend,pick}=U;class NetworkgraphPoint extends Point{destroy(){if(this.isNode){this.linksFrom.concat(this.linksTo).forEach(function(link){if(link.destroyElements){link.destroyElements()}})}this.series.layout.removeElementFromCollection(this,this.series.layout[this.isNode?"nodes":"links"]);return Point.prototype.destroy.apply(this,arguments)}getDegree(){const deg=this.isNode?this.linksFrom.length+this.linksTo.length:0;return deg===0?1:deg}getLinkAttributes(){const linkOptions=this.series.options.link,pointOptions=this.options;return{"stroke-width":pick(pointOptions.width,linkOptions.width),stroke:pointOptions.color||linkOptions.color,dashstyle:pointOptions.dashStyle||linkOptions.dashStyle,opacity:pick(pointOptions.opacity,linkOptions.opacity,1)}}getLinkPath(){let left=this.fromNode,right=this.toNode;if(left.plotX>right.plotX){left=this.toNode;right=this.fromNode}return[["M",left.plotX||0,left.plotY||0],["L",right.plotX||0,right.plotY||0]]}getMass(){const m1=this.fromNode.mass,m2=this.toNode.mass,sum=m1+m2;return{fromNode:1-m1/sum,toNode:1-m2/sum}}constructor(series,options,x){super(series,options,x);if(this.series.options.draggable&&!this.series.chart.styledMode){addEvent(this,"mouseOver",function(){css(this.series.chart.container,{cursor:"move"})});addEvent(this,"mouseOut",function(){css(this.series.chart.container,{cursor:"default"})})}}isValid(){return!this.isNode||defined(this.id)}redrawLink(){const path=this.getLinkPath();let attribs;if(this.graphic){this.shapeArgs={d:path};if(!this.series.chart.styledMode){attribs=this.series.pointAttribs(this);this.graphic.attr(attribs);(this.dataLabels||[]).forEach(function(label){if(label){label.attr({opacity:attribs.opacity})}})}this.graphic.animate(this.shapeArgs);const start=path[0];const end=path[1];if(start[0]==="M"&&end[0]==="L"){this.plotX=(start[1]+end[1])/2;this.plotY=(start[2]+end[2])/2}}}remove(redraw,animation){const point=this,series=point.series,nodesOptions=series.options.nodes||[];let index,i=nodesOptions.length;if(point.isNode){series.points=[];[].concat(point.linksFrom).concat(point.linksTo).forEach(function(linkFromTo){index=linkFromTo.fromNode.linksFrom.indexOf(linkFromTo);if(index>-1){linkFromTo.fromNode.linksFrom.splice(index,1)}index=linkFromTo.toNode.linksTo.indexOf(linkFromTo);if(index>-1){linkFromTo.toNode.linksTo.splice(index,1)}seriesProto.removePoint.call(series,series.data.indexOf(linkFromTo),false,false)});series.points=series.data.slice();series.nodes.splice(series.nodes.indexOf(point),1);while(i--){if(nodesOptions[i].id===point.options.id){series.options.nodes.splice(i,1);break}}if(point){point.destroy()}series.isDirty=true;series.isDirtyData=true;if(redraw){series.chart.redraw(redraw)}}else{series.removePoint(series.data.indexOf(point),redraw,animation)}}renderLink(){let attribs;if(!this.graphic){this.graphic=this.series.chart.renderer.path(this.getLinkPath()).addClass(this.getClassName(),true).add(this.series.group);if(!this.series.chart.styledMode){attribs=this.series.pointAttribs(this);this.graphic.attr(attribs);(this.dataLabels||[]).forEach(function(label){if(label){label.attr({opacity:attribs.opacity})}})}}}}extend(NetworkgraphPoint.prototype,{setState:NodesComposition.setNodeState});export default NetworkgraphPoint;