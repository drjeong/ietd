"use strict";import FlagsPoint from"./FlagsPoint.js";import FlagsSeriesDefaults from"./FlagsSeriesDefaults.js";import FlagsSymbols from"./FlagsSymbols.js";import H from"../../Core/Globals.js";const{noop}=H;import OnSeriesComposition from"../OnSeriesComposition.js";import R from"../../Core/Renderer/RendererUtilities.js";const{distribute}=R;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series,seriesTypes:{column:ColumnSeries}}=SeriesRegistry;import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import U from"../../Core/Utilities.js";const{addEvent,defined,extend,isNumber,merge,objectEach,wrap}=U;class FlagsSeries extends ColumnSeries{animate(init){if(init){this.setClip()}}drawPoints(){const series=this,points=series.points,chart=series.chart,renderer=chart.renderer,inverted=chart.inverted,options=series.options,optionsY=options.y,yAxis=series.yAxis,boxesMap={},boxes=[],borderRadius=isNumber(options.borderRadius)?options.borderRadius:0;let plotX,plotY,shape,i,point,graphic,stackIndex,anchorY,attribs,outsideRight,centered;i=points.length;while(i--){point=points[i];outsideRight=(inverted?point.plotY:point.plotX)>series.xAxis.len;plotX=point.plotX;stackIndex=point.stackIndex;shape=point.options.shape||options.shape;plotY=point.plotY;if(typeof plotY!=="undefined"){plotY=point.plotY+optionsY-(typeof stackIndex!=="undefined"&&stackIndex*options.stackDistance)}point.anchorX=stackIndex?void 0:point.plotX;anchorY=stackIndex?void 0:point.plotY;centered=shape!=="flag";graphic=point.graphic;if(typeof plotY!=="undefined"&&plotX>=0&&!outsideRight){if(graphic&&point.hasNewShapeType()){graphic=graphic.destroy()}if(!graphic){graphic=point.graphic=renderer.label("",0,void 0,shape,void 0,void 0,options.useHTML).addClass("highcharts-point").add(series.markerGroup);if(point.graphic.div){point.graphic.div.point=point}graphic.isNew=true}graphic.attr({align:centered?"center":"left",width:options.width,height:options.height,"text-align":options.textAlign,r:borderRadius});if(!chart.styledMode){graphic.attr(series.pointAttribs(point)).css(merge(options.style,point.style)).shadow(options.shadow)}if(plotX>0){plotX-=graphic.strokeWidth()%2}attribs={y:plotY,anchorY:anchorY};if(options.allowOverlapX){attribs.x=plotX;attribs.anchorX=point.anchorX}graphic.attr({text:point.options.title??options.title??"A"})[graphic.isNew?"attr":"animate"](attribs);if(!options.allowOverlapX){if(!boxesMap[point.plotX]){boxesMap[point.plotX]={align:centered?.5:0,size:graphic.width||0,target:plotX,anchorX:plotX}}else{boxesMap[point.plotX].size=Math.max(boxesMap[point.plotX].size,graphic.width||0)}}point.tooltipPos=[plotX,plotY+yAxis.pos-chart.plotTop]}else if(graphic){point.graphic=graphic.destroy()}}if(!options.allowOverlapX){let maxDistance=100;objectEach(boxesMap,function(box){box.plotX=box.anchorX;boxes.push(box);maxDistance=Math.max(box.size,maxDistance)});distribute(boxes,inverted?yAxis.len:this.xAxis.len,maxDistance);for(const point of points){const plotX=point.plotX,graphic=point.graphic,box=graphic&&boxesMap[plotX];if(box&&graphic){if(!defined(box.pos)){graphic.hide().isNew=true}else{graphic[graphic.isNew?"attr":"animate"]({x:box.pos+(box.align||0)*box.size,anchorX:point.anchorX}).show().isNew=false}}}}if(options.useHTML&&series.markerGroup){wrap(series.markerGroup,"on",function(proceed){return SVGElement.prototype.on.apply(proceed.apply(this,[].slice.call(arguments,1)),[].slice.call(arguments,1))})}}drawTracker(){const series=this,points=series.points;super.drawTracker();for(const point of points){const graphic=point.graphic;if(graphic){if(point.unbindMouseOver){point.unbindMouseOver()}point.unbindMouseOver=addEvent(graphic.element,"mouseover",function(){if(point.stackIndex>0&&!point.raised){point._y=graphic.y;graphic.attr({y:point._y-8});point.raised=true}for(const otherPoint of points){if(otherPoint!==point&&otherPoint.raised&&otherPoint.graphic){otherPoint.graphic.attr({y:otherPoint._y});otherPoint.raised=false}}})}}}pointAttribs(point,state){const options=this.options,color=point&&point.color||this.color;let lineColor=options.lineColor,lineWidth=point&&point.lineWidth,fill=point&&point.fillColor||options.fillColor;if(state){fill=options.states[state].fillColor;lineColor=options.states[state].lineColor;lineWidth=options.states[state].lineWidth}return{fill:fill||color,stroke:lineColor||color,"stroke-width":lineWidth||options.lineWidth||0}}setClip(){Series.prototype.setClip.apply(this,arguments);if(this.options.clip!==false&&this.sharedClipKey&&this.markerGroup){this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey])}}}FlagsSeries.compose=FlagsSymbols.compose;FlagsSeries.defaultOptions=merge(ColumnSeries.defaultOptions,FlagsSeriesDefaults);OnSeriesComposition.compose(FlagsSeries);extend(FlagsSeries.prototype,{allowDG:false,forceCrop:true,invertible:false,noSharedTooltip:true,pointClass:FlagsPoint,sorted:false,takeOrdinalPosition:false,trackerGroups:["markerGroup"],buildKDTree:noop,init:Series.prototype.init});SeriesRegistry.registerSeriesType("flags",FlagsSeries);export default FlagsSeries;"";