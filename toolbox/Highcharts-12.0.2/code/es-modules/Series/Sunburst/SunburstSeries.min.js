"use strict";import CU from"../CenteredUtilities.js";const{getCenter,getStartAndEndRadians}=CU;import H from"../../Core/Globals.js";const{noop}=H;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,treemap:TreemapSeries}=SeriesRegistry.seriesTypes;import SunburstPoint from"./SunburstPoint.js";import SunburstUtilities from"./SunburstUtilities.js";import TU from"../TreeUtilities.js";const{getColor,getLevelOptions,setTreeValues,updateRootId}=TU;import U from"../../Core/Utilities.js";import SunburstNode from"./SunburstNode.js";import SunburstSeriesDefaults from"./SunburstSeriesDefaults.js";const{defined,error,extend,fireEvent,isNumber,isObject,isString,merge,splat}=U;import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import TextPath from"../../Extensions/TextPath.js";TextPath.compose(SVGElement);const rad2deg=180/Math.PI;function isBoolean(x){return typeof x==="boolean"}const getEndPoint=function getEndPoint(x,y,angle,distance){return{x:x+Math.cos(angle)*distance,y:y+Math.sin(angle)*distance}};function getDlOptions(params){const point=params.point,shape=isObject(params.shapeArgs)?params.shapeArgs:{},optionsPoint=isObject(params.optionsPoint)?params.optionsPoint.dataLabels:{},optionsLevel=splat(isObject(params.level)?params.level.dataLabels:{})[0],options=merge({style:{}},optionsLevel,optionsPoint),{innerArcLength=0,outerArcLength=0}=point;let rotationRad,rotation,rotationMode=options.rotationMode;if(!isNumber(options.rotation)){if(rotationMode==="auto"||rotationMode==="circular"){if(options.useHTML&&rotationMode==="circular"){rotationMode="auto"}if(innerArcLength<1&&outerArcLength>shape.radius){rotationRad=0;if(point.dataLabelPath&&rotationMode==="circular"){options.textPath={enabled:true}}}else if(innerArcLength>1&&outerArcLength>1.5*shape.radius){if(rotationMode==="circular"){options.textPath={enabled:true,attributes:{dy:5}}}else{rotationMode="parallel"}}else{if(point.dataLabel?.textPath&&rotationMode==="circular"){options.textPath={enabled:false}}rotationMode="perpendicular"}}if(rotationMode!=="auto"&&rotationMode!=="circular"){if(point.dataLabel&&point.dataLabel.textPath){options.textPath={enabled:false}}rotationRad=shape.end-(shape.end-shape.start)/2}if(rotationMode==="parallel"){options.style.width=Math.min(shape.radius*2.5,(outerArcLength+innerArcLength)/2)}else{if(!defined(options.style.width)&&shape.radius){options.style.width=point.node.level===1?2*shape.radius:shape.radius}}if(rotationMode==="perpendicular"){if(outerArcLength<16){options.style.width=1}else{options.style.lineClamp=Math.floor(innerArcLength/16)||1}}options.style.width=Math.max(options.style.width-2*(options.padding||0),1);rotation=rotationRad*rad2deg%180;if(rotationMode==="parallel"){rotation-=90}if(rotation>90){rotation-=180}else if(rotation<-90){rotation+=180}options.rotation=rotation}if(options.textPath){if(point.shapeExisting.innerR===0&&options.textPath.enabled){options.rotation=0;options.textPath.enabled=false;options.style.width=Math.max(point.shapeExisting.r*2-2*(options.padding||0),1)}else if(point.dlOptions&&point.dlOptions.textPath&&!point.dlOptions.textPath.enabled&&rotationMode==="circular"){options.textPath.enabled=true}if(options.textPath.enabled){options.rotation=0;options.style.width=Math.max((point.outerArcLength+point.innerArcLength)/2-2*(options.padding||0),1);options.style.whiteSpace="nowrap"}}return options}function getAnimation(shape,params){const point=params.point,radians=params.radians,innerR=params.innerR,idRoot=params.idRoot,idPreviousRoot=params.idPreviousRoot,shapeExisting=params.shapeExisting,shapeRoot=params.shapeRoot,shapePreviousRoot=params.shapePreviousRoot,visible=params.visible;let from={},to={end:shape.end,start:shape.start,innerR:shape.innerR,r:shape.r,x:shape.x,y:shape.y};if(visible){if(!point.graphic&&shapePreviousRoot){if(idRoot===point.id){from={start:radians.start,end:radians.end}}else{from=shapePreviousRoot.end<=shape.start?{start:radians.end,end:radians.end}:{start:radians.start,end:radians.start}}from.innerR=from.r=innerR}}else{if(point.graphic){if(idPreviousRoot===point.id){to={innerR:innerR,r:innerR}}else if(shapeRoot){to=shapeRoot.end<=shapeExisting.start?{innerR:innerR,r:innerR,start:radians.end,end:radians.end}:{innerR:innerR,r:innerR,start:radians.start,end:radians.start}}}}return{from:from,to:to}}function getDrillId(point,idRoot,mapIdToNode){const node=point.node;let drillId,nodeRoot;if(!node.isLeaf){if(idRoot===point.id){nodeRoot=mapIdToNode[idRoot];drillId=nodeRoot.parent}else{drillId=point.id}}return drillId}function cbSetTreeValuesBefore(node,options){const mapIdToNode=options.mapIdToNode,parent=node.parent,nodeParent=parent?mapIdToNode[parent]:void 0,series=options.series,chart=series.chart,points=series.points,point=points[node.i],colors=series.options.colors||chart&&chart.options.colors,colorInfo=getColor(node,{colors:colors,colorIndex:series.colorIndex,index:options.index,mapOptionsToLevel:options.mapOptionsToLevel,parentColor:nodeParent&&nodeParent.color,parentColorIndex:nodeParent&&nodeParent.colorIndex,series:options.series,siblings:options.siblings});node.color=colorInfo.color;node.colorIndex=colorInfo.colorIndex;if(point){point.color=node.color;point.colorIndex=node.colorIndex;node.sliced=node.id!==options.idRoot?point.sliced:false}return node}class SunburstSeries extends TreemapSeries{alignDataLabel(point,dataLabel,labelOptions){if(labelOptions.textPath&&labelOptions.textPath.enabled){return}return super.alignDataLabel.apply(this,arguments)}animate(init){const chart=this.chart,center=[chart.plotWidth/2,chart.plotHeight/2],plotLeft=chart.plotLeft,plotTop=chart.plotTop,group=this.group;let attribs;if(init){attribs={translateX:center[0]+plotLeft,translateY:center[1]+plotTop,scaleX:.001,scaleY:.001,rotation:10,opacity:.01};group.attr(attribs)}else{attribs={translateX:plotLeft,translateY:plotTop,scaleX:1,scaleY:1,rotation:0,opacity:1};group.animate(attribs,this.options.animation)}}drawPoints(){const series=this,mapOptionsToLevel=series.mapOptionsToLevel,shapeRoot=series.shapeRoot,group=series.group,hasRendered=series.hasRendered,idRoot=series.rootNode,idPreviousRoot=series.idPreviousRoot,nodeMap=series.nodeMap,nodePreviousRoot=nodeMap[idPreviousRoot],shapePreviousRoot=nodePreviousRoot&&nodePreviousRoot.shapeArgs,points=series.points,radians=series.startAndEndRadians,chart=series.chart,optionsChart=chart&&chart.options&&chart.options.chart||{},animation=isBoolean(optionsChart.animation)?optionsChart.animation:true,positions=series.center,center={x:positions[0],y:positions[1]},innerR=positions[3]/2,renderer=series.chart.renderer,hackDataLabelAnimation=!!(animation&&hasRendered&&idRoot!==idPreviousRoot&&series.dataLabelsGroup);let animateLabels,animateLabelsCalled=false,addedHack=false;if(hackDataLabelAnimation){series.dataLabelsGroup.attr({opacity:0});animateLabels=function(){const s=series;animateLabelsCalled=true;if(s.dataLabelsGroup){s.dataLabelsGroup.animate({opacity:1,visibility:"inherit"})}}}for(const point of points){const node=point.node,level=mapOptionsToLevel[node.level],shapeExisting=point.shapeExisting||{},shape=node.shapeArgs||{},visible=!!(node.visible&&node.shapeArgs);let animationInfo,onComplete;shape.borderRadius=series.options.borderRadius;if(hasRendered&&animation){animationInfo=getAnimation(shape,{center:center,point:point,radians:radians,innerR:innerR,idRoot:idRoot,idPreviousRoot:idPreviousRoot,shapeExisting:shapeExisting,shapeRoot:shapeRoot,shapePreviousRoot:shapePreviousRoot,visible:visible})}else{animationInfo={to:shape,from:{}}}extend(point,{shapeExisting:shape,tooltipPos:[shape.plotX,shape.plotY],drillId:getDrillId(point,idRoot,nodeMap),name:""+(point.name||point.id||point.index),plotX:shape.plotX,plotY:shape.plotY,value:node.val,isInside:visible,isNull:!visible});point.dlOptions=getDlOptions({point:point,level:level,optionsPoint:point.options,shapeArgs:shape});if(!addedHack&&visible){addedHack=true;onComplete=animateLabels}point.draw({animatableAttribs:animationInfo.to,attribs:extend(animationInfo.from,!chart.styledMode&&series.pointAttribs(point,point.selected&&"select")),onComplete:onComplete,group:group,renderer:renderer,shapeType:"arc",shapeArgs:shape})}if(hackDataLabelAnimation&&addedHack){series.hasRendered=false;series.options.dataLabels.defer=true;ColumnSeries.prototype.drawDataLabels.call(series);series.hasRendered=true;if(animateLabelsCalled){animateLabels()}}else{ColumnSeries.prototype.drawDataLabels.call(series)}series.idPreviousRoot=idRoot}layoutAlgorithm(parent,children,options){let startAngle=parent.start;const range=parent.end-startAngle,total=parent.val,x=parent.x,y=parent.y,radius=options&&isObject(options.levelSize)&&isNumber(options.levelSize.value)?options.levelSize.value:0,innerRadius=parent.r,outerRadius=innerRadius+radius,slicedOffset=options&&isNumber(options.slicedOffset)?options.slicedOffset:0;return(children||[]).reduce((arr,child)=>{const percentage=1/total*child.val,radians=percentage*range,radiansCenter=startAngle+radians/2,offsetPosition=getEndPoint(x,y,radiansCenter,slicedOffset),values={x:child.sliced?offsetPosition.x:x,y:child.sliced?offsetPosition.y:y,innerR:innerRadius,r:outerRadius,radius:radius,start:startAngle,end:startAngle+radians};arr.push(values);startAngle=values.end;return arr},[])}setRootNode(id,redraw,eventArguments){const series=this;if(series.nodeMap[id].level===1&&series.nodeList.filter(node=>node.level===1).length===1){if(series.idPreviousRoot===""){return}id=""}super.setRootNode(id,redraw,eventArguments)}setShapeArgs(parent,parentValues,mapOptionsToLevel){const level=parent.level+1,options=mapOptionsToLevel[level],children=parent.children.filter(function(n){return n.visible}),twoPi=6.28;let childrenValues=[];childrenValues=this.layoutAlgorithm(parentValues,children,options);let i=-1;for(const child of children){const values=childrenValues[++i],angle=values.start+(values.end-values.start)/2,radius=values.innerR+(values.r-values.innerR)/2,radians=values.end-values.start,isCircle=values.innerR===0&&radians>twoPi,center=isCircle?{x:values.x,y:values.y}:getEndPoint(values.x,values.y,angle,radius),val=child.val?child.childrenTotal>child.val?child.childrenTotal:child.val:child.childrenTotal;if(this.points[child.i]){this.points[child.i].innerArcLength=radians*values.innerR;this.points[child.i].outerArcLength=radians*values.r}child.shapeArgs=merge(values,{plotX:center.x,plotY:center.y});child.values=merge(values,{val:val});if(child.children.length){this.setShapeArgs(child,child.values,mapOptionsToLevel)}}}translate(){const series=this,options=series.options,positions=series.center=series.getCenter(),radians=series.startAndEndRadians=getStartAndEndRadians(options.startAngle,options.endAngle),innerRadius=positions[3]/2,outerRadius=positions[2]/2,diffRadius=outerRadius-innerRadius,rootId=updateRootId(series);let mapIdToNode=series.nodeMap,mapOptionsToLevel,nodeRoot=mapIdToNode&&mapIdToNode[rootId],nodeIds={};series.shapeRoot=nodeRoot&&nodeRoot.shapeArgs;series.generatePoints();fireEvent(series,"afterTranslate");const tree=series.tree=series.getTree();mapIdToNode=series.nodeMap;nodeRoot=mapIdToNode[rootId];const idTop=isString(nodeRoot.parent)?nodeRoot.parent:"",nodeTop=mapIdToNode[idTop],{from,to}=SunburstUtilities.getLevelFromAndTo(nodeRoot);mapOptionsToLevel=getLevelOptions({from:from,levels:series.options.levels,to:to,defaults:{colorByPoint:options.colorByPoint,dataLabels:options.dataLabels,levelIsConstant:options.levelIsConstant,levelSize:options.levelSize,slicedOffset:options.slicedOffset}});mapOptionsToLevel=SunburstUtilities.calculateLevelSizes(mapOptionsToLevel,{diffRadius:diffRadius,from:from,to:to});setTreeValues(tree,{before:cbSetTreeValuesBefore,idRoot:rootId,levelIsConstant:options.levelIsConstant,mapOptionsToLevel:mapOptionsToLevel,mapIdToNode:mapIdToNode,points:series.points,series:series});const values=mapIdToNode[""].shapeArgs={end:radians.end,r:innerRadius,start:radians.start,val:nodeRoot.val,x:positions[0],y:positions[1]};this.setShapeArgs(nodeTop,values,mapOptionsToLevel);series.mapOptionsToLevel=mapOptionsToLevel;for(const point of series.points){if(nodeIds[point.id]){error(31,false,series.chart)}nodeIds[point.id]=true}nodeIds={}}}SunburstSeries.defaultOptions=merge(TreemapSeries.defaultOptions,SunburstSeriesDefaults);extend(SunburstSeries.prototype,{axisTypes:[],drawDataLabels:noop,getCenter:getCenter,isCartesian:false,onPointSupported:true,pointAttribs:ColumnSeries.prototype.pointAttribs,pointClass:SunburstPoint,NodeClass:SunburstNode,utils:SunburstUtilities});SeriesRegistry.registerSeriesType("sunburst",SunburstSeries);export default SunburstSeries;