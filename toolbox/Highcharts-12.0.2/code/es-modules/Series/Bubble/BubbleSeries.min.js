"use strict";import BubbleLegendComposition from"./BubbleLegendComposition.js";import BubblePoint from"./BubblePoint.js";import Color from"../../Core/Color/Color.js";const{parse:color}=Color;import H from"../../Core/Globals.js";const{composed,noop}=H;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series,seriesTypes:{column:{prototype:columnProto},scatter:ScatterSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,clamp,extend,isNumber,merge,pick,pushUnique}=U;function onAxisFoundExtremes(){const axisLength=this.len,{coll,isXAxis,min}=this,range=(this.max||0)-(min||0);let pxMin=0,pxMax=axisLength,transA=axisLength/range,hasActiveSeries;if(coll!=="xAxis"&&coll!=="yAxis"){return}this.series.forEach(series=>{if(series.bubblePadding&&series.reserveSpace()){this.allowZoomOutside=true;hasActiveSeries=true;const data=series.getColumn(isXAxis?"x":"y");if(isXAxis){(series.onPoint||series).getRadii(0,0,series);if(series.onPoint){series.radii=series.onPoint.radii}}if(range>0){let i=data.length;while(i--){if(isNumber(data[i])&&this.dataMin<=data[i]&&data[i]<=this.max){const radius=series.radii&&series.radii[i]||0;pxMin=Math.min((data[i]-min)*transA-radius,pxMin);pxMax=Math.max((data[i]-min)*transA+radius,pxMax)}}}}});if(hasActiveSeries&&range>0&&!this.logarithmic){pxMax-=axisLength;transA*=(axisLength+Math.max(0,pxMin)-Math.min(pxMax,axisLength))/axisLength;[["min","userMin",pxMin],["max","userMax",pxMax]].forEach(keys=>{if(typeof pick(this.options[keys[0]],this[keys[1]])==="undefined"){this[keys[0]]+=keys[2]/transA}})}}function onAxisAfterRender(){const{ticks,tickPositions,dataMin=0,dataMax=0,categories}=this,type=this.options.type;if((categories?.length||type==="category")&&this.series.find(s=>s.bubblePadding)){let tickCount=tickPositions.length;while(tickCount--){const tick=ticks[tickPositions[tickCount]],pos=tick.pos||0;if(pos>dataMax||pos<dataMin){tick.label?.hide()}}}}class BubbleSeries extends ScatterSeries{static compose(AxisClass,ChartClass,LegendClass){BubbleLegendComposition.compose(ChartClass,LegendClass);if(pushUnique(composed,"Series.Bubble")){addEvent(AxisClass,"foundExtremes",onAxisFoundExtremes);addEvent(AxisClass,"afterRender",onAxisAfterRender)}}animate(init){if(!init&&this.points.length<this.options.animationLimit){this.points.forEach(function(point){const{graphic,plotX=0,plotY=0}=point;if(graphic&&graphic.width){if(!this.hasRendered){graphic.attr({x:plotX,y:plotY,width:1,height:1})}graphic.animate(this.markerAttribs(point),this.options.animation)}},this)}}getRadii(){const zData=this.getColumn("z"),yData=this.getColumn("y"),radii=[];let len,i,value,zExtremes=this.chart.bubbleZExtremes;const{minPxSize,maxPxSize}=this.getPxExtremes();if(!zExtremes){let zMin=Number.MAX_VALUE;let zMax=-Number.MAX_VALUE;let valid;this.chart.series.forEach(otherSeries=>{if(otherSeries.bubblePadding&&otherSeries.reserveSpace()){const zExtremes=(otherSeries.onPoint||otherSeries).getZExtremes();if(zExtremes){zMin=Math.min(pick(zMin,zExtremes.zMin),zExtremes.zMin);zMax=Math.max(pick(zMax,zExtremes.zMax),zExtremes.zMax);valid=true}}});if(valid){zExtremes={zMin:zMin,zMax:zMax};this.chart.bubbleZExtremes=zExtremes}else{zExtremes={zMin:0,zMax:0}}}for(i=0,len=zData.length;i<len;i++){value=zData[i];radii.push(this.getRadius(zExtremes.zMin,zExtremes.zMax,minPxSize,maxPxSize,value,yData&&yData[i]))}this.radii=radii}getRadius(zMin,zMax,minSize,maxSize,value,yValue){const options=this.options,sizeByArea=options.sizeBy!=="width",zThreshold=options.zThreshold;let zRange=zMax-zMin,pos=.5;if(yValue===null||value===null){return null}if(isNumber(value)){if(options.sizeByAbsoluteValue){value=Math.abs(value-zThreshold);zMax=zRange=Math.max(zMax-zThreshold,Math.abs(zMin-zThreshold));zMin=0}if(value<zMin){return minSize/2-1}if(zRange>0){pos=(value-zMin)/zRange}}if(sizeByArea&&pos>=0){pos=Math.sqrt(pos)}return Math.ceil(minSize+pos*(maxSize-minSize))/2}hasData(){return!!this.dataTable.rowCount}markerAttribs(point,state){const attr=super.markerAttribs(point,state),{height=0,width=0}=attr;return this.chart.inverted?extend(attr,{x:(point.plotX||0)-width/2,y:(point.plotY||0)-height/2}):attr}pointAttribs(point,state){const markerOptions=this.options.marker,fillOpacity=markerOptions.fillOpacity,attr=Series.prototype.pointAttribs.call(this,point,state);if(fillOpacity!==1){attr.fill=color(attr.fill).setOpacity(fillOpacity).get("rgba")}return attr}translate(){super.translate.call(this);this.getRadii();this.translateBubble()}translateBubble(){const{data,options,radii}=this,{minPxSize}=this.getPxExtremes();let i=data.length;while(i--){const point=data[i],radius=radii?radii[i]:0;if(this.zoneAxis==="z"){point.negative=(point.z||0)<(options.zThreshold||0)}if(isNumber(radius)&&radius>=minPxSize/2){point.marker=extend(point.marker,{radius:radius,width:2*radius,height:2*radius});point.dlBox={x:point.plotX-radius,y:point.plotY-radius,width:2*radius,height:2*radius}}else{point.shapeArgs=point.plotY=point.dlBox=void 0;point.isInside=false}}}getPxExtremes(){const smallestSize=Math.min(this.chart.plotWidth,this.chart.plotHeight);const getPxSize=length=>{let isPercent;if(typeof length==="string"){isPercent=/%$/.test(length);length=parseInt(length,10)}return isPercent?smallestSize*length/100:length};const minPxSize=getPxSize(pick(this.options.minSize,8));const maxPxSize=Math.max(getPxSize(pick(this.options.maxSize,"20%")),minPxSize);return{minPxSize:minPxSize,maxPxSize:maxPxSize}}getZExtremes(){const options=this.options,zData=this.getColumn("z").filter(isNumber);if(zData.length){const zMin=pick(options.zMin,clamp(arrayMin(zData),options.displayNegative===false?options.zThreshold||0:-Number.MAX_VALUE,Number.MAX_VALUE));const zMax=pick(options.zMax,arrayMax(zData));if(isNumber(zMin)&&isNumber(zMax)){return{zMin:zMin,zMax:zMax}}}}}BubbleSeries.defaultOptions=merge(ScatterSeries.defaultOptions,{dataLabels:{formatter:function(){const{numberFormatter}=this.series.chart;const{z}=this.point;return isNumber(z)?numberFormatter(z,-1):""},inside:true,verticalAlign:"middle"},animationLimit:250,marker:{lineColor:null,lineWidth:1,fillOpacity:.5,radius:null,states:{hover:{radiusPlus:0}},symbol:"circle"},minSize:8,maxSize:"20%",softThreshold:false,states:{hover:{halo:{size:5}}},tooltip:{pointFormat:"({point.x}, {point.y}), Size: {point.z}"},turboThreshold:0,zThreshold:0,zoneAxis:"z"});extend(BubbleSeries.prototype,{alignDataLabel:columnProto.alignDataLabel,applyZones:noop,bubblePadding:true,isBubble:true,keysAffectYAxis:["y"],pointArrayMap:["y","z"],pointClass:BubblePoint,parallelArrays:["x","y","z"],trackerGroups:["group","dataLabelsGroup"],specialGroup:"group",zoneAxis:"z"});addEvent(BubbleSeries,"updatedData",e=>{delete e.target.chart.bubbleZExtremes});addEvent(BubbleSeries,"remove",e=>{delete e.target.chart.bubbleZExtremes});SeriesRegistry.registerSeriesType("bubble",BubbleSeries);export default BubbleSeries;"";"";