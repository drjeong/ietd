"use strict";import AreaSeriesDefaults from"./AreaSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{seriesTypes:{line:LineSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{extend,merge,objectEach,pick}=U;class AreaSeries extends LineSeries{drawGraph(){this.areaPath=[];super.drawGraph.apply(this);const{areaPath,options}=this;[this,...this.zones].forEach((owner,i)=>{const attribs={},fillColor=owner.fillColor||options.fillColor;let area=owner.area;const verb=area?"animate":"attr";if(area){area.endX=this.preventGraphAnimation?null:areaPath.xMap;area.animate({d:areaPath})}else{attribs.zIndex=0;area=owner.area=this.chart.renderer.path(areaPath).addClass("highcharts-area"+(i?` highcharts-zone-area-${i-1} `:" ")+(i&&owner.className||"")).add(this.group);area.isArea=true}if(!this.chart.styledMode){attribs.fill=fillColor||owner.color||this.color;attribs["fill-opacity"]=fillColor?1:options.fillOpacity??.75;area.css({pointerEvents:this.stickyTracking?"none":"auto"})}area[verb](attribs);area.startX=areaPath.xMap;area.shiftUnit=options.step?2:1})}getGraphPath(points){const getGraphPath=LineSeries.prototype.getGraphPath,options=this.options,stacking=options.stacking,yAxis=this.yAxis,bottomPoints=[],graphPoints=[],seriesIndex=this.index,stacks=yAxis.stacking.stacks[this.stackKey],threshold=options.threshold,translatedThreshold=Math.round(yAxis.getThreshold(options.threshold)),connectNulls=pick(options.connectNulls,stacking==="percent"),addDummyPoints=function(i,otherI,side){const point=points[i],stackedValues=stacking&&stacks[point.x].points[seriesIndex],nullVal=point[side+"Null"]||0,cliffVal=point[side+"Cliff"]||0;let top,bottom,isNull=true;if(cliffVal||nullVal){top=(nullVal?stackedValues[0]:stackedValues[1])+cliffVal;bottom=stackedValues[0]+cliffVal;isNull=!!nullVal}else if(!stacking&&points[otherI]&&points[otherI].isNull){top=bottom=threshold}if(typeof top!=="undefined"){graphPoints.push({plotX:plotX,plotY:top===null?translatedThreshold:yAxis.getThreshold(top),isNull:isNull,isCliff:true});bottomPoints.push({plotX:plotX,plotY:bottom===null?translatedThreshold:yAxis.getThreshold(bottom),doCurve:false})}};let plotX,isNull,yBottom;points=points||this.points;if(stacking){points=this.getStackPoints(points)}for(let i=0,iEnd=points.length;i<iEnd;++i){if(!stacking){points[i].leftCliff=points[i].rightCliff=points[i].leftNull=points[i].rightNull=void 0}isNull=points[i].isNull;plotX=pick(points[i].rectPlotX,points[i].plotX);yBottom=stacking?pick(points[i].yBottom,translatedThreshold):translatedThreshold;if(!isNull||connectNulls){if(!connectNulls){addDummyPoints(i,i-1,"left")}if(!(isNull&&!stacking&&connectNulls)){graphPoints.push(points[i]);bottomPoints.push({x:i,plotX:plotX,plotY:yBottom})}if(!connectNulls){addDummyPoints(i,i+1,"right")}}}const topPath=getGraphPath.call(this,graphPoints,true,true);bottomPoints.reversed=true;const bottomPath=getGraphPath.call(this,bottomPoints,true,true);const firstBottomPoint=bottomPath[0];if(firstBottomPoint&&firstBottomPoint[0]==="M"){bottomPath[0]=["L",firstBottomPoint[1],firstBottomPoint[2]]}const areaPath=topPath.concat(bottomPath);if(areaPath.length){areaPath.push(["Z"])}const graphPath=getGraphPath.call(this,graphPoints,false,connectNulls);if(this.chart.series.length>1&&stacking&&graphPoints.some(point=>point.isCliff)){areaPath.hasStackedCliffs=graphPath.hasStackedCliffs=true}areaPath.xMap=topPath.xMap;this.areaPath=areaPath;return graphPath}getStackPoints(points){const series=this,segment=[],keys=[],xAxis=this.xAxis,yAxis=this.yAxis,stack=yAxis.stacking.stacks[this.stackKey],pointMap={},yAxisSeries=yAxis.series,seriesLength=yAxisSeries.length,upOrDown=yAxis.options.reversedStacks?1:-1,seriesIndex=yAxisSeries.indexOf(series);points=points||this.points;if(this.options.stacking){for(let i=0;i<points.length;i++){points[i].leftNull=points[i].rightNull=void 0;pointMap[points[i].x]=points[i]}objectEach(stack,function(stackX,x){if(stackX.total!==null){keys.push(x)}});keys.sort(function(a,b){return a-b});const visibleSeries=yAxisSeries.map(s=>s.visible);keys.forEach(function(x,idx){let y=0,stackPoint,stackedValues;if(pointMap[x]&&!pointMap[x].isNull){segment.push(pointMap[x]);[-1,1].forEach(function(direction){const nullName=direction===1?"rightNull":"leftNull",cliffName=direction===1?"rightCliff":"leftCliff",otherStack=stack[keys[idx+direction]];let cliff=0;if(otherStack){let i=seriesIndex;while(i>=0&&i<seriesLength){const si=yAxisSeries[i].index;stackPoint=otherStack.points[si];if(!stackPoint){if(si===series.index){pointMap[x][nullName]=true}else if(visibleSeries[i]){stackedValues=stack[x].points[si];if(stackedValues){cliff-=stackedValues[1]-stackedValues[0]}}}i+=upOrDown}}pointMap[x][cliffName]=cliff})}else{let i=seriesIndex;while(i>=0&&i<seriesLength){const si=yAxisSeries[i].index;stackPoint=stack[x].points[si];if(stackPoint){y=stackPoint[1];break}i+=upOrDown}y=pick(y,0);y=yAxis.translate(y,0,1,0,1);segment.push({isNull:true,plotX:xAxis.translate(x,0,0,0,1),x:x,plotY:y,yBottom:y})}})}return segment}}AreaSeries.defaultOptions=merge(LineSeries.defaultOptions,AreaSeriesDefaults);extend(AreaSeries.prototype,{singleStacks:false});SeriesRegistry.registerSeriesType("area",AreaSeries);export default AreaSeries;