"use strict";import Breadcrumbs from"../../Extensions/Breadcrumbs/Breadcrumbs.js";import Color from"../../Core/Color/Color.js";const{parse:color}=Color;import ColorMapComposition from"../ColorMapComposition.js";import H from"../../Core/Globals.js";const{composed,noop}=H;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import TreemapAlgorithmGroup from"./TreemapAlgorithmGroup.js";import TreemapNode from"./TreemapNode.js";import TreemapPoint from"./TreemapPoint.js";import TreemapSeriesDefaults from"./TreemapSeriesDefaults.js";import TreemapUtilities from"./TreemapUtilities.js";import TU from"../TreeUtilities.js";const{getColor,getLevelOptions,updateRootId}=TU;import U from"../../Core/Utilities.js";const{addEvent,correctFloat,crisp,defined,error,extend,fireEvent,isArray,isObject,isString,merge,pick,pushUnique,stableSort}=U;const axisMax=100;let treemapAxisDefaultValues=false;function onSeriesAfterBindAxes(){const series=this,xAxis=series.xAxis,yAxis=series.yAxis;let treeAxis;if(xAxis&&yAxis){if(series.is("treemap")){treeAxis={endOnTick:false,gridLineWidth:0,lineWidth:0,min:0,minPadding:0,max:axisMax,maxPadding:0,startOnTick:false,title:void 0,tickPositions:[]};extend(yAxis.options,treeAxis);extend(xAxis.options,treeAxis);treemapAxisDefaultValues=true}else if(treemapAxisDefaultValues){yAxis.setOptions(yAxis.userOptions);xAxis.setOptions(xAxis.userOptions);treemapAxisDefaultValues=false}}}class TreemapSeries extends ScatterSeries{static compose(SeriesClass){if(pushUnique(composed,"TreemapSeries")){addEvent(SeriesClass,"afterBindAxes",onSeriesAfterBindAxes)}}algorithmCalcPoints(directionChange,last,group,childrenArea){const plot=group.plot,end=group.elArr.length-1;let pX,pY,pW,pH,gW=group.lW,gH=group.lH,keep,i=0;if(last){gW=group.nW;gH=group.nH}else{keep=group.elArr[end]}for(const p of group.elArr){if(last||i<end){if(group.direction===0){pX=plot.x;pY=plot.y;pW=gW;pH=p/pW}else{pX=plot.x;pY=plot.y;pH=gH;pW=p/pH}childrenArea.push({x:pX,y:pY,width:pW,height:correctFloat(pH)});if(group.direction===0){plot.y=plot.y+pH}else{plot.x=plot.x+pW}}i=i+1}group.reset();if(group.direction===0){group.width=group.width-gW}else{group.height=group.height-gH}plot.y=plot.parent.y+(plot.parent.height-group.height);plot.x=plot.parent.x+(plot.parent.width-group.width);if(directionChange){group.direction=1-group.direction}if(!last){group.addElement(keep)}}algorithmFill(directionChange,parent,children){const childrenArea=[];let pTot,direction=parent.direction,x=parent.x,y=parent.y,width=parent.width,height=parent.height,pX,pY,pW,pH;for(const child of children){pTot=parent.width*parent.height*(child.val/parent.val);pX=x;pY=y;if(direction===0){pH=height;pW=pTot/pH;width=width-pW;x=x+pW}else{pW=width;pH=pTot/pW;height=height-pH;y=y+pH}childrenArea.push({x:pX,y:pY,width:pW,height:pH});if(directionChange){direction=1-direction}}return childrenArea}algorithmLowAspectRatio(directionChange,parent,children){const series=this,childrenArea=[],plot={x:parent.x,y:parent.y,parent:parent},direction=parent.direction,end=children.length-1,group=new TreemapAlgorithmGroup(parent.height,parent.width,direction,plot);let pTot,i=0;for(const child of children){pTot=parent.width*parent.height*(child.val/parent.val);group.addElement(pTot);if(group.lP.nR>group.lP.lR){series.algorithmCalcPoints(directionChange,false,group,childrenArea,plot)}if(i===end){series.algorithmCalcPoints(directionChange,true,group,childrenArea,plot)}++i}return childrenArea}alignDataLabel(point,dataLabel,labelOptions){const style=labelOptions.style;if(style&&!defined(style.textOverflow)&&dataLabel.text&&dataLabel.getBBox().width>(dataLabel.text.textWidth||0)){dataLabel.css({textOverflow:"ellipsis",width:style.width+="px"})}ColumnSeries.prototype.alignDataLabel.apply(this,arguments);if(point.dataLabel){point.dataLabel.attr({zIndex:(point.node.zIndex||0)+1})}}calculateChildrenAreas(parent,area){const series=this,options=series.options,mapOptionsToLevel=series.mapOptionsToLevel,level=mapOptionsToLevel[parent.level+1],algorithm=pick(series[level&&level.layoutAlgorithm]&&level.layoutAlgorithm,options.layoutAlgorithm),alternate=options.alternateStartingDirection,children=parent.children.filter(n=>!n.ignore);let childrenValues=[];if(level&&level.layoutStartingDirection){area.direction=level.layoutStartingDirection==="vertical"?0:1}childrenValues=series[algorithm](area,children);let i=-1;for(const child of children){const values=childrenValues[++i];child.values=merge(values,{val:child.childrenTotal,direction:alternate?1-area.direction:area.direction});child.pointValues=merge(values,{x:values.x/series.axisRatio,y:axisMax-values.y-values.height,width:values.width/series.axisRatio});if(child.children.length){series.calculateChildrenAreas(child,child.values)}}}createList(e){const chart=this.chart,breadcrumbs=chart.breadcrumbs,list=[];if(breadcrumbs){let currentLevelNumber=0;list.push({level:currentLevelNumber,levelOptions:chart.series[0]});let node=e.target.nodeMap[e.newRootId];const extraNodes=[];while(node.parent||node.parent===""){extraNodes.push(node);node=e.target.nodeMap[node.parent]}for(const node of extraNodes.reverse()){list.push({level:++currentLevelNumber,levelOptions:node})}if(list.length<=1){list.length=0}}return list}drawDataLabels(){const series=this,mapOptionsToLevel=series.mapOptionsToLevel,points=series.points.filter(function(n){return n.node.visible});let options,level;for(const point of points){level=mapOptionsToLevel[point.node.level];options={style:{}};if(!point.node.isLeaf){options.enabled=false}if(level&&level.dataLabels){options=merge(options,level.dataLabels);series.hasDataLabels=()=>true}if(point.shapeArgs){const css={width:`${point.shapeArgs.width||0}px`,lineClamp:Math.floor((point.shapeArgs.height||0)/16)};extend(options.style,css);point.dataLabel?.css(css)}point.dlOptions=merge(options,point.options.dataLabels)}super.drawDataLabels()}drawPoints(points=this.points){const series=this,chart=series.chart,renderer=chart.renderer,styledMode=chart.styledMode,options=series.options,shadow=styledMode?{}:options.shadow,borderRadius=options.borderRadius,withinAnimationLimit=chart.pointCount<options.animationLimit,allowTraversingTree=options.allowTraversingTree;for(const point of points){const levelDynamic=point.node.levelDynamic,animatableAttribs={},attribs={},css={},groupKey="level-group-"+point.node.level,hasGraphic=!!point.graphic,shouldAnimate=withinAnimationLimit&&hasGraphic,shapeArgs=point.shapeArgs;if(point.shouldDraw()){point.isInside=true;if(borderRadius){attribs.r=borderRadius}merge(true,shouldAnimate?animatableAttribs:attribs,hasGraphic?shapeArgs:{},styledMode?{}:series.pointAttribs(point,point.selected?"select":void 0));if(series.colorAttribs&&styledMode){extend(css,series.colorAttribs(point))}if(!series[groupKey]){series[groupKey]=renderer.g(groupKey).attr({zIndex:1e3-(levelDynamic||0)}).add(series.group);series[groupKey].survive=true}}point.draw({animatableAttribs:animatableAttribs,attribs:attribs,css:css,group:series[groupKey],imageUrl:point.imageUrl,renderer:renderer,shadow:shadow,shapeArgs:shapeArgs,shapeType:point.shapeType});if(allowTraversingTree&&point.graphic){point.drillId=options.interactByLeaf?series.drillToByLeaf(point):series.drillToByGroup(point)}}}drillToByGroup(point){let drillId=false;if(!point.node.isLeaf&&point.node.level-this.nodeMap[this.rootNode].level===1){drillId=point.id}return drillId}drillToByLeaf(point){const{traverseToLeaf}=point.series.options;let drillId=false,nodeParent;if(point.node.parent!==this.rootNode&&point.node.isLeaf){if(traverseToLeaf){drillId=point.id}else{nodeParent=point.node;while(!drillId){if(typeof nodeParent.parent!=="undefined"){nodeParent=this.nodeMap[nodeParent.parent]}if(nodeParent.parent===this.rootNode){drillId=nodeParent.id}}}}return drillId}drillToNode(id,redraw){error(32,false,void 0,{"treemap.drillToNode":"use treemap.setRootNode"});this.setRootNode(id,redraw)}drillUp(){const series=this,node=series.nodeMap[series.rootNode];if(node&&isString(node.parent)){series.setRootNode(node.parent,true,{trigger:"traverseUpButton"})}}getExtremes(){const{dataMin,dataMax}=super.getExtremes(this.colorValueData);this.valueMin=dataMin;this.valueMax=dataMax;return super.getExtremes()}getListOfParents(data,existingIds){const arr=isArray(data)?data:[],ids=isArray(existingIds)?existingIds:[],listOfParents=arr.reduce(function(prev,curr,i){const parent=pick(curr.parent,"");if(typeof prev[parent]==="undefined"){prev[parent]=[]}prev[parent].push(i);return prev},{"":[]});for(const parent of Object.keys(listOfParents)){const children=listOfParents[parent];if(parent!==""&&ids.indexOf(parent)===-1){for(const child of children){listOfParents[""].push(child)}delete listOfParents[parent]}}return listOfParents}getTree(){const series=this,allIds=this.data.map(function(d){return d.id}),parentList=series.getListOfParents(this.data,allIds);series.nodeMap={};series.nodeList=[];return series.buildTree("",-1,0,parentList)}buildTree(id,index,level,list,parent){const series=this,children=[],point=series.points[index];let height=0,child;for(const i of list[id]||[]){child=series.buildTree(series.points[i].id,i,level+1,list,id);height=Math.max(child.height+1,height);children.push(child)}const node=(new series.NodeClass).init(id,index,children,height,level,series,parent);for(const child of children){child.parentNode=node}series.nodeMap[node.id]=node;series.nodeList.push(node);if(point){point.node=node;node.point=point}return node}hasData(){return!!this.dataTable.rowCount}init(chart,options){const series=this,breadcrumbsOptions=merge(options.drillUpButton,options.breadcrumbs),setOptionsEvent=addEvent(series,"setOptions",event=>{const options=event.userOptions;if(defined(options.allowDrillToNode)&&!defined(options.allowTraversingTree)){options.allowTraversingTree=options.allowDrillToNode;delete options.allowDrillToNode}if(defined(options.drillUpButton)&&!defined(options.traverseUpButton)){options.traverseUpButton=options.drillUpButton;delete options.drillUpButton}});super.init(chart,options);delete series.opacity;series.eventsToUnbind.push(setOptionsEvent);if(series.options.allowTraversingTree){series.eventsToUnbind.push(addEvent(series,"click",series.onClickDrillToNode));series.eventsToUnbind.push(addEvent(series,"setRootNode",function(e){const chart=series.chart;if(chart.breadcrumbs){chart.breadcrumbs.updateProperties(series.createList(e))}}));series.eventsToUnbind.push(addEvent(series,"update",function(e,redraw){const breadcrumbs=this.chart.breadcrumbs;if(breadcrumbs&&e.options.breadcrumbs){breadcrumbs.update(e.options.breadcrumbs)}}));series.eventsToUnbind.push(addEvent(series,"destroy",function destroyEvents(e){const chart=this.chart;if(chart.breadcrumbs&&!e.keepEventsForUpdate){chart.breadcrumbs.destroy();chart.breadcrumbs=void 0}}))}if(!chart.breadcrumbs){chart.breadcrumbs=new Breadcrumbs(chart,breadcrumbsOptions)}series.eventsToUnbind.push(addEvent(chart.breadcrumbs,"up",function(e){const drillUpsNumber=this.level-e.newLevel;for(let i=0;i<drillUpsNumber;i++){series.drillUp()}}))}onClickDrillToNode(event){const series=this,point=event.point,drillId=point&&point.drillId;if(isString(drillId)){point.setState("");series.setRootNode(drillId,true,{trigger:"click"})}}pointAttribs(point,state){const series=this,mapOptionsToLevel=isObject(series.mapOptionsToLevel)?series.mapOptionsToLevel:{},level=point&&mapOptionsToLevel[point.node.level]||{},options=this.options,stateOptions=state&&options.states&&options.states[state]||{},className=point&&point.getClassName()||"",attr={stroke:point&&point.borderColor||level.borderColor||stateOptions.borderColor||options.borderColor,"stroke-width":pick(point&&point.borderWidth,level.borderWidth,stateOptions.borderWidth,options.borderWidth),dashstyle:point&&point.borderDashStyle||level.borderDashStyle||stateOptions.borderDashStyle||options.borderDashStyle,fill:point&&point.color||this.color};let opacity;if(className.indexOf("highcharts-above-level")!==-1){attr.fill="none";attr["stroke-width"]=0}else if(className.indexOf("highcharts-internal-node-interactive")!==-1){opacity=pick(stateOptions.opacity,options.opacity);attr.fill=color(attr.fill).setOpacity(opacity).get();attr.cursor="pointer"}else if(className.indexOf("highcharts-internal-node")!==-1){attr.fill="none"}else if(state){attr.fill=color(attr.fill).brighten(stateOptions.brightness).get()}return attr}setColorRecursive(node,parentColor,colorIndex,index,siblings){const series=this,chart=series&&series.chart,colors=chart&&chart.options&&chart.options.colors;if(node){const colorInfo=getColor(node,{colors:colors,index:index,mapOptionsToLevel:series.mapOptionsToLevel,parentColor:parentColor,parentColorIndex:colorIndex,series:series,siblings:siblings}),point=series.points[node.i];if(point){point.color=colorInfo.color;point.colorIndex=colorInfo.colorIndex}let i=-1;for(const child of node.children||[]){series.setColorRecursive(child,colorInfo.color,colorInfo.colorIndex,++i,node.children.length)}}}setPointValues(){const series=this;const{points,xAxis,yAxis}=series;const styledMode=series.chart.styledMode;const getStrokeWidth=point=>styledMode?0:series.pointAttribs(point)["stroke-width"]||0;for(const point of points){const{pointValues:values,visible}=point.node;if(values&&visible){const{height,width,x,y}=values;const strokeWidth=getStrokeWidth(point);const x1=crisp(xAxis.toPixels(x,true),strokeWidth,true);const x2=crisp(xAxis.toPixels(x+width,true),strokeWidth,true);const y1=crisp(yAxis.toPixels(y,true),strokeWidth,true);const y2=crisp(yAxis.toPixels(y+height,true),strokeWidth,true);const shapeArgs={x:Math.min(x1,x2),y:Math.min(y1,y2),width:Math.abs(x2-x1),height:Math.abs(y2-y1)};point.plotX=shapeArgs.x+shapeArgs.width/2;point.plotY=shapeArgs.y+shapeArgs.height/2;point.shapeArgs=shapeArgs}else{delete point.plotX;delete point.plotY}}}setRootNode(id,redraw,eventArguments){const series=this,eventArgs=extend({newRootId:id,previousRootId:series.rootNode,redraw:pick(redraw,true),series:series},eventArguments);const defaultFn=function(args){const series=args.series;series.idPreviousRoot=args.previousRootId;series.rootNode=args.newRootId;series.isDirty=true;if(args.redraw){series.chart.redraw()}};fireEvent(series,"setRootNode",eventArgs,defaultFn)}setState(state){this.options.inactiveOtherPoints=true;super.setState(state,false);this.options.inactiveOtherPoints=false}setTreeValues(tree){const series=this,options=series.options,idRoot=series.rootNode,mapIdToNode=series.nodeMap,nodeRoot=mapIdToNode[idRoot],levelIsConstant=typeof options.levelIsConstant==="boolean"?options.levelIsConstant:true,children=[],point=series.points[tree.i];let childrenTotal=0;for(let child of tree.children){child=series.setTreeValues(child);children.push(child);if(!child.ignore){childrenTotal+=child.val}}stableSort(children,(a,b)=>(a.sortIndex||0)-(b.sortIndex||0));const val=pick(point&&point.options.value,childrenTotal);if(point){point.value=val}extend(tree,{children:children,childrenTotal:childrenTotal,ignore:!(pick(point&&point.visible,true)&&val>0),isLeaf:tree.visible&&!childrenTotal,levelDynamic:tree.level-(levelIsConstant?0:nodeRoot.level),name:pick(point&&point.name,""),sortIndex:pick(point&&point.sortIndex,-val),val:val});return tree}sliceAndDice(parent,children){return this.algorithmFill(true,parent,children)}squarified(parent,children){return this.algorithmLowAspectRatio(true,parent,children)}strip(parent,children){return this.algorithmLowAspectRatio(false,parent,children)}stripes(parent,children){return this.algorithmFill(false,parent,children)}translate(){const series=this,options=series.options;let rootId=updateRootId(series),rootNode,pointValues,seriesArea,val;super.translate();const tree=series.tree=series.getTree();rootNode=series.nodeMap[rootId];if(rootId!==""&&!rootNode){series.setRootNode("",false);rootId=series.rootNode;rootNode=series.nodeMap[rootId]}series.mapOptionsToLevel=getLevelOptions({from:rootNode.level+1,levels:options.levels,to:tree.height,defaults:{levelIsConstant:series.options.levelIsConstant,colorByPoint:options.colorByPoint}});TreemapUtilities.recursive(series.nodeMap[series.rootNode],node=>{const p=node.parent;let next=false;node.visible=true;if(p||p===""){next=series.nodeMap[p]}return next});TreemapUtilities.recursive(series.nodeMap[series.rootNode].children,children=>{let next=false;for(const child of children){child.visible=true;if(child.children.length){next=(next||[]).concat(child.children)}}return next});series.setTreeValues(tree);series.axisRatio=series.xAxis.len/series.yAxis.len;series.nodeMap[""].pointValues=pointValues={x:0,y:0,width:axisMax,height:axisMax};series.nodeMap[""].values=seriesArea=merge(pointValues,{width:pointValues.width*series.axisRatio,direction:options.layoutStartingDirection==="vertical"?0:1,val:tree.val});series.calculateChildrenAreas(tree,seriesArea);if(!series.colorAxis&&!options.colorByPoint){series.setColorRecursive(series.tree)}if(options.allowTraversingTree){val=rootNode.pointValues;series.xAxis.setExtremes(val.x,val.x+val.width,false);series.yAxis.setExtremes(val.y,val.y+val.height,false);series.xAxis.setScale();series.yAxis.setScale()}series.setPointValues()}}TreemapSeries.defaultOptions=merge(ScatterSeries.defaultOptions,TreemapSeriesDefaults);extend(TreemapSeries.prototype,{buildKDTree:noop,colorAttribs:ColorMapComposition.seriesMembers.colorAttribs,colorKey:"colorValue",directTouch:true,getExtremesFromAll:true,getSymbol:noop,optionalAxis:"colorAxis",parallelArrays:["x","y","value","colorValue"],pointArrayMap:["value","colorValue"],pointClass:TreemapPoint,NodeClass:TreemapNode,trackerGroups:["group","dataLabelsGroup"],utils:TreemapUtilities});ColorMapComposition.compose(TreemapSeries);SeriesRegistry.registerSeriesType("treemap",TreemapSeries);export default TreemapSeries;