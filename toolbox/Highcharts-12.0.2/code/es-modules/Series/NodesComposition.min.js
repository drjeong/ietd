"use strict";import SeriesRegistry from"../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto,prototype:{pointClass:{prototype:pointProto}}}}=SeriesRegistry;import U from"../Core/Utilities.js";const{defined,extend,find,merge,pick}=U;var NodesComposition;(function(NodesComposition){function compose(PointClass,SeriesClass){const pointProto=PointClass.prototype,seriesProto=SeriesClass.prototype;pointProto.setNodeState=setNodeState;pointProto.setState=setNodeState;pointProto.update=updateNode;seriesProto.destroy=destroy;seriesProto.setData=setData;return SeriesClass}NodesComposition.compose=compose;function createNode(id){const PointClass=this.pointClass,findById=(nodes,id)=>find(nodes,node=>node.id===id);let node=findById(this.nodes,id),options;if(!node){options=this.options.nodes&&findById(this.options.nodes,id);const newNode=new PointClass(this,extend({className:"highcharts-node",isNode:true,id:id,y:1},options));newNode.linksTo=[];newNode.linksFrom=[];newNode.getSum=function(){let sumTo=0,sumFrom=0;newNode.linksTo.forEach(link=>{sumTo+=link.weight||0});newNode.linksFrom.forEach(link=>{sumFrom+=link.weight||0});return Math.max(sumTo,sumFrom)};newNode.offset=function(point,coll){let offset=0;for(let i=0;i<newNode[coll].length;i++){if(newNode[coll][i]===point){return offset}offset+=newNode[coll][i].weight}};newNode.hasShape=function(){let outgoing=0;newNode.linksTo.forEach(link=>{if(link.outgoing){outgoing++}});return!newNode.linksTo.length||outgoing!==newNode.linksTo.length};newNode.index=this.nodes.push(newNode)-1;node=newNode}node.formatPrefix="node";node.name=node.name||node.options.id||"";node.mass=pick(node.options.mass,node.options.marker&&node.options.marker.radius,this.options.marker&&this.options.marker.radius,4);return node}NodesComposition.createNode=createNode;function destroy(){this.data=[].concat(this.points||[],this.nodes);return seriesProto.destroy.apply(this,arguments)}NodesComposition.destroy=destroy;function generatePoints(){const chart=this.chart,nodeLookup={};seriesProto.generatePoints.call(this);if(!this.nodes){this.nodes=[]}this.colorCounter=0;this.nodes.forEach(node=>{node.linksFrom.length=0;node.linksTo.length=0;node.level=node.options.level});this.points.forEach(point=>{if(defined(point.from)){if(!nodeLookup[point.from]){nodeLookup[point.from]=this.createNode(point.from)}nodeLookup[point.from].linksFrom.push(point);point.fromNode=nodeLookup[point.from];if(chart.styledMode){point.colorIndex=pick(point.options.colorIndex,nodeLookup[point.from].colorIndex)}else{point.color=point.options.color||nodeLookup[point.from].color}}if(defined(point.to)){if(!nodeLookup[point.to]){nodeLookup[point.to]=this.createNode(point.to)}nodeLookup[point.to].linksTo.push(point);point.toNode=nodeLookup[point.to]}point.name=point.name||point.id},this);this.nodeLookup=nodeLookup}NodesComposition.generatePoints=generatePoints;function setData(){if(this.nodes){this.nodes.forEach(node=>{node.destroy()});this.nodes.length=0}seriesProto.setData.apply(this,arguments)}function setNodeState(state){const args=arguments,others=this.isNode?this.linksTo.concat(this.linksFrom):[this.fromNode,this.toNode];if(state!=="select"){others.forEach(linkOrNode=>{if(linkOrNode&&linkOrNode.series){pointProto.setState.apply(linkOrNode,args);if(!linkOrNode.isNode){if(linkOrNode.fromNode.graphic){pointProto.setState.apply(linkOrNode.fromNode,args)}if(linkOrNode.toNode&&linkOrNode.toNode.graphic){pointProto.setState.apply(linkOrNode.toNode,args)}}}})}pointProto.setState.apply(this,args)}NodesComposition.setNodeState=setNodeState;function updateNode(options,redraw,animation,runEvent){const nodes=this.series.options.nodes,data=this.series.options.data,dataLength=data?.length||0,linkConfig=data?.[this.index];pointProto.update.call(this,options,this.isNode?false:redraw,animation,runEvent);if(this.isNode){const nodeIndex=(nodes||[]).reduce((prevIndex,n,index)=>this.id===n.id?index:prevIndex,-1),nodeConfig=merge(nodes&&nodes[nodeIndex]||{},data?.[this.index]||{});if(data){if(linkConfig){data[this.index]=linkConfig}else{data.length=dataLength}}if(nodes){if(nodeIndex>=0){nodes[nodeIndex]=nodeConfig}else{nodes.push(nodeConfig)}}else{this.series.options.nodes=[nodeConfig]}if(pick(redraw,true)){this.series.chart.redraw(animation)}}}NodesComposition.updateNode=updateNode})(NodesComposition||(NodesComposition={}));export default NodesComposition;