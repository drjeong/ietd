"use strict";import Color from"../../Core/Color/Color.js";const{parse:color}=Color;import DragNodesComposition from"../DragNodesComposition.js";import GraphLayout from"../GraphLayoutComposition.js";import H from"../../Core/Globals.js";const{noop}=H;import PackedBubblePoint from"./PackedBubblePoint.js";import PackedBubbleSeriesDefaults from"./PackedBubbleSeriesDefaults.js";import PackedBubbleLayout from"./PackedBubbleLayout.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto},seriesTypes:{bubble:BubbleSeries}}=SeriesRegistry;import D from"../SimulationSeriesUtilities.js";const{initDataLabels,initDataLabelsDefer}=D;import U from"../../Core/Utilities.js";const{addEvent,clamp,defined,extend,fireEvent,isArray,isNumber,merge,pick}=U;import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import TextPath from"../../Extensions/TextPath.js";TextPath.compose(SVGElement);class PackedBubbleSeries extends BubbleSeries{constructor(){super(...arguments);this.parentNodeMass=0;this.deferDataLabels=true}static compose(AxisClass,ChartClass,LegendClass){BubbleSeries.compose(AxisClass,ChartClass,LegendClass);DragNodesComposition.compose(ChartClass);PackedBubbleLayout.compose(ChartClass)}accumulateAllPoints(){const chart=this.chart,allDataPoints=[];for(const series of chart.series){if(series.is("packedbubble")&&series.reserveSpace()){const valueData=series.getColumn("value");for(let j=0;j<valueData.length;j++){allDataPoints.push([null,null,valueData[j],series.index,j,{id:j,marker:{radius:0}}])}}}return allDataPoints}addLayout(){const layoutOptions=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},layoutType=layoutOptions.type||"packedbubble",chartOptions=this.chart.options.chart;let graphLayoutsStorage=this.chart.graphLayoutsStorage,graphLayoutsLookup=this.chart.graphLayoutsLookup,layout;if(!graphLayoutsStorage){this.chart.graphLayoutsStorage=graphLayoutsStorage={};this.chart.graphLayoutsLookup=graphLayoutsLookup=[]}layout=graphLayoutsStorage[layoutType];if(!layout){layoutOptions.enableSimulation=!defined(chartOptions.forExport)?layoutOptions.enableSimulation:!chartOptions.forExport;graphLayoutsStorage[layoutType]=layout=new GraphLayout.layouts[layoutType];layout.init(layoutOptions);graphLayoutsLookup.splice(layout.index,0,layout)}this.layout=layout;this.points.forEach(node=>{node.mass=2;node.degree=1;node.collisionNmb=1});layout.setArea(0,0,this.chart.plotWidth,this.chart.plotHeight);layout.addElementsToCollection([this],layout.series);layout.addElementsToCollection(this.points,layout.nodes)}addSeriesLayout(){const layoutOptions=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},layoutType=layoutOptions.type||"packedbubble",graphLayoutsStorage=this.chart.graphLayoutsStorage,graphLayoutsLookup=this.chart.graphLayoutsLookup,parentNodeOptions=merge(layoutOptions,layoutOptions.parentNodeOptions,{enableSimulation:this.layout.options.enableSimulation});let seriesLayout=graphLayoutsStorage[layoutType+"-series"];if(!seriesLayout){graphLayoutsStorage[layoutType+"-series"]=seriesLayout=new GraphLayout.layouts[layoutType];seriesLayout.init(parentNodeOptions);graphLayoutsLookup.splice(seriesLayout.index,0,seriesLayout)}this.parentNodeLayout=seriesLayout;this.createParentNodes()}calculateParentRadius(){const bBox=this.seriesBox(),parentPadding=20,minParentRadius=20;this.parentNodeRadius=clamp(Math.sqrt(2*this.parentNodeMass/Math.PI)+parentPadding,minParentRadius,bBox?Math.max(Math.sqrt(Math.pow(bBox.width,2)+Math.pow(bBox.height,2))/2+parentPadding,minParentRadius):Math.sqrt(2*this.parentNodeMass/Math.PI)+parentPadding);if(this.parentNode){this.parentNode.marker.radius=this.parentNode.radius=this.parentNodeRadius}}calculateZExtremes(){const chart=this.chart,allSeries=chart.series;let zMin=this.options.zMin,zMax=this.options.zMax,valMin=Infinity,valMax=-Infinity;if(zMin&&zMax){return[zMin,zMax]}allSeries.forEach(series=>{series.getColumn("value").forEach(y=>{if(defined(y)){if(y>valMax){valMax=y}if(y<valMin){valMin=y}}})});zMin=pick(zMin,valMin);zMax=pick(zMax,valMax);return[zMin,zMax]}checkOverlap(bubble1,bubble2){const diffX=bubble1[0]-bubble2[0],diffY=bubble1[1]-bubble2[1],sumRad=bubble1[2]+bubble2[2];return Math.sqrt(diffX*diffX+diffY*diffY)-Math.abs(sumRad)<-.001}createParentNodes(){const PackedBubblePoint=this.pointClass,chart=this.chart,parentNodeLayout=this.parentNodeLayout,layoutOptions=this.layout.options;let nodeAdded,parentNode=this.parentNode,parentMarkerOptions={radius:this.parentNodeRadius,lineColor:this.color,fillColor:color(this.color).brighten(.4).get()};if(layoutOptions.parentNodeOptions){parentMarkerOptions=merge(layoutOptions.parentNodeOptions.marker||{},parentMarkerOptions)}this.parentNodeMass=0;this.points.forEach(p=>{this.parentNodeMass+=Math.PI*Math.pow(p.marker.radius,2)});this.calculateParentRadius();parentNodeLayout.nodes.forEach(node=>{if(node.seriesIndex===this.index){nodeAdded=true}});parentNodeLayout.setArea(0,0,chart.plotWidth,chart.plotHeight);if(!nodeAdded){if(!parentNode){parentNode=new PackedBubblePoint(this,{mass:this.parentNodeRadius/2,marker:parentMarkerOptions,dataLabels:{inside:false},states:{normal:{marker:parentMarkerOptions},hover:{marker:parentMarkerOptions}},dataLabelOnNull:true,degree:this.parentNodeRadius,isParentNode:true,seriesIndex:this.index})}if(this.parentNode){parentNode.plotX=this.parentNode.plotX;parentNode.plotY=this.parentNode.plotY}this.parentNode=parentNode;parentNodeLayout.addElementsToCollection([this],parentNodeLayout.series);parentNodeLayout.addElementsToCollection([parentNode],parentNodeLayout.nodes)}}deferLayout(){const layoutOptions=this.options.layoutAlgorithm;if(!this.visible){return}this.addLayout();if(layoutOptions.splitSeries){this.addSeriesLayout()}}destroy(){if(this.chart.graphLayoutsLookup){this.chart.graphLayoutsLookup.forEach(layout=>{layout.removeElementFromCollection(this,layout.series)},this)}if(this.parentNode&&this.parentNodeLayout){this.parentNodeLayout.removeElementFromCollection(this.parentNode,this.parentNodeLayout.nodes);if(this.parentNode.dataLabel){this.parentNode.dataLabel=this.parentNode.dataLabel.destroy()}}seriesProto.destroy.apply(this,arguments)}drawDataLabels(){if(this.deferDataLabels){return}seriesProto.drawDataLabels.call(this,this.points);if(this.parentNode){this.parentNode.formatPrefix="parentNode";seriesProto.drawDataLabels.call(this,[this.parentNode])}}drawGraph(){if(!this.layout||!this.layout.options.splitSeries){return}const chart=this.chart,nodeMarker=this.layout.options.parentNodeOptions.marker,parentOptions={fill:nodeMarker.fillColor||color(this.color).brighten(.4).get(),opacity:nodeMarker.fillOpacity,stroke:nodeMarker.lineColor||this.color,"stroke-width":pick(nodeMarker.lineWidth,this.options.lineWidth)};let parentAttribs={};this.parentNodesGroup=this.plotGroup("parentNodesGroup","parentNode",this.visible?"inherit":"hidden",.1,chart.seriesGroup);this.group?.attr({zIndex:2});this.calculateParentRadius();if(this.parentNode&&defined(this.parentNode.plotX)&&defined(this.parentNode.plotY)&&defined(this.parentNodeRadius)){parentAttribs=merge({x:this.parentNode.plotX-this.parentNodeRadius,y:this.parentNode.plotY-this.parentNodeRadius,width:this.parentNodeRadius*2,height:this.parentNodeRadius*2},parentOptions);if(!this.parentNode.graphic){this.graph=this.parentNode.graphic=chart.renderer.symbol(parentOptions.symbol).add(this.parentNodesGroup)}this.parentNode.graphic.attr(parentAttribs)}}drawTracker(){const parentNode=this.parentNode;let dataLabels;super.drawTracker();if(parentNode){dataLabels=isArray(parentNode.dataLabels)?parentNode.dataLabels:parentNode.dataLabel?[parentNode.dataLabel]:[];if(parentNode.graphic){parentNode.graphic.element.point=parentNode}dataLabels.forEach(dataLabel=>{(dataLabel.div||dataLabel.element).point=parentNode})}}getPointRadius(){const chart=this.chart,plotWidth=chart.plotWidth,plotHeight=chart.plotHeight,seriesOptions=this.options,useSimulation=seriesOptions.useSimulation,smallestSize=Math.min(plotWidth,plotHeight),extremes={},radii=[],allDataPoints=chart.allDataPoints||[],allDataPointsLength=allDataPoints.length;let minSize,maxSize,value,radius;["minSize","maxSize"].forEach(prop=>{const length=parseInt(seriesOptions[prop],10),isPercent=/%$/.test(seriesOptions[prop]);extremes[prop]=isPercent?smallestSize*length/100:length*Math.sqrt(allDataPointsLength)});chart.minRadius=minSize=extremes.minSize/Math.sqrt(allDataPointsLength);chart.maxRadius=maxSize=extremes.maxSize/Math.sqrt(allDataPointsLength);const zExtremes=useSimulation?this.calculateZExtremes():[minSize,maxSize];allDataPoints.forEach((point,i)=>{value=useSimulation?clamp(point[2],zExtremes[0],zExtremes[1]):point[2];radius=this.getRadius(zExtremes[0],zExtremes[1],minSize,maxSize,value);if(radius===0){radius=null}allDataPoints[i][2]=radius;radii.push(radius)});this.radii=radii}init(){seriesProto.init.apply(this,arguments);initDataLabelsDefer.call(this);this.eventsToUnbind.push(addEvent(this,"updatedData",function(){this.chart.series.forEach(s=>{if(s.type===this.type){s.isDirty=true}},this)}));return this}onMouseUp(dnPoint){const point=dnPoint;if(point.fixedPosition&&!point.removed){const layout=this.layout,parentNodeLayout=this.parentNodeLayout;let distanceXY,distanceR;if(parentNodeLayout&&layout.options.dragBetweenSeries){parentNodeLayout.nodes.forEach(node=>{if(point&&point.marker&&node!==point.series.parentNode){distanceXY=layout.getDistXY(point,node);distanceR=layout.vectorLength(distanceXY)-node.marker.radius-point.marker.radius;if(distanceR<0){node.series.addPoint(merge(point.options,{plotX:point.plotX,plotY:point.plotY}),false);layout.removeElementFromCollection(point,layout.nodes);point.remove()}}})}DragNodesComposition.onMouseUp.apply(this,arguments)}}placeBubbles(allDataPoints){const checkOverlap=this.checkOverlap,positionBubble=this.positionBubble,bubblePos=[];let stage=1,j=0,k=0,calculatedBubble,arr=[],i;const sortedArr=allDataPoints.sort((a,b)=>b[2]-a[2]);if(sortedArr.length){bubblePos.push([[0,0,sortedArr[0][2],sortedArr[0][3],sortedArr[0][4]]]);if(sortedArr.length>1){bubblePos.push([[0,0-sortedArr[1][2]-sortedArr[0][2],sortedArr[1][2],sortedArr[1][3],sortedArr[1][4]]]);for(i=2;i<sortedArr.length;i++){sortedArr[i][2]=sortedArr[i][2]||1;calculatedBubble=positionBubble(bubblePos[stage][j],bubblePos[stage-1][k],sortedArr[i]);if(checkOverlap(calculatedBubble,bubblePos[stage][0])){bubblePos.push([]);k=0;bubblePos[stage+1].push(positionBubble(bubblePos[stage][j],bubblePos[stage][0],sortedArr[i]));stage++;j=0}else if(stage>1&&bubblePos[stage-1][k+1]&&checkOverlap(calculatedBubble,bubblePos[stage-1][k+1])){k++;bubblePos[stage].push(positionBubble(bubblePos[stage][j],bubblePos[stage-1][k],sortedArr[i]));j++}else{j++;bubblePos[stage].push(calculatedBubble)}}}this.chart.stages=bubblePos;this.chart.rawPositions=[].concat.apply([],bubblePos);this.resizeRadius();arr=this.chart.rawPositions}return arr}pointAttribs(point,state){const options=this.options,hasParentMarker=point&&point.isParentNode;let markerOptions=options.marker;if(hasParentMarker&&options.layoutAlgorithm&&options.layoutAlgorithm.parentNodeOptions){markerOptions=options.layoutAlgorithm.parentNodeOptions.marker}const fillOpacity=markerOptions.fillOpacity,attr=seriesProto.pointAttribs.call(this,point,state);if(fillOpacity!==1){attr["fill-opacity"]=fillOpacity}return attr}positionBubble(lastBubble,newOrigin,nextBubble){const sqrt=Math.sqrt,asin=Math.asin,acos=Math.acos,pow=Math.pow,abs=Math.abs,distance=sqrt(pow(lastBubble[0]-newOrigin[0],2)+pow(lastBubble[1]-newOrigin[1],2)),alfa=acos((pow(distance,2)+pow(nextBubble[2]+newOrigin[2],2)-pow(nextBubble[2]+lastBubble[2],2))/(2*(nextBubble[2]+newOrigin[2])*distance)),beta=asin(abs(lastBubble[0]-newOrigin[0])/distance),gamma=lastBubble[1]-newOrigin[1]<0?0:Math.PI,delta=(lastBubble[0]-newOrigin[0])*(lastBubble[1]-newOrigin[1])<0?1:-1,finalAngle=gamma+alfa+beta*delta,cosA=Math.cos(finalAngle),sinA=Math.sin(finalAngle),posX=newOrigin[0]+(newOrigin[2]+nextBubble[2])*sinA,posY=newOrigin[1]-(newOrigin[2]+nextBubble[2])*cosA;return[posX,posY,nextBubble[2],nextBubble[3],nextBubble[4]]}render(){const dataLabels=[];seriesProto.render.apply(this,arguments);if(!this.options.dataLabels.allowOverlap){this.data.forEach(point=>{if(isArray(point.dataLabels)){point.dataLabels.forEach(dataLabel=>{dataLabels.push(dataLabel)})}});if(this.options.useSimulation){this.chart.hideOverlappingLabels(dataLabels)}}}resizeRadius(){const chart=this.chart,positions=chart.rawPositions,min=Math.min,max=Math.max,plotLeft=chart.plotLeft,plotTop=chart.plotTop,chartHeight=chart.plotHeight,chartWidth=chart.plotWidth;let minX,maxX,minY,maxY,radius;minX=minY=Number.POSITIVE_INFINITY;maxX=maxY=Number.NEGATIVE_INFINITY;for(const position of positions){radius=position[2];minX=min(minX,position[0]-radius);maxX=max(maxX,position[0]+radius);minY=min(minY,position[1]-radius);maxY=max(maxY,position[1]+radius)}const bBox=[maxX-minX,maxY-minY],spaceRatio=[(chartWidth-plotLeft)/bBox[0],(chartHeight-plotTop)/bBox[1]],smallerDimension=min.apply([],spaceRatio);if(Math.abs(smallerDimension-1)>1e-10){for(const position of positions){position[2]*=smallerDimension}this.placeBubbles(positions)}else{chart.diffY=chartHeight/2+plotTop-minY-(maxY-minY)/2;chart.diffX=chartWidth/2+plotLeft-minX-(maxX-minX)/2}}seriesBox(){const chart=this.chart,data=this.data,max=Math.max,min=Math.min,bBox=[chart.plotLeft,chart.plotLeft+chart.plotWidth,chart.plotTop,chart.plotTop+chart.plotHeight];let radius;data.forEach(p=>{if(defined(p.plotX)&&defined(p.plotY)&&p.marker.radius){radius=p.marker.radius;bBox[0]=min(bBox[0],p.plotX-radius);bBox[1]=max(bBox[1],p.plotX+radius);bBox[2]=min(bBox[2],p.plotY-radius);bBox[3]=max(bBox[3],p.plotY+radius)}});return isNumber(bBox.width/bBox.height)?bBox:null}setVisible(){const series=this;seriesProto.setVisible.apply(series,arguments);if(series.parentNodeLayout&&series.graph){if(series.visible){series.graph.show();if(series.parentNode.dataLabel){series.parentNode.dataLabel.show()}}else{series.graph.hide();series.parentNodeLayout.removeElementFromCollection(series.parentNode,series.parentNodeLayout.nodes);if(series.parentNode.dataLabel){series.parentNode.dataLabel.hide()}}}else if(series.layout){if(series.visible){series.layout.addElementsToCollection(series.points,series.layout.nodes)}else{series.points.forEach(node=>{series.layout.removeElementFromCollection(node,series.layout.nodes)})}}}translate(){const chart=this.chart,data=this.data,index=this.index,useSimulation=this.options.useSimulation;let point,radius,positions;this.generatePoints();if(!defined(chart.allDataPoints)){chart.allDataPoints=this.accumulateAllPoints();this.getPointRadius()}if(useSimulation){positions=chart.allDataPoints}else{positions=this.placeBubbles(chart.allDataPoints);this.options.draggable=false}for(const position of positions){if(position[3]===index){point=data[position[4]];radius=pick(position[2],void 0);if(!useSimulation){point.plotX=position[0]-chart.plotLeft+chart.diffX;point.plotY=position[1]-chart.plotTop+chart.diffY}if(isNumber(radius)){point.marker=extend(point.marker,{radius:radius,width:2*radius,height:2*radius});point.radius=radius}}}if(useSimulation){this.deferLayout()}fireEvent(this,"afterTranslate")}}PackedBubbleSeries.defaultOptions=merge(BubbleSeries.defaultOptions,PackedBubbleSeriesDefaults);extend(PackedBubbleSeries.prototype,{pointClass:PackedBubblePoint,axisTypes:[],directTouch:true,forces:["barycenter","repulsive"],hasDraggableNodes:true,invertible:false,isCartesian:false,noSharedTooltip:true,pointArrayMap:["value"],pointValKey:"value",requireSorting:false,trackerGroups:["group","dataLabelsGroup","parentNodesGroup"],initDataLabels:initDataLabels,alignDataLabel:seriesProto.alignDataLabel,indexateNodes:noop,onMouseDown:DragNodesComposition.onMouseDown,onMouseMove:DragNodesComposition.onMouseMove,redrawHalo:DragNodesComposition.redrawHalo,searchPoint:noop});SeriesRegistry.registerSeriesType("packedbubble",PackedBubbleSeries);export default PackedBubbleSeries;