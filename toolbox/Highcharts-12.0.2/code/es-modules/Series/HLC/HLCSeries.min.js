"use strict";import HLCPoint from"./HLCPoint.js";import HLCSeriesDefaults from"./HLCSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{crisp,extend,merge}=U;class HLCSeries extends ColumnSeries{extendStem(path,halfStrokeWidth,value){const start=path[0];const end=path[1];if(typeof start[2]==="number"){start[2]=Math.max(value+halfStrokeWidth,start[2])}if(typeof end[2]==="number"){end[2]=Math.min(value-halfStrokeWidth,end[2])}}getPointPath(point,graphic){const strokeWidth=graphic.strokeWidth(),series=point.series,crispX=crisp(point.plotX||0,strokeWidth),halfWidth=Math.round(point.shapeArgs.width/2);const path=[["M",crispX,Math.round(point.yBottom)],["L",crispX,Math.round(point.plotHigh)]];if(point.close!==null){const plotClose=crisp(point.plotClose,strokeWidth);path.push(["M",crispX,plotClose],["L",crispX+halfWidth,plotClose]);series.extendStem(path,strokeWidth/2,plotClose)}return path}drawSinglePoint(point){const series=point.series,chart=series.chart;let path,graphic=point.graphic;if(typeof point.plotY!=="undefined"){if(!graphic){point.graphic=graphic=chart.renderer.path().add(series.group)}if(!chart.styledMode){graphic.attr(series.pointAttribs(point,point.selected&&"select"))}path=series.getPointPath(point,graphic);graphic[!graphic?"attr":"animate"]({d:path}).addClass(point.getClassName(),true)}}drawPoints(){this.points.forEach(this.drawSinglePoint)}init(){super.init.apply(this,arguments);this.options.stacking=void 0}pointAttribs(point,state){const attribs=super.pointAttribs.call(this,point,state);delete attribs.fill;return attribs}toYData(point){return[point.high,point.low,point.close]}translate(){const series=this,yAxis=series.yAxis,names=this.pointArrayMap&&this.pointArrayMap.slice()||[],translated=names.map(name=>`plot${name.charAt(0).toUpperCase()+name.slice(1)}`);translated.push("yBottom");names.push("low");super.translate.apply(series);series.points.forEach(function(point){names.forEach(function(name,i){let value=point[name];if(value!==null){if(series.dataModify){value=series.dataModify.modifyValue(value)}point[translated[i]]=yAxis.toPixels(value,true)}});point.tooltipPos[1]=point.plotHigh+yAxis.pos-series.chart.plotTop})}}HLCSeries.defaultOptions=merge(ColumnSeries.defaultOptions,HLCSeriesDefaults);extend(HLCSeries.prototype,{pointClass:HLCPoint,animate:null,directTouch:false,keysAffectYAxis:["low","high"],pointArrayMap:["high","low","close"],pointAttrToOptions:{stroke:"color","stroke-width":"lineWidth"},pointValKey:"close"});SeriesRegistry.registerSeriesType("hlc",HLCSeries);export default HLCSeries;