"use strict";import FlowMapPoint from"./FlowMapPoint.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:{pointClass:Point}},seriesTypes:{column:ColumnSeries,map:MapSeries,mapline:MapLineSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,defined,extend,isArray,merge,pick,relativeLength}=U;class FlowMapSeries extends MapLineSeries{static getLength(x,y){return Math.sqrt(x*x+y*y)}static normalize(x,y){const length=this.getLength(x,y);return[x/length,y/length]}static markerEndPath(lCorner,rCorner,topCorner,options){const width=relativeLength(options.width||0,this.getLength(rCorner[0]-lCorner[0],rCorner[1]-lCorner[1]));const type=options.markerType||"arrow",[edgeX,edgeY]=this.normalize(rCorner[0]-lCorner[0],rCorner[1]-lCorner[1]);const path=[];if(type==="arrow"){let[x,y]=lCorner;x-=edgeX*width;y-=edgeY*width;path.push(["L",x,y]);path.push(["L",topCorner[0],topCorner[1]]);[x,y]=rCorner;x+=edgeX*width;y+=edgeY*width;path.push(["L",x,y])}if(type==="mushroom"){let[xLeft,yLeft]=lCorner,[xRight,yRight]=rCorner;const[xTop,yTop]=topCorner,xMid=(xRight-xLeft)/2+xLeft,yMid=(yRight-yLeft)/2+yLeft,xControl=(xTop-xMid)*2+xMid,yControl=(yTop-yMid)*2+yMid;xLeft-=edgeX*width;yLeft-=edgeY*width;path.push(["L",xLeft,yLeft]);xRight+=edgeX*width;yRight+=edgeY*width;path.push(["Q",xControl,yControl,xRight,yRight])}return path}animate(init){const series=this,points=series.points;if(!init){points.forEach(point=>{if(point.shapeArgs&&isArray(point.shapeArgs.d)&&point.shapeArgs.d.length){const path=point.shapeArgs.d,x=path[0][1],y=path[0][2];if(x&&y){const start=[];for(let i=0;i<path.length;i++){start.push([...path[i]]);for(let j=1;j<path[i].length;j++){start[i][j]=j%2?x:y}}if(point.graphic){point.graphic.attr({d:start});point.graphic.animate({d:path})}}}})}}getLinkWidth(point){const width=this.options.width,weight=point.options.weight||this.options.weight;point.options.weight=weight;if(width&&!weight){return width}const smallestWeight=this.smallestWeight,greatestWeight=this.greatestWeight;if(!defined(weight)||!smallestWeight||!greatestWeight){return 0}const minWidthLimit=this.options.minWidth,maxWidthLimit=this.options.maxWidth;return(weight-smallestWeight)*(maxWidthLimit-minWidthLimit)/(greatestWeight-smallestWeight||1)+minWidthLimit}autoCurve(fromX,fromY,toX,toY,centerX,centerY){const linkV={x:toX-fromX,y:toY-fromY},half={x:(toX-fromX)/2+fromX,y:(toY-fromY)/2+fromY},centerV={x:half.x-centerX,y:half.y-centerY};const dot=linkV.x*centerV.x+linkV.y*centerV.y,det=linkV.x*centerV.y-linkV.y*centerV.x;let angle=Math.atan2(det,dot),angleDeg=angle*180/Math.PI;if(angleDeg<0){angleDeg=360+angleDeg}angle=angleDeg*Math.PI/180;return-Math.sin(angle)*.7}pointAttribs(point,state){const attrs=MapSeries.prototype.pointAttribs.call(this,point,state);attrs.fill=pick(point.options.fillColor,point.options.color,this.options.fillColor==="none"?null:this.options.fillColor,this.color);attrs["fill-opacity"]=pick(point.options.fillOpacity,this.options.fillOpacity);attrs["stroke-width"]=pick(point.options.lineWidth,this.options.lineWidth,1);if(point.options.opacity){attrs.opacity=point.options.opacity}return attrs}translate(){if(this.chart.hasRendered&&(this.isDirtyData||!this.hasRendered)){this.processData();this.generatePoints()}const weights=[];let averageX=0,averageY=0;this.points.forEach(point=>{const chart=this.chart,mapView=chart.mapView,options=point.options,dirtySeries=()=>{point.series.isDirty=true},getPointXY=pointId=>{const foundPoint=chart.get(pointId);if(foundPoint instanceof Point&&foundPoint.plotX&&foundPoint.plotY){addEvent(foundPoint,"update",dirtySeries);return{x:foundPoint.plotX,y:foundPoint.plotY}}},getLonLatXY=lonLat=>{if(isArray(lonLat)){return{lon:lonLat[0],lat:lonLat[1]}}return lonLat};let fromPos,toPos;if(typeof options.from==="string"){fromPos=getPointXY(options.from)}else if(typeof options.from==="object"&&mapView){fromPos=mapView.lonLatToPixels(getLonLatXY(options.from))}if(typeof options.to==="string"){toPos=getPointXY(options.to)}else if(typeof options.to==="object"&&mapView){toPos=mapView.lonLatToPixels(getLonLatXY(options.to))}point.fromPos=fromPos;point.toPos=toPos;if(fromPos&&toPos){averageX+=(fromPos.x+toPos.x)/2;averageY+=(fromPos.y+toPos.y)/2}if(pick(point.options.weight,this.options.weight)){weights.push(pick(point.options.weight,this.options.weight))}});this.smallestWeight=arrayMin(weights);this.greatestWeight=arrayMax(weights);this.centerOfPoints={x:averageX/this.points.length,y:averageY/this.points.length};this.points.forEach(point=>{if(!this.getLinkWidth(point)){point.shapeArgs={d:[]};return}if(point.fromPos){point.plotX=point.fromPos.x;point.plotY=point.fromPos.y}point.shapeType="path";point.shapeArgs=this.getPointShapeArgs(point);point.color=pick(point.options.color,point.series.color)})}getPointShapeArgs(point){const{fromPos,toPos}=point;if(!fromPos||!toPos){return{}}const finalWidth=this.getLinkWidth(point)/2,pointOptions=point.options,markerEndOptions=merge(this.options.markerEnd,pointOptions.markerEnd),growTowards=pick(pointOptions.growTowards,this.options.growTowards),fromX=fromPos.x||0,fromY=fromPos.y||0;let toX=toPos.x||0,toY=toPos.y||0,curveFactor=pick(pointOptions.curveFactor,this.options.curveFactor),offset=markerEndOptions&&markerEndOptions.enabled&&markerEndOptions.height||0;if(!defined(curveFactor)){curveFactor=this.autoCurve(fromX,fromY,toX,toY,this.centerOfPoints.x,this.centerOfPoints.y)}if(offset){offset=relativeLength(offset,finalWidth*4);let dX=toX-fromX,dY=toY-fromY;dX*=.5;dY*=.5;const mX=fromX+dX,mY=fromY+dY;const tmp=dX;dX=dY;dY=-tmp;const arcPointX=mX+dX*curveFactor,arcPointY=mY+dY*curveFactor;let[offsetX,offsetY]=FlowMapSeries.normalize(arcPointX-toX,arcPointY-toY);offsetX*=offset;offsetY*=offset;toX+=offsetX;toY+=offsetY}let dX=toX-fromX,dY=toY-fromY;dX*=.5;dY*=.5;const mX=fromX+dX,mY=fromY+dY;let tmp=dX;dX=dY;dY=-tmp;let[wX,wY]=FlowMapSeries.normalize(dX,dY);const fineTune=1+Math.sqrt(curveFactor*curveFactor)*.25;wX*=finalWidth*fineTune;wY*=finalWidth*fineTune;const arcPointX=mX+dX*curveFactor,arcPointY=mY+dY*curveFactor;let[fromXToArc,fromYToArc]=FlowMapSeries.normalize(arcPointX-fromX,arcPointY-fromY);tmp=fromXToArc;fromXToArc=fromYToArc;fromYToArc=-tmp;fromXToArc*=finalWidth;fromYToArc*=finalWidth;let[toXToArc,toYToArc]=FlowMapSeries.normalize(arcPointX-toX,arcPointY-toY);tmp=toXToArc;toXToArc=-toYToArc;toYToArc=tmp;toXToArc*=finalWidth;toYToArc*=finalWidth;if(growTowards){fromXToArc/=finalWidth;fromYToArc/=finalWidth;wX/=4;wY/=4}const shapeArgs={d:[["M",fromX-fromXToArc,fromY-fromYToArc],["Q",arcPointX-wX,arcPointY-wY,toX-toXToArc,toY-toYToArc],["L",toX+toXToArc,toY+toYToArc],["Q",arcPointX+wX,arcPointY+wY,fromX+fromXToArc,fromY+fromYToArc],["Z"]]};if(markerEndOptions&&markerEndOptions.enabled&&shapeArgs.d){const marker=FlowMapSeries.markerEndPath([toX-toXToArc,toY-toYToArc],[toX+toXToArc,toY+toYToArc],[toPos.x,toPos.y],markerEndOptions);shapeArgs.d.splice(2,0,...marker)}const fromPoint=point.options.from,toPoint=point.options.to,fromLat=fromPoint.lat,fromLon=fromPoint.lon,toLat=toPoint.lat,toLon=toPoint.lon;if(fromLat&&fromLon){point.options.from=`${+fromLat}, ${+fromLon}`}if(toLat&&toLon){point.options.to=`${+toLat}, ${+toLon}`}return shapeArgs}}FlowMapSeries.defaultOptions=merge(MapLineSeries.defaultOptions,{animation:true,dataLabels:{enabled:false},fillOpacity:.5,markerEnd:{enabled:true,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}});extend(FlowMapSeries.prototype,{pointClass:FlowMapPoint,pointArrayMap:["from","to","weight"],drawPoints:ColumnSeries.prototype.drawPoints,dataColumnKeys:ColumnSeries.prototype.dataColumnKeys,useMapGeometry:true});SeriesRegistry.registerSeriesType("flowmap",FlowMapSeries);export default FlowMapSeries;"";