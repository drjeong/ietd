"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{animObject}=A;import Color from"../../Core/Color/Color.js";const{parse:color}=Color;import CU from"../../Core/Geometry/CircleUtilities.js";const{getAreaOfIntersectionBetweenCircles,getCirclesIntersectionPolygon,isCircle1CompletelyOverlappingCircle2,isPointInsideAllCircles,isPointOutsideAllCircles}=CU;import DPU from"../DrawPointUtilities.js";import GU from"../../Core/Geometry/GeometryUtilities.js";const{getCenterOfPoints}=GU;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import VennPoint from"./VennPoint.js";import VennSeriesDefaults from"./VennSeriesDefaults.js";import VennUtils from"./VennUtils.js";import U from"../../Core/Utilities.js";const{addEvent,extend,isArray,isNumber,isObject,merge}=U;class VennSeries extends ScatterSeries{static getLabelPosition(internal,external){let best=internal.reduce((best,circle)=>{const d=circle.r/2;return[{x:circle.x,y:circle.y},{x:circle.x+d,y:circle.y},{x:circle.x-d,y:circle.y},{x:circle.x,y:circle.y+d},{x:circle.x,y:circle.y-d}].reduce((best,point)=>{const margin=VennUtils.getMarginFromCircles(point,internal,external);if(best.margin<margin){best.point=point;best.margin=margin}return best},best)},{point:void 0,margin:-Number.MAX_VALUE}).point;const optimal=VennUtils.nelderMead(p=>-VennUtils.getMarginFromCircles({x:p[0],y:p[1]},internal,external),[best.x,best.y]);best={x:optimal[0],y:optimal[1]};if(!(isPointInsideAllCircles(best,internal)&&isPointOutsideAllCircles(best,external))){if(internal.length>1){best=getCenterOfPoints(getCirclesIntersectionPolygon(internal))}else{best={x:internal[0].x,y:internal[0].y}}}return best}static getLabelValues(relation,setRelations){const sets=relation.sets;const data=setRelations.reduce((data,set)=>{const isInternal=sets.indexOf(set.sets[0])>-1;const property=isInternal?"internal":"external";if(set.circle){data[property].push(set.circle)}return data},{internal:[],external:[]});data.external=data.external.filter(externalCircle=>data.internal.some(internalCircle=>!isCircle1CompletelyOverlappingCircle2(externalCircle,internalCircle)));const position=VennSeries.getLabelPosition(data.internal,data.external);const width=VennUtils.getLabelWidth(position,data.internal,data.external);return{position:position,width:width}}static layout(relations){const mapOfIdToShape={};const mapOfIdToLabelValues={};if(relations.length>0){const mapOfIdToCircles=VennUtils.layoutGreedyVenn(relations);const setRelations=relations.filter(VennUtils.isSet);for(const relation of relations){const sets=relation.sets;const id=sets.join();const shape=VennUtils.isSet(relation)?mapOfIdToCircles[id]:getAreaOfIntersectionBetweenCircles(sets.map(set=>mapOfIdToCircles[set]));if(shape){mapOfIdToShape[id]=shape;mapOfIdToLabelValues[id]=VennSeries.getLabelValues(relation,setRelations)}}}return{mapOfIdToShape:mapOfIdToShape,mapOfIdToLabelValues:mapOfIdToLabelValues}}static getScale(targetWidth,targetHeight,field){const height=field.bottom-field.top,width=field.right-field.left,scaleX=width>0?1/width*targetWidth:1,scaleY=height>0?1/height*targetHeight:1,adjustX=(field.right+field.left)/2,adjustY=(field.top+field.bottom)/2,scale=Math.min(scaleX,scaleY);return{scale:scale,centerX:targetWidth/2-adjustX*scale,centerY:targetHeight/2-adjustY*scale}}static updateFieldBoundaries(field,circle){const left=circle.x-circle.r,right=circle.x+circle.r,bottom=circle.y+circle.r,top=circle.y-circle.r;if(!isNumber(field.left)||field.left>left){field.left=left}if(!isNumber(field.right)||field.right<right){field.right=right}if(!isNumber(field.top)||field.top>top){field.top=top}if(!isNumber(field.bottom)||field.bottom<bottom){field.bottom=bottom}return field}animate(init){if(!init){const series=this,animOptions=animObject(series.options.animation);for(const point of series.points){const args=point.shapeArgs;if(point.graphic&&args){const attr={},animate={};if(args.d){attr.opacity=.001}else{attr.r=0;animate.r=args.r}point.graphic.attr(attr).animate(animate,animOptions);if(args.d){setTimeout(()=>{if(point&&point.graphic){point.graphic.animate({opacity:1})}},animOptions.duration)}}}}}drawPoints(){const series=this,chart=series.chart,group=series.group,points=series.points||[],renderer=chart.renderer;for(const point of points){const attribs={zIndex:isArray(point.sets)?point.sets.length:0},shapeArgs=point.shapeArgs;if(!chart.styledMode){extend(attribs,series.pointAttribs(point,point.state))}DPU.draw(point,{isNew:!point.graphic,animatableAttribs:shapeArgs,attribs:attribs,group:group,renderer:renderer,shapeType:shapeArgs&&shapeArgs.d?"path":"circle"})}}init(){ScatterSeries.prototype.init.apply(this,arguments);delete this.opacity}pointAttribs(point,state){const series=this,seriesOptions=series.options||{},pointOptions=point&&point.options||{},stateOptions=state&&seriesOptions.states[state]||{},options=merge(seriesOptions,{color:point&&point.color},pointOptions,stateOptions);return{fill:color(options.color).brighten(options.brightness).get(),opacity:options.opacity,stroke:options.borderColor,"stroke-width":options.borderWidth,dashstyle:options.borderDashStyle}}translate(){const chart=this.chart;this.dataTable.modified=this.dataTable;this.generatePoints();const relations=VennUtils.processVennData(this.options.data,VennSeries.splitter);const{mapOfIdToShape,mapOfIdToLabelValues}=VennSeries.layout(relations);const field=Object.keys(mapOfIdToShape).filter(key=>{const shape=mapOfIdToShape[key];return shape&&isNumber(shape.r)}).reduce((field,key)=>VennSeries.updateFieldBoundaries(field,mapOfIdToShape[key]),{top:0,bottom:0,left:0,right:0}),scaling=VennSeries.getScale(chart.plotWidth,chart.plotHeight,field),scale=scaling.scale,centerX=scaling.centerX,centerY=scaling.centerY;for(const point of this.points){const sets=isArray(point.sets)?point.sets:[],id=sets.join(),shape=mapOfIdToShape[id],dataLabelValues=mapOfIdToLabelValues[id]||{},dlOptions=point.options&&point.options.dataLabels;let shapeArgs,dataLabelWidth=dataLabelValues.width,dataLabelPosition=dataLabelValues.position;if(shape){if(shape.r){shapeArgs={x:centerX+shape.x*scale,y:centerY+shape.y*scale,r:shape.r*scale}}else if(shape.d){const d=shape.d;d.forEach(seg=>{if(seg[0]==="M"){seg[1]=centerX+seg[1]*scale;seg[2]=centerY+seg[2]*scale}else if(seg[0]==="A"){seg[1]=seg[1]*scale;seg[2]=seg[2]*scale;seg[6]=centerX+seg[6]*scale;seg[7]=centerY+seg[7]*scale}});shapeArgs={d:d}}if(dataLabelPosition){dataLabelPosition.x=centerX+dataLabelPosition.x*scale;dataLabelPosition.y=centerY+dataLabelPosition.y*scale}else{dataLabelPosition={}}if(isNumber(dataLabelWidth)){dataLabelWidth=Math.round(dataLabelWidth*scale)}}point.shapeArgs=shapeArgs;if(dataLabelPosition&&shapeArgs){point.plotX=dataLabelPosition.x;point.plotY=dataLabelPosition.y}if(dataLabelWidth&&shapeArgs){point.dlOptions=merge(true,{style:{width:dataLabelWidth}},isObject(dlOptions,true)?dlOptions:void 0)}point.name=point.options.name||sets.join("âˆ©")}}}VennSeries.splitter="highcharts-split";VennSeries.defaultOptions=merge(ScatterSeries.defaultOptions,VennSeriesDefaults);extend(VennSeries.prototype,{axisTypes:[],directTouch:true,isCartesian:false,pointArrayMap:["value"],pointClass:VennPoint,utils:VennUtils});addEvent(VennSeries,"afterSetOptions",function(e){const options=e.options,states=options.states||{};if(this.is("venn")){for(const state of Object.keys(states)){states[state].halo=false}}});SeriesRegistry.registerSeriesType("venn",VennSeries);export default VennSeries;