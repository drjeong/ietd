"use strict";import CU from"../../Core/Geometry/CircleUtilities.js";const{getAreaOfCircle,getCircleCircleIntersection,getOverlapBetweenCircles:getOverlapBetweenCirclesByDistance,isPointInsideAllCircles,isPointInsideCircle,isPointOutsideAllCircles}=CU;import GU from"../../Core/Geometry/GeometryUtilities.js";const{getDistanceBetweenPoints}=GU;import U from"../../Core/Utilities.js";const{extend,isArray,isNumber,isObject,isString}=U;function addOverlapToSets(relations){const mapOfIdToProps={};relations.filter(relation=>relation.sets.length===2).forEach(relation=>{relation.sets.forEach((set,i,arr)=>{if(!isObject(mapOfIdToProps[set])){mapOfIdToProps[set]={totalOverlap:0,overlapping:{}}}mapOfIdToProps[set]={totalOverlap:(mapOfIdToProps[set].totalOverlap||0)+relation.value,overlapping:{...mapOfIdToProps[set].overlapping||{},[arr[1-i]]:relation.value}}})});relations.filter(isSet).forEach(set=>{const properties=mapOfIdToProps[set.sets[0]];extend(set,properties)});return relations}function bisect(f,a,b,tolerance,maxIterations){const fA=f(a),fB=f(b),nMax=maxIterations||100,tol=tolerance||1e-10;let delta=b-a,x,fX,n=1;if(a>=b){throw new Error("a must be smaller than b.")}else if(fA*fB>0){throw new Error("f(a) and f(b) must have opposite signs.")}if(fA===0){x=a}else if(fB===0){x=b}else{while(n++<=nMax&&fX!==0&&delta>tol){delta=(b-a)/2;x=a+delta;fX=f(x);if(fA*fX>0){a=x}else{b=x}}}return x}function getCentroid(simplex){const arr=simplex.slice(0,-1),length=arr.length,result=[],sum=(data,point)=>{data.sum+=point[data.i];return data};for(let i=0;i<length;i++){result[i]=arr.reduce(sum,{sum:0,i:i}).sum/length}return result}function getDistanceBetweenCirclesByOverlap(r1,r2,overlap){const maxDistance=r1+r2;let distance;if(overlap<=0){distance=maxDistance}else if(getAreaOfCircle(r1<r2?r1:r2)<=overlap){distance=0}else{distance=bisect(x=>{const actualOverlap=getOverlapBetweenCirclesByDistance(r1,r2,x);return overlap-actualOverlap},0,maxDistance)}return distance}function getLabelWidth(pos,internal,external){const radius=internal.reduce((min,circle)=>Math.min(circle.r,min),Infinity),filteredExternals=external.filter(circle=>!isPointInsideCircle(pos,circle));const findDistance=function(maxDistance,direction){return bisect(x=>{const testPos={x:pos.x+direction*x,y:pos.y},isValid=isPointInsideAllCircles(testPos,internal)&&isPointOutsideAllCircles(testPos,filteredExternals);return-(maxDistance-x)+(isValid?0:Number.MAX_VALUE)},0,maxDistance)};return Math.min(findDistance(radius,-1),findDistance(radius,1))*2}function getMarginFromCircles(point,internal,external){let margin=internal.reduce((margin,circle)=>{const m=circle.r-getDistanceBetweenPoints(point,circle);return m<=margin?m:margin},Number.MAX_VALUE);margin=external.reduce((margin,circle)=>{const m=getDistanceBetweenPoints(point,circle)-circle.r;return m<=margin?m:margin},margin);return margin}function getOverlapBetweenCircles(circles){let overlap=0;if(circles.length===2){const circle1=circles[0];const circle2=circles[1];overlap=getOverlapBetweenCirclesByDistance(circle1.r,circle2.r,getDistanceBetweenPoints(circle1,circle2))}return overlap}function isSet(x){return isArray(x.sets)&&x.sets.length===1}function isValidRelation(x){const map={};return isObject(x)&&(isNumber(x.value)&&x.value>-1)&&(isArray(x.sets)&&x.sets.length>0)&&!x.sets.some(function(set){let invalid=false;if(!map[set]&&isString(set)){map[set]=true}else{invalid=true}return invalid})}function isValidSet(x){return isValidRelation(x)&&isSet(x)&&x.value>0}function layoutGreedyVenn(relations){const positionedSets=[],mapOfIdToCircles={};relations.filter(relation=>relation.sets.length===1).forEach(relation=>{mapOfIdToCircles[relation.sets[0]]=relation.circle={x:Number.MAX_VALUE,y:Number.MAX_VALUE,r:Math.sqrt(relation.value/Math.PI)}});const positionSet=(set,coordinates)=>{const circle=set.circle;if(circle){circle.x=coordinates.x;circle.y=coordinates.y}positionedSets.push(set)};addOverlapToSets(relations);const sortedByOverlap=relations.filter(isSet).sort(sortByTotalOverlap);positionSet(sortedByOverlap.shift(),{x:0,y:0});const relationsWithTwoSets=relations.filter(x=>x.sets.length===2);for(const set of sortedByOverlap){const circle=set.circle;if(!circle){continue}const radius=circle.r,overlapping=set.overlapping;const bestPosition=positionedSets.reduce((best,positionedSet,i)=>{const positionedCircle=positionedSet.circle;if(!positionedCircle||!overlapping){return best}const overlap=overlapping[positionedSet.sets[0]];const distance=getDistanceBetweenCirclesByOverlap(radius,positionedCircle.r,overlap);let possibleCoordinates=[{x:positionedCircle.x+distance,y:positionedCircle.y},{x:positionedCircle.x-distance,y:positionedCircle.y},{x:positionedCircle.x,y:positionedCircle.y+distance},{x:positionedCircle.x,y:positionedCircle.y-distance}];for(const positionedSet2 of positionedSets.slice(i+1)){const positionedCircle2=positionedSet2.circle,overlap2=overlapping[positionedSet2.sets[0]];if(!positionedCircle2){continue}const distance2=getDistanceBetweenCirclesByOverlap(radius,positionedCircle2.r,overlap2);possibleCoordinates=possibleCoordinates.concat(getCircleCircleIntersection({x:positionedCircle.x,y:positionedCircle.y,r:distance},{x:positionedCircle2.x,y:positionedCircle2.y,r:distance2}))}for(const coordinates of possibleCoordinates){circle.x=coordinates.x;circle.y=coordinates.y;const currentLoss=loss(mapOfIdToCircles,relationsWithTwoSets);if(currentLoss<best.loss){best.loss=currentLoss;best.coordinates=coordinates}}return best},{loss:Number.MAX_VALUE,coordinates:void 0});positionSet(set,bestPosition.coordinates)}return mapOfIdToCircles}function loss(mapOfIdToCircle,relations){const precision=1e11;return relations.reduce(function(totalLoss,relation){let loss=0;if(relation.sets.length>1){const wantedOverlap=relation.value;const actualOverlap=getOverlapBetweenCircles(relation.sets.map(function(set){return mapOfIdToCircle[set]}));const diff=wantedOverlap-actualOverlap;loss=Math.round(diff*diff*precision)/precision}return totalLoss+loss},0)}function nelderMead(fn,initial){const maxIterations=100,sortByFx=function(a,b){return a.fx-b.fx},pRef=1,pExp=2,pCon=-.5,pOCon=pCon*pRef,pShrink=.5;const weightedSum=(weight1,v1,weight2,v2)=>v1.map((x,i)=>weight1*x+weight2*v2[i]);const getSimplex=initial=>{const n=initial.length,simplex=new Array(n+1);simplex[0]=initial;simplex[0].fx=fn(initial);for(let i=0;i<n;++i){const point=initial.slice();point[i]=point[i]?point[i]*1.05:.001;point.fx=fn(point);simplex[i+1]=point}return simplex};const updateSimplex=(simplex,point)=>{point.fx=fn(point);simplex[simplex.length-1]=point;return simplex};const shrinkSimplex=simplex=>{const best=simplex[0];return simplex.map(point=>{const p=weightedSum(1-pShrink,best,pShrink,point);p.fx=fn(p);return p})};const getPoint=(centroid,worst,a,b)=>{const point=weightedSum(a,centroid,b,worst);point.fx=fn(point);return point};let simplex=getSimplex(initial);for(let i=0;i<maxIterations;i++){simplex.sort(sortByFx);const worst=simplex[simplex.length-1];const centroid=getCentroid(simplex);const reflected=getPoint(centroid,worst,1+pRef,-pRef);if(reflected.fx<simplex[0].fx){const expanded=getPoint(centroid,worst,1+pExp,-pExp);simplex=updateSimplex(simplex,expanded.fx<reflected.fx?expanded:reflected)}else if(reflected.fx>=simplex[simplex.length-2].fx){let contracted;if(reflected.fx>worst.fx){contracted=getPoint(centroid,worst,1+pCon,-pCon);if(contracted.fx<worst.fx){simplex=updateSimplex(simplex,contracted)}else{simplex=shrinkSimplex(simplex)}}else{contracted=getPoint(centroid,worst,1-pOCon,pOCon);if(contracted.fx<reflected.fx){simplex=updateSimplex(simplex,contracted)}else{simplex=shrinkSimplex(simplex)}}}else{simplex=updateSimplex(simplex,reflected)}}return simplex[0]}function processVennData(data,splitter){const d=isArray(data)?data:[];const validSets=d.reduce(function(arr,x){if(x.sets&&isValidSet(x)&&arr.indexOf(x.sets[0])===-1){arr.push(x.sets[0])}return arr},[]).sort();const mapOfIdToRelation=d.reduce(function(mapOfIdToRelation,relation){if(relation.sets&&isValidRelation(relation)&&!relation.sets.some(function(set){return validSets.indexOf(set)===-1})){mapOfIdToRelation[relation.sets.sort().join(splitter)]={sets:relation.sets,value:relation.value||0}}return mapOfIdToRelation},{});validSets.reduce(function(combinations,set,i,arr){const remaining=arr.slice(i+1);remaining.forEach(function(set2){combinations.push(set+splitter+set2)});return combinations},[]).forEach(function(combination){if(!mapOfIdToRelation[combination]){const obj={sets:combination.split(splitter),value:0};mapOfIdToRelation[combination]=obj}});return Object.keys(mapOfIdToRelation).map(function(id){return mapOfIdToRelation[id]})}function sortByTotalOverlap(a,b){if(typeof b.totalOverlap!=="undefined"&&typeof a.totalOverlap!=="undefined"){return b.totalOverlap-a.totalOverlap}return NaN}const VennUtils={geometry:GU,geometryCircles:CU,addOverlapToSets:addOverlapToSets,getCentroid:getCentroid,getDistanceBetweenCirclesByOverlap:getDistanceBetweenCirclesByOverlap,getLabelWidth:getLabelWidth,getMarginFromCircles:getMarginFromCircles,isSet:isSet,layoutGreedyVenn:layoutGreedyVenn,loss:loss,nelderMead:nelderMead,processVennData:processVennData,sortByTotalOverlap:sortByTotalOverlap};export default VennUtils;