"use strict";import ColorMapComposition from"../ColorMapComposition.js";import MU from"../../Maps/MapUtilities.js";const{boundsFromPath}=MU;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const ScatterPoint=SeriesRegistry.seriesTypes.scatter.prototype.pointClass;import U from"../../Core/Utilities.js";const{extend,isNumber,pick}=U;class MapPoint extends ScatterPoint{static getProjectedPath(point,projection){if(!point.projectedPath){if(projection&&point.geometry){projection.hasCoordinates=true;point.projectedPath=projection.path(point.geometry)}else{point.projectedPath=point.path}}return point.projectedPath||[]}applyOptions(options,x){const series=this.series,point=super.applyOptions(options,x),joinBy=series.joinBy;if(series.mapData&&series.mapMap){const joinKey=joinBy[1],mapKey=super.getNestedProperty(joinKey),mapPoint=typeof mapKey!=="undefined"&&series.mapMap[mapKey];if(mapPoint){extend(point,{...mapPoint,name:point.name??mapPoint.name})}else if(series.pointArrayMap.indexOf("value")!==-1){point.value=point.value||null}}return point}getProjectedBounds(projection){const path=MapPoint.getProjectedPath(this,projection),bounds=boundsFromPath(path),properties=this.properties,mapView=this.series.chart.mapView;if(bounds){const propMiddleLon=properties&&properties["hc-middle-lon"],propMiddleLat=properties&&properties["hc-middle-lat"];if(mapView&&isNumber(propMiddleLon)&&isNumber(propMiddleLat)){const projectedPoint=projection.forward([propMiddleLon,propMiddleLat]);bounds.midX=projectedPoint[0];bounds.midY=projectedPoint[1]}else{const propMiddleX=properties&&properties["hc-middle-x"],propMiddleY=properties&&properties["hc-middle-y"];bounds.midX=bounds.x1+(bounds.x2-bounds.x1)*pick(this.middleX,isNumber(propMiddleX)?propMiddleX:.5);let middleYFraction=pick(this.middleY,isNumber(propMiddleY)?propMiddleY:.5);if(!this.geometry){middleYFraction=1-middleYFraction}bounds.midY=bounds.y2-(bounds.y2-bounds.y1)*middleYFraction}return bounds}}onMouseOver(e){U.clearTimeout(this.colorInterval);if(!this.isNull&&this.visible||this.series.options.nullInteraction){super.onMouseOver.call(this,e)}else{this.series.onMouseOut()}}setVisible(vis){const method=vis?"show":"hide";this.visible=this.options.visible=!!vis;if(this.dataLabel){this.dataLabel[method]()}if(this.graphic){this.graphic.attr(this.series.pointAttribs(this))}}zoomTo(animOptions){const point=this,chart=point.series.chart,mapView=chart.mapView;let bounds=point.bounds;if(mapView&&bounds){const inset=isNumber(point.insetIndex)&&mapView.insets[point.insetIndex];if(inset){const px1=inset.projectedUnitsToPixels({x:bounds.x1,y:bounds.y1}),px2=inset.projectedUnitsToPixels({x:bounds.x2,y:bounds.y2}),proj1=mapView.pixelsToProjectedUnits({x:px1.x,y:px1.y}),proj2=mapView.pixelsToProjectedUnits({x:px2.x,y:px2.y});bounds={x1:proj1.x,y1:proj1.y,x2:proj2.x,y2:proj2.y}}mapView.fitToBounds(bounds,void 0,false);point.series.isDirty=true;chart.redraw(animOptions)}}}extend(MapPoint.prototype,{dataLabelOnNull:ColorMapComposition.pointMembers.dataLabelOnNull,moveToTopOnHover:ColorMapComposition.pointMembers.moveToTopOnHover,isValid:ColorMapComposition.pointMembers.isValid});export default MapPoint;