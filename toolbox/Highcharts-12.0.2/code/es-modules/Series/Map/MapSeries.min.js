"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{animObject,stop}=A;import ColorMapComposition from"../ColorMapComposition.js";import CU from"../CenteredUtilities.js";import H from"../../Core/Globals.js";const{noop}=H;import MapChart from"../../Core/Chart/MapChart.js";const{splitPath}=MapChart;import MapPoint from"./MapPoint.js";import MapSeriesDefaults from"./MapSeriesDefaults.js";import MapView from"../../Maps/MapView.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{extend,find,fireEvent,getNestedProperty,isArray,defined,isNumber,isObject,merge,objectEach,pick,splat}=U;class MapSeries extends ScatterSeries{constructor(){super(...arguments);this.processedData=[]}animate(init){const{chart,group}=this,animation=animObject(this.options.animation);if(init){group.attr({translateX:chart.plotLeft+chart.plotWidth/2,translateY:chart.plotTop+chart.plotHeight/2,scaleX:.001,scaleY:.001})}else{group.animate({translateX:chart.plotLeft,translateY:chart.plotTop,scaleX:1,scaleY:1},animation)}}clearBounds(){this.points.forEach(point=>{delete point.bounds;delete point.insetIndex;delete point.projectedPath});delete this.bounds}doFullTranslate(){return Boolean(this.isDirtyData||this.chart.isResizing||!this.hasRendered)}drawMapDataLabels(){super.drawDataLabels();if(this.dataLabelsGroup){this.dataLabelsGroup.clip(this.chart.clipRect)}}drawPoints(){const series=this,{chart,group,transformGroups=[]}=this,{mapView,renderer}=chart;if(!mapView){return}this.transformGroups=transformGroups;if(!transformGroups[0]){transformGroups[0]=renderer.g().add(group)}for(let i=0,iEnd=mapView.insets.length;i<iEnd;++i){if(!transformGroups[i+1]){transformGroups.push(renderer.g().add(group))}}if(this.doFullTranslate()){this.points.forEach(point=>{const{graphic}=point;point.group=transformGroups[typeof point.insetIndex==="number"?point.insetIndex+1:0];if(graphic&&graphic.parentGroup!==point.group){graphic.add(point.group)}});ColumnSeries.prototype.drawPoints.apply(this);this.points.forEach(point=>{const graphic=point.graphic;if(graphic){const animate=graphic.animate;let className="";if(point.name){className+="highcharts-name-"+point.name.replace(/ /g,"-").toLowerCase()}if(point.properties&&point.properties["hc-key"]){className+=" highcharts-key-"+point.properties["hc-key"].toString().toLowerCase()}if(className){graphic.addClass(className)}if(chart.styledMode){graphic.css(this.pointAttribs(point,point.selected&&"select"||void 0))}graphic.attr({visibility:point.visible||!point.visible&&!point.isNull?"inherit":"hidden"});graphic.animate=function(params,options,complete){const animateIn=isNumber(params["stroke-width"])&&!isNumber(graphic["stroke-width"]),animateOut=isNumber(graphic["stroke-width"])&&!isNumber(params["stroke-width"]);if(animateIn||animateOut){const strokeWidth=pick(series.getStrokeWidth(series.options),1),inheritedStrokeWidth=strokeWidth/(chart.mapView&&chart.mapView.getScale()||1);if(animateIn){graphic["stroke-width"]=inheritedStrokeWidth}if(animateOut){params["stroke-width"]=inheritedStrokeWidth}}const ret=animate.call(graphic,params,options,animateOut?function(){graphic.element.removeAttribute("stroke-width");delete graphic["stroke-width"];if(complete){complete.apply(this,arguments)}}:complete);return ret}}})}transformGroups.forEach((transformGroup,i)=>{const view=i===0?mapView:mapView.insets[i-1],svgTransform=view.getSVGTransform(),strokeWidth=pick(this.getStrokeWidth(this.options),1);const scale=svgTransform.scaleX,flipFactor=svgTransform.scaleY>0?1:-1;const animatePoints=scale=>{(series.points||[]).forEach(point=>{const graphic=point.graphic;let strokeWidth;if(graphic&&graphic["stroke-width"]&&(strokeWidth=this.getStrokeWidth(point.options))){graphic.attr({"stroke-width":strokeWidth/scale})}})};if(renderer.globalAnimation&&chart.hasRendered&&mapView.allowTransformAnimation){const startTranslateX=Number(transformGroup.attr("translateX"));const startTranslateY=Number(transformGroup.attr("translateY"));const startScale=Number(transformGroup.attr("scaleX"));const step=(now,fx)=>{const scaleStep=startScale+(scale-startScale)*fx.pos;transformGroup.attr({translateX:startTranslateX+(svgTransform.translateX-startTranslateX)*fx.pos,translateY:startTranslateY+(svgTransform.translateY-startTranslateY)*fx.pos,scaleX:scaleStep,scaleY:scaleStep*flipFactor,"stroke-width":strokeWidth/scaleStep});animatePoints(scaleStep)};const animOptions=merge(animObject(renderer.globalAnimation)),userStep=animOptions.step;animOptions.step=function(){if(userStep){userStep.apply(this,arguments)}step.apply(this,arguments)};transformGroup.attr({animator:0}).animate({animator:1},animOptions,function(){if(typeof renderer.globalAnimation!=="boolean"&&renderer.globalAnimation.complete){renderer.globalAnimation.complete({applyDrilldown:true})}fireEvent(this,"mapZoomComplete")}.bind(this))}else{stop(transformGroup);transformGroup.attr(merge(svgTransform,{"stroke-width":strokeWidth/scale}));animatePoints(scale)}});if(!this.isDrilling){this.drawMapDataLabels()}}getProjectedBounds(){if(!this.bounds&&this.chart.mapView){const{insets,projection}=this.chart.mapView,allBounds=[];(this.points||[]).forEach(point=>{if(point.path||point.geometry){if(typeof point.path==="string"){point.path=splitPath(point.path)}else if(isArray(point.path)&&point.path[0]==="M"){point.path=this.chart.renderer.pathToSegments(point.path)}if(!point.bounds){let bounds=point.getProjectedBounds(projection);if(bounds){point.labelrank=pick(point.labelrank,(bounds.x2-bounds.x1)*(bounds.y2-bounds.y1));const{midX,midY}=bounds;if(insets&&isNumber(midX)&&isNumber(midY)){const inset=find(insets,inset=>inset.isInside({x:midX,y:midY}));if(inset){delete point.projectedPath;bounds=point.getProjectedBounds(inset.projection);if(bounds){inset.allBounds.push(bounds)}point.insetIndex=insets.indexOf(inset)}}point.bounds=bounds}}if(point.bounds&&point.insetIndex===void 0){allBounds.push(point.bounds)}}});this.bounds=MapView.compositeBounds(allBounds)}return this.bounds}getStrokeWidth(options){const pointAttrToOptions=this.pointAttrToOptions;return options[pointAttrToOptions&&pointAttrToOptions["stroke-width"]||"borderWidth"]}hasData(){return!!this.dataTable.rowCount}pointAttribs(point,state){const{mapView,styledMode}=point.series.chart;const attr=styledMode?this.colorAttribs(point):ColumnSeries.prototype.pointAttribs.call(this,point,state);let pointStrokeWidth=this.getStrokeWidth(point.options);if(state){const stateOptions=merge(this.options.states&&this.options.states[state],point.options.states&&point.options.states[state]||{}),stateStrokeWidth=this.getStrokeWidth(stateOptions);if(defined(stateStrokeWidth)){pointStrokeWidth=stateStrokeWidth}attr.stroke=stateOptions.borderColor??point.color}if(pointStrokeWidth&&mapView){pointStrokeWidth/=mapView.getScale()}const seriesStrokeWidth=this.getStrokeWidth(this.options);if(attr.dashstyle&&mapView&&isNumber(seriesStrokeWidth)){pointStrokeWidth=seriesStrokeWidth/mapView.getScale()}if(!point.visible){attr.fill=this.options.nullColor}if(defined(pointStrokeWidth)){attr["stroke-width"]=pointStrokeWidth}else{delete attr["stroke-width"]}attr["stroke-linecap"]=attr["stroke-linejoin"]=this.options.linecap;return attr}updateData(){if(this.processedData){return false}return super.updateData.apply(this,arguments)}setData(data,redraw=true,animation,updatePoints){delete this.bounds;super.setData(data,false,void 0,updatePoints);this.processData();this.generatePoints();if(redraw){this.chart.redraw(animation)}}dataColumnKeys(){return this.pointArrayMap}processData(){const options=this.options,data=options.data,chart=this.chart,chartOptions=chart.options.chart,joinBy=this.joinBy,pointArrayMap=options.keys||this.pointArrayMap,dataUsed=[],mapMap={},mapView=this.chart.mapView,mapDataObject=mapView&&(isObject(options.mapData,true)?mapView.getGeoMap(options.mapData):mapView.geoMap),mapTransforms=chart.mapTransforms=chartOptions.mapTransforms||mapDataObject&&mapDataObject["hc-transform"]||chart.mapTransforms;let mapPoint,props;if(mapTransforms){objectEach(mapTransforms,transform=>{if(transform.rotation){transform.cosAngle=Math.cos(transform.rotation);transform.sinAngle=Math.sin(transform.rotation)}})}let mapData;if(isArray(options.mapData)){mapData=options.mapData}else if(mapDataObject&&mapDataObject.type==="FeatureCollection"){this.mapTitle=mapDataObject.title;mapData=H.geojson(mapDataObject,this.type,this)}this.processedData=[];const processedData=this.processedData;if(data){let val;for(let i=0,iEnd=data.length;i<iEnd;++i){val=data[i];if(isNumber(val)){processedData[i]={value:val}}else if(isArray(val)){let ix=0;processedData[i]={};if(!options.keys&&val.length>pointArrayMap.length&&typeof val[0]==="string"){processedData[i]["hc-key"]=val[0];++ix}for(let j=0;j<pointArrayMap.length;++j,++ix){if(pointArrayMap[j]&&typeof val[ix]!=="undefined"){if(pointArrayMap[j].indexOf(".")>0){MapPoint.prototype.setNestedProperty(processedData[i],val[ix],pointArrayMap[j])}else{processedData[i][pointArrayMap[j]]=val[ix]}}}}else{processedData[i]=data[i]}if(joinBy&&joinBy[0]==="_i"){processedData[i]._i=i}}}if(mapData){this.mapData=mapData;this.mapMap={};for(let i=0;i<mapData.length;i++){mapPoint=mapData[i];props=mapPoint.properties;mapPoint._i=i;if(joinBy[0]&&props&&props[joinBy[0]]){mapPoint[joinBy[0]]=props[joinBy[0]]}mapMap[mapPoint[joinBy[0]]]=mapPoint}this.mapMap=mapMap;if(joinBy[1]){const joinKey=joinBy[1];processedData.forEach(pointOptions=>{const mapKey=getNestedProperty(joinKey,pointOptions);if(mapMap[mapKey]){dataUsed.push(mapMap[mapKey])}})}if(options.allAreas){if(joinBy[1]){const joinKey=joinBy[1];processedData.forEach(pointOptions=>{dataUsed.push(getNestedProperty(joinKey,pointOptions))})}const dataUsedString="|"+dataUsed.map(function(point){return point&&point[joinBy[0]]}).join("|")+"|";mapData.forEach(mapPoint=>{if(!joinBy[0]||dataUsedString.indexOf("|"+mapPoint[joinBy[0]]+"|")===-1){processedData.push(merge(mapPoint,{value:null}))}})}}this.dataTable.rowCount=processedData.length;return void 0}setOptions(itemOptions){const options=super.setOptions(itemOptions);let joinBy=options.joinBy;if(options.joinBy===null){joinBy="_i"}if(joinBy){this.joinBy=splat(joinBy);if(!this.joinBy[1]){this.joinBy[1]=this.joinBy[0]}}return options}translate(){const series=this,doFullTranslate=series.doFullTranslate(),mapView=this.chart.mapView,projection=mapView&&mapView.projection;if(this.chart.hasRendered&&(this.isDirtyData||!this.hasRendered)){this.processData();this.generatePoints();delete this.bounds;if(mapView&&!mapView.userOptions.center&&!isNumber(mapView.userOptions.zoom)&&mapView.zoom===mapView.minZoom){mapView.fitToBounds(void 0,void 0,false)}else{this.getProjectedBounds()}}if(mapView){const mainSvgTransform=mapView.getSVGTransform();series.points.forEach(point=>{const svgTransform=isNumber(point.insetIndex)&&mapView.insets[point.insetIndex].getSVGTransform()||mainSvgTransform;if(svgTransform&&point.bounds&&isNumber(point.bounds.midX)&&isNumber(point.bounds.midY)){point.plotX=point.bounds.midX*svgTransform.scaleX+svgTransform.translateX;point.plotY=point.bounds.midY*svgTransform.scaleY+svgTransform.translateY}if(doFullTranslate){point.shapeType="path";point.shapeArgs={d:MapPoint.getProjectedPath(point,projection)}}if(!point.hiddenInDataClass){if(point.projectedPath&&!point.projectedPath.length){point.setVisible(false)}else if(!point.visible){point.setVisible(true)}}})}fireEvent(series,"afterTranslate")}update(options){if(options.mapData){this.chart.mapView?.recommendMapView(this.chart,[this.chart.options.chart.map,...(this.chart.options.series||[]).map((s,i)=>{if(i===this._i){return options.mapData}return s.mapData})],true)}super.update.apply(this,arguments)}}MapSeries.defaultOptions=merge(ScatterSeries.defaultOptions,MapSeriesDefaults);extend(MapSeries.prototype,{type:"map",axisTypes:ColorMapComposition.seriesMembers.axisTypes,colorAttribs:ColorMapComposition.seriesMembers.colorAttribs,colorKey:ColorMapComposition.seriesMembers.colorKey,directTouch:true,drawDataLabels:noop,drawGraph:noop,forceDL:true,getCenter:CU.getCenter,getExtremesFromAll:true,getSymbol:noop,isCartesian:false,parallelArrays:ColorMapComposition.seriesMembers.parallelArrays,pointArrayMap:ColorMapComposition.seriesMembers.pointArrayMap,pointClass:MapPoint,preserveAspectRatio:true,searchPoint:noop,trackerGroups:ColorMapComposition.seriesMembers.trackerGroups,useMapGeometry:true});ColorMapComposition.compose(MapSeries);SeriesRegistry.registerSeriesType("map",MapSeries);export default MapSeries;