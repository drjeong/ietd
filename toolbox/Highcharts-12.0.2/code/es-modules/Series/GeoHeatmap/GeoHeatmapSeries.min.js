"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{animObject,stop}=A;import GeoHeatmapPoint from"./GeoHeatmapPoint.js";import H from"../../Core/Globals.js";const{noop}=H;import IU from"../InterpolationUtilities.js";const{colorFromPoint,getContext}=IU;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{seriesTypes:{map:MapSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{addEvent,extend,isNumber,isObject,merge,pick}=U;function normalizeLonValue(lon){return lon-Math.floor((lon+180)/360)*360}function scaledPointPos(lon,lat,canvasWidth,canvasHeight,colsize,rowsize){return Math.ceil(canvasWidth*(canvasHeight-1-(lat+90)/rowsize)+(lon+180)/colsize)}class GeoHeatmapSeries extends MapSeries{constructor(){super(...arguments);this.isDirtyCanvas=true}update(){const series=this;series.options=merge(series.options,arguments[0]);if(series.getInterpolation().enabled){series.isDirtyCanvas=true;series.points.forEach(point=>{if(point.graphic){point.graphic.destroy();delete point.graphic}})}super.update.apply(series,arguments)}translate(){if(this.getInterpolation().enabled&&this.image&&!this.isDirty&&!this.isDirtyData){return}super.translate.apply(this,arguments)}getInterpolation(){if(!isObject(this.options.interpolation)){return{blur:1,enabled:this.options.interpolation}}return this.options.interpolation}drawPoints(){const series=this,chart=series.chart,mapView=chart.mapView,seriesOptions=series.options;if(series.getInterpolation().enabled&&mapView&&series.bounds){const ctx=series.context||getContext(series),{canvas,colorAxis,image,chart,points}=series,[colsize,rowsize]=[pick(seriesOptions.colsize,1),pick(seriesOptions.rowsize,1)],topLeft=mapView.projectedUnitsToPixels({x:series.bounds.x1,y:series.bounds.y2}),bottomRight=mapView.projectedUnitsToPixels({x:series.bounds.x2,y:series.bounds.y1});if(canvas&&ctx&&colorAxis&&topLeft&&bottomRight){const dimensions={x:topLeft.x,y:topLeft.y,width:bottomRight.x-topLeft.x,height:bottomRight.y-topLeft.y};if(series.isDirtyCanvas||series.isDirtyData||mapView.projection.options.name==="Orthographic"){series.isDirtyCanvas=true;const canvasWidth=canvas.width=~~(360/colsize)+1,canvasHeight=canvas.height=~~(180/rowsize)+1,canvasArea=canvasWidth*canvasHeight,pixelData=new Uint8ClampedArray(canvasArea*4);series.directTouch=false;for(let i=0;i<points.length;i++){const p=points[i],sourceArr=new Uint8ClampedArray(colorFromPoint(p.value,p)),{lon,lat}=p.options;if(isNumber(lon)&&isNumber(lat)){pixelData.set(sourceArr,scaledPointPos(lon,lat,canvasWidth,canvasHeight,colsize,rowsize)*4)}}const blur=series.getInterpolation().blur,blurFactor=blur===0?1:blur*11,upscaledWidth=~~(canvasWidth*blurFactor),upscaledHeight=~~(canvasHeight*blurFactor),projectedWidth=~~dimensions.width,projectedHeight=~~dimensions.height,img=new ImageData(pixelData,canvasWidth,canvasHeight);canvas.width=upscaledWidth;canvas.height=upscaledHeight;ctx.putImageData(img,0,0);ctx.globalCompositeOperation="copy";ctx.drawImage(canvas,0,0,img.width,img.height,0,0,canvas.width,canvas.height);const cartesianImageData=ctx.getImageData(0,0,canvas.width,canvas.height),projectedPixelData=this.getProjectedImageData(mapView,projectedWidth,projectedHeight,cartesianImageData,canvas,dimensions.x,dimensions.y),projectedImg=new ImageData(projectedPixelData,projectedWidth,projectedHeight);ctx.globalCompositeOperation="copy";canvas.width=projectedWidth;canvas.height=projectedHeight;ctx.putImageData(projectedImg,0,0)}if(image){if(chart.renderer.globalAnimation&&chart.hasRendered){const startX=Number(image.attr("x")),startY=Number(image.attr("y")),startWidth=Number(image.attr("width")),startHeight=Number(image.attr("height"));const step=(now,fx)=>{image.attr({x:startX+(dimensions.x-startX)*fx.pos,y:startY+(dimensions.y-startY)*fx.pos,width:startWidth+(dimensions.width-startWidth)*fx.pos,height:startHeight+(dimensions.height-startHeight)*fx.pos})};const animOptions=merge(animObject(chart.renderer.globalAnimation)),userStep=animOptions.step;animOptions.step=function(){if(userStep){userStep.apply(this,arguments)}step.apply(this,arguments)};image.attr(merge({animator:0},series.isDirtyCanvas?{href:canvas.toDataURL("image/png",1)}:void 0)).animate({animator:1},animOptions)}else{stop(image);image.attr(merge(dimensions,series.isDirtyCanvas?{href:canvas.toDataURL("image/png",1)}:void 0))}}else{series.image=chart.renderer.image(canvas.toDataURL("image/png",1)).attr(dimensions).add(series.group)}series.isDirtyCanvas=false}}else{super.drawPoints.apply(series,arguments)}}getProjectedImageData(mapView,projectedWidth,projectedHeight,cartesianImageData,canvas,horizontalShift,verticalShift){const projectedPixelData=new Uint8ClampedArray(projectedWidth*projectedHeight*4),lambda=pick(mapView.projection.options.rotation?.[0],0),widthFactor=canvas.width/360,heightFactor=-1*canvas.height/180;let y=-1;for(let i=0;i<projectedPixelData.length;i+=4){const x=i/4%projectedWidth;if(x===0){y++}const projectedCoords=mapView.pixelsToLonLat({x:horizontalShift+x,y:verticalShift+y});if(projectedCoords){if(projectedCoords.lon>-180-lambda&&projectedCoords.lon<180-lambda){projectedCoords.lon=normalizeLonValue(projectedCoords.lon)}const projected=[projectedCoords.lon,projectedCoords.lat],cvs2PixelX=projected[0]*widthFactor+canvas.width/2,cvs2PixelY=projected[1]*heightFactor+canvas.height/2;if(cvs2PixelX>=0&&cvs2PixelX<=canvas.width&&cvs2PixelY>=0&&cvs2PixelY<=canvas.height){const redPos=Math.floor(cvs2PixelY)*canvas.width*4+Math.round(cvs2PixelX)*4;projectedPixelData[i]=cartesianImageData.data[redPos];projectedPixelData[i+1]=cartesianImageData.data[redPos+1];projectedPixelData[i+2]=cartesianImageData.data[redPos+2];projectedPixelData[i+3]=cartesianImageData.data[redPos+3]}}}return projectedPixelData}searchPoint(e,compareX){const series=this,chart=this.chart,mapView=chart.mapView;if(mapView&&series.bounds&&series.image&&chart.tooltip&&chart.tooltip.options.enabled){if(!chart.pointer.hasDragged&&(+series.image.attr("animator")<=.01||+series.image.attr("animator")>=.99)){const topLeft=mapView.projectedUnitsToPixels({x:series.bounds.x1,y:series.bounds.y2}),bottomRight=mapView.projectedUnitsToPixels({x:series.bounds.x2,y:series.bounds.y1});chart.pointer.normalize(e);if(e.lon&&e.lat&&topLeft&&bottomRight&&e.chartX-chart.plotLeft>topLeft.x&&e.chartX-chart.plotLeft<bottomRight.x&&e.chartY-chart.plotTop>topLeft.y&&e.chartY-chart.plotTop<bottomRight.y){return this.searchKDTree({clientX:e.chartX,lon:normalizeLonValue(e.lon),lat:e.lat},compareX,e)}}else{chart.tooltip.destroy()}}}}GeoHeatmapSeries.defaultOptions=merge(MapSeries.defaultOptions,{nullColor:"transparent",tooltip:{pointFormat:"Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>"},borderWidth:0,colsize:1,rowsize:1,stickyTracking:true,interpolation:{enabled:false,blur:1}});addEvent(GeoHeatmapSeries,"afterDataClassLegendClick",function(){this.isDirtyCanvas=true;this.drawPoints()});extend(GeoHeatmapSeries.prototype,{type:"geoheatmap",applyJitter:noop,pointClass:GeoHeatmapPoint,pointArrayMap:["lon","lat","value"],kdAxisArray:["lon","lat"]});SeriesRegistry.registerSeriesType("geoheatmap",GeoHeatmapSeries);export default GeoHeatmapSeries;"";