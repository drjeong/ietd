"use strict";import GaugePoint from"./GaugePoint.js";import H from"../../Core/Globals.js";const{noop}=H;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series,seriesTypes:{column:ColumnSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{clamp,isNumber,extend,merge,pick,pInt,defined}=U;class GaugeSeries extends Series{translate(){const series=this,yAxis=series.yAxis,options=series.options,center=yAxis.center;series.generatePoints();series.points.forEach(point=>{const dialOptions=merge(options.dial,point.dial),radius=pInt(dialOptions.radius)*center[2]/200,baseLength=pInt(dialOptions.baseLength)*radius/100,rearLength=pInt(dialOptions.rearLength)*radius/100,baseWidth=dialOptions.baseWidth,topWidth=dialOptions.topWidth;let overshoot=options.overshoot,rotation=yAxis.startAngleRad+yAxis.translate(point.y,void 0,void 0,void 0,true);if(isNumber(overshoot)||options.wrap===false){overshoot=isNumber(overshoot)?overshoot/180*Math.PI:0;rotation=clamp(rotation,yAxis.startAngleRad-overshoot,yAxis.endAngleRad+overshoot)}rotation=rotation*180/Math.PI;point.shapeType="path";const d=dialOptions.path||[["M",-rearLength,-baseWidth/2],["L",baseLength,-baseWidth/2],["L",radius,-topWidth/2],["L",radius,topWidth/2],["L",baseLength,baseWidth/2],["L",-rearLength,baseWidth/2],["Z"]];point.shapeArgs={d:d,translateX:center[0],translateY:center[1],rotation:rotation};point.plotX=center[0];point.plotY=center[1];if(defined(point.y)&&yAxis.max-yAxis.min){point.percentage=(point.y-yAxis.min)/(yAxis.max-yAxis.min)*100}})}drawPoints(){const series=this,chart=series.chart,center=series.yAxis.center,pivot=series.pivot,options=series.options,pivotOptions=options.pivot,renderer=chart.renderer;series.points.forEach(point=>{const graphic=point.graphic,shapeArgs=point.shapeArgs,d=shapeArgs.d,dialOptions=merge(options.dial,point.dial);if(graphic){graphic.animate(shapeArgs);shapeArgs.d=d}else{point.graphic=renderer[point.shapeType](shapeArgs).addClass("highcharts-dial").add(series.group)}if(!chart.styledMode){point.graphic[graphic?"animate":"attr"]({stroke:dialOptions.borderColor,"stroke-width":dialOptions.borderWidth,fill:dialOptions.backgroundColor})}});if(pivot){pivot.animate({translateX:center[0],translateY:center[1]})}else if(pivotOptions){series.pivot=renderer.circle(0,0,pivotOptions.radius).attr({zIndex:2}).addClass("highcharts-pivot").translate(center[0],center[1]).add(series.group);if(!chart.styledMode){series.pivot.attr({fill:pivotOptions.backgroundColor,stroke:pivotOptions.borderColor,"stroke-width":pivotOptions.borderWidth})}}}animate(init){const series=this;if(!init){series.points.forEach(point=>{const graphic=point.graphic;if(graphic){graphic.attr({rotation:series.yAxis.startAngleRad*180/Math.PI});graphic.animate({rotation:point.shapeArgs.rotation},series.options.animation)}})}}render(){this.group=this.plotGroup("group","series",this.visible?"inherit":"hidden",this.options.zIndex,this.chart.seriesGroup);Series.prototype.render.call(this);this.group.clip(this.chart.clipRect)}setData(data,redraw){Series.prototype.setData.call(this,data,false);this.processData();this.generatePoints();if(pick(redraw,true)){this.chart.redraw()}}hasData(){return!!this.points.length}}GaugeSeries.defaultOptions=merge(Series.defaultOptions,{dataLabels:{borderColor:"#cccccc",borderRadius:3,borderWidth:1,crop:false,defer:false,enabled:true,verticalAlign:"top",y:15,zIndex:2},dial:{backgroundColor:"#000000",baseLength:"70%",baseWidth:3,borderColor:"#cccccc",borderWidth:0,radius:"80%",rearLength:"10%",topWidth:1},pivot:{radius:5,borderWidth:0,borderColor:"#cccccc",backgroundColor:"#000000"},tooltip:{headerFormat:""},showInLegend:false});extend(GaugeSeries.prototype,{angular:true,directTouch:true,drawGraph:noop,drawTracker:ColumnSeries.prototype.drawTracker,fixedBox:true,forceDL:true,noSharedTooltip:true,pointClass:GaugePoint,trackerGroups:["group","dataLabelsGroup"]});SeriesRegistry.registerSeriesType("gauge",GaugeSeries);export default GaugeSeries;"";