"use strict";import H from"../../Core/Globals.js";const{composed}=H;import HeikinAshiPoint from"./HeikinAshiPoint.js";import HeikinAshiSeriesDefaults from"./HeikinAshiSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{candlestick:CandlestickSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{addEvent,merge,pushUnique}=U;function onAxisPostProcessData(){const series=this.series;series.forEach(series=>{if(series.is("heikinashi")){const heikinashiSeries=series;heikinashiSeries.heikiashiData.length=0;heikinashiSeries.getHeikinashiData()}})}function onHeikinAshiSeriesAfterTranslate(){const series=this,points=series.points,heikiashiData=series.heikiashiData,cropStart=series.cropStart||0;for(let i=0;i<points.length;i++){const point=points[i],heikiashiDataPoint=heikiashiData[i+cropStart];point.open=heikiashiDataPoint[0];point.high=heikiashiDataPoint[1];point.low=heikiashiDataPoint[2];point.close=heikiashiDataPoint[3]}}function onHeikinAshiSeriesUpdatedData(){if(this.heikiashiData.length){this.heikiashiData.length=0}}class HeikinAshiSeries extends CandlestickSeries{constructor(){super(...arguments);this.heikiashiData=[]}static compose(SeriesClass,AxisClass){CandlestickSeries.compose(SeriesClass);if(pushUnique(composed,"HeikinAshi")){addEvent(AxisClass,"postProcessData",onAxisPostProcessData);addEvent(HeikinAshiSeries,"afterTranslate",onHeikinAshiSeriesAfterTranslate);addEvent(HeikinAshiSeries,"updatedData",onHeikinAshiSeriesUpdatedData)}}getHeikinashiData(){const series=this,table=series.allGroupedTable||series.dataTable,dataLength=table.rowCount,heikiashiData=series.heikiashiData;if(!heikiashiData.length&&dataLength){this.modifyFirstPointValue(table.getRow(0,this.pointArrayMap));for(let i=1;i<dataLength;i++){this.modifyDataPoint(table.getRow(i,this.pointArrayMap),heikiashiData[i-1])}}series.heikiashiData=heikiashiData}init(){super.init.apply(this,arguments);this.heikiashiData=[]}modifyFirstPointValue(dataPoint){const open=(dataPoint[0]+dataPoint[1]+dataPoint[2]+dataPoint[3])/4,close=(dataPoint[0]+dataPoint[3])/2;this.heikiashiData.push([open,dataPoint[1],dataPoint[2],close])}modifyDataPoint(dataPoint,previousDataPoint){const newOpen=(previousDataPoint[0]+previousDataPoint[3])/2,newClose=(dataPoint[0]+dataPoint[1]+dataPoint[2]+dataPoint[3])/4,newHigh=Math.max(dataPoint[1],newClose,newOpen),newLow=Math.min(dataPoint[2],newClose,newOpen);this.heikiashiData.push([newOpen,newHigh,newLow,newClose])}}HeikinAshiSeries.defaultOptions=merge(CandlestickSeries.defaultOptions,HeikinAshiSeriesDefaults);HeikinAshiSeries.prototype.pointClass=HeikinAshiPoint;SeriesRegistry.registerSeriesType("heikinashi",HeikinAshiSeries);export default HeikinAshiSeries;