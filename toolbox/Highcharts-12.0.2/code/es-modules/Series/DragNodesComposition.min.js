"use strict";import H from"../Core/Globals.js";const{composed}=H;import U from"../Core/Utilities.js";const{addEvent,pushUnique}=U;function compose(ChartClass){if(pushUnique(composed,"DragNodes")){addEvent(ChartClass,"load",onChartLoad)}}function onChartLoad(){const chart=this;let mousedownUnbinder,mousemoveUnbinder,mouseupUnbinder;if(chart.container){mousedownUnbinder=addEvent(chart.container,"mousedown",event=>{const point=chart.hoverPoint;if(point&&point.series&&point.series.hasDraggableNodes&&point.series.options.draggable){point.series.onMouseDown(point,event);mousemoveUnbinder=addEvent(chart.container,"mousemove",e=>point&&point.series&&point.series.onMouseMove(point,e));mouseupUnbinder=addEvent(chart.container.ownerDocument,"mouseup",e=>{mousemoveUnbinder();mouseupUnbinder();return point&&point.series&&point.series.onMouseUp(point,e)})}})}addEvent(chart,"destroy",function(){mousedownUnbinder()})}function onMouseDown(point,event){const normalizedEvent=this.chart.pointer?.normalize(event)||event;point.fixedPosition={chartX:normalizedEvent.chartX,chartY:normalizedEvent.chartY,plotX:point.plotX,plotY:point.plotY};point.inDragMode=true}function onMouseMove(point,event){if(point.fixedPosition&&point.inDragMode){const series=this,chart=series.chart,normalizedEvent=chart.pointer?.normalize(event)||event,diffX=point.fixedPosition.chartX-normalizedEvent.chartX,diffY=point.fixedPosition.chartY-normalizedEvent.chartY,graphLayoutsLookup=chart.graphLayoutsLookup;let newPlotX,newPlotY;if(Math.abs(diffX)>5||Math.abs(diffY)>5){newPlotX=point.fixedPosition.plotX-diffX;newPlotY=point.fixedPosition.plotY-diffY;if(chart.isInsidePlot(newPlotX,newPlotY)){point.plotX=newPlotX;point.plotY=newPlotY;point.hasDragged=true;this.redrawHalo(point);graphLayoutsLookup.forEach(layout=>{layout.restartSimulation()})}}}}function onMouseUp(point){if(point.fixedPosition){if(point.hasDragged){if(this.layout.enableSimulation){this.layout.start()}else{this.chart.redraw()}}point.inDragMode=point.hasDragged=false;if(!this.options.fixedDraggable){delete point.fixedPosition}}}function redrawHalo(point){if(point&&this.halo){this.halo.attr({d:point.haloPath(this.options.states.hover.halo.size)})}}const DragNodesComposition={compose:compose,onMouseDown:onMouseDown,onMouseMove:onMouseMove,onMouseUp:onMouseUp,redrawHalo:redrawHalo};export default DragNodesComposition;