"use strict";import H from"../../Core/Globals.js";const{deg2rad}=H;import U from"../../Core/Utilities.js";const{extend,find,isNumber,isObject,merge}=U;function isRectanglesIntersecting(r1,r2){return!(r2.left>r1.right||r2.right<r1.left||r2.top>r1.bottom||r2.bottom<r1.top)}function getNormals(p1,p2){const dx=p2[0]-p1[0],dy=p2[1]-p1[1];return[[-dy,dx],[dy,-dx]]}function getAxesFromPolygon(polygon){let points,axes=polygon.axes||[];if(!axes.length){axes=[];points=points=polygon.concat([polygon[0]]);points.reduce((p1,p2)=>{const normals=getNormals(p1,p2),axis=normals[0];if(!find(axes,existing=>existing[0]===axis[0]&&existing[1]===axis[1])){axes.push(axis)}return p2});polygon.axes=axes}return axes}function project(polygon,target){const products=polygon.map(point=>{const ax=point[0],ay=point[1],bx=target[0],by=target[1];return ax*bx+ay*by});return{min:Math.min.apply(this,products),max:Math.max.apply(this,products)}}function isPolygonsOverlappingOnAxis(axis,polygon1,polygon2){const projection1=project(polygon1,axis),projection2=project(polygon2,axis),isOverlapping=!(projection2.min>projection1.max||projection2.max<projection1.min);return!isOverlapping}function isPolygonsColliding(polygon1,polygon2){const axes1=getAxesFromPolygon(polygon1),axes2=getAxesFromPolygon(polygon2),axes=axes1.concat(axes2),overlappingOnAllAxes=!find(axes,axis=>isPolygonsOverlappingOnAxis(axis,polygon1,polygon2));return overlappingOnAllAxes}function intersectsAnyWord(point,points){const rect=point.rect,polygon=point.polygon,lastCollidedWith=point.lastCollidedWith,isIntersecting=function(p){let result=isRectanglesIntersecting(rect,p.rect);if(result&&(point.rotation%90||p.rotation%90)){result=isPolygonsColliding(polygon,p.polygon)}return result};let intersects=false;if(lastCollidedWith){intersects=isIntersecting(lastCollidedWith);if(!intersects){delete point.lastCollidedWith}}if(!intersects){intersects=!!find(points,function(p){const result=isIntersecting(p);if(result){point.lastCollidedWith=p}return result})}return intersects}function archimedeanSpiral(attempt,params){const field=params.field,maxDelta=field.width*field.width+field.height*field.height,t=attempt*.8;let result=false;if(attempt<=1e4){result={x:t*Math.cos(t),y:t*Math.sin(t)};if(!(Math.min(Math.abs(result.x),Math.abs(result.y))<maxDelta)){result=false}}return result}function squareSpiral(attempt,params){const a=attempt*4,k=Math.ceil((Math.sqrt(a)-1)/2),isBoolean=x=>typeof x==="boolean";let t=2*k+1,m=Math.pow(t,2),result=false;t-=1;if(attempt<=1e4){if(isBoolean(result)&&a>=m-t){result={x:k-(m-a),y:-k}}m-=t;if(isBoolean(result)&&a>=m-t){result={x:-k,y:-k+(m-a)}}m-=t;if(isBoolean(result)){if(a>=m-t){result={x:-k+(m-a),y:k}}else{result={x:k,y:k-(m-a-t)}}}result.x*=5;result.y*=5}return result}function rectangularSpiral(attempt,params){const result=squareSpiral(attempt,params),field=params.field;if(result){result.x*=field.ratioX;result.y*=field.ratioY}return result}function getRandomPosition(size){return Math.round(size*(Math.random()+.5)/2)}function getScale(targetWidth,targetHeight,field){const height=Math.max(Math.abs(field.top),Math.abs(field.bottom))*2,width=Math.max(Math.abs(field.left),Math.abs(field.right))*2,scaleX=width>0?1/width*targetWidth:1,scaleY=height>0?1/height*targetHeight:1;return Math.min(scaleX,scaleY)}function getPlayingField(targetWidth,targetHeight,data){const info=data.reduce(function(obj,point){const dimensions=point.dimensions,x=Math.max(dimensions.width,dimensions.height);obj.maxHeight=Math.max(obj.maxHeight,dimensions.height);obj.maxWidth=Math.max(obj.maxWidth,dimensions.width);obj.area+=x*x;return obj},{maxHeight:0,maxWidth:0,area:0}),x=Math.max(info.maxHeight,info.maxWidth,Math.sqrt(info.area)*.85),ratioX=targetWidth>targetHeight?targetWidth/targetHeight:1,ratioY=targetHeight>targetWidth?targetHeight/targetWidth:1;return{width:x*ratioX,height:x*ratioY,ratioX:ratioX,ratioY:ratioY}}function getRotation(orientations,index,from,to){let result=false,range,intervals,orientation;if(isNumber(orientations)&&isNumber(index)&&isNumber(from)&&isNumber(to)&&orientations>0&&index>-1&&to>from){range=to-from;intervals=range/(orientations-1||1);orientation=index%orientations;result=from+orientation*intervals}return result}function getSpiral(fn,params){const length=1e4,arr=[];for(let i=1;i<length;i++){arr.push(fn(i,params))}return attempt=>attempt<=length?arr[attempt-1]:false}function outsidePlayingField(rect,field){const playingField={left:-(field.width/2),right:field.width/2,top:-(field.height/2),bottom:field.height/2};return!(playingField.left<rect.left&&playingField.right>rect.right&&playingField.top<rect.top&&playingField.bottom>rect.bottom)}function movePolygon(deltaX,deltaY,polygon){return polygon.map(function(point){return[point[0]+deltaX,point[1]+deltaY]})}function intersectionTesting(point,options){const placed=options.placed,field=options.field,rectangle=options.rectangle,polygon=options.polygon,spiral=options.spiral,rect=point.rect=extend({},rectangle);let attempt=1,delta={x:0,y:0};point.polygon=polygon;point.rotation=options.rotation;while(delta!==false&&(intersectsAnyWord(point,placed)||outsidePlayingField(rect,field))){delta=spiral(attempt);if(isObject(delta)){rect.left=rectangle.left+delta.x;rect.right=rectangle.right+delta.x;rect.top=rectangle.top+delta.y;rect.bottom=rectangle.bottom+delta.y;point.polygon=movePolygon(delta.x,delta.y,polygon)}attempt++}return delta}function extendPlayingField(field,rectangle){let height,width,ratioX,ratioY,x,extendWidth,extendHeight,result;if(isObject(field)&&isObject(rectangle)){height=rectangle.bottom-rectangle.top;width=rectangle.right-rectangle.left;ratioX=field.ratioX;ratioY=field.ratioY;x=width*ratioX>height*ratioY?width:height;extendWidth=x*ratioX;extendHeight=x*ratioY;result=merge(field,{width:field.width+extendWidth*2,height:field.height+extendHeight*2})}else{result=field}return result}function updateFieldBoundaries(field,rectangle){if(!isNumber(field.left)||field.left>rectangle.left){field.left=rectangle.left}if(!isNumber(field.right)||field.right<rectangle.right){field.right=rectangle.right}if(!isNumber(field.top)||field.top>rectangle.top){field.top=rectangle.top}if(!isNumber(field.bottom)||field.bottom<rectangle.bottom){field.bottom=rectangle.bottom}return field}function correctFloat(number,precision){const p=isNumber(precision)?precision:14,magnitude=Math.pow(10,p);return Math.round(number*magnitude)/magnitude}function getBoundingBoxFromPolygon(points){return points.reduce(function(obj,point){const x=point[0],y=point[1];obj.left=Math.min(x,obj.left);obj.right=Math.max(x,obj.right);obj.bottom=Math.max(y,obj.bottom);obj.top=Math.min(y,obj.top);return obj},{left:Number.MAX_VALUE,right:-Number.MAX_VALUE,bottom:-Number.MAX_VALUE,top:Number.MAX_VALUE})}function getPolygon(x,y,width,height,rotation){const origin=[x,y],left=x-width/2,right=x+width/2,top=y-height/2,bottom=y+height/2,polygon=[[left,top],[right,top],[right,bottom],[left,bottom]];return polygon.map(function(point){return rotate2DToPoint(point,origin,-rotation)})}function rotate2DToOrigin(point,angle){const x=point[0],y=point[1],rad=deg2rad*-angle,cosAngle=Math.cos(rad),sinAngle=Math.sin(rad);return[correctFloat(x*cosAngle-y*sinAngle),correctFloat(x*sinAngle+y*cosAngle)]}function rotate2DToPoint(point,origin,angle){const x=point[0]-origin[0],y=point[1]-origin[1],rotated=rotate2DToOrigin([x,y],angle);return[rotated[0]+origin[0],rotated[1]+origin[1]]}const WordcloudUtils={archimedeanSpiral:archimedeanSpiral,extendPlayingField:extendPlayingField,getBoundingBoxFromPolygon:getBoundingBoxFromPolygon,getPlayingField:getPlayingField,getPolygon:getPolygon,getRandomPosition:getRandomPosition,getRotation:getRotation,getScale:getScale,getSpiral:getSpiral,intersectionTesting:intersectionTesting,isPolygonsColliding:isPolygonsColliding,isRectanglesIntersecting:isRectanglesIntersecting,rectangularSpiral:rectangularSpiral,rotate2DToOrigin:rotate2DToOrigin,rotate2DToPoint:rotate2DToPoint,squareSpiral:squareSpiral,updateFieldBoundaries:updateFieldBoundaries};export default WordcloudUtils;