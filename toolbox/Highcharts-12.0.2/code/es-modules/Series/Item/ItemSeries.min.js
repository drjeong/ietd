"use strict";import ItemPoint from"./ItemPoint.js";import ItemSeriesDefaults from"./ItemSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{pie:PieSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{defined,extend,fireEvent,isNumber,merge,pick}=U;class ItemSeries extends PieSeries{animate(init){const group=this.group;if(group){if(init){group.attr({opacity:0})}else{group.animate({opacity:1},this.options.animation)}}}drawDataLabels(){if(this.center&&this.slots){super.drawDataLabels()}else{for(const point of this.points){point.destroyElements({dataLabel:1})}}}drawPoints(){const series=this,options=this.options,renderer=series.chart.renderer,seriesMarkerOptions=options.marker,borderWidth=this.borderWidth,crisp=borderWidth%2?.5:1,rows=this.getRows(),cols=Math.ceil(this.total/rows),cellWidth=this.chart.plotWidth/cols,cellHeight=this.chart.plotHeight/rows,itemSize=this.itemSize||Math.min(cellWidth,cellHeight);let i=0;for(const point of series.points){const pointMarkerOptions=point.marker||{},symbol=pointMarkerOptions.symbol||seriesMarkerOptions.symbol,r=pick(pointMarkerOptions.radius,seriesMarkerOptions.radius),size=defined(r)?2*r:itemSize,padding=size*options.itemPadding;let attr,graphics,pointAttr,x,y,width,height;point.graphics=graphics=point.graphics||[];if(!series.chart.styledMode){pointAttr=series.pointAttribs(point,point.selected&&"select")}if(!point.isNull&&point.visible){if(!point.graphic){point.graphic=renderer.g("point").add(series.group)}for(let val=0;val<(point.y||0);++val){if(series.center&&series.slots){const slot=series.slots.shift();x=slot.x-itemSize/2;y=slot.y-itemSize/2}else if(options.layout==="horizontal"){x=cellWidth*(i%cols);y=cellHeight*Math.floor(i/cols)}else{x=cellWidth*Math.floor(i/rows);y=cellHeight*(i%rows)}x+=padding;y+=padding;width=Math.round(size-2*padding);height=width;if(series.options.crisp){x=Math.round(x)-crisp;y=Math.round(y)+crisp}attr={x:x,y:y,width:width,height:height};if(typeof r!=="undefined"){attr.r=r}if(pointAttr){extend(attr,pointAttr)}let graphic=graphics[val];if(graphic){graphic.animate(attr)}else{graphic=renderer.symbol(symbol,void 0,void 0,void 0,void 0,{backgroundSize:"within"}).attr(attr).add(point.graphic)}graphic.isActive=true;graphics[val]=graphic;++i}}for(let j=0;j<graphics.length;j++){const graphic=graphics[j];if(!graphic){return}if(!graphic.isActive){graphic.destroy();graphics.splice(j,1);j--}else{graphic.isActive=false}}}}getRows(){const chart=this.chart,total=this.total||0;let rows=this.options.rows,cols,ratio;if(!rows){ratio=chart.plotWidth/chart.plotHeight;rows=Math.sqrt(total);if(ratio>1){rows=Math.ceil(rows);while(rows>0){cols=total/rows;if(cols/rows>ratio){break}rows--}}else{rows=Math.floor(rows);while(rows<total){cols=total/rows;if(cols/rows<ratio){break}rows++}}}return rows}getSlots(){const series=this,center=series.center,diameter=center[2],slots=series.slots=series.slots||[],fullAngle=series.endAngleRad-series.startAngleRad,rowsOption=series.options.rows,isCircle=fullAngle%(2*Math.PI)===0,total=series.total||0;let innerSize=center[3],x,y,rowRadius,rowLength,colCount,increment,angle,col,itemSize=0,rowCount,itemCount=Number.MAX_VALUE,finalItemCount,rows,testRows,rowFraction=(diameter-innerSize)/diameter;while(itemCount>total+(rows&&isCircle?rows.length:0)){finalItemCount=itemCount;slots.length=0;itemCount=0;rows=testRows;testRows=[];itemSize++;rowCount=diameter/itemSize/2;if(rowsOption){innerSize=(rowCount-rowsOption)/rowCount*diameter;if(innerSize>=0){rowCount=rowsOption}else{innerSize=0;rowFraction=1}}else{rowCount=Math.floor(rowCount*rowFraction)}for(let row=rowCount;row>0;row--){rowRadius=(innerSize+row/rowCount*(diameter-innerSize-itemSize))/2;rowLength=fullAngle*rowRadius;colCount=Math.ceil(rowLength/itemSize);testRows.push({rowRadius:rowRadius,rowLength:rowLength,colCount:colCount});itemCount+=colCount+1}}if(!rows){return}let overshoot=finalItemCount-series.total-(isCircle?rows.length:0);const cutOffRow=item=>{if(overshoot>0){item.row.colCount--;overshoot--}};while(overshoot>0){rows.map(row=>({angle:row.colCount/row.rowLength,row:row})).sort((a,b)=>b.angle-a.angle).slice(0,Math.min(overshoot,Math.ceil(rows.length/2))).forEach(cutOffRow)}for(const row of rows){const rowRadius=row.rowRadius,colCount=row.colCount;increment=colCount?fullAngle/colCount:0;for(col=0;col<=colCount;col+=1){angle=series.startAngleRad+col*increment;x=center[0]+Math.cos(angle)*rowRadius;y=center[1]+Math.sin(angle)*rowRadius;slots.push({x:x,y:y,angle:angle})}}slots.sort((a,b)=>a.angle-b.angle);series.itemSize=itemSize;return slots}translate(positions){if(this.total===0&&isNumber(this.options.startAngle)&&isNumber(this.options.endAngle)){this.center=this.getCenter()}if(!this.slots){this.slots=[]}if(isNumber(this.options.startAngle)&&isNumber(this.options.endAngle)){super.translate(positions);this.slots=this.getSlots()}else{this.generatePoints();fireEvent(this,"afterTranslate")}}}ItemSeries.defaultOptions=merge(PieSeries.defaultOptions,ItemSeriesDefaults);extend(ItemSeries.prototype,{markerAttribs:void 0,pointClass:ItemPoint});SeriesRegistry.registerSeriesType("item",ItemSeries);export default ItemSeries;