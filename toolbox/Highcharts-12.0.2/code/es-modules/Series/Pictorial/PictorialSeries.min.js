"use strict";import"../Column/ColumnSeries.js";import PatternFill from"../../Extensions/PatternFill.js";import A from"../../Core/Animation/AnimationUtilities.js";import Chart from"../../Core/Chart/Chart.js";import PictorialPoint from"./PictorialPoint.js";import PictorialUtilities from"./PictorialUtilities.js";import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import StackItem from"../../Core/Axis/Stacking/StackItem.js";import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";import U from"../../Core/Utilities.js";const ColumnSeries=SeriesRegistry.seriesTypes.column;PatternFill.compose(Chart,Series,SVGRenderer);const{animObject}=A;const{getStackMetrics,invertShadowGroup,rescalePatternFill}=PictorialUtilities;const{addEvent,defined,merge,objectEach,pick}=U;class PictorialSeries extends ColumnSeries{animate(init){const{chart,group}=this,animation=animObject(this.options.animation),animationClipKey=[this.getSharedClipKey(),animation.duration,animation.easing,animation.defer].join(",");let animationClipRect=chart.sharedClips[animationClipKey];if(init&&group){const clipBox=this.getClipBox();if(!animationClipRect){clipBox.y=clipBox.height;clipBox.height=0;animationClipRect=chart.renderer.clipRect(clipBox);chart.sharedClips[animationClipKey]=animationClipRect}group.clip(animationClipRect)}else if(animationClipRect&&!animationClipRect.hasClass("highcharts-animating")){const finalBox=this.getClipBox();animationClipRect.addClass("highcharts-animating").animate(finalBox,animation)}}animateDrilldown(){}animateDrillupFrom(){}pointAttribs(point){const pointAttribs=super.pointAttribs.apply(this,arguments),seriesOptions=this.options,series=this,paths=seriesOptions.paths;if(point&&point.shapeArgs&&paths){const shape=paths[point.index%paths.length],{y,height}=getStackMetrics(series.yAxis,shape),pathDef=shape.definition;if(pathDef!==point.pathDef){point.pathDef=pathDef;pointAttribs.fill={pattern:{path:{d:pathDef,fill:pointAttribs.fill,strokeWidth:pointAttribs["stroke-width"],stroke:pointAttribs.stroke},x:point.shapeArgs.x,y:y,width:point.shapeArgs.width||0,height:height,patternContentUnits:"objectBoundingBox",backgroundColor:"none",color:"#ff0000"}}}else if(point.pathDef&&point.graphic){delete pointAttribs.fill}}delete pointAttribs.stroke;delete pointAttribs.strokeWidth;return pointAttribs}getExtremes(){const extremes=super.getExtremes.apply(this,arguments),series=this,paths=series.options.paths;if(paths){paths.forEach(function(path){if(defined(path.max)&&defined(extremes.dataMax)&&path.max>extremes.dataMax){extremes.dataMax=path.max}})}return extremes}}PictorialSeries.defaultOptions=merge(ColumnSeries.defaultOptions,{borderWidth:0});addEvent(PictorialSeries,"afterRender",function(){const series=this,paths=series.options.paths,fillUrlMatcher=/url\(([^)]+)\)/;series.points.forEach(function(point){if(point.graphic&&point.shapeArgs&&paths){const shape=paths[point.index%paths.length],fill=point.graphic.attr("fill"),match=fill&&fill.match(fillUrlMatcher),{y,height}=getStackMetrics(series.yAxis,shape);if(match&&series.chart.renderer.patternElements){const currentPattern=series.chart.renderer.patternElements[match[1].slice(1)];if(currentPattern){currentPattern.animate({x:point.shapeArgs.x,y:y,width:point.shapeArgs.width||0,height:height})}}rescalePatternFill(point.graphic,getStackMetrics(series.yAxis,shape).height,point.shapeArgs.width||0,point.shapeArgs.height||Infinity,series.options.borderWidth||0)}})});function renderStackShadow(stack){const stackKeys=Object.keys(stack.points).filter(p=>p.split(",").length>1),allSeries=stack.axis.chart.series,seriesIndexes=stackKeys.map(key=>parseFloat(key.split(",")[0]));let seriesIndex=-1;seriesIndexes.forEach(index=>{if(allSeries[index]&&allSeries[index].visible){seriesIndex=index}});const series=stack.axis.chart.series[seriesIndex];if(series&&series.is("pictorial")&&stack.axis.hasData()&&series.xAxis.hasData()){const xAxis=series.xAxis,options=stack.axis.options,chart=stack.axis.chart,stackShadow=stack.shadow,xCenter=xAxis.toPixels(stack.x,true),x=chart.inverted?xAxis.len-xCenter:xCenter,paths=series.options.paths||[],index=stack.x%paths.length,shape=paths[index],width=series.getColumnMetrics&&series.getColumnMetrics().width,{height,y}=getStackMetrics(series.yAxis,shape),shadowOptions=options.stackShadow,strokeWidth=pick(shadowOptions&&shadowOptions.borderWidth,series.options.borderWidth,1);if(!stackShadow&&shadowOptions&&shadowOptions.enabled&&shape){if(!stack.shadowGroup){stack.shadowGroup=chart.renderer.g("shadow-group").add()}stack.shadowGroup.attr({translateX:chart.inverted?stack.axis.pos:xAxis.pos,translateY:chart.inverted?xAxis.pos:stack.axis.pos});stack.shadow=chart.renderer.rect(x,y,width,height).attr({fill:{pattern:{path:{d:shape.definition,fill:shadowOptions.color||"#dedede",strokeWidth:strokeWidth,stroke:shadowOptions.borderColor||"transparent"},x:x,y:y,width:width,height:height,patternContentUnits:"objectBoundingBox",backgroundColor:"none",color:"#dedede"}}}).add(stack.shadowGroup);invertShadowGroup(stack.shadowGroup,stack.axis);rescalePatternFill(stack.shadow,height,width,height,strokeWidth);stack.setOffset(series.pointXOffset||0,series.barW||0)}else if(stackShadow&&stack.shadowGroup){stackShadow.animate({x:x,y:y,width:width,height:height});const fillUrlMatcher=/url\(([^)]+)\)/,fill=stackShadow.attr("fill"),match=fill&&fill.match(fillUrlMatcher);if(match&&chart.renderer.patternElements){chart.renderer.patternElements[match[1].slice(1)].animate({x:x,y:y,width:width,height:height})}stack.shadowGroup.animate({translateX:chart.inverted?stack.axis.pos:xAxis.pos,translateY:chart.inverted?xAxis.pos:stack.axis.pos});invertShadowGroup(stack.shadowGroup,stack.axis);rescalePatternFill(stackShadow,height,width,height,strokeWidth);stack.setOffset(series.pointXOffset||0,series.barW||0)}}else if(stack.shadow&&stack.shadowGroup){stack.shadow.destroy();stack.shadow=void 0;stack.shadowGroup.destroy();stack.shadowGroup=void 0}}function forEachStack(chart,callback){if(chart.axes){chart.axes.forEach(function(axis){if(!axis.stacking){return}const stacks=axis.stacking.stacks;objectEach(stacks,function(type){objectEach(type,function(stack){callback(stack)})})})}}addEvent(Chart,"render",function(){forEachStack(this,renderStackShadow)});addEvent(StackItem,"afterSetOffset",function(e){if(this.shadow){const{chart,len}=this.axis,{xOffset,width}=e,translateX=chart.inverted?xOffset-chart.xAxis[0].len:xOffset,translateY=chart.inverted?-len:0;this.shadow.attr({translateX:translateX,translateY:translateY});this.shadow.animate({width:width})}});function destroyAllStackShadows(chart){forEachStack(chart,function(stack){if(stack.shadow&&stack.shadowGroup){stack.shadow.destroy();stack.shadowGroup.destroy();delete stack.shadow;delete stack.shadowGroup}})}addEvent(Chart,"afterDrilldown",function(){destroyAllStackShadows(this)});addEvent(Chart,"afterDrillUp",function(){destroyAllStackShadows(this)});PictorialSeries.prototype.pointClass=PictorialPoint;SeriesRegistry.registerSeriesType("pictorial",PictorialSeries);export default PictorialSeries;"";