"use strict";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,line:LineSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,correctFloat,crisp,extend,isNumber,merge,objectEach,pick}=U;import WaterfallAxis from"../../Core/Axis/WaterfallAxis.js";import WaterfallPoint from"./WaterfallPoint.js";import WaterfallSeriesDefaults from"./WaterfallSeriesDefaults.js";function ownProp(obj,key){return Object.hasOwnProperty.call(obj,key)}class WaterfallSeries extends ColumnSeries{generatePoints(){ColumnSeries.prototype.generatePoints.apply(this);const processedYData=this.getColumn("y",true);for(let i=0,len=this.points.length;i<len;i++){const point=this.points[i],y=processedYData[i];if(isNumber(y)&&(point.isIntermediateSum||point.isSum)){point.y=correctFloat(y)}}}processData(force){const series=this,options=series.options,yData=series.getColumn("y"),points=options.data,dataLength=yData.length,threshold=options.threshold||0;let point,subSum,sum,dataMin,dataMax,y;sum=subSum=dataMin=dataMax=0;for(let i=0;i<dataLength;i++){y=yData[i];point=points?.[i]||{};if(y==="sum"||point.isSum){yData[i]=correctFloat(sum)}else if(y==="intermediateSum"||point.isIntermediateSum){yData[i]=correctFloat(subSum);subSum=0}else{sum+=y;subSum+=y}dataMin=Math.min(sum,dataMin);dataMax=Math.max(sum,dataMax)}super.processData.call(this,force);if(!options.stacking){series.dataMin=dataMin+threshold;series.dataMax=dataMax}return}toYData(pt){if(pt.isSum){return"sum"}if(pt.isIntermediateSum){return"intermediateSum"}return pt.y}pointAttribs(point,state){const upColor=this.options.upColor;if(upColor&&!point.options.color&&isNumber(point.y)){point.color=point.y>0?upColor:void 0}const attr=ColumnSeries.prototype.pointAttribs.call(this,point,state);delete attr.dashstyle;return attr}getGraphPath(){return[["M",0,0]]}getCrispPath(){const data=this.data.filter(d=>isNumber(d.y)),yAxis=this.yAxis,length=data.length,graphLineWidth=this.graph?.strokeWidth()||0,reversedXAxis=this.xAxis.reversed,reversedYAxis=this.yAxis.reversed,stacking=this.options.stacking,path=[];for(let i=1;i<length;i++){if(!(this.options.connectNulls||isNumber(this.data[data[i].index-1].y))){continue}const box=data[i].box,prevPoint=data[i-1],prevY=prevPoint.y||0,prevBox=data[i-1].box;if(!box||!prevBox){continue}const prevStack=yAxis.waterfall.stacks[this.stackKey],isPos=prevY>0?-prevBox.height:0;if(prevStack&&prevBox&&box){const prevStackX=prevStack[i-1];let yPos;if(stacking){const connectorThreshold=prevStackX.connectorThreshold;yPos=crisp(yAxis.translate(connectorThreshold,false,true,false,true)+(reversedYAxis?isPos:0),graphLineWidth)}else{yPos=crisp(prevBox.y+(prevPoint.minPointLengthOffset||0),graphLineWidth)}path.push(["M",(prevBox.x||0)+(reversedXAxis?0:prevBox.width||0),yPos],["L",(box.x||0)+(reversedXAxis?box.width||0:0),yPos])}if(prevBox&&path.length&&(!stacking&&prevY<0&&!reversedYAxis||prevY>0&&reversedYAxis)){const nextLast=path[path.length-2];if(nextLast&&typeof nextLast[2]==="number"){nextLast[2]+=prevBox.height||0}const last=path[path.length-1];if(last&&typeof last[2]==="number"){last[2]+=prevBox.height||0}}}return path}drawGraph(){LineSeries.prototype.drawGraph.call(this);if(this.graph){this.graph.attr({d:this.getCrispPath()})}}setStackedPoints(axis){const series=this,options=series.options,waterfallStacks=axis.waterfall?.stacks,seriesThreshold=options.threshold||0,stackKey=series.stackKey,xData=series.getColumn("x"),yData=series.getColumn("y"),xLength=xData.length;let stackThreshold=seriesThreshold,interSum=stackThreshold,actualStackX,totalYVal=0,actualSum=0,prevSum=0,statesLen,posTotal,negTotal,xPoint,yVal,x,alreadyChanged,changed;const calculateStackState=(firstS,nextS,sInx,sOff)=>{if(actualStackX){if(!statesLen){actualStackX.stackState[0]=firstS;statesLen=actualStackX.stackState.length}else{for(sInx;sInx<statesLen;sInx++){actualStackX.stackState[sInx]+=sOff}}actualStackX.stackState.push(actualStackX.stackState[statesLen-1]+nextS)}};if(axis.stacking&&waterfallStacks){if(series.reserveSpace()){changed=waterfallStacks.changed;alreadyChanged=waterfallStacks.alreadyChanged;if(alreadyChanged&&alreadyChanged.indexOf(stackKey)<0){changed=true}if(!waterfallStacks[stackKey]){waterfallStacks[stackKey]={}}const actualStack=waterfallStacks[stackKey];if(actualStack){for(let i=0;i<xLength;i++){x=xData[i];if(!actualStack[x]||changed){actualStack[x]={negTotal:0,posTotal:0,stackTotal:0,threshold:0,stateIndex:0,stackState:[],label:changed&&actualStack[x]?actualStack[x].label:void 0}}actualStackX=actualStack[x];yVal=yData[i];if(yVal>=0){actualStackX.posTotal+=yVal}else{actualStackX.negTotal+=yVal}xPoint=options.data[i];posTotal=actualStackX.absolutePos=actualStackX.posTotal;negTotal=actualStackX.absoluteNeg=actualStackX.negTotal;actualStackX.stackTotal=posTotal+negTotal;statesLen=actualStackX.stackState.length;if(xPoint&&xPoint.isIntermediateSum){calculateStackState(prevSum,actualSum,0,prevSum);prevSum=actualSum;actualSum=seriesThreshold;stackThreshold^=interSum;interSum^=stackThreshold;stackThreshold^=interSum}else if(xPoint&&xPoint.isSum){calculateStackState(seriesThreshold,totalYVal,statesLen,0);stackThreshold=seriesThreshold}else{calculateStackState(stackThreshold,yVal,0,totalYVal);if(xPoint){totalYVal+=yVal;actualSum+=yVal}}actualStackX.stateIndex++;actualStackX.threshold=stackThreshold;stackThreshold+=actualStackX.stackTotal}}waterfallStacks.changed=false;if(!waterfallStacks.alreadyChanged){waterfallStacks.alreadyChanged=[]}waterfallStacks.alreadyChanged.push(stackKey)}}}getExtremes(){const stacking=this.options.stacking;let yAxis,waterfallStacks,stackedYNeg,stackedYPos;if(stacking){yAxis=this.yAxis;waterfallStacks=yAxis.waterfall.stacks;stackedYNeg=this.stackedYNeg=[];stackedYPos=this.stackedYPos=[];if(stacking==="overlap"){objectEach(waterfallStacks[this.stackKey],function(stackX){stackedYNeg.push(arrayMin(stackX.stackState));stackedYPos.push(arrayMax(stackX.stackState))})}else{objectEach(waterfallStacks[this.stackKey],function(stackX){stackedYNeg.push(stackX.negTotal+stackX.threshold);stackedYPos.push(stackX.posTotal+stackX.threshold)})}return{dataMin:arrayMin(stackedYNeg),dataMax:arrayMax(stackedYPos)}}return{dataMin:this.dataMin,dataMax:this.dataMax}}}WaterfallSeries.defaultOptions=merge(ColumnSeries.defaultOptions,WaterfallSeriesDefaults);WaterfallSeries.compose=WaterfallAxis.compose;extend(WaterfallSeries.prototype,{pointValKey:"y",showLine:true,pointClass:WaterfallPoint});addEvent(WaterfallSeries,"afterColumnTranslate",function(){const series=this,{options,points,yAxis}=series,minPointLength=pick(options.minPointLength,5),halfMinPointLength=minPointLength/2,threshold=options.threshold||0,stacking=options.stacking,actualStack=yAxis.waterfall.stacks[series.stackKey],processedYData=series.getColumn("y",true);let previousIntermediate=threshold,previousY=threshold,y,total,yPos,hPos;for(let i=0;i<points.length;i++){const point=points[i],yValue=processedYData[i],shapeArgs=point.shapeArgs,box=extend({x:0,y:0,width:0,height:0},shapeArgs||{});point.box=box;const range=[0,yValue],pointY=point.y||0;if(stacking){if(actualStack){const actualStackX=actualStack[i];if(stacking==="overlap"){total=actualStackX.stackState[actualStackX.stateIndex--];y=pointY>=0?total:total-pointY;if(ownProp(actualStackX,"absolutePos")){delete actualStackX.absolutePos}if(ownProp(actualStackX,"absoluteNeg")){delete actualStackX.absoluteNeg}}else{if(pointY>=0){total=actualStackX.threshold+actualStackX.posTotal;actualStackX.posTotal-=pointY;y=total}else{total=actualStackX.threshold+actualStackX.negTotal;actualStackX.negTotal-=pointY;y=total-pointY}if(!actualStackX.posTotal){if(isNumber(actualStackX.absolutePos)&&ownProp(actualStackX,"absolutePos")){actualStackX.posTotal=actualStackX.absolutePos;delete actualStackX.absolutePos}}if(!actualStackX.negTotal){if(isNumber(actualStackX.absoluteNeg)&&ownProp(actualStackX,"absoluteNeg")){actualStackX.negTotal=actualStackX.absoluteNeg;delete actualStackX.absoluteNeg}}}if(!point.isSum){actualStackX.connectorThreshold=actualStackX.threshold+actualStackX.stackTotal}if(yAxis.reversed){yPos=pointY>=0?y-pointY:y+pointY;hPos=y}else{yPos=y;hPos=y-pointY}point.below=yPos<=threshold;box.y=yAxis.translate(yPos,false,true,false,true);box.height=Math.abs(box.y-yAxis.translate(hPos,false,true,false,true));const dummyStackItem=yAxis.waterfall.dummyStackItem;if(dummyStackItem){dummyStackItem.x=i;dummyStackItem.label=actualStack[i].label;dummyStackItem.setOffset(series.pointXOffset||0,series.barW||0,series.stackedYNeg[i],series.stackedYPos[i],void 0,this.xAxis)}}}else{y=Math.max(previousY,previousY+pointY)+range[0];box.y=yAxis.translate(y,false,true,false,true);if(point.isSum){box.y=yAxis.translate(range[1],false,true,false,true);box.height=Math.min(yAxis.translate(range[0],false,true,false,true),yAxis.len)-box.y;point.below=range[1]<=threshold}else if(point.isIntermediateSum){if(pointY>=0){yPos=range[1]+previousIntermediate;hPos=previousIntermediate}else{yPos=previousIntermediate;hPos=range[1]+previousIntermediate}if(yAxis.reversed){yPos^=hPos;hPos^=yPos;yPos^=hPos}box.y=yAxis.translate(yPos,false,true,false,true);box.height=Math.abs(box.y-Math.min(yAxis.translate(hPos,false,true,false,true),yAxis.len));previousIntermediate+=range[1];point.below=yPos<=threshold}else{box.height=yValue>0?yAxis.translate(previousY,false,true,false,true)-box.y:yAxis.translate(previousY,false,true,false,true)-yAxis.translate(previousY-yValue,false,true,false,true);previousY+=yValue;point.below=previousY<threshold}if(box.height<0){box.y+=box.height;box.height*=-1}}point.plotY=box.y;point.yBottom=box.y+box.height;if(box.height<=minPointLength&&!point.isNull){box.height=minPointLength;box.y-=halfMinPointLength;point.yBottom=box.y+box.height;point.plotY=box.y;if(pointY<0){point.minPointLengthOffset=-halfMinPointLength}else{point.minPointLengthOffset=halfMinPointLength}}else{if(point.isNull){box.width=0}point.minPointLengthOffset=0}const tooltipY=point.plotY+(point.negative?box.height:0);if(point.below){point.plotY+=box.height}if(point.tooltipPos){if(series.chart.inverted){point.tooltipPos[0]=yAxis.len-tooltipY}else{point.tooltipPos[1]=tooltipY}}point.isInside=this.isPointInside(point);const crispBottom=crisp(point.yBottom,series.borderWidth);box.y=crisp(box.y,series.borderWidth);box.height=crispBottom-box.y;merge(true,point.shapeArgs,box)}},{order:2});SeriesRegistry.registerSeriesType("waterfall",WaterfallSeries);export default WaterfallSeries;