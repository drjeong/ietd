"use strict";import H from"../../Core/Globals.js";const{composed,deg2rad}=H;import Pie3DPoint from"./Pie3DPoint.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{pie:PieSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{extend,pick,pushUnique}=U;class Pie3DSeries extends PieSeries{static compose(SeriesClass){if(pushUnique(composed,"Pie3D")){SeriesClass.types.pie=Pie3DSeries}}addPoint(){super.addPoint.apply(this,arguments);if(this.chart.is3d()){this.update(this.userOptions,true)}}animate(init){if(!this.chart.is3d()){super.animate.apply(this,arguments)}else{const center=this.center,group=this.group,markerGroup=this.markerGroup;let animation=this.options.animation,attribs;if(animation===true){animation={}}if(init){group.oldtranslateX=pick(group.oldtranslateX,group.translateX);group.oldtranslateY=pick(group.oldtranslateY,group.translateY);attribs={translateX:center[0],translateY:center[1],scaleX:.001,scaleY:.001};group.attr(attribs);if(markerGroup){markerGroup.attrSetters=group.attrSetters;markerGroup.attr(attribs)}}else{attribs={translateX:group.oldtranslateX,translateY:group.oldtranslateY,scaleX:1,scaleY:1};group.animate(attribs,animation);if(markerGroup){markerGroup.animate(attribs,animation)}}}}getDataLabelPosition(point,distance){const labelPosition=super.getDataLabelPosition(point,distance);if(this.chart.is3d()){const options3d=this.chart.options.chart.options3d,shapeArgs=point.shapeArgs,r=shapeArgs.r,a1=(shapeArgs.alpha||options3d?.alpha)*deg2rad,b1=(shapeArgs.beta||options3d?.beta)*deg2rad,a2=(shapeArgs.start+shapeArgs.end)/2,connectorPosition=labelPosition.connectorPosition,yOffset=-r*(1-Math.cos(a1))*Math.sin(a2),xOffset=r*(Math.cos(b1)-1)*Math.cos(a2);for(const coordinates of[labelPosition?.natural,connectorPosition.breakAt,connectorPosition.touchingSliceAt]){coordinates.x+=xOffset;coordinates.y+=yOffset}}return labelPosition}pointAttribs(point){const attr=super.pointAttribs.apply(this,arguments),options=this.options;if(this.chart.is3d()&&!this.chart.styledMode){attr.stroke=options.edgeColor||point.color||this.color;attr["stroke-width"]=pick(options.edgeWidth,1)}return attr}translate(){super.translate.apply(this,arguments);if(!this.chart.is3d()){return}const series=this,seriesOptions=series.options,depth=seriesOptions.depth||0,options3d=series.chart.options.chart.options3d,alpha=options3d.alpha,beta=options3d.beta;let z=seriesOptions.stacking?(seriesOptions.stack||0)*depth:series._i*depth;z+=depth/2;if(seriesOptions.grouping!==false){z=0}for(const point of series.points){const shapeArgs=point.shapeArgs;point.shapeType="arc3d";shapeArgs.z=z;shapeArgs.depth=depth*.75;shapeArgs.alpha=alpha;shapeArgs.beta=beta;shapeArgs.center=series.center;const angle=(shapeArgs.end+shapeArgs.start)/2;point.slicedTranslation={translateX:Math.round(Math.cos(angle)*seriesOptions.slicedOffset*Math.cos(alpha*deg2rad)),translateY:Math.round(Math.sin(angle)*seriesOptions.slicedOffset*Math.cos(alpha*deg2rad))}}}drawTracker(){super.drawTracker.apply(this,arguments);if(!this.chart.is3d()){return}for(const point of this.points){if(point.graphic){for(const face of["out","inn","side1","side2"]){if(point.graphic){point.graphic[face].element.point=point}}}}}}extend(Pie3DSeries.prototype,{pointClass:Pie3DPoint});export default Pie3DSeries;"";