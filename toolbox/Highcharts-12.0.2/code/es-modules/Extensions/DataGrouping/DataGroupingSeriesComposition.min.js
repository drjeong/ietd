"use strict";import ApproximationRegistry from"./ApproximationRegistry.js";import DataGroupingDefaults from"./DataGroupingDefaults.js";import DataTableCore from"../../Data/DataTableCore.js";import DateTimeAxis from"../../Core/Axis/DateTimeAxis.js";import D from"../../Core/Defaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{addEvent,defined,error,extend,isNumber,merge,pick,splat}=U;const baseGeneratePoints=seriesProto.generatePoints;function adjustExtremes(xAxis,groupedXData){if(defined(groupedXData[0])&&isNumber(xAxis.min)&&isNumber(xAxis.dataMin)&&groupedXData[0]<xAxis.min){if(!defined(xAxis.options.min)&&xAxis.min<=xAxis.dataMin||xAxis.min===xAxis.dataMin){xAxis.min=Math.min(groupedXData[0],xAxis.min)}xAxis.dataMin=Math.min(groupedXData[0],xAxis.dataMin)}if(defined(groupedXData[groupedXData.length-1])&&isNumber(xAxis.max)&&isNumber(xAxis.dataMax)&&groupedXData[groupedXData.length-1]>xAxis.max){if(!defined(xAxis.options.max)&&isNumber(xAxis.dataMax)&&xAxis.max>=xAxis.dataMax||xAxis.max===xAxis.dataMax){xAxis.max=Math.max(groupedXData[groupedXData.length-1],xAxis.max)}xAxis.dataMax=Math.max(groupedXData[groupedXData.length-1],xAxis.dataMax)}}function anchorPoints(series,groupedXData,xMax){const options=series.options,dataGroupingOptions=options.dataGrouping,totalRange=series.currentDataGrouping&&series.currentDataGrouping.gapSize,xData=series.getColumn("x");if(!(dataGroupingOptions&&xData.length&&totalRange&&series.groupMap)){return}const groupedDataLastIndex=groupedXData.length-1,anchor=dataGroupingOptions.anchor,firstAnchor=dataGroupingOptions.firstAnchor,lastAnchor=dataGroupingOptions.lastAnchor;let anchorIndexIterator=groupedXData.length-1,anchorFirstIndex=0;if(firstAnchor&&xData[0]>=groupedXData[0]){anchorFirstIndex++;const groupStart=series.groupMap[0].start,groupLength=series.groupMap[0].length;let firstGroupEnd;if(isNumber(groupStart)&&isNumber(groupLength)){firstGroupEnd=groupStart+(groupLength-1)}groupedXData[0]={start:groupedXData[0],middle:groupedXData[0]+.5*totalRange,end:groupedXData[0]+totalRange,firstPoint:xData[0],lastPoint:firstGroupEnd&&xData[firstGroupEnd]}[firstAnchor]}if(groupedDataLastIndex>0&&lastAnchor&&totalRange&&groupedXData[groupedDataLastIndex]>=xMax-totalRange){anchorIndexIterator--;const lastGroupStart=series.groupMap[series.groupMap.length-1].start;groupedXData[groupedDataLastIndex]={start:groupedXData[groupedDataLastIndex],middle:groupedXData[groupedDataLastIndex]+.5*totalRange,end:groupedXData[groupedDataLastIndex]+totalRange,firstPoint:lastGroupStart&&xData[lastGroupStart],lastPoint:xData[xData.length-1]}[lastAnchor]}if(anchor&&anchor!=="start"){const shiftInterval=totalRange*{middle:.5,end:1}[anchor];while(anchorIndexIterator>=anchorFirstIndex){groupedXData[anchorIndexIterator]+=shiftInterval;anchorIndexIterator--}}}function applyGrouping(hasExtremesChanged){const series=this,chart=series.chart,options=series.options,dataGroupingOptions=options.dataGrouping,groupingEnabled=series.allowDG!==false&&dataGroupingOptions&&pick(dataGroupingOptions.enabled,chart.options.isStock),reserveSpace=series.reserveSpace(),lastDataGrouping=this.currentDataGrouping;let currentDataGrouping,croppedData,revertRequireSorting=false;if(groupingEnabled&&!series.requireSorting){series.requireSorting=revertRequireSorting=true}const skip=skipDataGrouping(series,hasExtremesChanged)===false||!groupingEnabled;if(revertRequireSorting){series.requireSorting=false}if(skip){return}series.destroyGroupedData();const table=dataGroupingOptions.groupAll?series.dataTable:series.dataTable.modified||series.dataTable,processedXData=series.getColumn("x",!dataGroupingOptions.groupAll),xData=processedXData,plotSizeX=chart.plotSizeX,xAxis=series.xAxis,extremes=xAxis.getExtremes(),ordinal=xAxis.options.ordinal,groupPixelWidth=series.groupPixelWidth;let i,hasGroupedData;if(groupPixelWidth&&xData&&table.rowCount&&plotSizeX&&isNumber(extremes.min)){hasGroupedData=true;series.isDirty=true;series.points=null;const xMin=extremes.min,xMax=extremes.max,groupIntervalFactor=ordinal&&xAxis.ordinal&&xAxis.ordinal.getGroupIntervalFactor(xMin,xMax,series)||1,interval=groupPixelWidth*(xMax-xMin)/plotSizeX*groupIntervalFactor,groupPositions=xAxis.getTimeTicks(DateTimeAxis.Additions.prototype.normalizeTimeTickInterval(interval,dataGroupingOptions.units||DataGroupingDefaults.units),Math.min(xMin,xData[0]),Math.max(xMax,xData[xData.length-1]),xAxis.options.startOfWeek,processedXData,series.closestPointRange),groupedData=seriesProto.groupData.apply(series,[table,groupPositions,dataGroupingOptions.approximation]);let modified=groupedData.modified,groupedXData=modified.getColumn("x",true),gapSize=0;if(dataGroupingOptions?.smoothed&&modified.rowCount){dataGroupingOptions.firstAnchor="firstPoint";dataGroupingOptions.anchor="middle";dataGroupingOptions.lastAnchor="lastPoint";error(32,false,chart,{"dataGrouping.smoothed":"use dataGrouping.anchor"})}for(i=1;i<groupPositions.length;i++){if(!groupPositions.info.segmentStarts||groupPositions.info.segmentStarts.indexOf(i)===-1){gapSize=Math.max(groupPositions[i]-groupPositions[i-1],gapSize)}}currentDataGrouping=groupPositions.info;currentDataGrouping.gapSize=gapSize;series.closestPointRange=groupPositions.info.totalRange;series.groupMap=groupedData.groupMap;series.currentDataGrouping=currentDataGrouping;anchorPoints(series,groupedXData||[],xMax);if(reserveSpace&&groupedXData){adjustExtremes(xAxis,groupedXData)}if(dataGroupingOptions.groupAll){series.allGroupedTable=modified;croppedData=series.cropData(modified,xAxis.min||0,xAxis.max||0);modified=croppedData.modified;groupedXData=modified.getColumn("x");series.cropStart=croppedData.start}series.dataTable.modified=modified}else{series.groupMap=void 0;series.currentDataGrouping=void 0}series.hasGroupedData=hasGroupedData;series.preventGraphAnimation=(lastDataGrouping&&lastDataGrouping.totalRange)!==(currentDataGrouping&&currentDataGrouping.totalRange)}function compose(SeriesClass){const seriesProto=SeriesClass.prototype;if(!seriesProto.applyGrouping){const PointClass=SeriesClass.prototype.pointClass;addEvent(PointClass,"update",function(){if(this.dataGroup){error(24,false,this.series.chart);return false}});addEvent(SeriesClass,"afterSetOptions",onAfterSetOptions);addEvent(SeriesClass,"destroy",destroyGroupedData);extend(seriesProto,{applyGrouping:applyGrouping,destroyGroupedData:destroyGroupedData,generatePoints:generatePoints,getDGApproximation:getDGApproximation,groupData:groupData})}}function destroyGroupedData(){if(this.groupedData){this.groupedData.forEach(function(point,i){if(point){this.groupedData[i]=point.destroy?point.destroy():null}},this);this.groupedData.length=0;delete this.allGroupedTable}}function generatePoints(){baseGeneratePoints.apply(this);this.destroyGroupedData();this.groupedData=this.hasGroupedData?this.points:null}function getDGApproximation(){if(this.is("arearange")){return"range"}if(this.is("ohlc")){return"ohlc"}if(this.is("hlc")){return"hlc"}if(this.is("column")||this.options.cumulative){return"sum"}return"average"}function groupData(table,groupPositions,approximation){const xData=table.getColumn("x",true)||[],yData=table.getColumn("y",true),series=this,data=series.data,dataOptions=series.options&&series.options.data,groupedXData=[],modified=new DataTableCore,groupMap=[],dataLength=table.rowCount,handleYData=!!yData,values=[],pointArrayMap=series.pointArrayMap,pointArrayMapLength=pointArrayMap&&pointArrayMap.length,extendedPointArrayMap=["x"].concat(pointArrayMap||["y"]),valueColumns=(pointArrayMap||["y"]).map(()=>[]),groupAll=this.options.dataGrouping&&this.options.dataGrouping.groupAll;let pointX,pointY,groupedY,pos=0,start=0;const approximationFn=typeof approximation==="function"?approximation:approximation&&ApproximationRegistry[approximation]?ApproximationRegistry[approximation]:ApproximationRegistry[series.getDGApproximation&&series.getDGApproximation()||"average"];if(pointArrayMapLength){let len=pointArrayMap.length;while(len--){values.push([])}}else{values.push([])}const valuesLen=pointArrayMapLength||1;for(let i=0;i<=dataLength;i++){if(xData[i]<groupPositions[0]){continue}while(typeof groupPositions[pos+1]!=="undefined"&&xData[i]>=groupPositions[pos+1]||i===dataLength){pointX=groupPositions[pos];series.dataGroupInfo={start:groupAll?start:series.cropStart+start,length:values[0].length,groupStart:pointX};groupedY=approximationFn.apply(series,values);if(series.pointClass&&!defined(series.dataGroupInfo.options)){series.dataGroupInfo.options=merge(series.pointClass.prototype.optionsToObject.call({series:series},series.options.data[series.cropStart+start]));extendedPointArrayMap.forEach(function(key){delete series.dataGroupInfo.options[key]})}if(typeof groupedY!=="undefined"){groupedXData.push(pointX);const groupedValuesArr=splat(groupedY);for(let j=0;j<groupedValuesArr.length;j++){valueColumns[j].push(groupedValuesArr[j])}groupMap.push(series.dataGroupInfo)}start=i;for(let j=0;j<valuesLen;j++){values[j].length=0;values[j].hasNulls=false}pos+=1;if(i===dataLength){break}}if(i===dataLength){break}if(pointArrayMap){const index=groupAll?i:series.cropStart+i,point=data&&data[index]||series.pointClass.prototype.applyOptions.apply({series:series},[dataOptions[index]]);let val;for(let j=0;j<pointArrayMapLength;j++){val=point[pointArrayMap[j]];if(isNumber(val)){values[j].push(val)}else if(val===null){values[j].hasNulls=true}}}else{pointY=handleYData?yData[i]:null;if(isNumber(pointY)){values[0].push(pointY)}else if(pointY===null){values[0].hasNulls=true}}}const columns={x:groupedXData};(pointArrayMap||["y"]).forEach((key,i)=>{columns[key]=valueColumns[i]});modified.setColumns(columns);return{groupMap:groupMap,modified:modified}}function onAfterSetOptions(e){const options=e.options,type=this.type,plotOptions=this.chart.options.plotOptions,baseOptions=this.useCommonDataGrouping&&DataGroupingDefaults.common,seriesSpecific=DataGroupingDefaults.seriesSpecific;let defaultOptions=D.defaultOptions.plotOptions[type].dataGrouping;if(plotOptions&&(seriesSpecific[type]||baseOptions)){const rangeSelector=this.chart.rangeSelector;if(!defaultOptions){defaultOptions=merge(DataGroupingDefaults.common,seriesSpecific[type])}options.dataGrouping=merge(baseOptions,defaultOptions,plotOptions.series&&plotOptions.series.dataGrouping,plotOptions[type].dataGrouping,this.userOptions.dataGrouping,!options.isInternal&&rangeSelector&&isNumber(rangeSelector.selected)&&rangeSelector.buttonOptions[rangeSelector.selected].dataGrouping)}}function skipDataGrouping(series,force){return!(series.isCartesian&&!series.isDirty&&!series.xAxis.isDirty&&!series.yAxis.isDirty&&!force)}const DataGroupingSeriesComposition={compose:compose,groupData:groupData};export default DataGroupingSeriesComposition;