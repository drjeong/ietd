"use strict";import AxisResizerDefaults from"./AxisResizerDefaults.js";import U from"../../Core/Utilities.js";const{addEvent,clamp,isNumber,relativeLength}=U;class AxisResizer{constructor(axis){this.init(axis)}init(axis,update){this.axis=axis;this.options=axis.options.resize||{};this.render();if(!update){this.addMouseEvents()}}render(){const resizer=this,axis=resizer.axis,chart=axis.chart,options=resizer.options,x=options.x||0,y=options.y,pos=clamp(axis.top+axis.height+y,chart.plotTop,chart.plotTop+chart.plotHeight);let attr={};if(!chart.styledMode){attr={cursor:options.cursor,stroke:options.lineColor,"stroke-width":options.lineWidth,dashstyle:options.lineDashStyle}}resizer.lastPos=pos-y;if(!resizer.controlLine){resizer.controlLine=chart.renderer.path().addClass("highcharts-axis-resizer")}resizer.controlLine.add(axis.axisGroup);const lineWidth=chart.styledMode?resizer.controlLine.strokeWidth():options.lineWidth;attr.d=chart.renderer.crispLine([["M",axis.left+x,pos],["L",axis.left+axis.width+x,pos]],lineWidth);resizer.controlLine.attr(attr)}addMouseEvents(){const resizer=this,ctrlLineElem=resizer.controlLine.element,container=resizer.axis.chart.container,eventsToUnbind=[];let mouseMoveHandler,mouseUpHandler,mouseDownHandler;resizer.mouseMoveHandler=mouseMoveHandler=e=>resizer.onMouseMove(e);resizer.mouseUpHandler=mouseUpHandler=e=>resizer.onMouseUp(e);resizer.mouseDownHandler=mouseDownHandler=()=>resizer.onMouseDown();eventsToUnbind.push(addEvent(container,"mousemove",mouseMoveHandler),addEvent(container.ownerDocument,"mouseup",mouseUpHandler),addEvent(ctrlLineElem,"mousedown",mouseDownHandler),addEvent(container,"touchmove",mouseMoveHandler),addEvent(container.ownerDocument,"touchend",mouseUpHandler),addEvent(ctrlLineElem,"touchstart",mouseDownHandler));resizer.eventsToUnbind=eventsToUnbind}onMouseMove(e){if(!e.touches||e.touches[0].pageX!==0){const pointer=this.axis.chart.pointer;if(this.grabbed&&pointer){this.hasDragged=true;this.updateAxes(pointer.normalize(e).chartY-(this.options.y||0))}}}onMouseUp(e){const pointer=this.axis.chart.pointer;if(this.hasDragged&&pointer){this.updateAxes(pointer.normalize(e).chartY-(this.options.y||0))}this.grabbed=this.hasDragged=this.axis.chart.activeResizer=void 0}onMouseDown(){this.axis.chart.pointer?.reset(false,0);this.grabbed=this.axis.chart.activeResizer=true}updateAxes(chartY){const resizer=this,chart=resizer.axis.chart,axes=resizer.options.controlledAxis,nextAxes=axes.next.length===0?[chart.yAxis.indexOf(resizer.axis)+1]:axes.next,prevAxes=[resizer.axis].concat(axes.prev),axesConfigs=[],plotTop=chart.plotTop,plotHeight=chart.plotHeight,plotBottom=plotTop+plotHeight,calculatePercent=value=>value*100/plotHeight+"%",normalize=(val,min,max)=>Math.round(clamp(val,min,max));chartY=clamp(chartY,plotTop,plotBottom);let stopDrag=false,yDelta=chartY-resizer.lastPos;if(yDelta*yDelta<1){return}let isFirst=true;for(const axesGroup of[prevAxes,nextAxes]){for(const axisInfo of axesGroup){const axis=isNumber(axisInfo)?chart.yAxis[axisInfo]:isFirst?axisInfo:chart.get(axisInfo),axisOptions=axis&&axis.options,optionsToUpdate={};let height,top;if(!axisOptions||axisOptions.isInternal){isFirst=false;continue}top=axis.top;const minLength=Math.round(relativeLength(axisOptions.minLength||NaN,plotHeight)),maxLength=Math.round(relativeLength(axisOptions.maxLength||NaN,plotHeight));if(!isFirst){yDelta=chartY-resizer.lastPos;height=normalize(axis.len-yDelta,minLength,maxLength);top=axis.top+yDelta;if(top+height>plotBottom){const hDelta=plotBottom-height-top;chartY+=hDelta;top+=hDelta}if(top<plotTop){top=plotTop;if(top+height>plotBottom){height=plotHeight}}if(height===minLength){stopDrag=true}axesConfigs.push({axis:axis,options:{top:calculatePercent(top-plotTop),height:calculatePercent(height)}})}else{height=normalize(chartY-top,minLength,maxLength);if(height===maxLength){stopDrag=true}chartY=top+height;axesConfigs.push({axis:axis,options:{height:calculatePercent(height)}})}isFirst=false;optionsToUpdate.height=height}}if(!stopDrag){for(const config of axesConfigs){config.axis.update(config.options,false)}chart.redraw(false)}}destroy(){const resizer=this,axis=resizer.axis;delete axis.resizer;if(this.eventsToUnbind){this.eventsToUnbind.forEach(unbind=>unbind())}resizer.controlLine.destroy();for(const key of Object.keys(resizer)){resizer[key]=null}}}AxisResizer.resizerOptions=AxisResizerDefaults;export default AxisResizer;