"use strict";import DDU from"./DragDropUtilities.js";const{addEvents,getNormalizedEvent}=DDU;import DraggableChart from"./DraggableChart.js";const{initDragDrop}=DraggableChart;import DragDropDefaults from"./DragDropDefaults.js";import DragDropProps from"./DragDropProps.js";import U from"../../Core/Utilities.js";const{addEvent,clamp,isNumber,merge}=U;function compose(ChartClass,SeriesClass){DraggableChart.compose(ChartClass);const seriesProto=SeriesClass.prototype;if(!seriesProto.dragDropProps){const PointClass=SeriesClass.prototype.pointClass,seriesTypes=SeriesClass.types,pointProto=PointClass.prototype;pointProto.getDropValues=pointGetDropValues;pointProto.showDragHandles=pointShowDragHandles;addEvent(PointClass,"mouseOut",onPointMouseOut);addEvent(PointClass,"mouseOver",onPointMouseOver);addEvent(PointClass,"remove",onPointRemove);seriesProto.dragDropProps=DragDropProps.line;seriesProto.getGuideBox=seriesGetGuideBox;const seriesWithDragDropProps=["arearange","boxplot","bullet","column","columnrange","errorbar","flags","gantt","ohlc","waterfall","xrange"];for(const seriesType of seriesWithDragDropProps){if(seriesTypes[seriesType]){seriesTypes[seriesType].prototype.dragDropProps=DragDropProps[seriesType]}}const seriesWithoutDragDropProps=["bellcurve","gauge","histogram","map","mapline","pareto","pie","sankey","sma","sunburst","treemap","vector","windbarb","wordcloud"];for(const seriesType of seriesWithoutDragDropProps){if(seriesTypes[seriesType]){seriesTypes[seriesType].prototype.dragDropProps=null}}}}function mouseOut(point){const chart=point.series&&point.series.chart,dragDropData=chart&&chart.dragDropData;if(chart&&chart.dragHandles&&!(dragDropData&&(dragDropData.isDragging&&dragDropData.draggedPastSensitivity||dragDropData.isHoveringHandle===point.id))){chart.hideDragHandles()}}function mouseOver(point){const series=point.series,chart=series&&series.chart,dragDropData=chart&&chart.dragDropData,is3d=chart&&chart.is3d&&chart.is3d();if(chart&&!(dragDropData&&dragDropData.isDragging&&dragDropData.draggedPastSensitivity)&&!chart.isDragDropAnimating&&series.options.dragDrop&&!is3d){if(chart.dragHandles){chart.hideDragHandles()}point.showDragHandles()}}function onPointMouseOut(){const point=this;setTimeout(()=>{if(point.series){mouseOut(point)}},10)}function onPointMouseOver(){const point=this;setTimeout(()=>mouseOver(point),12)}function onPointRemove(){const chart=this.series.chart,dragHandles=chart.dragHandles;if(dragHandles&&dragHandles.point===this.id){chart.hideDragHandles()}}function onResizeHandleMouseOut(point){const chart=point.series.chart;if(chart.dragDropData&&point.id===chart.dragDropData.isHoveringHandle){delete chart.dragDropData.isHoveringHandle}if(!chart.hoverPoint){mouseOut(point)}}function onResizeHandleMouseDown(e,point,updateProp){const chart=point.series.chart;if(chart.zoomOrPanKeyPressed(e)){return}chart.mouseIsDown=false;initDragDrop(e,point);chart.dragDropData.updateProp=e.updateProp=updateProp;point.firePointEvent("dragStart",e);e.stopPropagation();e.preventDefault()}function pointGetDropValues(origin,newPos,updateProps){const point=this,series=point.series,chart=series.chart,mapView=chart.mapView,options=merge(series.options.dragDrop,point.options.dragDrop),result={},pointOrigin=origin.points[point.id],updateSingleProp=Object.keys(updateProps).length===1;const limitToRange=(val,dir)=>{const direction=dir.toUpperCase(),time=series.chart.time,defaultPrecision=series[`${dir}Axis`].categories?1:0,precision=options[`dragPrecision${direction}`]??defaultPrecision,min=time.parse(options[`dragMin${direction}`])??-Infinity,max=time.parse(options[`dragMax${direction}`])??Infinity;let res=val;if(precision){res=Math.round(res/precision)*precision}return clamp(res,min,max)};const limitToMapRange=(newPos,dir,key)=>{if(mapView){const direction=dir.toUpperCase(),precision=options[`dragPrecision${direction}`]??0,lonLatMin=mapView.pixelsToLonLat({x:0,y:0}),lonLatMax=mapView.pixelsToLonLat({x:chart.plotBox.width,y:chart.plotBox.height});let min=options[`dragMin${direction}`]??lonLatMin?.[key]??-Infinity,max=options[`dragMax${direction}`]??lonLatMax?.[key]??Infinity,res=newPos[key];if(mapView.projection.options.name==="Orthographic"){return res}if(key==="lat"){if(isNaN(min)||min>mapView.projection.maxLatitude){min=mapView.projection.maxLatitude}if(isNaN(max)||max<-1*mapView.projection.maxLatitude){max=-1*mapView.projection.maxLatitude}const temp=max;max=min;min=temp}if(!mapView.projection.hasCoordinates){const lonLatRes=mapView.pixelsToLonLat({x:newPos.chartX-chart.plotLeft,y:chart.plotHeight-newPos.chartY+chart.plotTop});if(lonLatRes){res=lonLatRes[key]}}if(precision){res=Math.round(res/precision)*precision}return clamp(res,min,max)}};for(const key of Object.keys(updateProps)){const val=updateProps[key],oldVal=pointOrigin.point[key],axis=series[val.axis+"Axis"],newVal=mapView?limitToMapRange(newPos,val.axis,key):limitToRange(axis.toValue((axis.horiz?newPos.chartX:newPos.chartY)+pointOrigin[key+"Offset"]),val.axis);if(isNumber(newVal)&&!(updateSingleProp&&val.propValidate&&!val.propValidate(newVal,point))&&typeof oldVal!=="undefined"){result[key]=newVal}}return result}function pointShowDragHandles(){const point=this,series=point.series,chart=series.chart,{inverted,renderer}=chart,options=merge(series.options.dragDrop,point.options.dragDrop),dragDropProps=series.dragDropProps||{};let dragHandles=chart.dragHandles;for(const key of Object.keys(dragDropProps)){const val=dragDropProps[key],handleOptions=merge(DragDropDefaults.dragHandle,val.handleOptions,options.dragHandle),handleAttrs={class:handleOptions.className,"stroke-width":handleOptions.lineWidth,fill:handleOptions.color,stroke:handleOptions.lineColor},pathFormatter=handleOptions.pathFormatter||val.handleFormatter,handlePositioner=val.handlePositioner,validate=val.validateIndividualDrag?val.validateIndividualDrag(point):true;let pos,handle,path;if(val.resize&&validate&&val.resizeSide&&pathFormatter&&(options["draggable"+val.axis.toUpperCase()]||options[val.optionName])&&options[val.optionName]!==false){if(!dragHandles){dragHandles=chart.dragHandles={group:renderer.g("drag-drop-handles").add(series.markerGroup||series.group),point:point.id}}else{dragHandles.point=point.id}pos=handlePositioner(point);handleAttrs.d=path=pathFormatter(point);const minEdge=point.series.xAxis.categories?-.5:0;if(!path||pos.x<minEdge||pos.y<0){return}handleAttrs.cursor=handleOptions.cursor||(val.axis==="x"!==!!inverted?"ew-resize":"ns-resize");handle=dragHandles[val.optionName];if(!handle){handle=dragHandles[val.optionName]=renderer.path().add(dragHandles.group)}handleAttrs.translateX=inverted?series.yAxis.len-pos.y:pos.x;handleAttrs.translateY=inverted?series.xAxis.len-pos.x:pos.y;if(inverted){handleAttrs.rotation=-90}handle.attr(handleAttrs);addEvents(handle.element,["touchstart","mousedown"],e=>{onResizeHandleMouseDown(getNormalizedEvent(e,chart),point,key)},{passive:false});addEvent(dragHandles.group.element,"mouseover",()=>{chart.dragDropData=chart.dragDropData||{};chart.dragDropData.isHoveringHandle=point.id});addEvents(dragHandles.group.element,["touchend","mouseout"],()=>{onResizeHandleMouseOut(point)})}}}function seriesGetGuideBox(points){const chart=this.chart;let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,changed;for(const point of points){const bBox=point.graphic&&point.graphic.getBBox()||point.shapeArgs;if(bBox){let plotX2;const x2=point.x2;if(isNumber(x2)){plotX2=point.series.xAxis.translate(x2,false,false,false,true)}const skipBBox=!(bBox.width||bBox.height||bBox.x||bBox.y);changed=true;minX=Math.min(point.plotX||0,plotX2||0,skipBBox?Infinity:bBox.x||0,minX);maxX=Math.max(point.plotX||0,plotX2||0,(bBox.x||0)+(bBox.width||0),maxX);minY=Math.min(point.plotY||0,skipBBox?Infinity:bBox.y||0,minY);maxY=Math.max((bBox.y||0)+(bBox.height||0),maxY)}}return changed?chart.renderer.rect(minX,minY,maxX-minX,maxY-minY):chart.renderer.g()}const DraggablePoints={compose:compose};export default DraggablePoints;"";