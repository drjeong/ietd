"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{getDeferredAnimation}=A;import AnnotationChart from"./AnnotationChart.js";import AnnotationDefaults from"./AnnotationDefaults.js";import ControllableRect from"./Controllables/ControllableRect.js";import ControllableCircle from"./Controllables/ControllableCircle.js";import ControllableEllipse from"./Controllables/ControllableEllipse.js";import ControllablePath from"./Controllables/ControllablePath.js";import ControllableImage from"./Controllables/ControllableImage.js";import ControllableLabel from"./Controllables/ControllableLabel.js";import ControlPoint from"./ControlPoint.js";import ControlTarget from"./ControlTarget.js";import EventEmitter from"./EventEmitter.js";import MockPoint from"./MockPoint.js";import PopupComposition from"./Popup/PopupComposition.js";import U from"../../Core/Utilities.js";const{destroyObjectProperties,erase,fireEvent,merge,pick,splat}=U;function adjustVisibility(item){const label=item.graphic,hasVisiblePoints=item.points.some(point=>point.series.visible!==false&&point.visible!==false);if(label){if(!hasVisiblePoints){label.hide()}else if(label.visibility==="hidden"){label.show()}}}function getLabelsAndShapesOptions(baseOptions,newOptions){const mergedOptions={};["labels","shapes"].forEach(name=>{const someBaseOptions=baseOptions[name],newOptionsValue=newOptions[name];if(someBaseOptions){if(newOptionsValue){mergedOptions[name]=splat(newOptionsValue).map((basicOptions,i)=>merge(someBaseOptions[i],basicOptions))}else{mergedOptions[name]=baseOptions[name]}}});return mergedOptions}class Annotation extends EventEmitter{static compose(ChartClass,NavigationBindingsClass,PointerClass,SVGRendererClass){AnnotationChart.compose(Annotation,ChartClass,PointerClass);ControllableLabel.compose(SVGRendererClass);ControllablePath.compose(ChartClass,SVGRendererClass);NavigationBindingsClass.compose(Annotation,ChartClass);PopupComposition.compose(NavigationBindingsClass,PointerClass)}constructor(chart,userOptions){super();this.coll="annotations";this.chart=chart;this.points=[];this.controlPoints=[];this.coll="annotations";this.index=-1;this.labels=[];this.shapes=[];this.options=merge(this.defaultOptions,userOptions);this.userOptions=userOptions;const labelsAndShapes=getLabelsAndShapesOptions(this.options,userOptions);this.options.labels=labelsAndShapes.labels;this.options.shapes=labelsAndShapes.shapes;this.init(chart,this.options)}addClipPaths(){this.setClipAxes();if(this.clipXAxis&&this.clipYAxis&&this.options.crop){this.clipRect=this.chart.renderer.clipRect(this.getClipBox())}}addLabels(){const labelsOptions=this.options.labels||[];labelsOptions.forEach((labelOptions,i)=>{const label=this.initLabel(labelOptions,i);merge(true,labelsOptions[i],label.options)})}addShapes(){const shapes=this.options.shapes||[];shapes.forEach((shapeOptions,i)=>{const shape=this.initShape(shapeOptions,i);merge(true,shapes[i],shape.options)})}destroy(){const chart=this.chart,destroyItem=function(item){item.destroy()};this.labels.forEach(destroyItem);this.shapes.forEach(destroyItem);this.clipXAxis=null;this.clipYAxis=null;erase(chart.labelCollectors,this.labelCollector);super.destroy();this.destroyControlTarget();destroyObjectProperties(this,chart)}destroyItem(item){erase(this[item.itemType+"s"],item);item.destroy()}getClipBox(){if(this.clipXAxis&&this.clipYAxis){return{x:this.clipXAxis.left,y:this.clipYAxis.top,width:this.clipXAxis.width,height:this.clipYAxis.height}}}initProperties(chart,userOptions){this.setOptions(userOptions);const labelsAndShapes=getLabelsAndShapesOptions(this.options,userOptions);this.options.labels=labelsAndShapes.labels;this.options.shapes=labelsAndShapes.shapes;this.chart=chart;this.points=[];this.controlPoints=[];this.coll="annotations";this.userOptions=userOptions;this.labels=[];this.shapes=[]}init(_annotationOrChart,_userOptions,index=this.index){const chart=this.chart,animOptions=this.options.animation;this.index=index;this.linkPoints();this.addControlPoints();this.addShapes();this.addLabels();this.setLabelCollector();this.animationConfig=getDeferredAnimation(chart,animOptions)}initLabel(labelOptions,index){const options=merge(this.options.labelOptions,{controlPointOptions:this.options.controlPointOptions},labelOptions),label=new ControllableLabel(this,options,index);label.itemType="label";this.labels.push(label);return label}initShape(shapeOptions,index){const options=merge(this.options.shapeOptions,{controlPointOptions:this.options.controlPointOptions},shapeOptions),shape=new Annotation.shapesMap[options.type](this,options,index);shape.itemType="shape";this.shapes.push(shape);return shape}redraw(animation){this.linkPoints();if(!this.graphic){this.render()}if(this.clipRect){this.clipRect.animate(this.getClipBox())}this.redrawItems(this.shapes,animation);this.redrawItems(this.labels,animation);this.redrawControlPoints(animation)}redrawItem(item,animation){item.linkPoints();if(!item.shouldBeDrawn()){this.destroyItem(item)}else{if(!item.graphic){this.renderItem(item)}item.redraw(pick(animation,true)&&item.graphic.placed);if(item.points.length){adjustVisibility(item)}}}redrawItems(items,animation){let i=items.length;while(i--){this.redrawItem(items[i],animation)}}remove(){return this.chart.removeAnnotation(this)}render(){const renderer=this.chart.renderer;this.graphic=renderer.g("annotation").attr({opacity:0,zIndex:this.options.zIndex,visibility:this.options.visible?"inherit":"hidden"}).add();this.shapesGroup=renderer.g("annotation-shapes").add(this.graphic);if(this.options.crop){this.shapesGroup.clip(this.chart.plotBoxClip)}this.labelsGroup=renderer.g("annotation-labels").attr({translateX:0,translateY:0}).add(this.graphic);this.addClipPaths();if(this.clipRect){this.graphic.clip(this.clipRect)}this.renderItems(this.shapes);this.renderItems(this.labels);this.addEvents();this.renderControlPoints()}renderItem(item){item.render(item.itemType==="label"?this.labelsGroup:this.shapesGroup)}renderItems(items){let i=items.length;while(i--){this.renderItem(items[i])}}setClipAxes(){const xAxes=this.chart.xAxis,yAxes=this.chart.yAxis,linkedAxes=(this.options.labels||[]).concat(this.options.shapes||[]).reduce((axes,labelOrShape)=>{const point=labelOrShape&&(labelOrShape.point||labelOrShape.points&&labelOrShape.points[0]);return[xAxes[point&&point.xAxis]||axes[0],yAxes[point&&point.yAxis]||axes[1]]},[]);this.clipXAxis=linkedAxes[0];this.clipYAxis=linkedAxes[1]}setControlPointsVisibility(visible){const setItemControlPointsVisibility=function(item){item.setControlPointsVisibility(visible)};this.controlPoints.forEach(controlPoint=>{controlPoint.setVisibility(visible)});this.shapes.forEach(setItemControlPointsVisibility);this.labels.forEach(setItemControlPointsVisibility)}setLabelCollector(){const annotation=this;annotation.labelCollector=function(){return annotation.labels.reduce(function(labels,label){if(!label.options.allowOverlap){labels.push(label.graphic)}return labels},[])};annotation.chart.labelCollectors.push(annotation.labelCollector)}setOptions(userOptions){this.options=merge(this.defaultOptions,userOptions)}setVisibility(visible){const options=this.options,navigation=this.chart.navigationBindings,visibility=pick(visible,!options.visible);this.graphic.attr("visibility",visibility?"inherit":"hidden");if(!visibility){const setItemControlPointsVisibility=function(item){item.setControlPointsVisibility(visibility)};this.shapes.forEach(setItemControlPointsVisibility);this.labels.forEach(setItemControlPointsVisibility);if(navigation.activeAnnotation===this&&navigation.popup&&navigation.popup.type==="annotation-toolbar"){fireEvent(navigation,"closePopup")}}options.visible=visibility}update(userOptions,redraw){const chart=this.chart,labelsAndShapes=getLabelsAndShapesOptions(this.userOptions,userOptions),userOptionsIndex=chart.annotations.indexOf(this),options=merge(true,this.userOptions,userOptions);options.labels=labelsAndShapes.labels;options.shapes=labelsAndShapes.shapes;this.destroy();this.initProperties(chart,options);this.init(chart,options);chart.options.annotations[userOptionsIndex]=this.options;this.isUpdating=true;if(pick(redraw,true)){chart.drawAnnotations()}fireEvent(this,"afterUpdate");this.isUpdating=false}}Annotation.ControlPoint=ControlPoint;Annotation.MockPoint=MockPoint;Annotation.shapesMap={rect:ControllableRect,circle:ControllableCircle,ellipse:ControllableEllipse,path:ControllablePath,image:ControllableImage};Annotation.types={};Annotation.prototype.defaultOptions=AnnotationDefaults;Annotation.prototype.nonDOMEvents=["add","afterUpdate","drag","remove"];ControlTarget.compose(Annotation);export default Annotation;"";