"use strict";import Annotation from"../Annotation.js";import ControlPoint from"../ControlPoint.js";import CrookedLine from"./CrookedLine.js";import InfinityLine from"./InfinityLine.js";import MockPoint from"../MockPoint.js";import U from"../../../Core/Utilities.js";const{merge}=U;function edgePoint(startIndex,endIndex,fibonacciIndex){return function(target){const chart=target.annotation.chart,plotLeftOrTop=chart.inverted?chart.plotTop:chart.plotLeft;let points=target.annotation.points;const xAxis=points[0].series.xAxis,deltaX=points.length>1?points[1].plotX-points[0].plotX:0,x=xAxis.toValue(points[0].plotX+plotLeftOrTop+fibonacciIndex*deltaX);points=[new MockPoint(chart,points[0].target,{x:x,y:0,xAxis:points[0].options.xAxis,yAxis:points[0].options.yAxis}),new MockPoint(chart,points[0].target,{x:x,y:1,xAxis:points[0].options.xAxis,yAxis:points[0].options.yAxis})];return InfinityLine.findEdgePoint(points[startIndex],points[endIndex])}}class FibonacciTimeZones extends CrookedLine{addShapes(){const numberOfLines=11;let fibb=1,nextFibb=1;for(let i=0;i<numberOfLines;i++){const correctedFibb=!i?0:fibb,points=[edgePoint(1,0,correctedFibb),edgePoint(0,1,correctedFibb)];nextFibb=fibb+nextFibb;fibb=nextFibb-fibb;if(i===1){this.secondLineEdgePoints=[points[0],points[1]]}this.initShape(merge(this.options.typeOptions.line,{type:"path",points:points,className:"highcharts-fibonacci-timezones-lines"}),i)}}addControlPoints(){const options=this.options,typeOptions=options.typeOptions,controlPoint=new ControlPoint(this.chart,this,merge(options.controlPointOptions,typeOptions.controlPointOptions),0);this.controlPoints.push(controlPoint);typeOptions.controlPointOptions=controlPoint.options}}FibonacciTimeZones.prototype.defaultOptions=merge(CrookedLine.prototype.defaultOptions,{typeOptions:{line:{stroke:"rgba(0, 0, 0, 0.75)",strokeWidth:1,fill:void 0},controlPointOptions:{positioner:function(){const target=this.target,graphic=this.graphic,edgePoints=target.secondLineEdgePoints,args={annotation:target},firstEdgePointY=edgePoints[0](args).y,secondEdgePointY=edgePoints[1](args).y,plotLeft=this.chart.plotLeft,plotTop=this.chart.plotTop;let x=edgePoints[0](args).x,y=(firstEdgePointY+secondEdgePointY)/2;if(this.chart.inverted){[x,y]=[y,x]}return{x:plotLeft+x-(graphic.width||0)/2,y:plotTop+y-(graphic.height||0)/2}},events:{drag:function(e,target){const isInsidePlot=target.chart.isInsidePlot(e.chartX-target.chart.plotLeft,e.chartY-target.chart.plotTop,{visiblePlotOnly:true});if(isInsidePlot){const translation=this.mouseMoveToTranslation(e);target.translatePoint(translation.x,0,1);target.redraw(false)}}}}}});Annotation.types.fibonacciTimeZones=FibonacciTimeZones;export default FibonacciTimeZones;