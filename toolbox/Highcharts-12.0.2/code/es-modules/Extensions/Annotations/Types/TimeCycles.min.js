"use strict";import Annotation from"../Annotation.js";import CrookedLine from"./CrookedLine.js";import ControlPoint from"../ControlPoint.js";import U from"../../../Core/Utilities.js";const{merge,isNumber,defined}=U;function getStartingPath(x,y){return["M",x,y]}function getCirclePath(pixelInterval,numberOfCircles,startX,y){const path=[];for(let i=1;i<=numberOfCircles;i++){path.push(["A",pixelInterval/2,pixelInterval/2,0,1,1,startX+i*pixelInterval,y])}return path}class TimeCycles extends CrookedLine{init(annotation,userOptions,index){if(defined(userOptions.yAxis)){userOptions.points.forEach(point=>{point.yAxis=userOptions.yAxis})}if(defined(userOptions.xAxis)){userOptions.points.forEach(point=>{point.xAxis=userOptions.xAxis})}super.init(annotation,userOptions,index)}setPath(){this.shapes[0].options.d=this.getPath()}getPath(){return[getStartingPath(this.startX,this.y)].concat(getCirclePath(this.pixelInterval,this.numberOfCircles,this.startX,this.y))}addShapes(){const typeOptions=this.options.typeOptions;this.setPathProperties();const shape=this.initShape(merge(typeOptions.line,{type:"path",d:this.getPath(),points:this.options.points,className:"highcharts-timecycles-lines"}),0);typeOptions.line=shape.options}addControlPoints(){const options=this.options,typeOptions=options.typeOptions;options.controlPointOptions.style.cursor=this.chart.inverted?"ns-resize":"ew-resize";typeOptions.controlPointOptions.forEach(option=>{const controlPointsOptions=merge(options.controlPointOptions,option);const controlPoint=new ControlPoint(this.chart,this,controlPointsOptions,0);this.controlPoints.push(controlPoint)})}setPathProperties(){const options=this.options.typeOptions,points=options.points;if(!points){return}const point1=points[0],point2=points[1],xAxisNumber=options.xAxis||0,yAxisNumber=options.yAxis||0,xAxis=this.chart.xAxis[xAxisNumber],yAxis=this.chart.yAxis[yAxisNumber],xValue1=point1.x,yValue=point1.y,xValue2=point2.x;if(!xValue1||!xValue2){return}const y=isNumber(yValue)?yAxis.toPixels(yValue):yAxis.top+yAxis.height,x=isNumber(xValue1)?xAxis.toPixels(xValue1):xAxis.left,x2=isNumber(xValue2)?xAxis.toPixels(xValue2):xAxis.left+30,xAxisLength=xAxis.len,pixelInterval=Math.round(Math.max(Math.abs(x2-x),2)),numberOfCircles=Math.floor(xAxisLength/pixelInterval)+2,pixelShift=(Math.floor((x-xAxis.left)/pixelInterval)+1)*pixelInterval;this.startX=x-pixelShift;this.y=y;this.pixelInterval=pixelInterval;this.numberOfCircles=numberOfCircles}redraw(animation){this.setPathProperties();this.setPath();super.redraw(animation)}}TimeCycles.prototype.defaultOptions=merge(CrookedLine.prototype.defaultOptions,{typeOptions:{controlPointOptions:[{positioner:function(target){const point=target.points[0],position=target.anchor(point).absolutePosition;return{x:position.x-(this.graphic.width||0)/2,y:target.y-(this.graphic.height||0)}},events:{drag:function(e,target){const position=target.anchor(target.points[0]).absolutePosition;target.translatePoint(e.chartX-position.x,0,0);target.redraw(false)}}},{positioner:function(target){const point=target.points[1],position=target.anchor(point).absolutePosition;return{x:position.x-(this.graphic.width||0)/2,y:target.y-(this.graphic.height||0)}},events:{drag:function(e,target){const position=target.anchor(target.points[1]).absolutePosition;target.translatePoint(e.chartX-position.x,0,1);target.redraw(false)}}}]}});Annotation.types.timeCycles=TimeCycles;export default TimeCycles;