"use strict";import D from"../Core/Defaults.js";const{defaultOptions}=D;import H from"../Core/Globals.js";const{noop}=H;import U from"../Core/Utilities.js";const{addEvent,extend,isObject,merge,relativeLength}=U;const defaultBorderRadiusOptions={radius:0,scope:"stack",where:void 0};let oldArc=noop;let oldRoundedRect=noop;function applyBorderRadius(path,i,r){const a=path[i];let b=path[i+1];if(b[0]==="Z"){b=path[0]}let line,arc,fromLineToArc;if((a[0]==="M"||a[0]==="L")&&b[0]==="A"){line=a;arc=b;fromLineToArc=true}else if(a[0]==="A"&&(b[0]==="M"||b[0]==="L")){line=b;arc=a}if(line&&arc&&arc.params){const bigR=arc[1],clockwise=arc[5],params=arc.params,{start,end,cx,cy}=params;const relativeR=clockwise?bigR-r:bigR+r,angleOfBorderRadius=relativeR?Math.asin(r/relativeR):0,angleOffset=clockwise?angleOfBorderRadius:-angleOfBorderRadius,distanceBigCenterToStartArc=Math.cos(angleOfBorderRadius)*relativeR;if(fromLineToArc){params.start=start+angleOffset;line[1]=cx+distanceBigCenterToStartArc*Math.cos(start);line[2]=cy+distanceBigCenterToStartArc*Math.sin(start);path.splice(i+1,0,["A",r,r,0,0,1,cx+bigR*Math.cos(params.start),cy+bigR*Math.sin(params.start)])}else{params.end=end-angleOffset;arc[6]=cx+bigR*Math.cos(params.end);arc[7]=cy+bigR*Math.sin(params.end);path.splice(i+1,0,["A",r,r,0,0,1,cx+distanceBigCenterToStartArc*Math.cos(end),cy+distanceBigCenterToStartArc*Math.sin(end)])}arc[4]=Math.abs(params.end-params.start)<Math.PI?0:1}}function arc(x,y,w,h,options={}){const path=oldArc(x,y,w,h,options),{innerR=0,r=w,start=0,end=0}=options;if(options.open||!options.borderRadius){return path}const alpha=end-start,sinHalfAlpha=Math.sin(alpha/2),borderRadius=Math.max(Math.min(relativeLength(options.borderRadius||0,r-innerR),(r-innerR)/2,r*sinHalfAlpha/(1+sinHalfAlpha)),0),innerBorderRadius=Math.min(borderRadius,2*(alpha/Math.PI)*innerR);let i=path.length-1;while(i--){applyBorderRadius(path,i,i>1?innerBorderRadius:borderRadius)}return path}function seriesOnAfterColumnTranslate(){if(this.options.borderRadius&&!(this.chart.is3d&&this.chart.is3d())){const{options,yAxis}=this,percent=options.stacking==="percent",seriesDefault=defaultOptions.plotOptions?.[this.type]?.borderRadius,borderRadius=optionsToObject(options.borderRadius,isObject(seriesDefault)?seriesDefault:{}),reversed=yAxis.options.reversed;for(const point of this.points){const{shapeArgs}=point;if(point.shapeType==="roundedRect"&&shapeArgs){const{width=0,height=0,y=0}=shapeArgs;let brBoxY=y,brBoxHeight=height;if(borderRadius.scope==="stack"&&point.stackTotal){const stackEnd=yAxis.translate(percent?100:point.stackTotal,false,true,false,true),stackThreshold=yAxis.translate(options.threshold||0,false,true,false,true),box=this.crispCol(0,Math.min(stackEnd,stackThreshold),0,Math.abs(stackEnd-stackThreshold));brBoxY=box.y;brBoxHeight=box.height}const flip=(point.negative?-1:1)*(reversed?-1:1)===-1;let where=borderRadius.where;if(!where&&this.is("waterfall")&&Math.abs((point.yBottom||0)-(this.translatedThreshold||0))>this.borderWidth){where="all"}if(!where){where="end"}const r=Math.min(relativeLength(borderRadius.radius,width),width/2,where==="all"?height/2:Infinity)||0;if(where==="end"){if(flip){brBoxY-=r;brBoxHeight+=r}else{brBoxHeight+=r}}extend(shapeArgs,{brBoxHeight:brBoxHeight,brBoxY:brBoxY,r:r})}}}}function compose(SeriesClass,SVGElementClass,SVGRendererClass){const PieSeriesClass=SeriesClass.types.pie;if(!SVGElementClass.symbolCustomAttribs.includes("borderRadius")){const symbols=SVGRendererClass.prototype.symbols;addEvent(SeriesClass,"afterColumnTranslate",seriesOnAfterColumnTranslate,{order:9});addEvent(PieSeriesClass,"afterTranslate",pieSeriesOnAfterTranslate);SVGElementClass.symbolCustomAttribs.push("borderRadius","brBoxHeight","brBoxY");oldArc=symbols.arc;oldRoundedRect=symbols.roundedRect;symbols.arc=arc;symbols.roundedRect=roundedRect}}function optionsToObject(options,seriesBROptions){if(!isObject(options)){options={radius:options||0}}return merge(defaultBorderRadiusOptions,seriesBROptions,options)}function pieSeriesOnAfterTranslate(){const borderRadius=optionsToObject(this.options.borderRadius);for(const point of this.points){const shapeArgs=point.shapeArgs;if(shapeArgs){shapeArgs.borderRadius=relativeLength(borderRadius.radius,(shapeArgs.r||0)-(shapeArgs.innerR||0))}}}function roundedRect(x,y,width,height,options={}){const path=oldRoundedRect(x,y,width,height,options),{r=0,brBoxHeight=height,brBoxY=y}=options,brOffsetTop=y-brBoxY,brOffsetBtm=brBoxY+brBoxHeight-(y+height),rTop=brOffsetTop-r>-.1?0:r,rBtm=brOffsetBtm-r>-.1?0:r,cutTop=Math.max(rTop&&brOffsetTop,0),cutBtm=Math.max(rBtm&&brOffsetBtm,0);const a=[x+rTop,y],b=[x+width-rTop,y],c=[x+width,y+rTop],d=[x+width,y+height-rBtm],e=[x+width-rBtm,y+height],f=[x+rBtm,y+height],g=[x,y+height-rBtm],h=[x,y+rTop];const applyPythagoras=(r,altitude)=>Math.sqrt(Math.pow(r,2)-Math.pow(altitude,2));if(cutTop){const base=applyPythagoras(rTop,rTop-cutTop);a[0]-=base;b[0]+=base;c[1]=h[1]=y+rTop-cutTop}if(height<rTop-cutTop){const base=applyPythagoras(rTop,rTop-cutTop-height);c[0]=d[0]=x+width-rTop+base;e[0]=Math.min(c[0],e[0]);f[0]=Math.max(d[0],f[0]);g[0]=h[0]=x+rTop-base;c[1]=h[1]=y+height}if(cutBtm){const base=applyPythagoras(rBtm,rBtm-cutBtm);e[0]+=base;f[0]-=base;d[1]=g[1]=y+height-rBtm+cutBtm}if(height<rBtm-cutBtm){const base=applyPythagoras(rBtm,rBtm-cutBtm-height);c[0]=d[0]=x+width-rBtm+base;b[0]=Math.min(c[0],b[0]);a[0]=Math.max(d[0],a[0]);g[0]=h[0]=x+rBtm-base;d[1]=g[1]=y}path.length=0;path.push(["M",...a],["L",...b],["A",rTop,rTop,0,0,1,...c],["L",...d],["A",rBtm,rBtm,0,0,1,...e],["L",...f],["A",rBtm,rBtm,0,0,1,...g],["L",...h],["A",rTop,rTop,0,0,1,...a],["Z"]);return path}const BorderRadius={compose:compose,optionsToObject:optionsToObject};export default BorderRadius;"";