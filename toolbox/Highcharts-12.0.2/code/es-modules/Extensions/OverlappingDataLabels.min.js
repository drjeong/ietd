"use strict";import GeometryUtilities from"../Core/Geometry/GeometryUtilities.js";const{pointInPolygon}=GeometryUtilities;import U from"../Core/Utilities.js";const{addEvent,fireEvent,objectEach,pick}=U;function chartHideOverlappingLabels(labels){const chart=this,len=labels.length,isIntersectRect=(box1,box2)=>!(box2.x>=box1.x+box1.width||box2.x+box2.width<=box1.x||box2.y>=box1.y+box1.height||box2.y+box2.height<=box1.y),isPolygonOverlap=(box1Poly,box2Poly)=>{for(const p of box1Poly){if(pointInPolygon({x:p[0],y:p[1]},box2Poly)){return true}}return false};function getAbsoluteBox(label){if(label&&(!label.alignAttr||label.placed)){const padding=label.box?0:label.padding||0,pos=label.alignAttr||{x:label.attr("x"),y:label.attr("y")},bBox=label.getBBox();label.width=bBox.width;label.height=bBox.height;return{x:pos.x+(label.parentGroup?.translateX||0)+padding,y:pos.y+(label.parentGroup?.translateY||0)+padding,width:(label.width||0)-2*padding,height:(label.height||0)-2*padding,polygon:bBox?.polygon}}}let label,label1,label2,box1,box2,isLabelAffected=false;for(let i=0;i<len;i++){label=labels[i];if(label){label.oldOpacity=label.opacity;label.newOpacity=1;label.absoluteBox=getAbsoluteBox(label)}}labels.sort((a,b)=>(b.labelrank||0)-(a.labelrank||0));for(let i=0;i<len;++i){label1=labels[i];box1=label1&&label1.absoluteBox;const box1Poly=box1?.polygon;for(let j=i+1;j<len;++j){label2=labels[j];box2=label2&&label2.absoluteBox;let toHide=false;if(box1&&box2&&label1!==label2&&label1.newOpacity!==0&&label2.newOpacity!==0&&label1.visibility!=="hidden"&&label2.visibility!=="hidden"){const box2Poly=box2.polygon;if(box1Poly&&box2Poly&&box1Poly!==box2Poly){if(isPolygonOverlap(box1Poly,box2Poly)){toHide=true}}else if(isIntersectRect(box1,box2)){toHide=true}if(toHide){const overlappingLabel=label1.labelrank<label2.labelrank?label1:label2,labelText=overlappingLabel.text;overlappingLabel.newOpacity=0;if(labelText?.element.querySelector("textPath")){labelText.hide()}}}}}for(const label of labels){if(hideOrShow(label,chart)){isLabelAffected=true}}if(isLabelAffected){fireEvent(chart,"afterHideAllOverlappingLabels")}}function compose(ChartClass){const chartProto=ChartClass.prototype;if(!chartProto.hideOverlappingLabels){chartProto.hideOverlappingLabels=chartHideOverlappingLabels;addEvent(ChartClass,"render",onChartRender)}}function hideOrShow(label,chart){let complete,newOpacity,isLabelAffected=false;if(label){newOpacity=label.newOpacity;if(label.oldOpacity!==newOpacity){if(label.hasClass("highcharts-data-label")){label[newOpacity?"removeClass":"addClass"]("highcharts-data-label-hidden");complete=function(){if(!chart.styledMode){label.css({pointerEvents:newOpacity?"auto":"none"})}};isLabelAffected=true;label[label.isOld?"animate":"attr"]({opacity:newOpacity},void 0,complete);fireEvent(chart,"afterHideOverlappingLabel")}else{label.attr({opacity:newOpacity})}}label.isOld=true}return isLabelAffected}function onChartRender(){const chart=this;let labels=[];for(const collector of chart.labelCollectors||[]){labels=labels.concat(collector())}for(const yAxis of chart.yAxis||[]){if(yAxis.stacking&&yAxis.options.stackLabels&&!yAxis.options.stackLabels.allowOverlap){objectEach(yAxis.stacking.stacks,stack=>{objectEach(stack,stackItem=>{if(stackItem.label){labels.push(stackItem.label)}})})}}for(const series of chart.series||[]){if(series.visible&&series.hasDataLabels?.()){const push=points=>{for(const point of points){if(point.visible){(point.dataLabels||[]).forEach(label=>{const options=label.options||{};label.labelrank=pick(options.labelrank,point.labelrank,point.shapeArgs?.height);if(options.allowOverlap??Number(options.distance)>0){label.oldOpacity=label.opacity;label.newOpacity=1;hideOrShow(label,chart)}else{labels.push(label)}})}}};push(series.nodes||[]);push(series.points)}}this.hideOverlappingLabels(labels)}const OverlappingDataLabels={compose:compose};export default OverlappingDataLabels;