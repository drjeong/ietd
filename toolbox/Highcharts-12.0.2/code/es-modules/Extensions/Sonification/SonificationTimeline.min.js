"use strict";import TimelineChannel from"./TimelineChannel.js";import toMIDI from"./MIDI.js";import DU from"../DownloadURL.js";const{downloadURL}=DU;import U from"../../Core/Utilities.js";const{defined,find,merge}=U;function filterChannels(filter,channels){const filtered=channels.map(channel=>{channel.cancel();return{channel:channel,filteredEvents:channel.muted?[]:channel.events.filter(filter)}}),minTime=filtered.reduce((acc,cur)=>Math.min(acc,cur.filteredEvents.length?cur.filteredEvents[0].time:Infinity),Infinity);return filtered.map(c=>new TimelineChannel(c.channel.type,c.channel.engine,c.channel.showPlayMarker,c.filteredEvents.map(e=>merge(e,{time:e.time-minTime})),c.channel.muted))}class SonificationTimeline{constructor(options,chart){this.chart=chart;this.isPaused=false;this.isPlaying=false;this.channels=[];this.scheduledCallbacks=[];this.playTimestamp=0;this.resumeFromTime=0;this.options=options||{}}addChannel(type,engine,showPlayMarker=false,events){if(type==="instrument"&&!engine.scheduleEventAtTime||type==="speech"&&!engine.sayAtTime){throw new Error("Highcharts Sonification: Invalid channel engine.")}const channel=new TimelineChannel(type,engine,showPlayMarker,events);this.channels.push(channel);return channel}play(filter,filterPersists=true,resetAfter=true,onEnd){if(this.isPlaying){this.cancel()}else{this.clearScheduledCallbacks()}this.onEndArgument=onEnd;this.playTimestamp=Date.now();this.resumeFromTime=0;this.isPaused=false;this.isPlaying=true;const skipThreshold=this.options.skipThreshold||2,onPlay=this.options.onPlay,showTooltip=this.options.showTooltip,showCrosshair=this.options.showCrosshair,channels=filter?filterChannels(filter,this.playingChannels||this.channels):this.channels,getEventKeysSignature=e=>Object.keys(e.speechOptions||{}).concat(Object.keys(e.instrumentEventOptions||{})).join(),pointsPlayed=[];if(filterPersists){this.playingChannels=channels}if(onPlay){onPlay({chart:this.chart,timeline:this})}let maxTime=0;channels.forEach(channel=>{if(channel.muted){return}const numEvents=channel.events.length;let lastCallbackTime=-Infinity,lastEventTime=-Infinity,lastEventKeys="";maxTime=Math.max(channel.events[numEvents-1]&&channel.events[numEvents-1].time||0,maxTime);for(let i=0;i<numEvents;++i){const e=channel.events[i],keysSig=getEventKeysSignature(e);if(keysSig===lastEventKeys&&e.time-lastEventTime<skipThreshold){continue}lastEventKeys=keysSig;lastEventTime=e.time;if(channel.type==="instrument"){channel.engine.scheduleEventAtTime(e.time/1e3,e.instrumentEventOptions||{})}else{channel.engine.sayAtTime(e.time,e.message||"",e.speechOptions||{})}const point=e.relatedPoint,chart=point&&point.series&&point.series.chart,needsCallback=e.callback||point&&(showTooltip||showCrosshair)&&channel.showPlayMarker!==false&&(e.time-lastCallbackTime>50||i===numEvents-1);if(point){pointsPlayed.push(point)}if(needsCallback){this.scheduledCallbacks.push(setTimeout(()=>{if(e.callback){e.callback()}if(point){if(showCrosshair){const s=point.series;if(s&&s.xAxis&&s.xAxis.crosshair){s.xAxis.drawCrosshair(void 0,point)}if(s&&s.yAxis&&s.yAxis.crosshair){s.yAxis.drawCrosshair(void 0,point)}}if(showTooltip&&!(chart&&chart.hoverPoints&&chart.hoverPoints.length>1&&find(chart.hoverPoints,p=>p===point)&&point.onMouseOver)){point.onMouseOver()}}},e.time));lastCallbackTime=e.time}}});const onEndOpt=this.options.onEnd,onStop=this.options.onStop;this.scheduledCallbacks.push(setTimeout(()=>{const chart=this.chart,context={chart:chart,timeline:this,pointsPlayed:pointsPlayed};this.isPlaying=false;if(resetAfter){this.resetPlayState()}if(onStop){onStop(context)}if(onEndOpt){onEndOpt(context)}if(onEnd){onEnd(context)}if(chart){if(chart.tooltip){chart.tooltip.hide(0)}if(chart.hoverSeries){chart.hoverSeries.onMouseOut()}chart.axes.forEach(a=>a.hideCrosshair())}},maxTime+250));this.resumeFromTime=filterPersists?maxTime:this.getLength()}pause(){this.isPaused=true;this.cancel();this.resumeFromTime=Date.now()-this.playTimestamp-10;return this.resumeFromTime}getCurrentTime(){return this.isPlaying?Date.now()-this.playTimestamp:this.resumeFromTime}getLength(){return this.channels.reduce((maxTime,channel)=>{const lastEvent=channel.events[channel.events.length-1];return lastEvent?Math.max(lastEvent.time,maxTime):maxTime},0)}resume(){if(this.playingChannels){const resumeFrom=this.resumeFromTime-50;this.play(e=>e.time>resumeFrom,false,false,this.onEndArgument);this.playTimestamp-=resumeFrom}else{this.play(void 0,false,false,this.onEndArgument)}}anchorPlayMoment(eventFilter,onEnd){if(this.isPlaying){this.pause()}let finalEventTime=0;this.play((e,ix,arr)=>{const res=eventFilter(e,ix,arr);if(res&&e.time>finalEventTime){finalEventTime=e.time}return res},false,false,onEnd);this.playingChannels=this.playingChannels||this.channels;this.isPaused=true;this.isPlaying=false;this.resumeFromTime=finalEventTime}playAdjacent(next,onEnd,onBoundaryHit,eventFilter){if(this.isPlaying){this.pause()}const fromTime=this.resumeFromTime,closestTime=this.channels.reduce((time,channel)=>{const events=eventFilter?channel.events.filter(eventFilter):channel.events;let s=0,e=events.length,lastValidTime=time;while(s<e){const mid=s+e>>1,t=events[mid].time,cmp=t-fromTime;if(cmp>0){if(next&&t<lastValidTime){lastValidTime=t}e=mid}else if(cmp<0){if(!next&&t>lastValidTime){lastValidTime=t}s=mid+1}else{if(next){s=mid+1}else{e=mid}}}return lastValidTime},next?Infinity:-Infinity),margin=.02;if(closestTime===Infinity||closestTime===-Infinity){if(onBoundaryHit){onBoundaryHit({chart:this.chart,timeline:this,attemptedNext:next})}return}this.anchorPlayMoment((e,ix,arr)=>{const withinTime=next?e.time>fromTime&&e.time<=closestTime+margin:e.time<fromTime&&e.time>=closestTime-margin;return eventFilter?withinTime&&eventFilter(e,ix,arr):withinTime},onEnd)}playClosestToPropValue(prop,targetVal,onEnd,onBoundaryHit,eventFilter){const filter=(e,ix,arr)=>!!(eventFilter?eventFilter(e,ix,arr)&&e.relatedPoint:e.relatedPoint);let closestValDiff=Infinity,closestEvent=null;(this.playingChannels||this.channels).forEach(channel=>{const events=channel.events;let i=events.length;while(i--){if(!filter(events[i],i,events)){continue}const val=events[i].relatedPoint[prop],diff=defined(val)&&Math.abs(targetVal-val);if(diff!==false&&diff<closestValDiff){closestValDiff=diff;closestEvent=events[i]}}});if(closestEvent){this.play(e=>!!(closestEvent&&e.time<closestEvent.time+1&&e.time>closestEvent.time-1&&e.relatedPoint===closestEvent.relatedPoint),false,false,onEnd);this.playingChannels=this.playingChannels||this.channels;this.isPaused=true;this.isPlaying=false;this.resumeFromTime=closestEvent.time}else if(onBoundaryHit){onBoundaryHit({chart:this.chart,timeline:this})}}getEventsForPoint(point){return this.channels.reduce((events,channel)=>{const pointEvents=channel.events.filter(e=>e.relatedPoint===point);return events.concat(pointEvents)},[])}playSegment(segment,onEnd){const numSegments=100;const eventTimes={first:Infinity,last:-Infinity};this.channels.forEach(c=>{if(c.events.length){eventTimes.first=Math.min(c.events[0].time,eventTimes.first);eventTimes.last=Math.max(c.events[c.events.length-1].time,eventTimes.last)}});if(eventTimes.first<Infinity){const segmentSize=(eventTimes.last-eventTimes.first)/numSegments,fromTime=eventTimes.first+segment*segmentSize,toTime=fromTime+segmentSize;if(!this.channels.some(c=>{const events=c.events;let s=0,e=events.length;while(s<e){const mid=s+e>>1,t=events[mid].time;if(t<fromTime){s=mid+1}else if(t>toTime){e=mid}else{return true}}return false})){return}this.play(e=>e.time>=fromTime&&e.time<=toTime,false,false,onEnd);this.playingChannels=this.playingChannels||this.channels;this.isPaused=true;this.isPlaying=false;this.resumeFromTime=toTime}}getLastPlayedPoint(filter){const curTime=this.getCurrentTime(),channels=this.playingChannels||this.channels;let closestDiff=Infinity,closestPoint=null;channels.forEach(c=>{const events=c.events.filter((e,ix,arr)=>!!(e.relatedPoint&&e.time<=curTime&&(!filter||filter(e,ix,arr)))),closestEvent=events[events.length-1];if(closestEvent){const closestTime=closestEvent.time,diff=Math.abs(closestTime-curTime);if(diff<closestDiff){closestDiff=diff;closestPoint=closestEvent.relatedPoint}}});return closestPoint}reset(){if(this.isPlaying){this.cancel()}this.resetPlayState()}cancel(){const onStop=this.options.onStop;if(onStop){onStop({chart:this.chart,timeline:this})}this.isPlaying=false;this.channels.forEach(c=>c.cancel());if(this.playingChannels&&this.playingChannels!==this.channels){this.playingChannels.forEach(c=>c.cancel())}this.clearScheduledCallbacks();this.resumeFromTime=0}destroy(){this.cancel();if(this.playingChannels&&this.playingChannels!==this.channels){this.playingChannels.forEach(c=>c.destroy())}this.channels.forEach(c=>c.destroy())}setMasterVolume(vol){this.channels.forEach(c=>c.engine.setMasterVolume(vol))}getMIDIData(){return toMIDI(this.channels.filter(c=>c.type==="instrument"))}downloadMIDI(filename){const data=this.getMIDIData(),name=(filename||this.chart&&this.chart.options.title&&this.chart.options.title.text||"chart")+".mid",blob=new Blob([data],{type:"application/octet-stream"}),url=window.URL.createObjectURL(blob);downloadURL(url,name);window.URL.revokeObjectURL(url)}resetPlayState(){delete this.playingChannels;delete this.onEndArgument;this.playTimestamp=this.resumeFromTime=0;this.isPaused=false}clearScheduledCallbacks(){this.scheduledCallbacks.forEach(clearTimeout);this.scheduledCallbacks=[]}}export default SonificationTimeline;"";