"use strict";import U from"../../Core/Utilities.js";const{clamp,defined,pick}=U;function getPitchTrackedMultiplierVal(multiplier,freq){const a=.2414*multiplier-.2414,b=(3.5-1.7*multiplier)/1.8;return a*Math.log(freq)+b}function miniRampToVolAtTime(gainNode,time,vol){gainNode.gain.cancelScheduledValues(time);gainNode.gain.setTargetAtTime(vol,time,SynthPatch.stopRampTime/4);gainNode.gain.setValueAtTime(vol,time+SynthPatch.stopRampTime)}function scheduleGainEnvelope(envelope,type,time,gainNode,volumeMultiplier=1){const isAtk=type==="attack",gain=gainNode.gain;gain.cancelScheduledValues(time);if(!envelope.length){miniRampToVolAtTime(gainNode,time,isAtk?volumeMultiplier:0);return}if(envelope[0].t>1){envelope.unshift({t:0,vol:isAtk?0:1})}envelope.forEach((ep,ix)=>{const prev=envelope[ix-1],delta=prev?(ep.t-prev.t)/1e3:0,startTime=time+(prev?prev.t/1e3+SynthPatch.stopRampTime:0);gain.setTargetAtTime(ep.vol*volumeMultiplier,startTime,Math.max(delta,SynthPatch.stopRampTime)/2)})}class PulseOscNode{constructor(context,options){this.pulseWidth=Math.min(Math.max(0,options.pulseWidth||.5));const makeOsc=()=>new OscillatorNode(context,{type:"sawtooth",detune:options.detune,frequency:Math.max(1,options.frequency||350)});this.sawOscA=makeOsc();this.sawOscB=makeOsc();this.phaseInverter=new GainNode(context,{gain:-1});this.masterGain=new GainNode(context);this.delayNode=new DelayNode(context,{delayTime:this.pulseWidth/this.sawOscA.frequency.value});this.sawOscA.connect(this.masterGain);this.sawOscB.connect(this.phaseInverter);this.phaseInverter.connect(this.delayNode);this.delayNode.connect(this.masterGain)}connect(destination){this.masterGain.connect(destination)}getFrequencyFacade(){const pulse=this;return{cancelScheduledValues(fromTime){pulse.sawOscA.frequency.cancelScheduledValues(fromTime);pulse.sawOscB.frequency.cancelScheduledValues(fromTime);pulse.delayNode.delayTime.cancelScheduledValues(fromTime);return pulse.sawOscA.frequency},setValueAtTime(frequency,time){this.cancelScheduledValues(time);pulse.sawOscA.frequency.setValueAtTime(frequency,time);pulse.sawOscB.frequency.setValueAtTime(frequency,time);pulse.delayNode.delayTime.setValueAtTime(Math.round(1e4*pulse.pulseWidth/frequency)/1e4,time);return pulse.sawOscA.frequency},setTargetAtTime(frequency,time,timeConstant){this.cancelScheduledValues(time);pulse.sawOscA.frequency.setTargetAtTime(frequency,time,timeConstant);pulse.sawOscB.frequency.setTargetAtTime(frequency,time,timeConstant);pulse.delayNode.delayTime.setTargetAtTime(Math.round(1e4*pulse.pulseWidth/frequency)/1e4,time,timeConstant);return pulse.sawOscA.frequency}}}getPWMTarget(){return this.delayNode.delayTime}start(){this.sawOscA.start();this.sawOscB.start()}stop(time){this.sawOscA.stop(time);this.sawOscB.stop(time)}}class Oscillator{constructor(audioContext,options,destination){this.audioContext=audioContext;this.options=options;this.fmOscillatorIx=options.fmOscillator;this.vmOscillatorIx=options.vmOscillator;this.createSoundSource();this.createGain();this.createFilters();this.createVolTracking();if(destination){this.connect(destination)}}connect(destination){[this.lowpassNode,this.highpassNode,this.volTrackingNode,this.vmNode,this.gainNode,this.whiteNoise,this.pulseNode,this.oscNode].reduce((prev,cur)=>cur?(cur.connect(prev),cur):prev,destination)}start(){if(this.oscNode){this.oscNode.start()}if(this.whiteNoise){this.whiteNoise.start()}if(this.pulseNode){this.pulseNode.start()}}stopAtTime(time){if(this.oscNode){this.oscNode.stop(time)}if(this.whiteNoise){this.whiteNoise.stop(time)}if(this.pulseNode){this.pulseNode.stop(time)}}setFreqAtTime(time,frequency,glideDuration=0){const opts=this.options,f=clamp(pick(opts.fixedFrequency,frequency)*(opts.freqMultiplier||1),0,21e3),oscTarget=this.getOscTarget(),timeConstant=glideDuration/5e3;if(oscTarget){oscTarget.cancelScheduledValues(time);if(glideDuration&&time-(this.lastUpdateTime||-1)>.01){oscTarget.setTargetAtTime(f,time,timeConstant);oscTarget.setValueAtTime(f,time+timeConstant)}else{oscTarget.setValueAtTime(f,time)}}this.scheduleVolTrackingChange(f,time,glideDuration);this.scheduleFilterTrackingChange(f,time,glideDuration);this.lastUpdateTime=time}getFMTarget(){return this.oscNode&&this.oscNode.detune||this.whiteNoise&&this.whiteNoise.detune||this.pulseNode&&this.pulseNode.getPWMTarget()}getVMTarget(){return this.vmNode&&this.vmNode.gain}runEnvelopeAtTime(type,time){if(!this.gainNode){return}const env=(type==="attack"?this.options.attackEnvelope:this.options.releaseEnvelope)||[];scheduleGainEnvelope(env,type,time,this.gainNode,this.options.volume)}cancelScheduled(){if(this.gainNode){this.gainNode.gain.cancelScheduledValues(this.audioContext.currentTime)}const oscTarget=this.getOscTarget();if(oscTarget){oscTarget.cancelScheduledValues(0)}if(this.lowpassNode){this.lowpassNode.frequency.cancelScheduledValues(0)}if(this.highpassNode){this.highpassNode.frequency.cancelScheduledValues(0)}if(this.volTrackingNode){this.volTrackingNode.gain.cancelScheduledValues(0)}}scheduleVolTrackingChange(frequency,time,glideDuration){if(this.volTrackingNode){const v=getPitchTrackedMultiplierVal(this.options.volumePitchTrackingMultiplier||1,frequency),rampTime=glideDuration?glideDuration/1e3:SynthPatch.stopRampTime;this.volTrackingNode.gain.cancelScheduledValues(time);this.volTrackingNode.gain.setTargetAtTime(v,time,rampTime/5);this.volTrackingNode.gain.setValueAtTime(v,time+rampTime)}}scheduleFilterTrackingChange(frequency,time,glideDuration){const opts=this.options,rampTime=glideDuration?glideDuration/1e3:SynthPatch.stopRampTime,scheduleFilterTarget=(filterNode,filterOptions)=>{const multiplier=getPitchTrackedMultiplierVal(filterOptions.frequencyPitchTrackingMultiplier||1,frequency),f=clamp((filterOptions.frequency||1e3)*multiplier,0,21e3);filterNode.frequency.cancelScheduledValues(time);filterNode.frequency.setTargetAtTime(f,time,rampTime/5);filterNode.frequency.setValueAtTime(f,time+rampTime)};if(this.lowpassNode&&opts.lowpass){scheduleFilterTarget(this.lowpassNode,opts.lowpass)}if(this.highpassNode&&opts.highpass){scheduleFilterTarget(this.highpassNode,opts.highpass)}}createGain(){const opts=this.options,needsGainNode=defined(opts.volume)||opts.attackEnvelope&&opts.attackEnvelope.length||opts.releaseEnvelope&&opts.releaseEnvelope.length;if(needsGainNode){this.gainNode=new GainNode(this.audioContext,{gain:pick(opts.volume,1)})}this.vmNode=new GainNode(this.audioContext)}createSoundSource(){const opts=this.options,ctx=this.audioContext,frequency=(opts.fixedFrequency||0)*(opts.freqMultiplier||1);if(opts.type==="whitenoise"){const bSize=ctx.sampleRate*2,buffer=ctx.createBuffer(1,bSize,ctx.sampleRate),data=buffer.getChannelData(0);for(let i=0;i<bSize;++i){data[i]=Math.random()*1.2-.6}const wn=this.whiteNoise=ctx.createBufferSource();wn.buffer=buffer;wn.loop=true}else if(opts.type==="pulse"){this.pulseNode=new PulseOscNode(ctx,{detune:opts.detune,pulseWidth:opts.pulseWidth,frequency:frequency})}else{this.oscNode=new OscillatorNode(ctx,{type:opts.type||"sine",detune:opts.detune,frequency:frequency})}}createFilters(){const opts=this.options;if(opts.lowpass&&opts.lowpass.frequency){this.lowpassNode=new BiquadFilterNode(this.audioContext,{type:"lowpass",Q:opts.lowpass.Q||1,frequency:opts.lowpass.frequency})}if(opts.highpass&&opts.highpass.frequency){this.highpassNode=new BiquadFilterNode(this.audioContext,{type:"highpass",Q:opts.highpass.Q||1,frequency:opts.highpass.frequency})}}createVolTracking(){const opts=this.options;if(opts.volumePitchTrackingMultiplier&&opts.volumePitchTrackingMultiplier!==1){this.volTrackingNode=new GainNode(this.audioContext,{gain:1})}}getOscTarget(){return this.oscNode?this.oscNode.frequency:this.pulseNode&&this.pulseNode.getFrequencyFacade()}}class SynthPatch{constructor(audioContext,options){this.audioContext=audioContext;this.options=options;this.eqNodes=[];this.midiInstrument=options.midiInstrument||1;this.outputNode=new GainNode(audioContext,{gain:0});this.createEqChain(this.outputNode);const inputNode=this.eqNodes.length?this.eqNodes[0]:this.outputNode;this.oscillators=(this.options.oscillators||[]).map(oscOpts=>new Oscillator(audioContext,oscOpts,defined(oscOpts.fmOscillator)||defined(oscOpts.vmOscillator)?void 0:inputNode));this.oscillators.forEach(osc=>{const connectTarget=(targetFunc,targetOsc)=>{if(targetOsc){const target=targetOsc[targetFunc]();if(target){osc.connect(target)}}};if(defined(osc.fmOscillatorIx)){connectTarget("getFMTarget",this.oscillators[osc.fmOscillatorIx])}if(defined(osc.vmOscillatorIx)){connectTarget("getVMTarget",this.oscillators[osc.vmOscillatorIx])}})}startSilently(){this.outputNode.gain.value=0;this.oscillators.forEach(o=>o.start())}stop(){const curTime=this.audioContext.currentTime,endTime=curTime+SynthPatch.stopRampTime;miniRampToVolAtTime(this.outputNode,curTime,0);this.oscillators.forEach(o=>o.stopAtTime(endTime));this.outputNode.disconnect()}silenceAtTime(time){if(!time&&this.outputNode.gain.value<.01){this.outputNode.gain.value=0;return}this.releaseAtTime((time||0)+this.audioContext.currentTime)}mute(){this.cancelScheduled();miniRampToVolAtTime(this.outputNode,this.audioContext.currentTime,0)}playFreqAtTime(time,frequency,noteDuration){const t=(time||0)+this.audioContext.currentTime,opts=this.options;this.oscillators.forEach(o=>{o.setFreqAtTime(t,frequency,opts.noteGlideDuration);o.runEnvelopeAtTime("attack",t)});scheduleGainEnvelope(opts.masterAttackEnvelope||[],"attack",t,this.outputNode,opts.masterVolume);if(noteDuration){this.releaseAtTime(t+noteDuration/1e3)}}cancelScheduled(){this.outputNode.gain.cancelScheduledValues(this.audioContext.currentTime);this.oscillators.forEach(o=>o.cancelScheduled())}connect(destinationNode){return this.outputNode.connect(destinationNode)}createEqChain(outputNode){this.eqNodes=(this.options.eq||[]).map(eqDef=>new BiquadFilterNode(this.audioContext,{type:"peaking",...eqDef}));this.eqNodes.reduceRight((chain,node)=>{node.connect(chain);return node},outputNode)}releaseAtTime(time){let maxReleaseDuration=0;this.oscillators.forEach(o=>{const env=o.options.releaseEnvelope;if(env&&env.length){maxReleaseDuration=Math.max(maxReleaseDuration,env[env.length-1].t);o.runEnvelopeAtTime("release",time)}});const masterEnv=this.options.masterReleaseEnvelope||[];if(masterEnv.length){scheduleGainEnvelope(masterEnv,"release",time,this.outputNode,this.options.masterVolume);maxReleaseDuration=Math.max(maxReleaseDuration,masterEnv[masterEnv.length-1].t)}miniRampToVolAtTime(this.outputNode,time+maxReleaseDuration/1e3,0)}}SynthPatch.stopRampTime=.012;export default SynthPatch;"";