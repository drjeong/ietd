"use strict";import BoostableMap from"./BoostableMap.js";import Boostables from"./Boostables.js";import BoostChart from"./BoostChart.js";const{getBoostClipRect,isChartSeriesBoosting}=BoostChart;import D from"../../Core/Defaults.js";const{getOptions}=D;import H from"../../Core/Globals.js";const{composed,doc,noop,win}=H;import U from"../../Core/Utilities.js";const{addEvent,destroyObjectProperties,error,extend,fireEvent,isArray,isNumber,pick,pushUnique,wrap,defined}=U;import WGLRenderer from"./WGLRenderer.js";const CHUNK_SIZE=3e3;let index,mainCanvas;function allocateIfNotSeriesBoosting(renderer,series){const boost=series.boost;if(renderer&&boost&&boost.target&&boost.canvas&&!isChartSeriesBoosting(series.chart)){renderer.allocateBufferForSingleSeries(series)}}function boostEnabled(chart){return pick(chart&&chart.options&&chart.options.boost&&chart.options.boost.enabled,true)}function compose(SeriesClass,seriesTypes,wglMode){if(pushUnique(composed,"Boost.Series")){const plotOptions=getOptions().plotOptions,seriesProto=SeriesClass.prototype;addEvent(SeriesClass,"destroy",onSeriesDestroy);addEvent(SeriesClass,"hide",onSeriesHide);if(wglMode){seriesProto.renderCanvas=seriesRenderCanvas}wrap(seriesProto,"getExtremes",wrapSeriesGetExtremes);wrap(seriesProto,"processData",wrapSeriesProcessData);wrap(seriesProto,"searchPoint",wrapSeriesSearchPoint);["translate","generatePoints","drawTracker","drawPoints","render"].forEach(method=>wrapSeriesFunctions(seriesProto,seriesTypes,method));Boostables.forEach(type=>{const typePlotOptions=plotOptions[type];if(typePlotOptions){typePlotOptions.boostThreshold=5e3;typePlotOptions.boostData=[];seriesTypes[type].prototype.fillOpacity=true}});if(wglMode){const{area:AreaSeries,areaspline:AreaSplineSeries,bubble:BubbleSeries,column:ColumnSeries,heatmap:HeatmapSeries,scatter:ScatterSeries,treemap:TreemapSeries}=seriesTypes;if(AreaSeries){extend(AreaSeries.prototype,{fill:true,fillOpacity:true,sampling:true})}if(AreaSplineSeries){extend(AreaSplineSeries.prototype,{fill:true,fillOpacity:true,sampling:true})}if(BubbleSeries){const bubbleProto=BubbleSeries.prototype;delete bubbleProto.buildKDTree;wrap(bubbleProto,"markerAttribs",function(proceed){if(this.boosted){return false}return proceed.apply(this,[].slice.call(arguments,1))})}if(ColumnSeries){extend(ColumnSeries.prototype,{fill:true,sampling:true})}if(ScatterSeries){ScatterSeries.prototype.fill=true}[HeatmapSeries,TreemapSeries].forEach(SC=>{if(SC){wrap(SC.prototype,"drawPoints",wrapSeriesDrawPoints)}})}}return SeriesClass}function createAndAttachRenderer(chart,series){const ChartClass=chart.constructor,targetGroup=chart.seriesGroup||series.group,alpha=1;let width=chart.chartWidth,height=chart.chartHeight,target=chart,foSupported=typeof SVGForeignObjectElement!=="undefined",hasClickHandler=false;if(isChartSeriesBoosting(chart)){target=chart}else{target=series;hasClickHandler=Boolean(series.options.events?.click||series.options.point?.events?.click)}const boost=target.boost=target.boost||{};foSupported=false;if(!mainCanvas){mainCanvas=doc.createElement("canvas")}if(!boost.target){boost.canvas=mainCanvas;if(chart.renderer.forExport||!foSupported){target.renderTarget=boost.target=chart.renderer.image("",0,0,width,height).addClass("highcharts-boost-canvas").add(targetGroup);boost.clear=function(){boost.target.attr({href:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="})};boost.copy=function(){boost.resize();boost.target.attr({href:boost.canvas.toDataURL("image/png")})}}else{boost.targetFo=chart.renderer.createElement("foreignObject").add(targetGroup);target.renderTarget=boost.target=doc.createElement("canvas");boost.targetCtx=boost.target.getContext("2d");boost.targetFo.element.appendChild(boost.target);boost.clear=function(){boost.target.width=boost.canvas.width;boost.target.height=boost.canvas.height};boost.copy=function(){boost.target.width=boost.canvas.width;boost.target.height=boost.canvas.height;boost.targetCtx.drawImage(boost.canvas,0,0)}}boost.resize=function(){width=chart.chartWidth;height=chart.chartHeight;(boost.targetFo||boost.target).attr({x:0,y:0,width:width,height:height}).css({pointerEvents:hasClickHandler?void 0:"none",mixedBlendMode:"normal",opacity:alpha}).addClass(hasClickHandler?"highcharts-tracker":"");if(target instanceof ChartClass){target.boost?.markerGroup?.translate(chart.plotLeft,chart.plotTop)}};boost.clipRect=chart.renderer.clipRect();(boost.targetFo||boost.target).attr({zIndex:series.options.zIndex});if(target instanceof ChartClass){target.boost.markerGroup=target.renderer.g().add(targetGroup).translate(series.xAxis.pos,series.yAxis.pos)}}boost.canvas.width=width;boost.canvas.height=height;if(boost.clipRect){const box=getBoostClipRect(chart,target),clippedElement=box.width===chart.clipBox.width&&box.height===chart.clipBox.height?targetGroup:boost.targetFo||boost.target;boost.clipRect.attr(box);clippedElement?.clip(boost.clipRect)}boost.resize();boost.clear();if(!boost.wgl){boost.wgl=new WGLRenderer(wgl=>{if(wgl.settings.debug.timeBufferCopy){console.time("buffer copy")}boost.copy();if(wgl.settings.debug.timeBufferCopy){console.timeEnd("buffer copy")}});if(!boost.wgl.init(boost.canvas)){error("[highcharts boost] - unable to init WebGL renderer")}boost.wgl.setOptions(chart.options.boost||{});if(target instanceof ChartClass){boost.wgl.allocateBuffer(chart)}}boost.wgl.setSize(width,height);return boost.wgl}function destroyGraphics(series){const points=series.points;if(points){let point,i;for(i=0;i<points.length;i=i+1){point=points[i];if(point&&point.destroyElements){point.destroyElements()}}}["graph","area","tracker"].forEach(prop=>{const seriesProp=series[prop];if(seriesProp){series[prop]=seriesProp.destroy()}});for(const zone of series.zones){destroyObjectProperties(zone,void 0,true)}}function eachAsync(arr,fn,finalFunc,chunkSize,i,noTimeout){i=i||0;chunkSize=chunkSize||CHUNK_SIZE;const threshold=i+chunkSize;let proceed=true;while(proceed&&i<threshold&&i<arr.length){proceed=fn(arr[i],i);++i}if(proceed){if(i<arr.length){if(noTimeout){eachAsync(arr,fn,finalFunc,chunkSize,i,noTimeout)}else if(win.requestAnimationFrame){win.requestAnimationFrame(function(){eachAsync(arr,fn,finalFunc,chunkSize,i)})}else{setTimeout(eachAsync,0,arr,fn,finalFunc,chunkSize,i)}}else if(finalFunc){finalFunc()}}}function enterBoost(series){series.boost=series.boost||{getPoint:bp=>getPoint(series,bp)};const alteredByBoost=series.boost.altered=[];["allowDG","directTouch","stickyTracking"].forEach(prop=>{alteredByBoost.push({prop:prop,val:series[prop],own:Object.hasOwnProperty.call(series,prop)})});series.allowDG=false;series.directTouch=false;series.stickyTracking=true;series.finishedAnimating=true;if(series.labelBySeries){series.labelBySeries=series.labelBySeries.destroy()}if(series.is("scatter")&&!series.is("treemap")&&series.data.length){for(const point of series.data){point?.destroy?.()}series.data.length=0;series.points.length=0;delete series.processedData}}function exitBoost(series){const boost=series.boost,chart=series.chart,chartBoost=chart.boost;if(chartBoost?.markerGroup){chartBoost.markerGroup.destroy();chartBoost.markerGroup=void 0;for(const s of chart.series){s.markerGroup=void 0;s.markerGroup=s.plotGroup("markerGroup","markers","visible",1,chart.seriesGroup).addClass("highcharts-tracker")}}if(boost){(boost.altered||[]).forEach(setting=>{if(setting.own){series[setting.prop]=setting.val}else{delete series[setting.prop]}});if(boost.clear){boost.clear()}}(chart.seriesGroup||series.group)?.clip()}function hasExtremes(series,checkX){const options=series.options,dataLength=series.dataTable.modified.rowCount,xAxis=series.xAxis&&series.xAxis.options,yAxis=series.yAxis&&series.yAxis.options,colorAxis=series.colorAxis&&series.colorAxis.options;return dataLength>(options.boostThreshold||Number.MAX_VALUE)&&isNumber(yAxis.min)&&isNumber(yAxis.max)&&(!checkX||isNumber(xAxis.min)&&isNumber(xAxis.max))&&(!colorAxis||isNumber(colorAxis.min)&&isNumber(colorAxis.max))}const getSeriesBoosting=(series,data)=>{if(series.forceCrop){return false}return isChartSeriesBoosting(series.chart)||(data?data.length:0)>=(series.options.boostThreshold||Number.MAX_VALUE)};function onSeriesDestroy(){const series=this,chart=series.chart;if(chart.boost&&chart.boost.markerGroup===series.markerGroup){series.markerGroup=null}if(chart.hoverPoints){chart.hoverPoints=chart.hoverPoints.filter(function(point){return point.series===series})}if(chart.hoverPoint&&chart.hoverPoint.series===series){chart.hoverPoint=null}}function onSeriesHide(){const boost=this.boost;if(boost&&boost.canvas&&boost.target){if(boost.wgl){boost.wgl.clear()}if(boost.clear){boost.clear()}}}function renderIfNotSeriesBoosting(series){const boost=series.boost;if(boost&&boost.canvas&&boost.target&&boost.wgl&&!isChartSeriesBoosting(series.chart)){boost.wgl.render(series.chart)}}function getPoint(series,boostPoint){const seriesOptions=series.options,xAxis=series.xAxis,PointClass=series.pointClass;if(boostPoint instanceof PointClass){return boostPoint}const xData=(series.getColumn("x").length?series.getColumn("x"):void 0)||seriesOptions.xData||series.getColumn("x",true)||false,point=new PointClass(series,(isArray(series.options.data)?series.options.data:[])[boostPoint.i],xData?xData[boostPoint.i]:void 0);point.category=pick(xAxis.categories?xAxis.categories[point.x]:point.x,point.x);point.key=point.name??point.category;point.dist=boostPoint.dist;point.distX=boostPoint.distX;point.plotX=boostPoint.plotX;point.plotY=boostPoint.plotY;point.index=boostPoint.i;point.percentage=boostPoint.percentage;point.isInside=series.isPointInside(point);return point}function scatterProcessData(force){var _a,_b,_c,_d;const series=this,{options,xAxis,yAxis}=series;if(!series.isDirty&&!xAxis.isDirty&&!yAxis.isDirty&&!force){return false}series.yAxis.setTickInterval();const boostThreshold=options.boostThreshold||0,cropThreshold=options.cropThreshold,xData=series.getColumn("x"),xExtremes=xAxis.getExtremes(),xMax=xExtremes.max??Number.MAX_VALUE,xMin=xExtremes.min??-Number.MAX_VALUE,yData=series.getColumn("y"),yExtremes=yAxis.getExtremes(),yMax=yExtremes.max??Number.MAX_VALUE,yMin=yExtremes.min??-Number.MAX_VALUE;if(!series.boosted&&xAxis.old&&yAxis.old&&xMin>=(xAxis.old.min??-Number.MAX_VALUE)&&xMax<=(xAxis.old.max??Number.MAX_VALUE)&&yMin>=(yAxis.old.min??-Number.MAX_VALUE)&&yMax<=(yAxis.old.max??Number.MAX_VALUE)){series.dataTable.modified.setColumns({x:xData,y:yData});return true}const dataLength=series.dataTable.rowCount;if(!boostThreshold||dataLength<boostThreshold||cropThreshold&&!series.forceCrop&&!series.getExtremesFromAll&&!options.getExtremesFromAll&&dataLength<cropThreshold){series.dataTable.modified.setColumns({x:xData,y:yData});return true}const processedData=[],processedXData=[],processedYData=[],xRangeNeeded=!(isNumber(xExtremes.max)||isNumber(xExtremes.min)),yRangeNeeded=!(isNumber(yExtremes.max)||isNumber(yExtremes.min));let cropped=false,x,xDataMax=xData[0],xDataMin=xData[0],y,yDataMax=yData?.[0],yDataMin=yData?.[0];for(let i=0,iEnd=xData.length;i<iEnd;++i){x=xData[i];y=yData?.[i];if(x>=xMin&&x<=xMax&&y>=yMin&&y<=yMax){processedData.push({x:x,y:y});processedXData.push(x);processedYData.push(y);if(xRangeNeeded){xDataMax=Math.max(xDataMax,x);xDataMin=Math.min(xDataMin,x)}if(yRangeNeeded){yDataMax=Math.max(yDataMax,y);yDataMin=Math.min(yDataMin,y)}}else{cropped=true}}if(xRangeNeeded){(_a=xAxis.options).max??(_a.max=xDataMax);(_b=xAxis.options).min??(_b.min=xDataMin)}if(yRangeNeeded){(_c=yAxis.options).max??(_c.max=yDataMax);(_d=yAxis.options).min??(_d.min=yDataMin)}series.cropped=cropped;series.cropStart=0;series.dataTable.modified.setColumns({x:processedXData,y:processedYData});if(!getSeriesBoosting(series,processedXData)){series.processedData=processedData}return true}function seriesRenderCanvas(){const options=this.options||{},chart=this.chart,chartBoost=chart.boost,seriesBoost=this.boost,xAxis=this.xAxis,yAxis=this.yAxis,xData=options.xData||this.getColumn("x",true),yData=options.yData||this.getColumn("y",true),lowData=this.getColumn("low",true),highData=this.getColumn("high",true),rawData=this.processedData||options.data,xExtremes=xAxis.getExtremes(),xMin=xExtremes.min-(xAxis.minPointOffset||0),xMax=xExtremes.max+(xAxis.minPointOffset||0),yExtremes=yAxis.getExtremes(),yMin=yExtremes.min-(yAxis.minPointOffset||0),yMax=yExtremes.max+(yAxis.minPointOffset||0),pointTaken={},sampling=!!this.sampling,enableMouseTracking=options.enableMouseTracking,threshold=options.threshold,isRange=this.pointArrayMap&&this.pointArrayMap.join(",")==="low,high",isStacked=!!options.stacking,cropStart=this.cropStart||0,requireSorting=this.requireSorting,useRaw=!xData,compareX=options.findNearestPointBy==="x",xDataFull=(this.getColumn("x",true).length?this.getColumn("x",true):void 0)||this.options.xData||this.getColumn("x",true),lineWidth=pick(options.lineWidth,1);let renderer=false,lastClientX,yBottom=yAxis.getThreshold(threshold),minVal,maxVal,minI,maxI;if(xAxis.isPanning||yAxis.isPanning){return}renderer=createAndAttachRenderer(chart,this);chart.boosted=true;if(!this.visible){return}if(this.points||this.graph){destroyGraphics(this)}if(!isChartSeriesBoosting(chart)){if(this.markerGroup===chartBoost?.markerGroup){this.markerGroup=void 0}this.markerGroup=this.plotGroup("markerGroup","markers","visible",1,chart.seriesGroup).addClass("highcharts-tracker")}else{if(this.markerGroup&&this.markerGroup!==chartBoost?.markerGroup){this.markerGroup.destroy()}this.markerGroup=chartBoost?.markerGroup;if(seriesBoost&&seriesBoost.target){this.renderTarget=seriesBoost.target=seriesBoost.target.destroy()}}const points=this.points=[],addKDPoint=(clientX,plotY,i,percentage)=>{const x=xDataFull?xDataFull[cropStart+i]:false,pushPoint=plotX=>{if(chart.inverted){plotX=xAxis.len-plotX;plotY=yAxis.len-plotY}points.push({destroy:noop,x:x,clientX:plotX,plotX:plotX,plotY:plotY,i:cropStart+i,percentage:percentage})};clientX=Math.ceil(clientX);index=compareX?clientX:clientX+","+plotY;if(enableMouseTracking){if(!pointTaken[index]){pointTaken[index]=true;pushPoint(clientX)}else if(x===xDataFull[xDataFull.length-1]){points.length--;pushPoint(clientX)}}};this.buildKDTree=noop;fireEvent(this,"renderCanvas");if(this.is("line")&&lineWidth>1&&seriesBoost?.target&&chartBoost&&!chartBoost.lineWidthFilter){chartBoost.lineWidthFilter=chart.renderer.definition({tagName:"filter",children:[{tagName:"feMorphology",attributes:{operator:"dilate",radius:.25*lineWidth}}],attributes:{id:"linewidth"}});seriesBoost.target.attr({filter:"url(#linewidth)"})}if(renderer){allocateIfNotSeriesBoosting(renderer,this);renderer.pushSeries(this);renderIfNotSeriesBoosting(this)}function processPoint(d,i){const chartDestroyed=typeof chart.index==="undefined";let x,y,clientX,plotY,percentage,low=false,isYInside=true;if(!defined(d)){return true}if(!chartDestroyed){if(useRaw){x=d[0];y=d[1]}else{x=d;y=yData?.[i]}if(isRange){if(useRaw){y=d.slice(1,3)}low=lowData[i];y=highData[i]}else if(isStacked){x=d.x;y=d.stackY;low=y-d.y;percentage=d.percentage}if(!requireSorting){isYInside=(y||0)>=yMin&&y<=yMax}if(y!==null&&x>=xMin&&x<=xMax&&isYInside){clientX=xAxis.toPixels(x,true);if(sampling){if(typeof minI==="undefined"||clientX===lastClientX){if(!isRange){low=y}if(typeof maxI==="undefined"||y>maxVal){maxVal=y;maxI=i}if(typeof minI==="undefined"||low<minVal){minVal=low;minI=i}}if(!compareX||clientX!==lastClientX){if(typeof minI!=="undefined"){plotY=yAxis.toPixels(maxVal,true);yBottom=yAxis.toPixels(minVal,true);addKDPoint(clientX,plotY,maxI,percentage);if(yBottom!==plotY){addKDPoint(clientX,yBottom,minI,percentage)}}minI=maxI=void 0;lastClientX=clientX}}else{plotY=Math.ceil(yAxis.toPixels(y,true));addKDPoint(clientX,plotY,i,percentage)}}}return!chartDestroyed}const boostOptions=renderer.settings,doneProcessing=()=>{fireEvent(this,"renderedCanvas");delete this.buildKDTree;if(this.options){this.buildKDTree()}if(boostOptions.debug.timeKDTree){console.timeEnd("kd tree building")}};if(!chart.renderer.forExport){if(boostOptions.debug.timeKDTree){console.time("kd tree building")}eachAsync(isStacked?this.data.slice(cropStart):xData||rawData,processPoint,doneProcessing)}}function wrapSeriesDrawPoints(proceed){let enabled=true;if(this.chart.options&&this.chart.options.boost){enabled=typeof this.chart.options.boost.enabled==="undefined"?true:this.chart.options.boost.enabled}if(!enabled||!this.boosted){return proceed.call(this)}this.chart.boosted=true;const renderer=createAndAttachRenderer(this.chart,this);if(renderer){allocateIfNotSeriesBoosting(renderer,this);renderer.pushSeries(this)}renderIfNotSeriesBoosting(this)}function wrapSeriesFunctions(seriesProto,seriesTypes,method){function branch(proceed){const letItPass=this.options.stacking&&(method==="translate"||method==="generatePoints");if(!this.boosted||letItPass||!boostEnabled(this.chart)||this.type==="heatmap"||this.type==="treemap"||!BoostableMap[this.type]||this.options.boostThreshold===0){proceed.call(this)}else if(method==="render"&&this.renderCanvas){this.renderCanvas()}}wrap(seriesProto,method,branch);if(method==="translate"){for(const type of["column","arearange","columnrange","heatmap","treemap"]){if(seriesTypes[type]){wrap(seriesTypes[type].prototype,method,branch)}}}}function wrapSeriesGetExtremes(proceed){if(this.boosted){if(hasExtremes(this)){return{}}if(this.xAxis.isPanning||this.yAxis.isPanning){return this}}return proceed.apply(this,[].slice.call(arguments,1))}function wrapSeriesProcessData(proceed){let dataToMeasure=this.options.data;if(boostEnabled(this.chart)&&BoostableMap[this.type]){const series=this,isScatter=series.is("scatter")&&!series.is("bubble")&&!series.is("treemap")&&!series.is("heatmap");if(!getSeriesBoosting(series,dataToMeasure)||isScatter||series.is("treemap")||series.options.stacking||!hasExtremes(series,true)){if(series.boosted&&(series.xAxis?.isPanning||series.yAxis?.isPanning)){return}if(isScatter&&!series.yAxis.treeGrid){scatterProcessData.call(series,arguments[1])}else{proceed.apply(series,[].slice.call(arguments,1))}dataToMeasure=series.getColumn("x",true)}series.boosted=getSeriesBoosting(series,dataToMeasure);if(series.boosted){let firstPoint;if(series.options.data?.length){firstPoint=series.getFirstValidPoint(series.options.data);if(!isNumber(firstPoint)&&!isArray(firstPoint)&&!series.is("treemap")){error(12,false,series.chart)}}enterBoost(series)}else{exitBoost(series)}}else{proceed.apply(this,[].slice.call(arguments,1))}}function wrapSeriesSearchPoint(proceed){const result=proceed.apply(this,[].slice.call(arguments,1));if(this.boost&&result){return this.boost.getPoint(result)}return result}const BoostSeries={compose:compose,destroyGraphics:destroyGraphics,eachAsync:eachAsync,getPoint:getPoint};export default BoostSeries;