"use strict";import Color from"../../Core/Color/Color.js";const{parse:color}=Color;import H from"../../Core/Globals.js";const{doc,win}=H;import U from"../../Core/Utilities.js";const{isNumber,isObject,merge,objectEach,pick}=U;import WGLDrawMode from"./WGLDrawMode.js";import WGLShader from"./WGLShader.js";import WGLVertexBuffer from"./WGLVertexBuffer.js";const asBar={column:true,columnrange:true,bar:true,area:true,areaspline:true,arearange:true};const asCircle={scatter:true,bubble:true};const contexts=["webgl","experimental-webgl","moz-webgl","webkit-3d"];class WGLRenderer{static orthoMatrix(width,height){const near=0,far=1;return[2/width,0,0,0,0,-(2/height),0,0,0,0,-2/(far-near),0,-1,1,-(far+near)/(far-near),1]}static seriesPointCount(series){let isStacked,xData,s;if(series.boosted){isStacked=!!series.options.stacking;xData=(series.getColumn("x").length?series.getColumn("x"):void 0)||series.options.xData||series.getColumn("x",true);s=(isStacked?series.data:xData||series.options.data).length;if(series.type==="treemap"){s*=12}else if(series.type==="heatmap"){s*=6}else if(asBar[series.type]){s*=2}return s}return 0}constructor(postRenderCallback){this.data=[];this.height=0;this.isInited=false;this.markerData=[];this.series=[];this.textureHandles={};this.width=0;this.postRenderCallback=postRenderCallback;this.settings={pointSize:1,lineWidth:1,fillColor:"#AA00AA",useAlpha:true,usePreallocated:false,useGPUTranslations:false,debug:{timeRendering:false,timeSeriesProcessing:false,timeSetup:false,timeBufferCopy:false,timeKDTree:false,showSkipSummary:false}}}getPixelRatio(){return this.settings.pixelRatio||win.devicePixelRatio||1}setOptions(options){if(!("pixelRatio"in options)){options.pixelRatio=1}merge(true,this.settings,options)}allocateBuffer(chart){const vbuffer=this.vbuffer;let s=0;if(!this.settings.usePreallocated){return}chart.series.forEach(series=>{if(series.boosted){s+=WGLRenderer.seriesPointCount(series)}});vbuffer&&vbuffer.allocate(s)}allocateBufferForSingleSeries(series){const vbuffer=this.vbuffer;let s=0;if(!this.settings.usePreallocated){return}if(series.boosted){s=WGLRenderer.seriesPointCount(series)}vbuffer&&vbuffer.allocate(s)}clear(){const gl=this.gl;gl&&gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)}pushSeriesData(series,inst){const data=this.data,settings=this.settings,vbuffer=this.vbuffer,isRange=series.pointArrayMap&&series.pointArrayMap.join(",")==="low,high",{chart,options,sorted,xAxis,yAxis}=series,isStacked=!!options.stacking,rawData=options.data,xExtremes=series.xAxis.getExtremes(),xMin=xExtremes.min-(series.xAxis.minPointOffset||0),xMax=xExtremes.max+(series.xAxis.minPointOffset||0),yExtremes=series.yAxis.getExtremes(),yMin=yExtremes.min-(series.yAxis.minPointOffset||0),yMax=yExtremes.max+(series.yAxis.minPointOffset||0),xData=(series.getColumn("x").length?series.getColumn("x"):void 0)||options.xData||series.getColumn("x",true),yData=(series.getColumn("y").length?series.getColumn("y"):void 0)||options.yData||series.getColumn("y",true),zData=(series.getColumn("z").length?series.getColumn("z"):void 0)||options.zData||series.getColumn("z",true),useRaw=!xData||xData.length===0,connectNulls=options.connectNulls,points=series.points||false,sdata=isStacked?series.data:xData||rawData,closestLeft={x:Number.MAX_VALUE,y:0},closestRight={x:-Number.MAX_VALUE,y:0},cullXThreshold=1,cullYThreshold=1,chartDestroyed=typeof chart.index==="undefined",drawAsBar=asBar[series.type],zoneAxis=options.zoneAxis||"y",zones=options.zones||false,threshold=options.threshold,pixelRatio=this.getPixelRatio();let plotWidth=series.chart.plotWidth,lastX=false,lastY=false,minVal,scolor,skipped=0,hadPoints=false,x,y,d,z,i=-1,px=false,nx=false,low,nextInside=false,prevInside=false,pcolor=false,isXInside=false,isYInside=true,firstPoint=true,zoneColors,zoneDefColor=false,gapSize=false,vlen=0;if(options.boostData&&options.boostData.length>0){return}if(options.gapSize){gapSize=options.gapUnit!=="value"?options.gapSize*series.closestPointRange:options.gapSize}if(zones){zoneColors=[];zones.forEach((zone,i)=>{if(zone.color){const zoneColor=color(zone.color).rgba;zoneColor[0]/=255;zoneColor[1]/=255;zoneColor[2]/=255;zoneColors[i]=zoneColor;if(!zoneDefColor&&typeof zone.value==="undefined"){zoneDefColor=zoneColor}}});if(!zoneDefColor){const seriesColor=series.pointAttribs&&series.pointAttribs().fill||series.color;zoneDefColor=color(seriesColor).rgba;zoneDefColor[0]/=255;zoneDefColor[1]/=255;zoneDefColor[2]/=255}}if(chart.inverted){plotWidth=series.chart.plotHeight}series.closestPointRangePx=Number.MAX_VALUE;const pushColor=color=>{if(color){inst.colorData.push(color[0]);inst.colorData.push(color[1]);inst.colorData.push(color[2]);inst.colorData.push(color[3])}};const vertice=(x,y,checkTreshold,pointSize=1,color)=>{pushColor(color);if(pixelRatio!==1&&(!settings.useGPUTranslations||inst.skipTranslation)){x*=pixelRatio;y*=pixelRatio;pointSize*=pixelRatio}if(settings.usePreallocated&&vbuffer){vbuffer.push(x,y,checkTreshold?1:0,pointSize);vlen+=4}else{data.push(x);data.push(y);data.push(checkTreshold?pixelRatio:0);data.push(pointSize)}};const closeSegment=()=>{if(inst.segments.length){inst.segments[inst.segments.length-1].to=data.length||vlen}};const beginSegment=()=>{if(inst.segments.length&&inst.segments[inst.segments.length-1].from===(data.length||vlen)){return}closeSegment();inst.segments.push({from:data.length||vlen})};const pushRect=(x,y,w,h,color)=>{pushColor(color);vertice(x+w,y);pushColor(color);vertice(x,y);pushColor(color);vertice(x,y+h);pushColor(color);vertice(x,y+h);pushColor(color);vertice(x+w,y+h);pushColor(color);vertice(x+w,y)};beginSegment();if(points&&points.length>0){inst.skipTranslation=true;inst.drawMode="TRIANGLES";if(points[0].node&&points[0].node.levelDynamic){points.sort((a,b)=>{if(a.node){if(a.node.levelDynamic>b.node.levelDynamic){return 1}if(a.node.levelDynamic<b.node.levelDynamic){return-1}}return 0})}points.forEach(point=>{const plotY=point.plotY;let swidth,pointAttr;if(typeof plotY!=="undefined"&&!isNaN(plotY)&&point.y!==null&&point.shapeArgs){let{x=0,y=0,width=0,height=0}=point.shapeArgs;pointAttr=chart.styledMode?point.series.colorAttribs(point):pointAttr=point.series.pointAttribs(point);swidth=pointAttr["stroke-width"]||0;pcolor=color(pointAttr.fill).rgba;pcolor[0]/=255;pcolor[1]/=255;pcolor[2]/=255;if(series.is("treemap")){swidth=swidth||1;scolor=color(pointAttr.stroke).rgba;scolor[0]/=255;scolor[1]/=255;scolor[2]/=255;pushRect(x,y,width,height,scolor);swidth/=2}if(series.is("heatmap")&&chart.inverted){x=xAxis.len-x;y=yAxis.len-y;width=-width;height=-height}pushRect(x+swidth,y+swidth,width-swidth*2,height-swidth*2,pcolor)}});closeSegment();return}while(i<sdata.length-1){d=sdata[++i];if(typeof d==="undefined"){continue}if(chartDestroyed){break}const pointOptions=rawData&&rawData[i];if(!useRaw&&isObject(pointOptions,true)){if(pointOptions.color){pcolor=color(pointOptions.color).rgba;pcolor[0]/=255;pcolor[1]/=255;pcolor[2]/=255}}if(useRaw){x=d[0];y=d[1];if(sdata[i+1]){nx=sdata[i+1][0]}if(sdata[i-1]){px=sdata[i-1][0]}if(d.length>=3){z=d[2];if(d[2]>inst.zMax){inst.zMax=d[2]}if(d[2]<inst.zMin){inst.zMin=d[2]}}}else{x=d;y=yData?.[i];if(sdata[i+1]){nx=sdata[i+1]}if(sdata[i-1]){px=sdata[i-1]}if(zData&&zData.length){z=zData[i];if(zData[i]>inst.zMax){inst.zMax=zData[i]}if(zData[i]<inst.zMin){inst.zMin=zData[i]}}}if(!connectNulls&&(x===null||y===null)){beginSegment();continue}if(nx&&nx>=xMin&&nx<=xMax){nextInside=true}if(px&&px>=xMin&&px<=xMax){prevInside=true}if(isRange){if(useRaw){y=d.slice(1,3)}low=series.getColumn("low",true)?.[i];y=series.getColumn("high",true)?.[i]||0}else if(isStacked){x=d.x;y=d.stackY;low=y-d.y}if(yMin!==null&&typeof yMin!=="undefined"&&yMax!==null&&typeof yMax!=="undefined"){isYInside=y>=yMin&&y<=yMax}if(!sorted&&!isYInside){continue}if(x>xMax&&closestRight.x<xMax){closestRight.x=x;closestRight.y=y}if(x<xMin&&closestLeft.x>xMin){closestLeft.x=x;closestLeft.y=y}if(y===null&&connectNulls){continue}if(y===null||!isYInside&&!nextInside&&!prevInside){beginSegment();continue}if(sorted&&((nx>=xMin||x>=xMin)&&(px<=xMax||x<=xMax))||!sorted&&(x>=xMin&&x<=xMax)){isXInside=true}if(!isXInside&&!nextInside&&!prevInside){continue}if(gapSize&&x-px>gapSize){beginSegment()}if(zones){let zoneColor;zones.some((zone,i)=>{const last=zones[i-1];if(zoneAxis==="x"){if(typeof zone.value!=="undefined"&&x<=zone.value){if(zoneColors[i]&&(!last||x>=last.value)){zoneColor=zoneColors[i]}return true}return false}if(typeof zone.value!=="undefined"&&y<=zone.value){if(zoneColors[i]&&(!last||y>=last.value)){zoneColor=zoneColors[i]}return true}return false});pcolor=zoneColor||zoneDefColor||pcolor}if(!settings.useGPUTranslations){inst.skipTranslation=true;x=xAxis.toPixels(x,true);y=yAxis.toPixels(y,true);if(x>plotWidth){if(inst.drawMode==="POINTS"){continue}}}if(inst.hasMarkers&&isXInside){if(lastX!==false){series.closestPointRangePx=Math.min(series.closestPointRangePx,Math.abs(x-lastX))}}if(!settings.useGPUTranslations&&!settings.usePreallocated&&(lastX&&Math.abs(x-lastX)<cullXThreshold)&&(lastY&&Math.abs(y-lastY)<cullYThreshold)){if(settings.debug.showSkipSummary){++skipped}continue}if(drawAsBar){minVal=low||0;if(low===false||typeof low==="undefined"){if(y<0){minVal=y}else{minVal=0}}if(!isRange&&!isStacked||yAxis.logarithmic){minVal=Math.max(threshold===null?yMin:threshold,yMin)}if(!settings.useGPUTranslations){minVal=yAxis.toPixels(minVal,true)}vertice(x,minVal,0,0,pcolor)}if(options.step&&!firstPoint){vertice(x,lastY,0,2,pcolor)}vertice(x,y,0,series.type==="bubble"?z||1:2,pcolor);lastX=x;lastY=y;hadPoints=true;firstPoint=false}if(settings.debug.showSkipSummary){console.log("skipped points:",skipped)}const pushSupplementPoint=(point,atStart)=>{if(!settings.useGPUTranslations){inst.skipTranslation=true;point.x=xAxis.toPixels(point.x,true);point.y=yAxis.toPixels(point.y,true)}if(atStart){this.data=[point.x,point.y,0,2].concat(this.data);return}vertice(point.x,point.y,0,2)};if(!hadPoints&&connectNulls!==false&&series.drawMode==="line_strip"){if(closestLeft.x<Number.MAX_VALUE){pushSupplementPoint(closestLeft,true)}if(closestRight.x>-Number.MAX_VALUE){pushSupplementPoint(closestRight)}}closeSegment()}pushSeries(s){const markerData=this.markerData,series=this.series,settings=this.settings;if(series.length>0){if(series[series.length-1].hasMarkers){series[series.length-1].markerTo=markerData.length}}if(settings.debug.timeSeriesProcessing){console.time("building "+s.type+" series")}const obj={segments:[],markerFrom:markerData.length,colorData:[],series:s,zMin:Number.MAX_VALUE,zMax:-Number.MAX_VALUE,hasMarkers:s.options.marker?s.options.marker.enabled!==false:false,showMarkers:true,drawMode:WGLDrawMode[s.type]||"LINE_STRIP"};if(s.index>=series.length){series.push(obj)}else{series[s.index]=obj}this.pushSeriesData(s,obj);if(settings.debug.timeSeriesProcessing){console.timeEnd("building "+s.type+" series")}}flush(){const vbuffer=this.vbuffer;this.data=[];this.markerData=[];this.series=[];if(vbuffer){vbuffer.destroy()}}setXAxis(axis){const shader=this.shader;if(!shader){return}const pixelRatio=this.getPixelRatio();shader.setUniform("xAxisTrans",axis.transA*pixelRatio);shader.setUniform("xAxisMin",axis.min);shader.setUniform("xAxisMinPad",axis.minPixelPadding*pixelRatio);shader.setUniform("xAxisPointRange",axis.pointRange);shader.setUniform("xAxisLen",axis.len*pixelRatio);shader.setUniform("xAxisPos",axis.pos*pixelRatio);shader.setUniform("xAxisCVSCoord",!axis.horiz);shader.setUniform("xAxisIsLog",!!axis.logarithmic);shader.setUniform("xAxisReversed",!!axis.reversed)}setYAxis(axis){const shader=this.shader;if(!shader){return}const pixelRatio=this.getPixelRatio();shader.setUniform("yAxisTrans",axis.transA*pixelRatio);shader.setUniform("yAxisMin",axis.min);shader.setUniform("yAxisMinPad",axis.minPixelPadding*pixelRatio);shader.setUniform("yAxisPointRange",axis.pointRange);shader.setUniform("yAxisLen",axis.len*pixelRatio);shader.setUniform("yAxisPos",axis.pos*pixelRatio);shader.setUniform("yAxisCVSCoord",!axis.horiz);shader.setUniform("yAxisIsLog",!!axis.logarithmic);shader.setUniform("yAxisReversed",!!axis.reversed)}setThreshold(has,translation){const shader=this.shader;if(!shader){return}shader.setUniform("hasThreshold",has);shader.setUniform("translatedThreshold",translation)}renderChart(chart){const gl=this.gl,settings=this.settings,shader=this.shader,vbuffer=this.vbuffer;const pixelRatio=this.getPixelRatio();if(chart){this.width=chart.chartWidth*pixelRatio;this.height=chart.chartHeight*pixelRatio}else{return false}const height=this.height,width=this.width;if(!gl||!shader||!width||!height){return false}if(settings.debug.timeRendering){console.time("gl rendering")}gl.canvas.width=width;gl.canvas.height=height;shader.bind();gl.viewport(0,0,width,height);shader.setPMatrix(WGLRenderer.orthoMatrix(width,height));if(settings.lineWidth>1&&!H.isMS){gl.lineWidth(settings.lineWidth)}if(vbuffer){vbuffer.build(this.data,"aVertexPosition",4);vbuffer.bind()}shader.setInverted(chart.inverted);this.series.forEach((s,si)=>{const options=s.series.options,shapeOptions=options.marker,lineWidth=typeof options.lineWidth!=="undefined"?options.lineWidth:1,threshold=options.threshold,hasThreshold=isNumber(threshold),yBottom=s.series.yAxis.getThreshold(threshold),translatedThreshold=yBottom,showMarkers=pick(options.marker?options.marker.enabled:null,s.series.xAxis.isRadial?true:null,s.series.closestPointRangePx>2*((options.marker?options.marker.radius:10)||10)),shapeTexture=this.textureHandles[shapeOptions&&shapeOptions.symbol||s.series.symbol]||this.textureHandles.circle;let sindex,cbuffer,fillColor,scolor=[];if(s.segments.length===0||s.segments[0].from===s.segments[0].to){return}if(shapeTexture.isReady){gl.bindTexture(gl.TEXTURE_2D,shapeTexture.handle);shader.setTexture(shapeTexture.handle)}if(chart.styledMode){if(s.series.markerGroup===s.series.chart.boost?.markerGroup){delete s.series.markerGroup;s.series.markerGroup=s.series.plotGroup("markerGroup","markers","visible",1,chart.seriesGroup).addClass("highcharts-tracker");fillColor=s.series.markerGroup.getStyle("fill");s.series.markerGroup.destroy();s.series.markerGroup=s.series.chart.boost?.markerGroup}else{fillColor=s.series.markerGroup?.getStyle("fill")}}else{fillColor=s.drawMode==="POINTS"&&s.series.pointAttribs&&s.series.pointAttribs().fill||s.series.color;if(options.colorByPoint){fillColor=s.series.chart.options.colors[si]}}if(s.series.fillOpacity&&options.fillOpacity){fillColor=new Color(fillColor).setOpacity(pick(options.fillOpacity,1)).get()}scolor=color(fillColor).rgba;if(!settings.useAlpha){scolor[3]=1}if(options.boostBlending==="add"){gl.blendFunc(gl.SRC_ALPHA,gl.ONE);gl.blendEquation(gl.FUNC_ADD)}else if(options.boostBlending==="mult"||options.boostBlending==="multiply"){gl.blendFunc(gl.DST_COLOR,gl.ZERO)}else if(options.boostBlending==="darken"){gl.blendFunc(gl.ONE,gl.ONE);gl.blendEquation(gl.FUNC_MIN)}else{gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA)}shader.reset();if(s.colorData.length>0){shader.setUniform("hasColor",1);cbuffer=new WGLVertexBuffer(gl,shader);cbuffer.build(Array(s.segments[0].from).concat(s.colorData),"aColor",4);cbuffer.bind()}else{shader.setUniform("hasColor",0);gl.disableVertexAttribArray(gl.getAttribLocation(shader.getProgram(),"aColor"))}shader.setColor(scolor);this.setXAxis(s.series.xAxis);this.setYAxis(s.series.yAxis);this.setThreshold(hasThreshold,translatedThreshold);if(s.drawMode==="POINTS"){shader.setPointSize(pick(options.marker&&options.marker.radius,.5)*2*pixelRatio)}shader.setSkipTranslation(s.skipTranslation);if(s.series.type==="bubble"){shader.setBubbleUniforms(s.series,s.zMin,s.zMax,pixelRatio)}shader.setDrawAsCircle(asCircle[s.series.type]||false);if(!vbuffer){return}if(lineWidth>0||s.drawMode!=="LINE_STRIP"){for(sindex=0;sindex<s.segments.length;sindex++){vbuffer.render(s.segments[sindex].from,s.segments[sindex].to,s.drawMode)}}if(s.hasMarkers&&showMarkers){shader.setPointSize(pick(options.marker&&options.marker.radius,5)*2*pixelRatio);shader.setDrawAsCircle(true);for(sindex=0;sindex<s.segments.length;sindex++){vbuffer.render(s.segments[sindex].from,s.segments[sindex].to,"POINTS")}}});if(settings.debug.timeRendering){console.timeEnd("gl rendering")}if(this.postRenderCallback){this.postRenderCallback(this)}this.flush()}render(chart){this.clear();if(chart.renderer.forExport){return this.renderChart(chart)}if(this.isInited){this.renderChart(chart)}else{setTimeout(()=>{this.render(chart)},1)}}setSize(width,height){const shader=this.shader;if(!shader||this.width===width&&this.height===height){return}this.width=width;this.height=height;shader.bind();shader.setPMatrix(WGLRenderer.orthoMatrix(width,height))}init(canvas,noFlush){const settings=this.settings;this.isInited=false;if(!canvas){return false}if(settings.debug.timeSetup){console.time("gl setup")}for(let i=0;i<contexts.length;++i){this.gl=canvas.getContext(contexts[i],{});if(this.gl){break}}const gl=this.gl;if(gl){if(!noFlush){this.flush()}}else{return false}gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);gl.disable(gl.DEPTH_TEST);gl.depthFunc(gl.LESS);const shader=this.shader=new WGLShader(gl);if(!shader){return false}this.vbuffer=new WGLVertexBuffer(gl,shader);const createTexture=(name,fn)=>{const props={isReady:false,texture:doc.createElement("canvas"),handle:gl.createTexture()},ctx=props.texture.getContext("2d");this.textureHandles[name]=props;props.texture.width=512;props.texture.height=512;ctx.mozImageSmoothingEnabled=false;ctx.webkitImageSmoothingEnabled=false;ctx.msImageSmoothingEnabled=false;ctx.imageSmoothingEnabled=false;ctx.strokeStyle="rgba(255, 255, 255, 0)";ctx.fillStyle="#FFF";fn(ctx);try{gl.activeTexture(gl.TEXTURE0);gl.bindTexture(gl.TEXTURE_2D,props.handle);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,props.texture);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.bindTexture(gl.TEXTURE_2D,null);props.isReady=true}catch(e){}};createTexture("circle",ctx=>{ctx.beginPath();ctx.arc(256,256,256,0,2*Math.PI);ctx.stroke();ctx.fill()});createTexture("square",ctx=>{ctx.fillRect(0,0,512,512)});createTexture("diamond",ctx=>{ctx.beginPath();ctx.moveTo(256,0);ctx.lineTo(512,256);ctx.lineTo(256,512);ctx.lineTo(0,256);ctx.lineTo(256,0);ctx.fill()});createTexture("triangle",ctx=>{ctx.beginPath();ctx.moveTo(0,512);ctx.lineTo(256,0);ctx.lineTo(512,512);ctx.lineTo(0,512);ctx.fill()});createTexture("triangle-down",ctx=>{ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(256,512);ctx.lineTo(512,0);ctx.lineTo(0,0);ctx.fill()});this.isInited=true;if(settings.debug.timeSetup){console.timeEnd("gl setup")}return true}destroy(){const gl=this.gl,shader=this.shader,vbuffer=this.vbuffer;this.flush();if(vbuffer){vbuffer.destroy()}if(shader){shader.destroy()}if(gl){objectEach(this.textureHandles,texture=>{if(texture.handle){gl.deleteTexture(texture.handle)}});gl.canvas.width=1;gl.canvas.height=1}}}export default WGLRenderer;