"use strict";var __spreadArray=this&&this.__spreadArray||function(to,from,pack){if(pack||arguments.length===2)for(var i=0,l=from.length,ar;i<l;i++){if(ar||!(i in from)){if(!ar)ar=Array.prototype.slice.call(from,0,i);ar[i]=from[i]}}return to.concat(ar||Array.prototype.slice.call(from))};import PC from"../Core/Geometry/PolygonClip.js";var clipLineString=PC.clipLineString,clipPolygon=PC.clipPolygon;import ProjectionRegistry from"./Projections/ProjectionRegistry.js";import U from"../Core/Utilities.js";var clamp=U.clamp,erase=U.erase;var deg2rad=Math.PI*2/360,floatCorrection=1e-6;var wrapLon=function(lon){if(lon<-180){lon+=360}if(lon>180){lon-=360}return lon};var hav=function(radians){return(1-Math.cos(radians))/2};var havFromCoords=function(point1,point2){var cos=Math.cos,lat1=point1[1]*deg2rad,lon1=point1[0]*deg2rad,lat2=point2[1]*deg2rad,lon2=point2[0]*deg2rad,deltaLat=lat2-lat1,deltaLon=lon2-lon1,havFromCoords=hav(deltaLat)+cos(lat1)*cos(lat2)*hav(deltaLon);return havFromCoords};var Projection=function(){function Projection(options){if(options===void 0){options={}}this.hasCoordinates=false;this.hasGeoProjection=false;this.maxLatitude=90;this.options=options;var name=options.name,projectedBounds=options.projectedBounds,rotation=options.rotation;this.rotator=rotation?this.getRotator(rotation):void 0;var ProjectionDefinition=name?Projection.registry[name]:void 0;if(ProjectionDefinition){this.def=new ProjectionDefinition(options)}var _a=this,def=_a.def,rotator=_a.rotator;if(def){this.maxLatitude=def.maxLatitude||90;this.hasGeoProjection=true}if(rotator&&def){this.forward=function(lonLat){return def.forward(rotator.forward(lonLat))};this.inverse=function(xy){return rotator.inverse(def.inverse(xy))}}else if(def){this.forward=function(lonLat){return def.forward(lonLat)};this.inverse=function(xy){return def.inverse(xy)}}else if(rotator){this.forward=rotator.forward;this.inverse=rotator.inverse}this.bounds=projectedBounds==="world"?def&&def.bounds:projectedBounds}Projection.add=function(name,definition){Projection.registry[name]=definition};Projection.distance=function(point1,point2){var atan2=Math.atan2,sqrt=Math.sqrt,hav=havFromCoords(point1,point2),angularDistance=2*atan2(sqrt(hav),sqrt(1-hav)),distance=angularDistance*6371e3;return distance};Projection.geodesic=function(point1,point2,inclusive,stepDistance){if(stepDistance===void 0){stepDistance=5e5}var atan2=Math.atan2,cos=Math.cos,sin=Math.sin,sqrt=Math.sqrt,distance=Projection.distance,lat1=point1[1]*deg2rad,lon1=point1[0]*deg2rad,lat2=point2[1]*deg2rad,lon2=point2[0]*deg2rad,cosLat1CosLon1=cos(lat1)*cos(lon1),cosLat2CosLon2=cos(lat2)*cos(lon2),cosLat1SinLon1=cos(lat1)*sin(lon1),cosLat2SinLon2=cos(lat2)*sin(lon2),sinLat1=sin(lat1),sinLat2=sin(lat2),pointDistance=distance(point1,point2),angDistance=pointDistance/6371e3,sinAng=sin(angDistance),jumps=Math.round(pointDistance/stepDistance),lineString=[];if(inclusive){lineString.push(point1)}if(jumps>1){var step=1/jumps;for(var fraction=step;fraction<.999;fraction+=step){var A=sin((1-fraction)*angDistance)/sinAng,B=sin(fraction*angDistance)/sinAng,x=A*cosLat1CosLon1+B*cosLat2CosLon2,y=A*cosLat1SinLon1+B*cosLat2SinLon2,z=A*sinLat1+B*sinLat2,lat3=atan2(z,sqrt(x*x+y*y)),lon3=atan2(y,x);lineString.push([lon3/deg2rad,lat3/deg2rad])}}if(inclusive){lineString.push(point2)}return lineString};Projection.insertGeodesics=function(poly){var i=poly.length-1;while(i--){var roughDistance=Math.max(Math.abs(poly[i][0]-poly[i+1][0]),Math.abs(poly[i][1]-poly[i+1][1]));if(roughDistance>10){var geodesic=Projection.geodesic(poly[i],poly[i+1]);if(geodesic.length){poly.splice.apply(poly,__spreadArray([i+1,0],geodesic,false))}}}};Projection.toString=function(options){var _a=options||{},name=_a.name,rotation=_a.rotation;return[name,rotation&&rotation.join(",")].join(";")};Projection.prototype.lineIntersectsBounds=function(line){var _a=this.bounds||{},x1=_a.x1,x2=_a.x2,y1=_a.y1,y2=_a.y2;var getIntersect=function(line,dim,val){var p1=line[0],p2=line[1],otherDim=dim?0:1;if(typeof val==="number"&&p1[dim]>=val!==p2[dim]>=val){var fraction=(val-p1[dim])/(p2[dim]-p1[dim]),crossingVal=p1[otherDim]+fraction*(p2[otherDim]-p1[otherDim]);return dim?[crossingVal,val]:[val,crossingVal]}};var intersection,ret=line[0];if(intersection=getIntersect(line,0,x1)){ret=intersection;line[1]=intersection}else if(intersection=getIntersect(line,0,x2)){ret=intersection;line[1]=intersection}if(intersection=getIntersect(line,1,y1)){ret=intersection}else if(intersection=getIntersect(line,1,y2)){ret=intersection}return ret};Projection.prototype.getRotator=function(rotation){var deltaLambda=rotation[0]*deg2rad,deltaPhi=(rotation[1]||0)*deg2rad,deltaGamma=(rotation[2]||0)*deg2rad;var cosDeltaPhi=Math.cos(deltaPhi),sinDeltaPhi=Math.sin(deltaPhi),cosDeltaGamma=Math.cos(deltaGamma),sinDeltaGamma=Math.sin(deltaGamma);if(deltaLambda===0&&deltaPhi===0&&deltaGamma===0){return}return{forward:function(lonLat){var lon=lonLat[0]*deg2rad+deltaLambda;var lat=lonLat[1]*deg2rad,cosLat=Math.cos(lat),x=Math.cos(lon)*cosLat,y=Math.sin(lon)*cosLat,sinLat=Math.sin(lat),k=sinLat*cosDeltaPhi+x*sinDeltaPhi;return[Math.atan2(y*cosDeltaGamma-k*sinDeltaGamma,x*cosDeltaPhi-sinLat*sinDeltaPhi)/deg2rad,Math.asin(k*cosDeltaGamma+y*sinDeltaGamma)/deg2rad]},inverse:function(rLonLat){var lon=rLonLat[0]*deg2rad;var lat=rLonLat[1]*deg2rad,cosLat=Math.cos(lat),x=Math.cos(lon)*cosLat,y=Math.sin(lon)*cosLat,sinLat=Math.sin(lat),k=sinLat*cosDeltaGamma-y*sinDeltaGamma;return[(Math.atan2(y*cosDeltaGamma+sinLat*sinDeltaGamma,x*cosDeltaPhi+k*sinDeltaPhi)-deltaLambda)/deg2rad,Math.asin(k*cosDeltaPhi-x*sinDeltaPhi)/deg2rad]}}};Projection.prototype.forward=function(lonLat){return lonLat};Projection.prototype.inverse=function(xy){return xy};Projection.prototype.cutOnAntimeridian=function(poly,isPolygon){var antimeridian=180,intersections=[];var polygons=[poly];for(var i=0,iEnd=poly.length;i<iEnd;++i){var lonLat=poly[i];var previousLonLat=poly[i-1];if(!i){if(!isPolygon){continue}previousLonLat=poly[poly.length-1]}var lon1=previousLonLat[0],lon2=lonLat[0];if((lon1<-90||lon1>90)&&(lon2<-90||lon2>90)&&lon1>0!==lon2>0){var fraction=clamp((antimeridian-(lon1+360)%360)/((lon2+360)%360-(lon1+360)%360),0,1),lat=previousLonLat[1]+fraction*(lonLat[1]-previousLonLat[1]);intersections.push({i:i,lat:lat,direction:lon1<0?1:-1,previousLonLat:previousLonLat,lonLat:lonLat})}}var polarIntersection;if(intersections.length){if(isPolygon){if(intersections.length%2===1){polarIntersection=intersections.slice().sort(function(a,b){return Math.abs(b.lat)-Math.abs(a.lat)})[0];erase(intersections,polarIntersection)}var i=intersections.length-2;while(i>=0){var index=intersections[i].i;var lonPlus=wrapLon(antimeridian+intersections[i].direction*floatCorrection);var lonMinus=wrapLon(antimeridian-intersections[i].direction*floatCorrection);var slice=poly.splice.apply(poly,__spreadArray([index,intersections[i+1].i-index],Projection.geodesic([lonPlus,intersections[i].lat],[lonPlus,intersections[i+1].lat],true),false));slice.push.apply(slice,Projection.geodesic([lonMinus,intersections[i+1].lat],[lonMinus,intersections[i].lat],true));polygons.push(slice);i-=2}if(polarIntersection){for(var i_1=0;i_1<polygons.length;i_1++){var direction=polarIntersection.direction,lat=polarIntersection.lat,poly_1=polygons[i_1],indexOf=poly_1.indexOf(polarIntersection.lonLat);if(indexOf>-1){var polarLatitude=(lat<0?-1:1)*this.maxLatitude;var lon1=wrapLon(antimeridian+direction*floatCorrection);var lon2=wrapLon(antimeridian-direction*floatCorrection);var polarSegment=Projection.geodesic([lon1,lat],[lon1,polarLatitude],true);for(var lon=lon1+120*direction;lon>-180&&lon<180;lon+=120*direction){polarSegment.push([lon,polarLatitude])}polarSegment.push.apply(polarSegment,Projection.geodesic([lon2,polarLatitude],[lon2,polarIntersection.lat],true));poly_1.splice.apply(poly_1,__spreadArray([indexOf,0],polarSegment,false));break}}}}else{var i=intersections.length;while(i--){var index=intersections[i].i;var slice=poly.splice(index,poly.length,[wrapLon(antimeridian+intersections[i].direction*floatCorrection),intersections[i].lat]);slice.unshift([wrapLon(antimeridian-intersections[i].direction*floatCorrection),intersections[i].lat]);polygons.push(slice)}}}return polygons};Projection.prototype.path=function(geometry){var _this=this;var _a=this,bounds=_a.bounds,def=_a.def,rotator=_a.rotator;var antimeridian=180;var path=[];var isPolygon=geometry.type==="Polygon"||geometry.type==="MultiPolygon";var hasGeoProjection=this.hasGeoProjection;var projectingToPlane=!def||def.antimeridianCutting!==false;var preclip=projectingToPlane?rotator:void 0;var postclip=projectingToPlane?def||this:this;var boundsPolygon;if(bounds){boundsPolygon=[[bounds.x1,bounds.y1],[bounds.x2,bounds.y1],[bounds.x2,bounds.y2],[bounds.x1,bounds.y2]]}var addToPath=function(polygon){var poly=polygon.map(function(lonLat){if(projectingToPlane){if(preclip){lonLat=preclip.forward(lonLat)}var lon=lonLat[0];if(Math.abs(lon-antimeridian)<floatCorrection){if(lon<antimeridian){lon=antimeridian-floatCorrection}else{lon=antimeridian+floatCorrection}}lonLat=[lon,lonLat[1]]}return lonLat});var polygons=[poly];if(hasGeoProjection){Projection.insertGeodesics(poly);if(projectingToPlane){polygons=_this.cutOnAntimeridian(poly,isPolygon)}}polygons.forEach(function(poly){if(poly.length<2){return}var movedTo=false;var firstValidLonLat;var lastValidLonLat;var gap=false;var pushToPath=function(point){if(!movedTo){path.push(["M",point[0],point[1]]);movedTo=true}else{path.push(["L",point[0],point[1]])}};var someOutside=false,someInside=false;var points=poly.map(function(lonLat){var xy=postclip.forward(lonLat);if(xy.outside){someOutside=true}else{someInside=true}if(xy[1]===Infinity){xy[1]=1e10}else if(xy[1]===-Infinity){xy[1]=-1e10}return xy});if(projectingToPlane){if(isPolygon){points.push(points[0])}if(someOutside){if(!someInside){return}if(boundsPolygon){if(isPolygon){points=clipPolygon(points,boundsPolygon)}else if(bounds){clipLineString(points,boundsPolygon).forEach(function(points){movedTo=false;points.forEach(pushToPath)});return}}}points.forEach(pushToPath)}else{for(var i=0;i<points.length;i++){var lonLat=poly[i],point=points[i];if(!point.outside){if(isPolygon&&!firstValidLonLat){firstValidLonLat=lonLat;poly.push(lonLat);points.push(point)}if(gap&&lastValidLonLat){if(isPolygon&&hasGeoProjection){var geodesic=Projection.geodesic(lastValidLonLat,lonLat);geodesic.forEach(function(lonLat){return pushToPath(postclip.forward(lonLat))})}else{movedTo=false}}pushToPath(point);lastValidLonLat=lonLat;gap=false}else{gap=true}}}})};if(geometry.type==="LineString"){addToPath(geometry.coordinates)}else if(geometry.type==="MultiLineString"){geometry.coordinates.forEach(function(c){return addToPath(c)})}else if(geometry.type==="Polygon"){geometry.coordinates.forEach(function(c){return addToPath(c)});if(path.length){path.push(["Z"])}}else if(geometry.type==="MultiPolygon"){geometry.coordinates.forEach(function(polygons){polygons.forEach(function(c){return addToPath(c)})});if(path.length){path.push(["Z"])}}return path};Projection.registry=ProjectionRegistry;return Projection}();export default Projection;