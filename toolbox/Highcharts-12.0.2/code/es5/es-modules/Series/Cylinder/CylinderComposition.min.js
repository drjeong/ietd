"use strict";import H from"../../Core/Globals.js";var charts=H.charts,deg2rad=H.deg2rad;import Math3D from"../../Core/Math3D.js";var perspective=Math3D.perspective;import SVGElement3DCylinder from"./SVGElement3DCylinder.js";import U from"../../Core/Utilities.js";var extend=U.extend,pick=U.pick;function compose(SVGRendererClass){var rendererProto=SVGRendererClass.prototype;if(!rendererProto.cylinder){rendererProto.Element3D.types.cylinder=SVGElement3DCylinder;extend(rendererProto,{cylinder:rendererCylinder,cylinderPath:rendererCylinderPath,getCurvedPath:rendererGetCurvedPath,getCylinderBack:rendererGetCylinderBack,getCylinderEnd:rendererGetCylinderEnd,getCylinderFront:rendererGetCylinderFront})}}function isSimplified(path){return!path.some(function(seg){return seg[0]==="C"})}function rendererCylinder(shapeArgs){return this.element3d("cylinder",shapeArgs)}function rendererCylinderPath(shapeArgs){var renderer=this,chart=charts[renderer.chartIndex],cuboidData=this.cuboidPath(shapeArgs),isTopFirst=!cuboidData.isTop,isFronFirst=!cuboidData.isFront,top=renderer.getCylinderEnd(chart,shapeArgs),bottom=renderer.getCylinderEnd(chart,shapeArgs,true);return{front:renderer.getCylinderFront(top,bottom),back:renderer.getCylinderBack(top,bottom),top:top,bottom:bottom,zIndexes:{top:isTopFirst?3:0,bottom:isTopFirst?0:3,front:isFronFirst?2:1,back:isFronFirst?1:2,group:cuboidData.zIndexes.group}}}function rendererGetCurvedPath(points){var path=[["M",points[0].x,points[0].y]],limit=points.length-2;for(var i=1;i<limit;i+=3){path.push(["C",points[i].x,points[i].y,points[i+1].x,points[i+1].y,points[i+2].x,points[i+2].y])}return path}function rendererGetCylinderBack(topPath,bottomPath){var path=[];if(isSimplified(topPath)){var move=topPath[0],line2=topPath[2];if(move[0]==="M"&&line2[0]==="L"){path.push(["M",line2[1],line2[2]]);path.push(topPath[3]);path.push(["L",move[1],move[2]])}}else{if(topPath[2][0]==="C"){path.push(["M",topPath[2][5],topPath[2][6]])}path.push(topPath[3],topPath[4])}if(isSimplified(bottomPath)){var move=bottomPath[0];if(move[0]==="M"){path.push(["L",move[1],move[2]]);path.push(bottomPath[3]);path.push(bottomPath[2])}}else{var curve2=bottomPath[2],curve3=bottomPath[3],curve4=bottomPath[4];if(curve2[0]==="C"&&curve3[0]==="C"&&curve4[0]==="C"){path.push(["L",curve4[5],curve4[6]]);path.push(["C",curve4[3],curve4[4],curve4[1],curve4[2],curve3[5],curve3[6]]);path.push(["C",curve3[3],curve3[4],curve3[1],curve3[2],curve2[5],curve2[6]])}}path.push(["Z"]);return path}function rendererGetCylinderEnd(chart,shapeArgs,isBottom){var _a=shapeArgs.width,width=_a===void 0?0:_a,_b=shapeArgs.height,height=_b===void 0?0:_b,_c=shapeArgs.alphaCorrection,alphaCorrection=_c===void 0?0:_c,depth=pick(shapeArgs.depth,width,0),radius=Math.min(width,depth)/2,angleOffset=deg2rad*(chart.options.chart.options3d.beta-90+alphaCorrection),y=(shapeArgs.y||0)+(isBottom?height:0),c=.5519*radius,centerX=width/2+(shapeArgs.x||0),centerZ=depth/2+(shapeArgs.z||0),points=[{x:0,y:y,z:radius},{x:c,y:y,z:radius},{x:radius,y:y,z:c},{x:radius,y:y,z:0},{x:radius,y:y,z:-c},{x:c,y:y,z:-radius},{x:0,y:y,z:-radius},{x:-c,y:y,z:-radius},{x:-radius,y:y,z:-c},{x:-radius,y:y,z:0},{x:-radius,y:y,z:c},{x:-c,y:y,z:radius},{x:0,y:y,z:radius}],cosTheta=Math.cos(angleOffset),sinTheta=Math.sin(angleOffset);var path,x,z;for(var _i=0,points_1=points;_i<points_1.length;_i++){var point=points_1[_i];x=point.x;z=point.z;point.x=x*cosTheta-z*sinTheta+centerX;point.z=z*cosTheta+x*sinTheta+centerZ}var perspectivePoints=perspective(points,chart,true);if(Math.abs(perspectivePoints[3].y-perspectivePoints[9].y)<2.5&&Math.abs(perspectivePoints[0].y-perspectivePoints[6].y)<2.5){path=this.toLinePath([perspectivePoints[0],perspectivePoints[3],perspectivePoints[6],perspectivePoints[9]],true)}else{path=this.getCurvedPath(perspectivePoints)}return path}function rendererGetCylinderFront(topPath,bottomPath){var path=topPath.slice(0,3);if(isSimplified(bottomPath)){var move=bottomPath[0];if(move[0]==="M"){path.push(bottomPath[2]);path.push(bottomPath[1]);path.push(["L",move[1],move[2]])}}else{var move=bottomPath[0],curve1=bottomPath[1],curve2=bottomPath[2];if(move[0]==="M"&&curve1[0]==="C"&&curve2[0]==="C"){path.push(["L",curve2[5],curve2[6]]);path.push(["C",curve2[3],curve2[4],curve2[1],curve2[2],curve1[5],curve1[6]]);path.push(["C",curve1[3],curve1[4],curve1[1],curve1[2],move[1],move[2]])}}path.push(["Z"]);return path}var CylinderComposition={compose:compose};export default CylinderComposition;