"use strict";import H from"../../Core/Globals.js";var noop=H.noop;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";var _a=SeriesRegistry.seriesTypes,HeatmapSeries=_a.heatmap,ScatterSeries=_a.scatter;import U from"../../Core/Utilities.js";var clamp=U.clamp,pick=U.pick;function tilePaddingFromTileSize(series,xDiv,yDiv){var options=series.options;return{xPad:(options.colsize||1)/-xDiv,yPad:(options.rowsize||1)/-yDiv}}var TilemapShapes={hexagon:{alignDataLabel:ScatterSeries.prototype.alignDataLabel,getSeriesPadding:function(series){return tilePaddingFromTileSize(series,3,2)},haloPath:function(size){if(!size){return[]}var hexagon=this.tileEdges;return[["M",hexagon.x2-size,hexagon.y1+size],["L",hexagon.x3+size,hexagon.y1+size],["L",hexagon.x4+size*1.5,hexagon.y2],["L",hexagon.x3+size,hexagon.y3-size],["L",hexagon.x2-size,hexagon.y3-size],["L",hexagon.x1-size*1.5,hexagon.y2],["Z"]]},translate:function(){var _a;var series=this,options=series.options,xAxis=series.xAxis,yAxis=series.yAxis,seriesPointPadding=options.pointPadding||0,xPad=(options.colsize||1)/3,yPad=(options.rowsize||1)/2;var yShift;series.generatePoints();for(var _i=0,_b=series.points;_i<_b.length;_i++){var point=_b[_i];var x1=clamp(Math.floor(xAxis.len-xAxis.translate(point.x-xPad*2,0,1,0,1)),-xAxis.len,2*xAxis.len),x2=clamp(Math.floor(xAxis.len-xAxis.translate(point.x-xPad,0,1,0,1)),-xAxis.len,2*xAxis.len),x3=clamp(Math.floor(xAxis.len-xAxis.translate(point.x+xPad,0,1,0,1)),-xAxis.len,2*xAxis.len),x4=clamp(Math.floor(xAxis.len-xAxis.translate(point.x+xPad*2,0,1,0,1)),-xAxis.len,2*xAxis.len),y1=clamp(Math.floor(yAxis.translate(point.y-yPad,0,1,0,1)),-yAxis.len,2*yAxis.len),y2=clamp(Math.floor(yAxis.translate(point.y,0,1,0,1)),-yAxis.len,2*yAxis.len),y3=clamp(Math.floor(yAxis.translate(point.y+yPad,0,1,0,1)),-yAxis.len,2*yAxis.len);var pointPadding=(_a=point.pointPadding)!==null&&_a!==void 0?_a:seriesPointPadding,midPointPadding=pointPadding*Math.abs(x2-x1)/Math.abs(y3-y2),xMidPadding=xAxis.reversed?-midPointPadding:midPointPadding,xPointPadding=xAxis.reversed?-pointPadding:pointPadding,yPointPadding=yAxis.reversed?-pointPadding:pointPadding;if(point.x%2){yShift=yShift||Math.round(Math.abs(y3-y1)/2)*(yAxis.reversed?-1:1);y1+=yShift;y2+=yShift;y3+=yShift}point.plotX=point.clientX=(x2+x3)/2;point.plotY=y2;x1+=xMidPadding+xPointPadding;x2+=xPointPadding;x3-=xPointPadding;x4-=xMidPadding+xPointPadding;y1-=yPointPadding;y3+=yPointPadding;point.tileEdges={x1:x1,x2:x2,x3:x3,x4:x4,y1:y1,y2:y2,y3:y3};point.shapeType="path";point.shapeArgs={d:[["M",x2,y1],["L",x3,y1],["L",x4,y2],["L",x3,y3],["L",x2,y3],["L",x1,y2],["Z"]]}}series.translateColors()}},diamond:{alignDataLabel:ScatterSeries.prototype.alignDataLabel,getSeriesPadding:function(series){return tilePaddingFromTileSize(series,2,2)},haloPath:function(size){if(!size){return[]}var diamond=this.tileEdges;return[["M",diamond.x2,diamond.y1+size],["L",diamond.x3+size,diamond.y2],["L",diamond.x2,diamond.y3-size],["L",diamond.x1-size,diamond.y2],["Z"]]},translate:function(){var series=this,options=series.options,xAxis=series.xAxis,yAxis=series.yAxis,seriesPointPadding=options.pointPadding||0,xPad=options.colsize||1,yPad=(options.rowsize||1)/2;var yShift;series.generatePoints();for(var _i=0,_a=series.points;_i<_a.length;_i++){var point=_a[_i];var x1=clamp(Math.round(xAxis.len-xAxis.translate(point.x-xPad,0,1,0,0)),-xAxis.len,2*xAxis.len),x3=clamp(Math.round(xAxis.len-xAxis.translate(point.x+xPad,0,1,0,0)),-xAxis.len,2*xAxis.len),y1=clamp(Math.round(yAxis.translate(point.y-yPad,0,1,0,0)),-yAxis.len,2*yAxis.len),y2=clamp(Math.round(yAxis.translate(point.y,0,1,0,0)),-yAxis.len,2*yAxis.len),y3=clamp(Math.round(yAxis.translate(point.y+yPad,0,1,0,0)),-yAxis.len,2*yAxis.len);var x2=clamp(Math.round(xAxis.len-xAxis.translate(point.x,0,1,0,0)),-xAxis.len,2*xAxis.len),pointPadding=pick(point.pointPadding,seriesPointPadding),midPointPadding=pointPadding*Math.abs(x2-x1)/Math.abs(y3-y2),xPointPadding=xAxis.reversed?-midPointPadding:midPointPadding,yPointPadding=yAxis.reversed?-pointPadding:pointPadding;if(point.x%2){yShift=Math.abs(y3-y1)/2*(yAxis.reversed?-1:1);y1+=yShift;y2+=yShift;y3+=yShift}point.plotX=point.clientX=x2;point.plotY=y2;x1+=xPointPadding;x3-=xPointPadding;y1-=yPointPadding;y3+=yPointPadding;point.tileEdges={x1:x1,x2:x2,x3:x3,y1:y1,y2:y2,y3:y3};point.shapeType="path";point.shapeArgs={d:[["M",x2,y1],["L",x3,y2],["L",x2,y3],["L",x1,y2],["Z"]]}}series.translateColors()}},circle:{alignDataLabel:ScatterSeries.prototype.alignDataLabel,getSeriesPadding:function(series){return tilePaddingFromTileSize(series,2,2)},haloPath:function(size){return ScatterSeries.prototype.pointClass.prototype.haloPath.call(this,size+(size&&this.radius))},translate:function(){var series=this,options=series.options,xAxis=series.xAxis,yAxis=series.yAxis,seriesPointPadding=options.pointPadding||0,yRadius=(options.rowsize||1)/2,colsize=options.colsize||1;var colsizePx,yRadiusPx,xRadiusPx,radius,forceNextRadiusCompute=false;series.generatePoints();for(var _i=0,_a=series.points;_i<_a.length;_i++){var point=_a[_i];var x=clamp(Math.round(xAxis.len-xAxis.translate(point.x,0,1,0,0)),-xAxis.len,2*xAxis.len);var pointPadding=seriesPointPadding,hasPerPointPadding=false,y=clamp(Math.round(yAxis.translate(point.y,0,1,0,0)),-yAxis.len,2*yAxis.len);if(typeof point.pointPadding!=="undefined"){pointPadding=point.pointPadding;hasPerPointPadding=true;forceNextRadiusCompute=true}if(!radius||forceNextRadiusCompute){colsizePx=Math.abs(clamp(Math.floor(xAxis.len-xAxis.translate(point.x+colsize,0,1,0,0)),-xAxis.len,2*xAxis.len)-x);yRadiusPx=Math.abs(clamp(Math.floor(yAxis.translate(point.y+yRadius,0,1,0,0)),-yAxis.len,2*yAxis.len)-y);xRadiusPx=Math.floor(Math.sqrt(colsizePx*colsizePx+yRadiusPx*yRadiusPx)/2);radius=Math.min(colsizePx,xRadiusPx,yRadiusPx)-pointPadding;if(forceNextRadiusCompute&&!hasPerPointPadding){forceNextRadiusCompute=false}}if(point.x%2){y+=yRadiusPx*(yAxis.reversed?-1:1)}point.plotX=point.clientX=x;point.plotY=y;point.radius=radius;point.shapeType="circle";point.shapeArgs={x:x,y:y,r:radius}}series.translateColors()}},square:{alignDataLabel:HeatmapSeries.prototype.alignDataLabel,translate:HeatmapSeries.prototype.translate,getSeriesPadding:noop,haloPath:HeatmapSeries.prototype.pointClass.prototype.haloPath}};export default TilemapShapes;