"use strict";import Connection from"./Connection.js";import PathfinderAlgorithms from"./PathfinderAlgorithms.js";import PathfinderComposition from"./PathfinderComposition.js";import Point from"../Core/Series/Point.js";import U from"../Core/Utilities.js";var addEvent=U.addEvent,defined=U.defined,pick=U.pick,splat=U.splat;var max=Math.max,min=Math.min;function getPointBB(point){var shapeArgs=point.shapeArgs;if(shapeArgs){return{xMin:shapeArgs.x||0,xMax:(shapeArgs.x||0)+(shapeArgs.width||0),yMin:shapeArgs.y||0,yMax:(shapeArgs.y||0)+(shapeArgs.height||0)}}var bb=point.graphic&&point.graphic.getBBox();return bb?{xMin:point.plotX-bb.width/2,xMax:point.plotX+bb.width/2,yMin:point.plotY-bb.height/2,yMax:point.plotY+bb.height/2}:null}function calculateObstacleDistance(a,b,bbMargin){var margin=pick(bbMargin,10),yOverlap=a.yMax+margin>b.yMin-margin&&a.yMin-margin<b.yMax+margin,xOverlap=a.xMax+margin>b.xMin-margin&&a.xMin-margin<b.xMax+margin,xDistance=yOverlap?a.xMin>b.xMax?a.xMin-b.xMax:b.xMin-a.xMax:Infinity,yDistance=xOverlap?a.yMin>b.yMax?a.yMin-b.yMax:b.yMin-a.yMax:Infinity;if(xOverlap&&yOverlap){return margin?calculateObstacleDistance(a,b,Math.floor(margin/2)):Infinity}return min(xDistance,yDistance)}function calculateObstacleMargin(obstacles){var len=obstacles.length,distances=[];var onstacleDistance;for(var i=0;i<len;++i){for(var j=i+1;j<len;++j){onstacleDistance=calculateObstacleDistance(obstacles[i],obstacles[j]);if(onstacleDistance<80){distances.push(onstacleDistance)}}}distances.push(80);return max(Math.floor(distances.sort(function(a,b){return a-b})[Math.floor(distances.length/10)]/2-1),1)}var Pathfinder=function(){function Pathfinder(chart){this.init(chart)}Pathfinder.compose=function(ChartClass,PointClass){PathfinderComposition.compose(ChartClass,Pathfinder,PointClass)};Pathfinder.prototype.init=function(chart){this.chart=chart;this.connections=[];addEvent(chart,"redraw",function(){this.pathfinder.update()})};Pathfinder.prototype.update=function(deferRender){var chart=this.chart,pathfinder=this,oldConnections=pathfinder.connections;pathfinder.connections=[];chart.series.forEach(function(series){if(series.visible&&!series.options.isInternal){series.points.forEach(function(point){var _a;var ganttPointOptions=point.options;if(ganttPointOptions&&ganttPointOptions.dependency){ganttPointOptions.connect=ganttPointOptions.dependency}var connects=((_a=point.options)===null||_a===void 0?void 0:_a.connect)?splat(point.options.connect):[];var to;if(point.visible&&point.isInside!==false){connects.forEach(function(connect){var toId=typeof connect==="string"?connect:connect.to;if(toId){to=chart.get(toId)}if(to instanceof Point&&to.series.visible&&to.visible&&to.isInside!==false){pathfinder.connections.push(new Connection(point,to,typeof connect==="string"?{}:connect))}})}})}});for(var j=0,k=void 0,found=void 0,lenOld=oldConnections.length,lenNew=pathfinder.connections.length;j<lenOld;++j){found=false;var oldCon=oldConnections[j];for(k=0;k<lenNew;++k){var newCon=pathfinder.connections[k];if((oldCon.options&&oldCon.options.type)===(newCon.options&&newCon.options.type)&&oldCon.fromPoint===newCon.fromPoint&&oldCon.toPoint===newCon.toPoint){newCon.graphics=oldCon.graphics;found=true;break}}if(!found){oldCon.destroy()}}delete this.chartObstacles;delete this.lineObstacles;pathfinder.renderConnections(deferRender)};Pathfinder.prototype.renderConnections=function(deferRender){if(deferRender){this.chart.series.forEach(function(series){var render=function(){var pathfinder=series.chart.pathfinder,conns=pathfinder&&pathfinder.connections||[];conns.forEach(function(connection){if(connection.fromPoint&&connection.fromPoint.series===series){connection.render()}});if(series.pathfinderRemoveRenderEvent){series.pathfinderRemoveRenderEvent();delete series.pathfinderRemoveRenderEvent}};if(series.options.animation===false){render()}else{series.pathfinderRemoveRenderEvent=addEvent(series,"afterAnimate",render)}})}else{this.connections.forEach(function(connection){connection.render()})}};Pathfinder.prototype.getChartObstacles=function(options){var series=this.chart.series,margin=pick(options.algorithmMargin,0);var obstacles=[],calculatedMargin;for(var i=0,sLen=series.length;i<sLen;++i){if(series[i].visible&&!series[i].options.isInternal){for(var j=0,pLen=series[i].points.length,bb=void 0,point=void 0;j<pLen;++j){point=series[i].points[j];if(point.visible){bb=getPointBB(point);if(bb){obstacles.push({xMin:bb.xMin-margin,xMax:bb.xMax+margin,yMin:bb.yMin-margin,yMax:bb.yMax+margin})}}}}}obstacles=obstacles.sort(function(a,b){return a.xMin-b.xMin});if(!defined(options.algorithmMargin)){calculatedMargin=options.algorithmMargin=calculateObstacleMargin(obstacles);obstacles.forEach(function(obstacle){obstacle.xMin-=calculatedMargin;obstacle.xMax+=calculatedMargin;obstacle.yMin-=calculatedMargin;obstacle.yMax+=calculatedMargin})}return obstacles};Pathfinder.prototype.getObstacleMetrics=function(obstacles){var maxWidth=0,maxHeight=0,width,height,i=obstacles.length;while(i--){width=obstacles[i].xMax-obstacles[i].xMin;height=obstacles[i].yMax-obstacles[i].yMin;if(maxWidth<width){maxWidth=width}if(maxHeight<height){maxHeight=height}}return{maxHeight:maxHeight,maxWidth:maxWidth}};Pathfinder.prototype.getAlgorithmStartDirection=function(markerOptions){var xCenter=markerOptions.align!=="left"&&markerOptions.align!=="right",yCenter=markerOptions.verticalAlign!=="top"&&markerOptions.verticalAlign!=="bottom";return xCenter?yCenter?void 0:false:yCenter?true:void 0};return Pathfinder}();Pathfinder.prototype.algorithms=PathfinderAlgorithms;export default Pathfinder;"";