"use strict";import PathUtilities from"../Series/PathUtilities.js";import U from"../Core/Utilities.js";var pick=U.pick;var min=Math.min,max=Math.max,abs=Math.abs;function findLastObstacleBefore(obstacles,xMin,startIx){var min=xMin-1e-7;var left=startIx||0,right=obstacles.length-1,cursor,cmp;while(left<=right){cursor=right+left>>1;cmp=min-obstacles[cursor].xMin;if(cmp>0){left=cursor+1}else if(cmp<0){right=cursor-1}else{return cursor}}return left>0?left-1:0}function pointWithinObstacle(obstacle,point){return point.x<=obstacle.xMax&&point.x>=obstacle.xMin&&point.y<=obstacle.yMax&&point.y>=obstacle.yMin}function findObstacleFromPoint(obstacles,point){var i=findLastObstacleBefore(obstacles,point.x+1)+1;while(i--){if(obstacles[i].xMax>=point.x&&pointWithinObstacle(obstacles[i],point)){return i}}return-1}function pathFromSegments(segments){var path=[];if(segments.length){path.push(["M",segments[0].start.x,segments[0].start.y]);for(var i=0;i<segments.length;++i){path.push(["L",segments[i].end.x,segments[i].end.y])}}return path}function limitObstacleToBounds(obstacle,bounds){obstacle.yMin=max(obstacle.yMin,bounds.yMin);obstacle.yMax=min(obstacle.yMax,bounds.yMax);obstacle.xMin=max(obstacle.xMin,bounds.xMin);obstacle.xMax=min(obstacle.xMax,bounds.xMax)}function straight(start,end){return{path:[["M",start.x,start.y],["L",end.x,end.y]],obstacles:[{start:start,end:end}]}}var simpleConnect=function(start,end,options){var segments=[],chartObstacles=options.chartObstacles,startObstacleIx=findObstacleFromPoint(chartObstacles,start),endObstacleIx=findObstacleFromPoint(chartObstacles,end);var endSegment,dir=pick(options.startDirectionX,abs(end.x-start.x)>abs(end.y-start.y))?"x":"y",startObstacle,endObstacle,waypoint,useMax,endPoint;function copyFromPoint(from,fromKey,to,toKey,offset){var point={x:from.x,y:from.y};point[fromKey]=to[toKey||fromKey]+(offset||0);return point}function getMeOut(obstacle,point,direction){var useMax=abs(point[direction]-obstacle[direction+"Min"])>abs(point[direction]-obstacle[direction+"Max"]);return copyFromPoint(point,direction,obstacle,direction+(useMax?"Max":"Min"),useMax?1:-1)}if(endObstacleIx>-1){endObstacle=chartObstacles[endObstacleIx];waypoint=getMeOut(endObstacle,end,dir);endSegment={start:waypoint,end:end};endPoint=waypoint}else{endPoint=end}if(startObstacleIx>-1){startObstacle=chartObstacles[startObstacleIx];waypoint=getMeOut(startObstacle,start,dir);segments.push({start:start,end:waypoint});if(waypoint[dir]>=start[dir]===waypoint[dir]>=endPoint[dir]){dir=dir==="y"?"x":"y";useMax=start[dir]<end[dir];segments.push({start:waypoint,end:copyFromPoint(waypoint,dir,startObstacle,dir+(useMax?"Max":"Min"),useMax?1:-1)});dir=dir==="y"?"x":"y"}}var prevWaypoint=segments.length?segments[segments.length-1].end:start;waypoint=copyFromPoint(prevWaypoint,dir,endPoint);segments.push({start:prevWaypoint,end:waypoint});dir=dir==="y"?"x":"y";var waypoint2=copyFromPoint(waypoint,dir,endPoint);segments.push({start:waypoint,end:waypoint2});segments.push(endSegment);var path=PathUtilities.applyRadius(pathFromSegments(segments),options.radius);return{path:path,obstacles:segments}};simpleConnect.requiresObstacles=true;function fastAvoid(start,end,options){var dirIsX=pick(options.startDirectionX,abs(end.x-start.x)>abs(end.y-start.y)),dir=dirIsX?"x":"y",endSegments=[],metrics=options.obstacleMetrics,softMinX=min(start.x,end.x)-metrics.maxWidth-10,softMaxX=max(start.x,end.x)+metrics.maxWidth+10,softMinY=min(start.y,end.y)-metrics.maxHeight-10,softMaxY=max(start.y,end.y)+metrics.maxHeight+10;var segments,useMax,extractedEndPoint,forceObstacleBreak=false,chartObstacles=options.chartObstacles,endObstacleIx=findLastObstacleBefore(chartObstacles,softMaxX);var startObstacleIx=findLastObstacleBefore(chartObstacles,softMinX);function pivotPoint(fromPoint,toPoint,directionIsX){var searchDirection=fromPoint.x<toPoint.x?1:-1;var firstPoint,lastPoint,highestPoint,lowestPoint;if(fromPoint.x<toPoint.x){firstPoint=fromPoint;lastPoint=toPoint}else{firstPoint=toPoint;lastPoint=fromPoint}if(fromPoint.y<toPoint.y){lowestPoint=fromPoint;highestPoint=toPoint}else{lowestPoint=toPoint;highestPoint=fromPoint}var i=searchDirection<0?min(findLastObstacleBefore(chartObstacles,lastPoint.x),chartObstacles.length-1):0;while(chartObstacles[i]&&(searchDirection>0&&chartObstacles[i].xMin<=lastPoint.x||searchDirection<0&&chartObstacles[i].xMax>=firstPoint.x)){if(chartObstacles[i].xMin<=lastPoint.x&&chartObstacles[i].xMax>=firstPoint.x&&chartObstacles[i].yMin<=highestPoint.y&&chartObstacles[i].yMax>=lowestPoint.y){if(directionIsX){return{y:fromPoint.y,x:fromPoint.x<toPoint.x?chartObstacles[i].xMin-1:chartObstacles[i].xMax+1,obstacle:chartObstacles[i]}}return{x:fromPoint.x,y:fromPoint.y<toPoint.y?chartObstacles[i].yMin-1:chartObstacles[i].yMax+1,obstacle:chartObstacles[i]}}i+=searchDirection}return toPoint}function getDodgeDirection(obstacle,fromPoint,toPoint,dirIsX,bounds){var softBounds=bounds.soft,hardBounds=bounds.hard,dir=dirIsX?"x":"y",toPointMax={x:fromPoint.x,y:fromPoint.y},toPointMin={x:fromPoint.x,y:fromPoint.y},maxOutOfSoftBounds=obstacle[dir+"Max"]>=softBounds[dir+"Max"],minOutOfSoftBounds=obstacle[dir+"Min"]<=softBounds[dir+"Min"],maxOutOfHardBounds=obstacle[dir+"Max"]>=hardBounds[dir+"Max"],minOutOfHardBounds=obstacle[dir+"Min"]<=hardBounds[dir+"Min"],minDistance=abs(obstacle[dir+"Min"]-fromPoint[dir]),maxDistance=abs(obstacle[dir+"Max"]-fromPoint[dir]);var useMax=abs(minDistance-maxDistance)<10?fromPoint[dir]<toPoint[dir]:maxDistance<minDistance;toPointMin[dir]=obstacle[dir+"Min"];toPointMax[dir]=obstacle[dir+"Max"];var minPivot=pivotPoint(fromPoint,toPointMin,dirIsX)[dir]!==toPointMin[dir],maxPivot=pivotPoint(fromPoint,toPointMax,dirIsX)[dir]!==toPointMax[dir];useMax=minPivot?maxPivot?useMax:true:maxPivot?false:useMax;useMax=minOutOfSoftBounds?maxOutOfSoftBounds?useMax:true:maxOutOfSoftBounds?false:useMax;useMax=minOutOfHardBounds?maxOutOfHardBounds?useMax:true:maxOutOfHardBounds?false:useMax;return useMax}function clearPathTo(fromPoint,toPoint,dirIsX){if(fromPoint.x===toPoint.x&&fromPoint.y===toPoint.y){return[]}var dir=dirIsX?"x":"y",obstacleMargin=options.obstacleOptions.margin,bounds={soft:{xMin:softMinX,xMax:softMaxX,yMin:softMinY,yMax:softMaxY},hard:options.hardBounds};var pivot,segments,waypoint,waypointUseMax,envelopingObstacle,secondEnvelopingObstacle,envelopWaypoint;envelopingObstacle=findObstacleFromPoint(chartObstacles,fromPoint);if(envelopingObstacle>-1){envelopingObstacle=chartObstacles[envelopingObstacle];waypointUseMax=getDodgeDirection(envelopingObstacle,fromPoint,toPoint,dirIsX,bounds);limitObstacleToBounds(envelopingObstacle,options.hardBounds);envelopWaypoint=dirIsX?{y:fromPoint.y,x:envelopingObstacle[waypointUseMax?"xMax":"xMin"]+(waypointUseMax?1:-1)}:{x:fromPoint.x,y:envelopingObstacle[waypointUseMax?"yMax":"yMin"]+(waypointUseMax?1:-1)};secondEnvelopingObstacle=findObstacleFromPoint(chartObstacles,envelopWaypoint);if(secondEnvelopingObstacle>-1){secondEnvelopingObstacle=chartObstacles[secondEnvelopingObstacle];limitObstacleToBounds(secondEnvelopingObstacle,options.hardBounds);envelopWaypoint[dir]=waypointUseMax?max(envelopingObstacle[dir+"Max"]-obstacleMargin+1,(secondEnvelopingObstacle[dir+"Min"]+envelopingObstacle[dir+"Max"])/2):min(envelopingObstacle[dir+"Min"]+obstacleMargin-1,(secondEnvelopingObstacle[dir+"Max"]+envelopingObstacle[dir+"Min"])/2);if(fromPoint.x===envelopWaypoint.x&&fromPoint.y===envelopWaypoint.y){if(forceObstacleBreak){envelopWaypoint[dir]=waypointUseMax?max(envelopingObstacle[dir+"Max"],secondEnvelopingObstacle[dir+"Max"])+1:min(envelopingObstacle[dir+"Min"],secondEnvelopingObstacle[dir+"Min"])-1}forceObstacleBreak=!forceObstacleBreak}else{forceObstacleBreak=false}}segments=[{start:fromPoint,end:envelopWaypoint}]}else{pivot=pivotPoint(fromPoint,{x:dirIsX?toPoint.x:fromPoint.x,y:dirIsX?fromPoint.y:toPoint.y},dirIsX);segments=[{start:fromPoint,end:{x:pivot.x,y:pivot.y}}];if(pivot[dirIsX?"x":"y"]!==toPoint[dirIsX?"x":"y"]){waypointUseMax=getDodgeDirection(pivot.obstacle,pivot,toPoint,!dirIsX,bounds);limitObstacleToBounds(pivot.obstacle,options.hardBounds);waypoint={x:dirIsX?pivot.x:pivot.obstacle[waypointUseMax?"xMax":"xMin"]+(waypointUseMax?1:-1),y:dirIsX?pivot.obstacle[waypointUseMax?"yMax":"yMin"]+(waypointUseMax?1:-1):pivot.y};dirIsX=!dirIsX;segments=segments.concat(clearPathTo({x:pivot.x,y:pivot.y},waypoint,dirIsX))}}segments=segments.concat(clearPathTo(segments[segments.length-1].end,toPoint,!dirIsX));return segments}function extractFromObstacle(obstacle,point,goalPoint){var dirIsX=min(obstacle.xMax-point.x,point.x-obstacle.xMin)<min(obstacle.yMax-point.y,point.y-obstacle.yMin),bounds={soft:options.hardBounds,hard:options.hardBounds},useMax=getDodgeDirection(obstacle,point,goalPoint,dirIsX,bounds);return dirIsX?{y:point.y,x:obstacle[useMax?"xMax":"xMin"]+(useMax?1:-1)}:{x:point.x,y:obstacle[useMax?"yMax":"yMin"]+(useMax?1:-1)}}chartObstacles=chartObstacles.slice(startObstacleIx,endObstacleIx+1);if((endObstacleIx=findObstacleFromPoint(chartObstacles,end))>-1){extractedEndPoint=extractFromObstacle(chartObstacles[endObstacleIx],end,start);endSegments.push({end:end,start:extractedEndPoint});end=extractedEndPoint}while((endObstacleIx=findObstacleFromPoint(chartObstacles,end))>-1){useMax=end[dir]-start[dir]<0;extractedEndPoint={x:end.x,y:end.y};extractedEndPoint[dir]=chartObstacles[endObstacleIx][useMax?dir+"Max":dir+"Min"]+(useMax?1:-1);endSegments.push({end:end,start:extractedEndPoint});end=extractedEndPoint}segments=clearPathTo(start,end,dirIsX);segments=segments.concat(endSegments.reverse());return{path:pathFromSegments(segments),obstacles:segments}}fastAvoid.requiresObstacles=true;var algorithms={fastAvoid:fastAvoid,straight:straight,simpleConnect:simpleConnect};export default algorithms;