(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory(root["_Highcharts"],root["_Highcharts"]["SeriesRegistry"],root["_Highcharts"]["Color"]);else if(typeof define==="function"&&define.amd)define("highcharts/modules/solid-gauge",["highcharts/highcharts"],function(amd1){return factory(amd1,amd1["SeriesRegistry"],amd1["Color"])});else if(typeof exports==="object")exports["highcharts/modules/solid-gauge"]=factory(root["_Highcharts"],root["_Highcharts"]["SeriesRegistry"],root["_Highcharts"]["Color"]);else root["Highcharts"]=factory(root["Highcharts"],root["Highcharts"]["SeriesRegistry"],root["Highcharts"]["Color"])})(typeof window==="undefined"?this:window,(__WEBPACK_EXTERNAL_MODULE__944__,__WEBPACK_EXTERNAL_MODULE__512__,__WEBPACK_EXTERNAL_MODULE__620__)=>{return(()=>{"use strict";var __webpack_modules__={620:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__620__},512:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__512__},944:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__944__}};var __webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(cachedModule!==undefined){return cachedModule.exports}var module=__webpack_module_cache__[moduleId]={exports:{}};__webpack_modules__[moduleId](module,module.exports,__webpack_require__);return module.exports}(()=>{__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module["default"]:()=>module;__webpack_require__.d(getter,{a:getter});return getter}})();(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>solid_gauge_src});var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_=__webpack_require__(944);var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default=__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);const{defaultOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{noop}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent,extend,isObject,merge,relativeLength}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const defaultBorderRadiusOptions={radius:0,scope:"stack",where:void 0};let oldArc=noop;let oldRoundedRect=noop;function applyBorderRadius(path,i,r){const a=path[i];let b=path[i+1];if(b[0]==="Z"){b=path[0]}let line,arc,fromLineToArc;if((a[0]==="M"||a[0]==="L")&&b[0]==="A"){line=a;arc=b;fromLineToArc=true}else if(a[0]==="A"&&(b[0]==="M"||b[0]==="L")){line=b;arc=a}if(line&&arc&&arc.params){const bigR=arc[1],clockwise=arc[5],params=arc.params,{start,end,cx,cy}=params;const relativeR=clockwise?bigR-r:bigR+r,angleOfBorderRadius=relativeR?Math.asin(r/relativeR):0,angleOffset=clockwise?angleOfBorderRadius:-angleOfBorderRadius,distanceBigCenterToStartArc=Math.cos(angleOfBorderRadius)*relativeR;if(fromLineToArc){params.start=start+angleOffset;line[1]=cx+distanceBigCenterToStartArc*Math.cos(start);line[2]=cy+distanceBigCenterToStartArc*Math.sin(start);path.splice(i+1,0,["A",r,r,0,0,1,cx+bigR*Math.cos(params.start),cy+bigR*Math.sin(params.start)])}else{params.end=end-angleOffset;arc[6]=cx+bigR*Math.cos(params.end);arc[7]=cy+bigR*Math.sin(params.end);path.splice(i+1,0,["A",r,r,0,0,1,cx+distanceBigCenterToStartArc*Math.cos(end),cy+distanceBigCenterToStartArc*Math.sin(end)])}arc[4]=Math.abs(params.end-params.start)<Math.PI?0:1}}function arc(x,y,w,h,options={}){const path=oldArc(x,y,w,h,options),{innerR=0,r=w,start=0,end=0}=options;if(options.open||!options.borderRadius){return path}const alpha=end-start,sinHalfAlpha=Math.sin(alpha/2),borderRadius=Math.max(Math.min(relativeLength(options.borderRadius||0,r-innerR),(r-innerR)/2,r*sinHalfAlpha/(1+sinHalfAlpha)),0),innerBorderRadius=Math.min(borderRadius,2*(alpha/Math.PI)*innerR);let i=path.length-1;while(i--){applyBorderRadius(path,i,i>1?innerBorderRadius:borderRadius)}return path}function seriesOnAfterColumnTranslate(){if(this.options.borderRadius&&!(this.chart.is3d&&this.chart.is3d())){const{options,yAxis}=this,percent=options.stacking==="percent",seriesDefault=defaultOptions.plotOptions?.[this.type]?.borderRadius,borderRadius=optionsToObject(options.borderRadius,isObject(seriesDefault)?seriesDefault:{}),reversed=yAxis.options.reversed;for(const point of this.points){const{shapeArgs}=point;if(point.shapeType==="roundedRect"&&shapeArgs){const{width=0,height=0,y=0}=shapeArgs;let brBoxY=y,brBoxHeight=height;if(borderRadius.scope==="stack"&&point.stackTotal){const stackEnd=yAxis.translate(percent?100:point.stackTotal,false,true,false,true),stackThreshold=yAxis.translate(options.threshold||0,false,true,false,true),box=this.crispCol(0,Math.min(stackEnd,stackThreshold),0,Math.abs(stackEnd-stackThreshold));brBoxY=box.y;brBoxHeight=box.height}const flip=(point.negative?-1:1)*(reversed?-1:1)===-1;let where=borderRadius.where;if(!where&&this.is("waterfall")&&Math.abs((point.yBottom||0)-(this.translatedThreshold||0))>this.borderWidth){where="all"}if(!where){where="end"}const r=Math.min(relativeLength(borderRadius.radius,width),width/2,where==="all"?height/2:Infinity)||0;if(where==="end"){if(flip){brBoxY-=r;brBoxHeight+=r}else{brBoxHeight+=r}}extend(shapeArgs,{brBoxHeight:brBoxHeight,brBoxY:brBoxY,r:r})}}}}function compose(SeriesClass,SVGElementClass,SVGRendererClass){const PieSeriesClass=SeriesClass.types.pie;if(!SVGElementClass.symbolCustomAttribs.includes("borderRadius")){const symbols=SVGRendererClass.prototype.symbols;addEvent(SeriesClass,"afterColumnTranslate",seriesOnAfterColumnTranslate,{order:9});addEvent(PieSeriesClass,"afterTranslate",pieSeriesOnAfterTranslate);SVGElementClass.symbolCustomAttribs.push("borderRadius","brBoxHeight","brBoxY");oldArc=symbols.arc;oldRoundedRect=symbols.roundedRect;symbols.arc=arc;symbols.roundedRect=roundedRect}}function optionsToObject(options,seriesBROptions){if(!isObject(options)){options={radius:options||0}}return merge(defaultBorderRadiusOptions,seriesBROptions,options)}function pieSeriesOnAfterTranslate(){const borderRadius=optionsToObject(this.options.borderRadius);for(const point of this.points){const shapeArgs=point.shapeArgs;if(shapeArgs){shapeArgs.borderRadius=relativeLength(borderRadius.radius,(shapeArgs.r||0)-(shapeArgs.innerR||0))}}}function roundedRect(x,y,width,height,options={}){const path=oldRoundedRect(x,y,width,height,options),{r=0,brBoxHeight=height,brBoxY=y}=options,brOffsetTop=y-brBoxY,brOffsetBtm=brBoxY+brBoxHeight-(y+height),rTop=brOffsetTop-r>-.1?0:r,rBtm=brOffsetBtm-r>-.1?0:r,cutTop=Math.max(rTop&&brOffsetTop,0),cutBtm=Math.max(rBtm&&brOffsetBtm,0);const a=[x+rTop,y],b=[x+width-rTop,y],c=[x+width,y+rTop],d=[x+width,y+height-rBtm],e=[x+width-rBtm,y+height],f=[x+rBtm,y+height],g=[x,y+height-rBtm],h=[x,y+rTop];const applyPythagoras=(r,altitude)=>Math.sqrt(Math.pow(r,2)-Math.pow(altitude,2));if(cutTop){const base=applyPythagoras(rTop,rTop-cutTop);a[0]-=base;b[0]+=base;c[1]=h[1]=y+rTop-cutTop}if(height<rTop-cutTop){const base=applyPythagoras(rTop,rTop-cutTop-height);c[0]=d[0]=x+width-rTop+base;e[0]=Math.min(c[0],e[0]);f[0]=Math.max(d[0],f[0]);g[0]=h[0]=x+rTop-base;c[1]=h[1]=y+height}if(cutBtm){const base=applyPythagoras(rBtm,rBtm-cutBtm);e[0]+=base;f[0]-=base;d[1]=g[1]=y+height-rBtm+cutBtm}if(height<rBtm-cutBtm){const base=applyPythagoras(rBtm,rBtm-cutBtm-height);c[0]=d[0]=x+width-rBtm+base;b[0]=Math.min(c[0],b[0]);a[0]=Math.max(d[0],a[0]);g[0]=h[0]=x+rBtm-base;d[1]=g[1]=y}path.length=0;path.push(["M",...a],["L",...b],["A",rTop,rTop,0,0,1,...c],["L",...d],["A",rBtm,rBtm,0,0,1,...e],["L",...f],["A",rBtm,rBtm,0,0,1,...g],["L",...h],["A",rTop,rTop,0,0,1,...a],["Z"]);return path}const BorderRadius={compose:compose,optionsToObject:optionsToObject};const Extensions_BorderRadius=BorderRadius;"";var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_=__webpack_require__(512);var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default=__webpack_require__.n(highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_);var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_=__webpack_require__(620);var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default=__webpack_require__.n(highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_);const{parse:color}=highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default();const{merge:ColorAxisLike_merge}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var ColorAxisLike;(function(ColorAxisLike){function initDataClasses(userOptions){const axis=this,chart=axis.chart,legendItem=axis.legendItem=axis.legendItem||{},options=axis.options,userDataClasses=userOptions.dataClasses||[];let dataClass,dataClasses,colorCount=chart.options.chart.colorCount,colorCounter=0,colors;axis.dataClasses=dataClasses=[];legendItem.labels=[];for(let i=0,iEnd=userDataClasses.length;i<iEnd;++i){dataClass=userDataClasses[i];dataClass=ColorAxisLike_merge(dataClass);dataClasses.push(dataClass);if(!chart.styledMode&&dataClass.color){continue}if(options.dataClassColor==="category"){if(!chart.styledMode){colors=chart.options.colors||[];colorCount=colors.length;dataClass.color=colors[colorCounter]}dataClass.colorIndex=colorCounter;colorCounter++;if(colorCounter===colorCount){colorCounter=0}}else{dataClass.color=color(options.minColor).tweenTo(color(options.maxColor),iEnd<2?.5:i/(iEnd-1))}}}ColorAxisLike.initDataClasses=initDataClasses;function initStops(){const axis=this,options=axis.options,stops=axis.stops=options.stops||[[0,options.minColor||""],[1,options.maxColor||""]];for(let i=0,iEnd=stops.length;i<iEnd;++i){stops[i].color=color(stops[i][1])}}ColorAxisLike.initStops=initStops;function normalizedValue(value){const axis=this,max=axis.max||0,min=axis.min||0;if(axis.logarithmic){value=axis.logarithmic.log2lin(value)}return 1-(max-value)/(max-min||1)}ColorAxisLike.normalizedValue=normalizedValue;function toColor(value,point){const axis=this;const dataClasses=axis.dataClasses;const stops=axis.stops;let pos,from,to,color,dataClass,i;if(dataClasses){i=dataClasses.length;while(i--){dataClass=dataClasses[i];from=dataClass.from;to=dataClass.to;if((typeof from==="undefined"||value>=from)&&(typeof to==="undefined"||value<=to)){color=dataClass.color;if(point){point.dataClass=i;point.colorIndex=dataClass.colorIndex}break}}}else{pos=axis.normalizedValue(value);i=stops.length;while(i--){if(pos>stops[i][0]){break}}from=stops[i]||stops[i+1];to=stops[i+1]||from;pos=1-(to[0]-pos)/(to[0]-from[0]||1);color=from.color.tweenTo(to.color,pos)}return color}ColorAxisLike.toColor=toColor})(ColorAxisLike||(ColorAxisLike={}));const Color_ColorAxisLike=ColorAxisLike;const{extend:SolidGaugeAxis_extend}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function init(axis){SolidGaugeAxis_extend(axis,Color_ColorAxisLike)}const SolidGaugeAxis={init:init};const Axis_SolidGaugeAxis=SolidGaugeAxis;const SolidGaugeSeriesDefaults={colorByPoint:true,dataLabels:{y:0}};"";const SolidGauge_SolidGaugeSeriesDefaults=SolidGaugeSeriesDefaults;const{gauge:GaugeSeries,pie:PieSeries}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().seriesTypes;const{clamp,extend:SolidGaugeSeries_extend,isNumber,merge:SolidGaugeSeries_merge,pick,pInt}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class SolidGaugeSeries extends GaugeSeries{translate(){const axis=this.yAxis;Axis_SolidGaugeAxis.init(axis);if(!axis.dataClasses&&axis.options.dataClasses){axis.initDataClasses(axis.options)}axis.initStops();GaugeSeries.prototype.translate.call(this)}drawPoints(){const series=this,yAxis=series.yAxis,center=yAxis.center,options=series.options,renderer=series.chart.renderer,overshoot=options.overshoot,rounded=options.rounded&&options.borderRadius===void 0,overshootVal=isNumber(overshoot)?overshoot/180*Math.PI:0;let thresholdAngleRad;if(isNumber(options.threshold)){thresholdAngleRad=yAxis.startAngleRad+yAxis.translate(options.threshold,void 0,void 0,void 0,true)}this.thresholdAngleRad=pick(thresholdAngleRad,yAxis.startAngleRad);for(const point of series.points){if(!point.isNull){const radius=pInt(pick(point.options.radius,options.radius,100))*center[2]/200,innerRadius=pInt(pick(point.options.innerRadius,options.innerRadius,60))*center[2]/200,axisMinAngle=Math.min(yAxis.startAngleRad,yAxis.endAngleRad),axisMaxAngle=Math.max(yAxis.startAngleRad,yAxis.endAngleRad);let graphic=point.graphic,rotation=yAxis.startAngleRad+yAxis.translate(point.y,void 0,void 0,void 0,true),shapeArgs,d,toColor=yAxis.toColor(point.y,point);if(toColor==="none"){toColor=point.color||series.color||"none"}if(toColor!=="none"){point.color=toColor}rotation=clamp(rotation,axisMinAngle-overshootVal,axisMaxAngle+overshootVal);if(options.wrap===false){rotation=clamp(rotation,axisMinAngle,axisMaxAngle)}const angleOfRounding=rounded?(radius-innerRadius)/2/radius:0,start=Math.min(rotation,series.thresholdAngleRad)-angleOfRounding;let end=Math.max(rotation,series.thresholdAngleRad)+angleOfRounding;if(end-start>2*Math.PI){end=start+2*Math.PI}let borderRadius=rounded?"50%":0;if(options.borderRadius){borderRadius=Extensions_BorderRadius.optionsToObject(options.borderRadius).radius}point.shapeArgs=shapeArgs={x:center[0],y:center[1],r:radius,innerR:innerRadius,start:start,end:end,borderRadius:borderRadius};point.startR=radius;if(graphic){d=shapeArgs.d;graphic.animate(SolidGaugeSeries_extend({fill:toColor},shapeArgs));if(d){shapeArgs.d=d}}else{point.graphic=graphic=renderer.arc(shapeArgs).attr({fill:toColor,"sweep-flag":0}).add(series.group)}if(!series.chart.styledMode){if(options.linecap!=="square"){graphic.attr({"stroke-linecap":"round","stroke-linejoin":"round"})}graphic.attr({stroke:options.borderColor||"none","stroke-width":options.borderWidth||0})}if(graphic){graphic.addClass(point.getClassName(),true)}}}}animate(init){if(!init){this.startAngleRad=this.thresholdAngleRad;PieSeries.prototype.animate.call(this,init)}}}SolidGaugeSeries.defaultOptions=SolidGaugeSeries_merge(GaugeSeries.defaultOptions,SolidGauge_SolidGaugeSeriesDefaults);highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().registerSeriesType("solidgauge",SolidGaugeSeries);const SolidGauge_SolidGaugeSeries=null&&SolidGaugeSeries;const solid_gauge_src=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});