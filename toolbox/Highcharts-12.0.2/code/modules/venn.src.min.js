(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory(root["_Highcharts"],root["_Highcharts"]["Color"],root["_Highcharts"]["SeriesRegistry"]);else if(typeof define==="function"&&define.amd)define("highcharts/modules/venn",["highcharts/highcharts"],function(amd1){return factory(amd1,amd1["Color"],amd1["SeriesRegistry"])});else if(typeof exports==="object")exports["highcharts/modules/venn"]=factory(root["_Highcharts"],root["_Highcharts"]["Color"],root["_Highcharts"]["SeriesRegistry"]);else root["Highcharts"]=factory(root["Highcharts"],root["Highcharts"]["Color"],root["Highcharts"]["SeriesRegistry"])})(typeof window==="undefined"?this:window,(__WEBPACK_EXTERNAL_MODULE__944__,__WEBPACK_EXTERNAL_MODULE__620__,__WEBPACK_EXTERNAL_MODULE__512__)=>{return(()=>{"use strict";var __webpack_modules__={620:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__620__},512:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__512__},944:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__944__}};var __webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(cachedModule!==undefined){return cachedModule.exports}var module=__webpack_module_cache__[moduleId]={exports:{}};__webpack_modules__[moduleId](module,module.exports,__webpack_require__);return module.exports}(()=>{__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module["default"]:()=>module;__webpack_require__.d(getter,{a:getter});return getter}})();(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>venn_src});var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_=__webpack_require__(944);var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default=__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_=__webpack_require__(620);var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default=__webpack_require__.n(highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_);var GeometryUtilities;(function(GeometryUtilities){function getCenterOfPoints(points){const sum=points.reduce((sum,point)=>{sum.x+=point.x;sum.y+=point.y;return sum},{x:0,y:0});return{x:sum.x/points.length,y:sum.y/points.length}}GeometryUtilities.getCenterOfPoints=getCenterOfPoints;function getDistanceBetweenPoints(p1,p2){return Math.sqrt(Math.pow(p2.x-p1.x,2)+Math.pow(p2.y-p1.y,2))}GeometryUtilities.getDistanceBetweenPoints=getDistanceBetweenPoints;function getAngleBetweenPoints(p1,p2){return Math.atan2(p2.x-p1.x,p2.y-p1.y)}GeometryUtilities.getAngleBetweenPoints=getAngleBetweenPoints;function pointInPolygon({x,y},polygon){const len=polygon.length;let i,j,inside=false;for(i=0,j=len-1;i<len;j=i++){const[x1,y1]=polygon[i],[x2,y2]=polygon[j];if(y1>y!==y2>y&&x<(x2-x1)*(y-y1)/(y2-y1)+x1){inside=!inside}}return inside}GeometryUtilities.pointInPolygon=pointInPolygon})(GeometryUtilities||(GeometryUtilities={}));const Geometry_GeometryUtilities=GeometryUtilities;const{getAngleBetweenPoints,getCenterOfPoints,getDistanceBetweenPoints}=Geometry_GeometryUtilities;var CircleUtilities;(function(CircleUtilities){function round(x,decimals){const a=Math.pow(10,decimals);return Math.round(x*a)/a}CircleUtilities.round=round;function getAreaOfCircle(r){if(r<=0){throw new Error("radius of circle must be a positive number.")}return Math.PI*r*r}CircleUtilities.getAreaOfCircle=getAreaOfCircle;function getCircularSegmentArea(r,h){return r*r*Math.acos(1-h/r)-(r-h)*Math.sqrt(h*(2*r-h))}CircleUtilities.getCircularSegmentArea=getCircularSegmentArea;function getOverlapBetweenCircles(r1,r2,d){let overlap=0;if(d<r1+r2){if(d<=Math.abs(r2-r1)){overlap=getAreaOfCircle(r1<r2?r1:r2)}else{const d1=(r1*r1-r2*r2+d*d)/(2*d),d2=d-d1;overlap=getCircularSegmentArea(r1,r1-d1)+getCircularSegmentArea(r2,r2-d2)}overlap=round(overlap,14)}return overlap}CircleUtilities.getOverlapBetweenCircles=getOverlapBetweenCircles;function getCircleCircleIntersection(c1,c2){const d=getDistanceBetweenPoints(c1,c2),r1=c1.r,r2=c2.r;let points=[];if(d<r1+r2&&d>Math.abs(r1-r2)){const r1Square=r1*r1,r2Square=r2*r2,x=(r1Square-r2Square+d*d)/(2*d),y=Math.sqrt(r1Square-x*x),x1=c1.x,x2=c2.x,y1=c1.y,y2=c2.y,x0=x1+x*(x2-x1)/d,y0=y1+x*(y2-y1)/d,rx=-(y2-y1)*(y/d),ry=-(x2-x1)*(y/d);points=[{x:round(x0+rx,14),y:round(y0-ry,14)},{x:round(x0-rx,14),y:round(y0+ry,14)}]}return points}CircleUtilities.getCircleCircleIntersection=getCircleCircleIntersection;function getCirclesIntersectionPoints(circles){return circles.reduce((points,c1,i,arr)=>{const additional=arr.slice(i+1).reduce((points,c2,j)=>{const indexes=[i,j+i+1];return points.concat(getCircleCircleIntersection(c1,c2).map(p=>{p.indexes=indexes;return p}))},[]);return points.concat(additional)},[])}CircleUtilities.getCirclesIntersectionPoints=getCirclesIntersectionPoints;function isCircle1CompletelyOverlappingCircle2(circle1,circle2){return getDistanceBetweenPoints(circle1,circle2)+circle2.r<circle1.r+1e-10}CircleUtilities.isCircle1CompletelyOverlappingCircle2=isCircle1CompletelyOverlappingCircle2;function isPointInsideCircle(point,circle){return getDistanceBetweenPoints(point,circle)<=circle.r+1e-10}CircleUtilities.isPointInsideCircle=isPointInsideCircle;function isPointInsideAllCircles(point,circles){return!circles.some(function(circle){return!isPointInsideCircle(point,circle)})}CircleUtilities.isPointInsideAllCircles=isPointInsideAllCircles;function isPointOutsideAllCircles(point,circles){return!circles.some(function(circle){return isPointInsideCircle(point,circle)})}CircleUtilities.isPointOutsideAllCircles=isPointOutsideAllCircles;function getCirclesIntersectionPolygon(circles){return getCirclesIntersectionPoints(circles).filter(function(p){return isPointInsideAllCircles(p,circles)})}CircleUtilities.getCirclesIntersectionPolygon=getCirclesIntersectionPolygon;function getAreaOfIntersectionBetweenCircles(circles){let intersectionPoints=getCirclesIntersectionPolygon(circles),result;if(intersectionPoints.length>1){const center=getCenterOfPoints(intersectionPoints);intersectionPoints=intersectionPoints.map(function(p){p.angle=getAngleBetweenPoints(center,p);return p}).sort(function(a,b){return b.angle-a.angle});const startPoint=intersectionPoints[intersectionPoints.length-1];const arcs=intersectionPoints.reduce(function(data,p1){const{startPoint}=data,midPoint=getCenterOfPoints([startPoint,p1]);const arc=p1.indexes.filter(function(index){return startPoint.indexes.indexOf(index)>-1}).reduce(function(arc,index){const circle=circles[index],angle1=getAngleBetweenPoints(circle,p1),angle2=getAngleBetweenPoints(circle,startPoint),angleDiff=angle2-angle1+(angle2<angle1?2*Math.PI:0),angle=angle2-angleDiff/2;let width=getDistanceBetweenPoints(midPoint,{x:circle.x+circle.r*Math.sin(angle),y:circle.y+circle.r*Math.cos(angle)});const{r}=circle;if(width>r*2){width=r*2}if(!arc||arc.width>width){arc={r:r,largeArc:width>r?1:0,width:width,x:p1.x,y:p1.y}}return arc},null);if(arc){const{r}=arc;data.arcs.push(["A",r,r,0,arc.largeArc,1,arc.x,arc.y]);data.startPoint=p1}return data},{startPoint:startPoint,arcs:[]}).arcs;if(arcs.length===0){}else if(arcs.length===1){}else{arcs.unshift(["M",startPoint.x,startPoint.y]);result={center:center,d:arcs}}}return result}CircleUtilities.getAreaOfIntersectionBetweenCircles=getAreaOfIntersectionBetweenCircles})(CircleUtilities||(CircleUtilities={}));const Geometry_CircleUtilities=CircleUtilities;function draw(point,params){const{animatableAttribs,onComplete,css,renderer}=params;const animation=point.series&&point.series.chart.hasRendered?void 0:point.series&&point.series.options.animation;let graphic=point.graphic;params.attribs={...params.attribs,class:point.getClassName()}||{};if(point.shouldDraw()){if(!graphic){if(params.shapeType==="text"){graphic=renderer.text()}else if(params.shapeType==="image"){graphic=renderer.image(params.imageUrl||"").attr(params.shapeArgs||{})}else{graphic=renderer[params.shapeType](params.shapeArgs||{})}point.graphic=graphic;graphic.add(params.group)}if(css){graphic.css(css)}graphic.attr(params.attribs).animate(animatableAttribs,params.isNew?false:animation,onComplete)}else if(graphic){const destroy=()=>{point.graphic=graphic=graphic&&graphic.destroy();if(typeof onComplete==="function"){onComplete()}};if(Object.keys(animatableAttribs).length){graphic.animate(animatableAttribs,void 0,()=>destroy())}else{destroy()}}}const DrawPointUtilities={draw:draw};const Series_DrawPointUtilities=DrawPointUtilities;var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_=__webpack_require__(512);var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default=__webpack_require__.n(highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_);const{scatter:{prototype:{pointClass:ScatterPoint}}}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().seriesTypes;const{isNumber}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class VennPoint extends ScatterPoint{isValid(){return isNumber(this.value)}shouldDraw(){return!!this.shapeArgs}}const Venn_VennPoint=VennPoint;const VennSeriesDefaults={borderColor:"#cccccc",borderDashStyle:"solid",borderWidth:1,brighten:0,clip:false,colorByPoint:true,dataLabels:{enabled:true,verticalAlign:"middle",formatter:function(){return this.point.name}},inactiveOtherPoints:true,marker:false,opacity:.75,showInLegend:false,legendType:"point",states:{hover:{opacity:1,borderColor:"#333333"},select:{color:"#cccccc",borderColor:"#000000",animation:false},inactive:{opacity:.075}},tooltip:{pointFormat:"{point.name}: {point.value}"},legendSymbol:"rectangle"};"";const Venn_VennSeriesDefaults=VennSeriesDefaults;const{getAreaOfCircle,getCircleCircleIntersection,getOverlapBetweenCircles:getOverlapBetweenCirclesByDistance,isPointInsideAllCircles,isPointInsideCircle,isPointOutsideAllCircles}=Geometry_CircleUtilities;const{getDistanceBetweenPoints:VennUtils_getDistanceBetweenPoints}=Geometry_GeometryUtilities;const{extend,isArray,isNumber:VennUtils_isNumber,isObject,isString}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function addOverlapToSets(relations){const mapOfIdToProps={};relations.filter(relation=>relation.sets.length===2).forEach(relation=>{relation.sets.forEach((set,i,arr)=>{if(!isObject(mapOfIdToProps[set])){mapOfIdToProps[set]={totalOverlap:0,overlapping:{}}}mapOfIdToProps[set]={totalOverlap:(mapOfIdToProps[set].totalOverlap||0)+relation.value,overlapping:{...mapOfIdToProps[set].overlapping||{},[arr[1-i]]:relation.value}}})});relations.filter(isSet).forEach(set=>{const properties=mapOfIdToProps[set.sets[0]];extend(set,properties)});return relations}function bisect(f,a,b,tolerance,maxIterations){const fA=f(a),fB=f(b),nMax=maxIterations||100,tol=tolerance||1e-10;let delta=b-a,x,fX,n=1;if(a>=b){throw new Error("a must be smaller than b.")}else if(fA*fB>0){throw new Error("f(a) and f(b) must have opposite signs.")}if(fA===0){x=a}else if(fB===0){x=b}else{while(n++<=nMax&&fX!==0&&delta>tol){delta=(b-a)/2;x=a+delta;fX=f(x);if(fA*fX>0){a=x}else{b=x}}}return x}function getCentroid(simplex){const arr=simplex.slice(0,-1),length=arr.length,result=[],sum=(data,point)=>{data.sum+=point[data.i];return data};for(let i=0;i<length;i++){result[i]=arr.reduce(sum,{sum:0,i:i}).sum/length}return result}function getDistanceBetweenCirclesByOverlap(r1,r2,overlap){const maxDistance=r1+r2;let distance;if(overlap<=0){distance=maxDistance}else if(getAreaOfCircle(r1<r2?r1:r2)<=overlap){distance=0}else{distance=bisect(x=>{const actualOverlap=getOverlapBetweenCirclesByDistance(r1,r2,x);return overlap-actualOverlap},0,maxDistance)}return distance}function getLabelWidth(pos,internal,external){const radius=internal.reduce((min,circle)=>Math.min(circle.r,min),Infinity),filteredExternals=external.filter(circle=>!isPointInsideCircle(pos,circle));const findDistance=function(maxDistance,direction){return bisect(x=>{const testPos={x:pos.x+direction*x,y:pos.y},isValid=isPointInsideAllCircles(testPos,internal)&&isPointOutsideAllCircles(testPos,filteredExternals);return-(maxDistance-x)+(isValid?0:Number.MAX_VALUE)},0,maxDistance)};return Math.min(findDistance(radius,-1),findDistance(radius,1))*2}function getMarginFromCircles(point,internal,external){let margin=internal.reduce((margin,circle)=>{const m=circle.r-VennUtils_getDistanceBetweenPoints(point,circle);return m<=margin?m:margin},Number.MAX_VALUE);margin=external.reduce((margin,circle)=>{const m=VennUtils_getDistanceBetweenPoints(point,circle)-circle.r;return m<=margin?m:margin},margin);return margin}function getOverlapBetweenCircles(circles){let overlap=0;if(circles.length===2){const circle1=circles[0];const circle2=circles[1];overlap=getOverlapBetweenCirclesByDistance(circle1.r,circle2.r,VennUtils_getDistanceBetweenPoints(circle1,circle2))}return overlap}function isSet(x){return isArray(x.sets)&&x.sets.length===1}function isValidRelation(x){const map={};return isObject(x)&&(VennUtils_isNumber(x.value)&&x.value>-1)&&(isArray(x.sets)&&x.sets.length>0)&&!x.sets.some(function(set){let invalid=false;if(!map[set]&&isString(set)){map[set]=true}else{invalid=true}return invalid})}function isValidSet(x){return isValidRelation(x)&&isSet(x)&&x.value>0}function layoutGreedyVenn(relations){const positionedSets=[],mapOfIdToCircles={};relations.filter(relation=>relation.sets.length===1).forEach(relation=>{mapOfIdToCircles[relation.sets[0]]=relation.circle={x:Number.MAX_VALUE,y:Number.MAX_VALUE,r:Math.sqrt(relation.value/Math.PI)}});const positionSet=(set,coordinates)=>{const circle=set.circle;if(circle){circle.x=coordinates.x;circle.y=coordinates.y}positionedSets.push(set)};addOverlapToSets(relations);const sortedByOverlap=relations.filter(isSet).sort(sortByTotalOverlap);positionSet(sortedByOverlap.shift(),{x:0,y:0});const relationsWithTwoSets=relations.filter(x=>x.sets.length===2);for(const set of sortedByOverlap){const circle=set.circle;if(!circle){continue}const radius=circle.r,overlapping=set.overlapping;const bestPosition=positionedSets.reduce((best,positionedSet,i)=>{const positionedCircle=positionedSet.circle;if(!positionedCircle||!overlapping){return best}const overlap=overlapping[positionedSet.sets[0]];const distance=getDistanceBetweenCirclesByOverlap(radius,positionedCircle.r,overlap);let possibleCoordinates=[{x:positionedCircle.x+distance,y:positionedCircle.y},{x:positionedCircle.x-distance,y:positionedCircle.y},{x:positionedCircle.x,y:positionedCircle.y+distance},{x:positionedCircle.x,y:positionedCircle.y-distance}];for(const positionedSet2 of positionedSets.slice(i+1)){const positionedCircle2=positionedSet2.circle,overlap2=overlapping[positionedSet2.sets[0]];if(!positionedCircle2){continue}const distance2=getDistanceBetweenCirclesByOverlap(radius,positionedCircle2.r,overlap2);possibleCoordinates=possibleCoordinates.concat(getCircleCircleIntersection({x:positionedCircle.x,y:positionedCircle.y,r:distance},{x:positionedCircle2.x,y:positionedCircle2.y,r:distance2}))}for(const coordinates of possibleCoordinates){circle.x=coordinates.x;circle.y=coordinates.y;const currentLoss=loss(mapOfIdToCircles,relationsWithTwoSets);if(currentLoss<best.loss){best.loss=currentLoss;best.coordinates=coordinates}}return best},{loss:Number.MAX_VALUE,coordinates:void 0});positionSet(set,bestPosition.coordinates)}return mapOfIdToCircles}function loss(mapOfIdToCircle,relations){const precision=1e11;return relations.reduce(function(totalLoss,relation){let loss=0;if(relation.sets.length>1){const wantedOverlap=relation.value;const actualOverlap=getOverlapBetweenCircles(relation.sets.map(function(set){return mapOfIdToCircle[set]}));const diff=wantedOverlap-actualOverlap;loss=Math.round(diff*diff*precision)/precision}return totalLoss+loss},0)}function nelderMead(fn,initial){const maxIterations=100,sortByFx=function(a,b){return a.fx-b.fx},pRef=1,pExp=2,pCon=-.5,pOCon=pCon*pRef,pShrink=.5;const weightedSum=(weight1,v1,weight2,v2)=>v1.map((x,i)=>weight1*x+weight2*v2[i]);const getSimplex=initial=>{const n=initial.length,simplex=new Array(n+1);simplex[0]=initial;simplex[0].fx=fn(initial);for(let i=0;i<n;++i){const point=initial.slice();point[i]=point[i]?point[i]*1.05:.001;point.fx=fn(point);simplex[i+1]=point}return simplex};const updateSimplex=(simplex,point)=>{point.fx=fn(point);simplex[simplex.length-1]=point;return simplex};const shrinkSimplex=simplex=>{const best=simplex[0];return simplex.map(point=>{const p=weightedSum(1-pShrink,best,pShrink,point);p.fx=fn(p);return p})};const getPoint=(centroid,worst,a,b)=>{const point=weightedSum(a,centroid,b,worst);point.fx=fn(point);return point};let simplex=getSimplex(initial);for(let i=0;i<maxIterations;i++){simplex.sort(sortByFx);const worst=simplex[simplex.length-1];const centroid=getCentroid(simplex);const reflected=getPoint(centroid,worst,1+pRef,-pRef);if(reflected.fx<simplex[0].fx){const expanded=getPoint(centroid,worst,1+pExp,-pExp);simplex=updateSimplex(simplex,expanded.fx<reflected.fx?expanded:reflected)}else if(reflected.fx>=simplex[simplex.length-2].fx){let contracted;if(reflected.fx>worst.fx){contracted=getPoint(centroid,worst,1+pCon,-pCon);if(contracted.fx<worst.fx){simplex=updateSimplex(simplex,contracted)}else{simplex=shrinkSimplex(simplex)}}else{contracted=getPoint(centroid,worst,1-pOCon,pOCon);if(contracted.fx<reflected.fx){simplex=updateSimplex(simplex,contracted)}else{simplex=shrinkSimplex(simplex)}}}else{simplex=updateSimplex(simplex,reflected)}}return simplex[0]}function processVennData(data,splitter){const d=isArray(data)?data:[];const validSets=d.reduce(function(arr,x){if(x.sets&&isValidSet(x)&&arr.indexOf(x.sets[0])===-1){arr.push(x.sets[0])}return arr},[]).sort();const mapOfIdToRelation=d.reduce(function(mapOfIdToRelation,relation){if(relation.sets&&isValidRelation(relation)&&!relation.sets.some(function(set){return validSets.indexOf(set)===-1})){mapOfIdToRelation[relation.sets.sort().join(splitter)]={sets:relation.sets,value:relation.value||0}}return mapOfIdToRelation},{});validSets.reduce(function(combinations,set,i,arr){const remaining=arr.slice(i+1);remaining.forEach(function(set2){combinations.push(set+splitter+set2)});return combinations},[]).forEach(function(combination){if(!mapOfIdToRelation[combination]){const obj={sets:combination.split(splitter),value:0};mapOfIdToRelation[combination]=obj}});return Object.keys(mapOfIdToRelation).map(function(id){return mapOfIdToRelation[id]})}function sortByTotalOverlap(a,b){if(typeof b.totalOverlap!=="undefined"&&typeof a.totalOverlap!=="undefined"){return b.totalOverlap-a.totalOverlap}return NaN}const VennUtils={geometry:Geometry_GeometryUtilities,geometryCircles:Geometry_CircleUtilities,addOverlapToSets:addOverlapToSets,getCentroid:getCentroid,getDistanceBetweenCirclesByOverlap:getDistanceBetweenCirclesByOverlap,getLabelWidth:getLabelWidth,getMarginFromCircles:getMarginFromCircles,isSet:isSet,layoutGreedyVenn:layoutGreedyVenn,loss:loss,nelderMead:nelderMead,processVennData:processVennData,sortByTotalOverlap:sortByTotalOverlap};const Venn_VennUtils=VennUtils;const{animObject}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{parse:color}=highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default();const{getAreaOfIntersectionBetweenCircles,getCirclesIntersectionPolygon,isCircle1CompletelyOverlappingCircle2,isPointInsideAllCircles:VennSeries_isPointInsideAllCircles,isPointOutsideAllCircles:VennSeries_isPointOutsideAllCircles}=Geometry_CircleUtilities;const{getCenterOfPoints:VennSeries_getCenterOfPoints}=Geometry_GeometryUtilities;const{scatter:ScatterSeries}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().seriesTypes;const{addEvent,extend:VennSeries_extend,isArray:VennSeries_isArray,isNumber:VennSeries_isNumber,isObject:VennSeries_isObject,merge}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class VennSeries extends ScatterSeries{static getLabelPosition(internal,external){let best=internal.reduce((best,circle)=>{const d=circle.r/2;return[{x:circle.x,y:circle.y},{x:circle.x+d,y:circle.y},{x:circle.x-d,y:circle.y},{x:circle.x,y:circle.y+d},{x:circle.x,y:circle.y-d}].reduce((best,point)=>{const margin=Venn_VennUtils.getMarginFromCircles(point,internal,external);if(best.margin<margin){best.point=point;best.margin=margin}return best},best)},{point:void 0,margin:-Number.MAX_VALUE}).point;const optimal=Venn_VennUtils.nelderMead(p=>-Venn_VennUtils.getMarginFromCircles({x:p[0],y:p[1]},internal,external),[best.x,best.y]);best={x:optimal[0],y:optimal[1]};if(!(VennSeries_isPointInsideAllCircles(best,internal)&&VennSeries_isPointOutsideAllCircles(best,external))){if(internal.length>1){best=VennSeries_getCenterOfPoints(getCirclesIntersectionPolygon(internal))}else{best={x:internal[0].x,y:internal[0].y}}}return best}static getLabelValues(relation,setRelations){const sets=relation.sets;const data=setRelations.reduce((data,set)=>{const isInternal=sets.indexOf(set.sets[0])>-1;const property=isInternal?"internal":"external";if(set.circle){data[property].push(set.circle)}return data},{internal:[],external:[]});data.external=data.external.filter(externalCircle=>data.internal.some(internalCircle=>!isCircle1CompletelyOverlappingCircle2(externalCircle,internalCircle)));const position=VennSeries.getLabelPosition(data.internal,data.external);const width=Venn_VennUtils.getLabelWidth(position,data.internal,data.external);return{position:position,width:width}}static layout(relations){const mapOfIdToShape={};const mapOfIdToLabelValues={};if(relations.length>0){const mapOfIdToCircles=Venn_VennUtils.layoutGreedyVenn(relations);const setRelations=relations.filter(Venn_VennUtils.isSet);for(const relation of relations){const sets=relation.sets;const id=sets.join();const shape=Venn_VennUtils.isSet(relation)?mapOfIdToCircles[id]:getAreaOfIntersectionBetweenCircles(sets.map(set=>mapOfIdToCircles[set]));if(shape){mapOfIdToShape[id]=shape;mapOfIdToLabelValues[id]=VennSeries.getLabelValues(relation,setRelations)}}}return{mapOfIdToShape:mapOfIdToShape,mapOfIdToLabelValues:mapOfIdToLabelValues}}static getScale(targetWidth,targetHeight,field){const height=field.bottom-field.top,width=field.right-field.left,scaleX=width>0?1/width*targetWidth:1,scaleY=height>0?1/height*targetHeight:1,adjustX=(field.right+field.left)/2,adjustY=(field.top+field.bottom)/2,scale=Math.min(scaleX,scaleY);return{scale:scale,centerX:targetWidth/2-adjustX*scale,centerY:targetHeight/2-adjustY*scale}}static updateFieldBoundaries(field,circle){const left=circle.x-circle.r,right=circle.x+circle.r,bottom=circle.y+circle.r,top=circle.y-circle.r;if(!VennSeries_isNumber(field.left)||field.left>left){field.left=left}if(!VennSeries_isNumber(field.right)||field.right<right){field.right=right}if(!VennSeries_isNumber(field.top)||field.top>top){field.top=top}if(!VennSeries_isNumber(field.bottom)||field.bottom<bottom){field.bottom=bottom}return field}animate(init){if(!init){const series=this,animOptions=animObject(series.options.animation);for(const point of series.points){const args=point.shapeArgs;if(point.graphic&&args){const attr={},animate={};if(args.d){attr.opacity=.001}else{attr.r=0;animate.r=args.r}point.graphic.attr(attr).animate(animate,animOptions);if(args.d){setTimeout(()=>{if(point&&point.graphic){point.graphic.animate({opacity:1})}},animOptions.duration)}}}}}drawPoints(){const series=this,chart=series.chart,group=series.group,points=series.points||[],renderer=chart.renderer;for(const point of points){const attribs={zIndex:VennSeries_isArray(point.sets)?point.sets.length:0},shapeArgs=point.shapeArgs;if(!chart.styledMode){VennSeries_extend(attribs,series.pointAttribs(point,point.state))}Series_DrawPointUtilities.draw(point,{isNew:!point.graphic,animatableAttribs:shapeArgs,attribs:attribs,group:group,renderer:renderer,shapeType:shapeArgs&&shapeArgs.d?"path":"circle"})}}init(){ScatterSeries.prototype.init.apply(this,arguments);delete this.opacity}pointAttribs(point,state){const series=this,seriesOptions=series.options||{},pointOptions=point&&point.options||{},stateOptions=state&&seriesOptions.states[state]||{},options=merge(seriesOptions,{color:point&&point.color},pointOptions,stateOptions);return{fill:color(options.color).brighten(options.brightness).get(),opacity:options.opacity,stroke:options.borderColor,"stroke-width":options.borderWidth,dashstyle:options.borderDashStyle}}translate(){const chart=this.chart;this.dataTable.modified=this.dataTable;this.generatePoints();const relations=Venn_VennUtils.processVennData(this.options.data,VennSeries.splitter);const{mapOfIdToShape,mapOfIdToLabelValues}=VennSeries.layout(relations);const field=Object.keys(mapOfIdToShape).filter(key=>{const shape=mapOfIdToShape[key];return shape&&VennSeries_isNumber(shape.r)}).reduce((field,key)=>VennSeries.updateFieldBoundaries(field,mapOfIdToShape[key]),{top:0,bottom:0,left:0,right:0}),scaling=VennSeries.getScale(chart.plotWidth,chart.plotHeight,field),scale=scaling.scale,centerX=scaling.centerX,centerY=scaling.centerY;for(const point of this.points){const sets=VennSeries_isArray(point.sets)?point.sets:[],id=sets.join(),shape=mapOfIdToShape[id],dataLabelValues=mapOfIdToLabelValues[id]||{},dlOptions=point.options&&point.options.dataLabels;let shapeArgs,dataLabelWidth=dataLabelValues.width,dataLabelPosition=dataLabelValues.position;if(shape){if(shape.r){shapeArgs={x:centerX+shape.x*scale,y:centerY+shape.y*scale,r:shape.r*scale}}else if(shape.d){const d=shape.d;d.forEach(seg=>{if(seg[0]==="M"){seg[1]=centerX+seg[1]*scale;seg[2]=centerY+seg[2]*scale}else if(seg[0]==="A"){seg[1]=seg[1]*scale;seg[2]=seg[2]*scale;seg[6]=centerX+seg[6]*scale;seg[7]=centerY+seg[7]*scale}});shapeArgs={d:d}}if(dataLabelPosition){dataLabelPosition.x=centerX+dataLabelPosition.x*scale;dataLabelPosition.y=centerY+dataLabelPosition.y*scale}else{dataLabelPosition={}}if(VennSeries_isNumber(dataLabelWidth)){dataLabelWidth=Math.round(dataLabelWidth*scale)}}point.shapeArgs=shapeArgs;if(dataLabelPosition&&shapeArgs){point.plotX=dataLabelPosition.x;point.plotY=dataLabelPosition.y}if(dataLabelWidth&&shapeArgs){point.dlOptions=merge(true,{style:{width:dataLabelWidth}},VennSeries_isObject(dlOptions,true)?dlOptions:void 0)}point.name=point.options.name||sets.join("∩")}}}VennSeries.splitter="highcharts-split";VennSeries.defaultOptions=merge(ScatterSeries.defaultOptions,Venn_VennSeriesDefaults);VennSeries_extend(VennSeries.prototype,{axisTypes:[],directTouch:true,isCartesian:false,pointArrayMap:["value"],pointClass:Venn_VennPoint,utils:Venn_VennUtils});addEvent(VennSeries,"afterSetOptions",function(e){const options=e.options,states=options.states||{};if(this.is("venn")){for(const state of Object.keys(states)){states[state].halo=false}}});highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().registerSeriesType("venn",VennSeries);const Venn_VennSeries=null&&VennSeries;const venn_src=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});