(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory(root["_Highcharts"],root["_Highcharts"]["StackItem"],root["_Highcharts"]["Axis"],root["_Highcharts"]["Color"]);else if(typeof define==="function"&&define.amd)define("highcharts/modules/treegrid",["highcharts/highcharts"],function(amd1){return factory(amd1,amd1["StackItem"],amd1["Axis"],amd1["Color"])});else if(typeof exports==="object")exports["highcharts/modules/treegrid"]=factory(root["_Highcharts"],root["_Highcharts"]["StackItem"],root["_Highcharts"]["Axis"],root["_Highcharts"]["Color"]);else root["Highcharts"]=factory(root["Highcharts"],root["Highcharts"]["StackItem"],root["Highcharts"]["Axis"],root["Highcharts"]["Color"])})(typeof window==="undefined"?this:window,(__WEBPACK_EXTERNAL_MODULE__944__,__WEBPACK_EXTERNAL_MODULE__184__,__WEBPACK_EXTERNAL_MODULE__532__,__WEBPACK_EXTERNAL_MODULE__620__)=>{return(()=>{"use strict";var __webpack_modules__={532:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__532__},620:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__620__},184:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__184__},944:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__944__}};var __webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(cachedModule!==undefined){return cachedModule.exports}var module=__webpack_module_cache__[moduleId]={exports:{}};__webpack_modules__[moduleId](module,module.exports,__webpack_require__);return module.exports}(()=>{__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module["default"]:()=>module;__webpack_require__.d(getter,{a:getter});return getter}})();(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>treegrid_src});var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_=__webpack_require__(944);var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default=__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);var highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_=__webpack_require__(184);var highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_default=__webpack_require__.n(highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_);const{addEvent,find,fireEvent,isArray,isNumber,pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var BrokenAxis;(function(BrokenAxis){function compose(AxisClass,SeriesClass){if(!AxisClass.keepProps.includes("brokenAxis")){AxisClass.keepProps.push("brokenAxis");addEvent(AxisClass,"init",onAxisInit);addEvent(AxisClass,"afterInit",onAxisAfterInit);addEvent(AxisClass,"afterSetTickPositions",onAxisAfterSetTickPositions);addEvent(AxisClass,"afterSetOptions",onAxisAfterSetOptions);const seriesProto=SeriesClass.prototype;seriesProto.drawBreaks=seriesDrawBreaks;seriesProto.gappedPath=seriesGappedPath;addEvent(SeriesClass,"afterGeneratePoints",onSeriesAfterGeneratePoints);addEvent(SeriesClass,"afterRender",onSeriesAfterRender)}return AxisClass}BrokenAxis.compose=compose;function onAxisAfterInit(){if(typeof this.brokenAxis!=="undefined"){this.brokenAxis.setBreaks(this.options.breaks,false)}}function onAxisAfterSetOptions(){const axis=this;if(axis.brokenAxis?.hasBreaks){axis.options.ordinal=false}}function onAxisAfterSetTickPositions(){const axis=this,brokenAxis=axis.brokenAxis;if(brokenAxis?.hasBreaks){const tickPositions=axis.tickPositions,info=axis.tickPositions.info,newPositions=[];for(let i=0;i<tickPositions.length;i++){if(!brokenAxis.isInAnyBreak(tickPositions[i])){newPositions.push(tickPositions[i])}}axis.tickPositions=newPositions;axis.tickPositions.info=info}}function onAxisInit(){const axis=this;if(!axis.brokenAxis){axis.brokenAxis=new Additions(axis)}}function onSeriesAfterGeneratePoints(){const{isDirty,options:{connectNulls},points,xAxis,yAxis}=this;if(isDirty){let i=points.length;while(i--){const point=points[i];const nullGap=point.y===null&&connectNulls===false;const isPointInBreak=!nullGap&&(xAxis?.brokenAxis?.isInAnyBreak(point.x,true)||yAxis?.brokenAxis?.isInAnyBreak(point.y,true));point.visible=isPointInBreak?false:point.options.visible!==false}}}function onSeriesAfterRender(){this.drawBreaks(this.xAxis,["x"]);this.drawBreaks(this.yAxis,pick(this.pointArrayMap,["y"]))}function seriesDrawBreaks(axis,keys){const series=this,points=series.points;let breaks,threshold,y;if(axis?.brokenAxis?.hasBreaks){const brokenAxis=axis.brokenAxis;keys.forEach(function(key){breaks=brokenAxis?.breakArray||[];threshold=axis.isXAxis?axis.min:pick(series.options.threshold,axis.min);const breaksOutOfRange=axis?.options?.breaks?.filter(function(brk){let isOut=true;for(let i=0;i<breaks.length;i++){const otherBreak=breaks[i];if(otherBreak.from===brk.from&&otherBreak.to===brk.to){isOut=false;break}}return isOut});points.forEach(function(point){y=pick(point["stack"+key.toUpperCase()],point[key]);breaks.forEach(function(brk){if(isNumber(threshold)&&isNumber(y)){let eventName="";if(threshold<brk.from&&y>brk.to||threshold>brk.from&&y<brk.from){eventName="pointBreak"}else if(threshold<brk.from&&y>brk.from&&y<brk.to||threshold>brk.from&&y>brk.to&&y<brk.from){eventName="pointInBreak"}if(eventName){fireEvent(axis,eventName,{point:point,brk:brk})}}});breaksOutOfRange?.forEach(function(brk){fireEvent(axis,"pointOutsideOfBreak",{point:point,brk:brk})})})})}}function seriesGappedPath(){const currentDataGrouping=this.currentDataGrouping,groupingSize=currentDataGrouping?.gapSize,points=this.points.slice(),yAxis=this.yAxis;let gapSize=this.options.gapSize,i=points.length-1,stack;if(gapSize&&i>0){if(this.options.gapUnit!=="value"){gapSize*=this.basePointRange}if(groupingSize&&groupingSize>gapSize&&groupingSize>=this.basePointRange){gapSize=groupingSize}let current,next;while(i--){if(!(next&&next.visible!==false)){next=points[i+1]}current=points[i];if(next.visible===false||current.visible===false){continue}if(next.x-current.x>gapSize){const xRange=(current.x+next.x)/2;points.splice(i+1,0,{isNull:true,x:xRange});if(yAxis.stacking&&this.options.stacking){stack=yAxis.stacking.stacks[this.stackKey][xRange]=new(highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_default())(yAxis,yAxis.options.stackLabels,false,xRange,this.stack);stack.total=0}}next=current}}return this.getGraphPath(points)}class Additions{static isInBreak(brk,val){const repeat=brk.repeat||Infinity,from=brk.from,length=brk.to-brk.from,test=val>=from?(val-from)%repeat:repeat-(from-val)%repeat;let ret;if(!brk.inclusive){ret=test<length&&test!==0}else{ret=test<=length}return ret}static lin2Val(val){const axis=this;const brokenAxis=axis.brokenAxis;const breakArray=brokenAxis&&brokenAxis.breakArray;if(!breakArray||!isNumber(val)){return val}let nval=val,brk,i;for(i=0;i<breakArray.length;i++){brk=breakArray[i];if(brk.from>=nval){break}else if(brk.to<nval){nval+=brk.len}else if(Additions.isInBreak(brk,nval)){nval+=brk.len}}return nval}static val2Lin(val){const axis=this;const brokenAxis=axis.brokenAxis;const breakArray=brokenAxis&&brokenAxis.breakArray;if(!breakArray||!isNumber(val)){return val}let nval=val,brk,i;for(i=0;i<breakArray.length;i++){brk=breakArray[i];if(brk.to<=val){nval-=brk.len}else if(brk.from>=val){break}else if(Additions.isInBreak(brk,val)){nval-=val-brk.from;break}}return nval}constructor(axis){this.hasBreaks=false;this.axis=axis}findBreakAt(x,breaks){return find(breaks,function(b){return b.from<x&&x<b.to})}isInAnyBreak(val,testKeep){const brokenAxis=this,axis=brokenAxis.axis,breaks=axis.options.breaks||[];let i=breaks.length,inbrk,keep,ret;if(i&&isNumber(val)){while(i--){if(Additions.isInBreak(breaks[i],val)){inbrk=true;if(!keep){keep=pick(breaks[i].showPoints,!axis.isXAxis)}}}if(inbrk&&testKeep){ret=inbrk&&!keep}else{ret=inbrk}}return ret}setBreaks(breaks,redraw){const brokenAxis=this,axis=brokenAxis.axis,time=axis.chart.time,hasBreaks=isArray(breaks)&&!!breaks.length&&!!Object.keys(breaks[0]).length;axis.isDirty=brokenAxis.hasBreaks!==hasBreaks;brokenAxis.hasBreaks=hasBreaks;breaks?.forEach(brk=>{brk.from=time.parse(brk.from)||0;brk.to=time.parse(brk.to)||0});if(breaks!==axis.options.breaks){axis.options.breaks=axis.userOptions.breaks=breaks}axis.forceRedraw=true;axis.series.forEach(function(series){series.isDirty=true});if(!hasBreaks&&axis.val2lin===Additions.val2Lin){delete axis.val2lin;delete axis.lin2val}if(hasBreaks){axis.userOptions.ordinal=false;axis.lin2val=Additions.lin2Val;axis.val2lin=Additions.val2Lin;axis.setExtremes=function(newMin,newMax,redraw,animation,eventArguments){if(brokenAxis.hasBreaks){const breaks=this.options.breaks||[];let axisBreak;while(axisBreak=brokenAxis.findBreakAt(newMin,breaks)){newMin=axisBreak.to}while(axisBreak=brokenAxis.findBreakAt(newMax,breaks)){newMax=axisBreak.from}if(newMax<newMin){newMax=newMin}}axis.constructor.prototype.setExtremes.call(this,newMin,newMax,redraw,animation,eventArguments)};axis.setAxisTranslation=function(){axis.constructor.prototype.setAxisTranslation.call(this);brokenAxis.unitLength=void 0;if(brokenAxis.hasBreaks){const breaks=axis.options.breaks||[],breakArrayT=[],breakArray=[],pointRangePadding=pick(axis.pointRangePadding,0);let length=0,inBrk,repeat,min=axis.userMin||axis.min,max=axis.userMax||axis.max,start,i;breaks.forEach(function(brk){repeat=brk.repeat||Infinity;if(isNumber(min)&&isNumber(max)){if(Additions.isInBreak(brk,min)){min+=brk.to%repeat-min%repeat}if(Additions.isInBreak(brk,max)){max-=max%repeat-brk.from%repeat}}});breaks.forEach(function(brk){start=brk.from;repeat=brk.repeat||Infinity;if(isNumber(min)&&isNumber(max)){while(start-repeat>min){start-=repeat}while(start<min){start+=repeat}for(i=start;i<max;i+=repeat){breakArrayT.push({value:i,move:"in"});breakArrayT.push({value:i+brk.to-brk.from,move:"out",size:brk.breakSize})}}});breakArrayT.sort(function(a,b){return a.value===b.value?(a.move==="in"?0:1)-(b.move==="in"?0:1):a.value-b.value});inBrk=0;start=min;breakArrayT.forEach(function(brk){inBrk+=brk.move==="in"?1:-1;if(inBrk===1&&brk.move==="in"){start=brk.value}if(inBrk===0&&isNumber(start)){breakArray.push({from:start,to:brk.value,len:brk.value-start-(brk.size||0)});length+=brk.value-start-(brk.size||0)}});brokenAxis.breakArray=breakArray;if(isNumber(min)&&isNumber(max)&&isNumber(axis.min)){brokenAxis.unitLength=max-min-length+pointRangePadding;fireEvent(axis,"afterBreaks");if(axis.staticScale){axis.transA=axis.staticScale}else if(brokenAxis.unitLength){axis.transA*=(max-axis.min+pointRangePadding)/brokenAxis.unitLength}if(pointRangePadding){axis.minPixelPadding=axis.transA*(axis.minPointOffset||0)}axis.min=min;axis.max=max}}}}if(pick(redraw,true)){axis.chart.redraw()}}}BrokenAxis.Additions=Additions})(BrokenAxis||(BrokenAxis={}));const Axis_BrokenAxis=BrokenAxis;var highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_=__webpack_require__(532);var highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_default=__webpack_require__.n(highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_);const{dateFormats}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:GridAxis_addEvent,defined,erase,find:GridAxis_find,isArray:GridAxis_isArray,isNumber:GridAxis_isNumber,merge,pick:GridAxis_pick,timeUnits,wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var GridAxisSide;(function(GridAxisSide){GridAxisSide[GridAxisSide["top"]=0]="top";GridAxisSide[GridAxisSide["right"]=1]="right";GridAxisSide[GridAxisSide["bottom"]=2]="bottom";GridAxisSide[GridAxisSide["left"]=3]="left"})(GridAxisSide||(GridAxisSide={}));function argsToArray(args){return Array.prototype.slice.call(args,1)}function isObject(x){return highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().isObject(x,true)}function applyGridOptions(axis){const options=axis.options;options.labels.align=GridAxis_pick(options.labels.align,"center");if(!axis.categories){options.showLastLabel=false}axis.labelRotation=0;options.labels.rotation=0;options.minTickInterval=1}function compose(AxisClass,ChartClass,TickClass){if(!AxisClass.keepProps.includes("grid")){AxisClass.keepProps.push("grid");AxisClass.prototype.getMaxLabelDimensions=getMaxLabelDimensions;wrap(AxisClass.prototype,"unsquish",wrapUnsquish);wrap(AxisClass.prototype,"getOffset",wrapGetOffset);GridAxis_addEvent(AxisClass,"init",onInit);GridAxis_addEvent(AxisClass,"afterGetTitlePosition",onAfterGetTitlePosition);GridAxis_addEvent(AxisClass,"afterInit",onAfterInit);GridAxis_addEvent(AxisClass,"afterRender",onAfterRender);GridAxis_addEvent(AxisClass,"afterSetAxisTranslation",onAfterSetAxisTranslation);GridAxis_addEvent(AxisClass,"afterSetOptions",onAfterSetOptions);GridAxis_addEvent(AxisClass,"afterSetOptions",onAfterSetOptions2);GridAxis_addEvent(AxisClass,"afterSetScale",onAfterSetScale);GridAxis_addEvent(AxisClass,"afterTickSize",onAfterTickSize);GridAxis_addEvent(AxisClass,"trimTicks",onTrimTicks);GridAxis_addEvent(AxisClass,"destroy",onDestroy);GridAxis_addEvent(ChartClass,"afterSetChartSize",onChartAfterSetChartSize);GridAxis_addEvent(TickClass,"afterGetLabelPosition",onTickAfterGetLabelPosition);GridAxis_addEvent(TickClass,"labelFormat",onTickLabelFormat)}return AxisClass}function getMaxLabelDimensions(ticks,tickPositions){const dimensions={width:0,height:0};tickPositions.forEach(function(pos){const tick=ticks[pos];let labelHeight=0,labelWidth=0,label;if(isObject(tick)){label=isObject(tick.label)?tick.label:{};labelHeight=label.getBBox?label.getBBox().height:0;if(label.textStr&&!GridAxis_isNumber(label.textPxLength)){label.textPxLength=label.getBBox().width}labelWidth=GridAxis_isNumber(label.textPxLength)?Math.round(label.textPxLength):0;if(label.textStr){labelWidth=Math.round(label.getBBox().width)}dimensions.height=Math.max(labelHeight,dimensions.height);dimensions.width=Math.max(labelWidth,dimensions.width)}});if(this.type==="treegrid"&&this.treeGrid&&this.treeGrid.mapOfPosToGridNode){const treeDepth=this.treeGrid.mapOfPosToGridNode[-1].height||0;dimensions.width+=this.options.labels.indentation*(treeDepth-1)}return dimensions}function wrapGetOffset(proceed){const{grid}=this,columnsFirst=this.side===3;if(!columnsFirst){proceed.apply(this)}if(!grid?.isColumn){let columns=grid?.columns||[];if(columnsFirst){columns=columns.slice().reverse()}columns.forEach(column=>{column.getOffset()})}if(columnsFirst){proceed.apply(this)}}function onAfterGetTitlePosition(e){const axis=this;const options=axis.options;const gridOptions=options.grid||{};if(gridOptions.enabled===true){const{axisTitle,height:axisHeight,horiz,left:axisLeft,offset,opposite,options,top:axisTop,width:axisWidth}=axis;const tickSize=axis.tickSize();const titleWidth=axisTitle&&axisTitle.getBBox().width;const xOption=options.title.x;const yOption=options.title.y;const titleMargin=GridAxis_pick(options.title.margin,horiz?5:10);const titleFontSize=axisTitle?axis.chart.renderer.fontMetrics(axisTitle).f:0;const crispCorr=tickSize?tickSize[0]/2:0;const offAxis=(horiz?axisTop+axisHeight:axisLeft)+(horiz?1:-1)*(opposite?-1:1)*crispCorr+(axis.side===GridAxisSide.bottom?titleFontSize:0);e.titlePosition.x=horiz?axisLeft-(titleWidth||0)/2-titleMargin+xOption:offAxis+(opposite?axisWidth:0)+offset+xOption;e.titlePosition.y=horiz?offAxis-(opposite?axisHeight:0)+(opposite?titleFontSize:-titleFontSize)/2+offset+yOption:axisTop-titleMargin+yOption}}function onAfterInit(){const axis=this;const{chart,options:{grid:gridOptions={}},userOptions}=axis;if(gridOptions.enabled){applyGridOptions(axis)}if(gridOptions.columns){const columns=axis.grid.columns=[];let columnIndex=axis.grid.columnIndex=0;while(++columnIndex<gridOptions.columns.length){const columnOptions=merge(userOptions,gridOptions.columns[columnIndex],{isInternal:true,linkedTo:0,scrollbar:{enabled:false}},{grid:{columns:void 0}});const column=new(highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_default())(axis.chart,columnOptions,"yAxis");column.grid.isColumn=true;column.grid.columnIndex=columnIndex;erase(chart.axes,column);erase(chart[axis.coll]||[],column);columns.push(column)}}}function onAfterRender(){const axis=this,{axisTitle,grid,options}=axis,gridOptions=options.grid||{};if(gridOptions.enabled===true){const min=axis.min||0,max=axis.max||0,firstTick=axis.ticks[axis.tickPositions[0]];if(axisTitle&&!axis.chart.styledMode&&firstTick?.slotWidth&&!axis.options.title.style.width){axisTitle.css({width:`${firstTick.slotWidth}px`})}axis.maxLabelDimensions=axis.getMaxLabelDimensions(axis.ticks,axis.tickPositions);if(axis.rightWall){axis.rightWall.destroy()}if(axis.grid&&axis.grid.isOuterAxis()&&axis.axisLine){const lineWidth=options.lineWidth;if(lineWidth){const linePath=axis.getLinePath(lineWidth),startPoint=linePath[0],endPoint=linePath[1],tickLength=(axis.tickSize("tick")||[1])[0],distance=tickLength*(axis.side===GridAxisSide.top||axis.side===GridAxisSide.left?-1:1);if(startPoint[0]==="M"&&endPoint[0]==="L"){if(axis.horiz){startPoint[2]+=distance;endPoint[2]+=distance}else{startPoint[1]+=distance;endPoint[1]+=distance}}if(!axis.horiz&&axis.chart.marginRight){const upperBorderStartPoint=startPoint,upperBorderEndPoint=["L",axis.left,startPoint[2]||0],upperBorderPath=[upperBorderStartPoint,upperBorderEndPoint],lowerBorderEndPoint=["L",axis.chart.chartWidth-axis.chart.marginRight,axis.toPixels(max+axis.tickmarkOffset)],lowerBorderStartPoint=["M",endPoint[1]||0,axis.toPixels(max+axis.tickmarkOffset)],lowerBorderPath=[lowerBorderStartPoint,lowerBorderEndPoint];if(!axis.grid.upperBorder&&min%1!==0){axis.grid.upperBorder=axis.grid.renderBorder(upperBorderPath)}if(axis.grid.upperBorder){axis.grid.upperBorder.attr({stroke:options.lineColor,"stroke-width":options.lineWidth});axis.grid.upperBorder.animate({d:upperBorderPath})}if(!axis.grid.lowerBorder&&max%1!==0){axis.grid.lowerBorder=axis.grid.renderBorder(lowerBorderPath)}if(axis.grid.lowerBorder){axis.grid.lowerBorder.attr({stroke:options.lineColor,"stroke-width":options.lineWidth});axis.grid.lowerBorder.animate({d:lowerBorderPath})}}if(!axis.grid.axisLineExtra){axis.grid.axisLineExtra=axis.grid.renderBorder(linePath)}else{axis.grid.axisLineExtra.attr({stroke:options.lineColor,"stroke-width":options.lineWidth});axis.grid.axisLineExtra.animate({d:linePath})}axis.axisLine[axis.showAxis?"show":"hide"]()}}(grid&&grid.columns||[]).forEach(column=>column.render());if(!axis.horiz&&axis.chart.hasRendered&&(axis.scrollbar||axis.linkedParent&&axis.linkedParent.scrollbar)&&axis.tickPositions.length){const tickmarkOffset=axis.tickmarkOffset,lastTick=axis.tickPositions[axis.tickPositions.length-1],firstTick=axis.tickPositions[0];let label,tickMark;while((label=axis.hiddenLabels.pop())&&label.element){label.show()}while((tickMark=axis.hiddenMarks.pop())&&tickMark.element){tickMark.show()}label=axis.ticks[firstTick].label;if(label){if(min-firstTick>tickmarkOffset){axis.hiddenLabels.push(label.hide())}else{label.show()}}label=axis.ticks[lastTick].label;if(label){if(lastTick-max>tickmarkOffset){axis.hiddenLabels.push(label.hide())}else{label.show()}}const mark=axis.ticks[lastTick].mark;if(mark&&lastTick-max<tickmarkOffset&&lastTick-max>0&&axis.ticks[lastTick].isLast){axis.hiddenMarks.push(mark.hide())}}}}function onAfterSetAxisTranslation(){const axis=this;const tickInfo=axis.tickPositions&&axis.tickPositions.info;const options=axis.options;const gridOptions=options.grid||{};const userLabels=axis.userOptions.labels||{};if(gridOptions.enabled){if(axis.horiz){axis.series.forEach(series=>{series.options.pointRange=0});if(tickInfo&&options.dateTimeLabelFormats&&options.labels&&!defined(userLabels.align)&&(options.dateTimeLabelFormats[tickInfo.unitName].range===false||tickInfo.count>1)){options.labels.align="left";if(!defined(userLabels.x)){options.labels.x=3}}}else{if(this.type!=="treegrid"&&axis.grid&&axis.grid.columns){this.minPointOffset=this.tickInterval}}}}function onAfterSetOptions(e){const options=this.options,userOptions=e.userOptions,gridOptions=options&&isObject(options.grid)?options.grid:{};let gridAxisOptions;if(gridOptions.enabled===true){gridAxisOptions=merge(true,{className:"highcharts-grid-axis "+(userOptions.className||""),dateTimeLabelFormats:{hour:{list:["%[HM]","%[H]"]},day:{list:["%[AeB]","%[aeb]","%[E]"]},week:{list:["Week %W","W%W"]},month:{list:["%[B]","%[b]","%o"]}},grid:{borderWidth:1},labels:{padding:2,style:{fontSize:"0.9em"}},margin:0,title:{text:null,reserveSpace:false,rotation:0,style:{textOverflow:"ellipsis"}},units:[["millisecond",[1,10,100]],["second",[1,10]],["minute",[1,5,15]],["hour",[1,6]],["day",[1]],["week",[1]],["month",[1]],["year",null]]},userOptions);if(this.coll==="xAxis"){if(defined(userOptions.linkedTo)&&!defined(userOptions.tickPixelInterval)){gridAxisOptions.tickPixelInterval=350}if(!defined(userOptions.tickPixelInterval)&&defined(userOptions.linkedTo)&&!defined(userOptions.tickPositioner)&&!defined(userOptions.tickInterval)&&!defined(userOptions.units)){gridAxisOptions.tickPositioner=function(min,max){const parentInfo=this.linkedParent&&this.linkedParent.tickPositions&&this.linkedParent.tickPositions.info;if(parentInfo){const units=gridAxisOptions.units||[];let unitIdx,count=1,unitName="year";for(let i=0;i<units.length;i++){const unit=units[i];if(unit&&unit[0]===parentInfo.unitName){unitIdx=i;break}}const unit=GridAxis_isNumber(unitIdx)&&units[unitIdx+1];if(unit){unitName=unit[0]||"year";const counts=unit[1];count=counts&&counts[0]||1}else if(parentInfo.unitName==="year"){count=parentInfo.count*10}const unitRange=timeUnits[unitName];this.tickInterval=unitRange*count;return this.chart.time.getTimeTicks({unitRange:unitRange,count:count,unitName:unitName},min,max,this.options.startOfWeek)}}}}merge(true,this.options,gridAxisOptions);if(this.horiz){options.minPadding=GridAxis_pick(userOptions.minPadding,0);options.maxPadding=GridAxis_pick(userOptions.maxPadding,0)}if(GridAxis_isNumber(options.grid.borderWidth)){options.tickWidth=options.lineWidth=gridOptions.borderWidth}}}function onAfterSetOptions2(e){const axis=this;const userOptions=e.userOptions;const gridOptions=userOptions&&userOptions.grid||{};const columns=gridOptions.columns;if(gridOptions.enabled&&columns){merge(true,axis.options,columns[0])}}function onAfterSetScale(){const axis=this;(axis.grid.columns||[]).forEach(column=>column.setScale())}function onAfterTickSize(e){const{horiz,maxLabelDimensions,options:{grid:gridOptions={}}}=this;if(gridOptions.enabled&&maxLabelDimensions){const labelPadding=this.options.labels.distance*2;const distance=horiz?gridOptions.cellHeight||labelPadding+maxLabelDimensions.height:labelPadding+maxLabelDimensions.width;if(GridAxis_isArray(e.tickSize)){e.tickSize[0]=distance}else{e.tickSize=[distance,0]}}}function onChartAfterSetChartSize(){this.axes.forEach(axis=>{(axis.grid&&axis.grid.columns||[]).forEach(column=>{column.setAxisSize();column.setAxisTranslation()})})}function onDestroy(e){const{grid}=this;(grid.columns||[]).forEach(column=>column.destroy(e.keepEvents));grid.columns=void 0}function onInit(e){const axis=this;const userOptions=e.userOptions||{};const gridOptions=userOptions.grid||{};if(gridOptions.enabled&&defined(gridOptions.borderColor)){userOptions.tickColor=userOptions.lineColor=gridOptions.borderColor}if(!axis.grid){axis.grid=new GridAxisAdditions(axis)}axis.hiddenLabels=[];axis.hiddenMarks=[]}function onTickAfterGetLabelPosition(e){const tick=this,label=tick.label,axis=tick.axis,reversed=axis.reversed,chart=axis.chart,options=axis.options,gridOptions=options.grid||{},labelOpts=axis.options.labels,align=labelOpts.align,verticalAlign="middle",side=GridAxisSide[axis.side],tickmarkOffset=e.tickmarkOffset,tickPositions=axis.tickPositions,tickPos=tick.pos-tickmarkOffset,nextTickPos=GridAxis_isNumber(tickPositions[e.index+1])?tickPositions[e.index+1]-tickmarkOffset:(axis.max||0)+tickmarkOffset,tickSize=axis.tickSize("tick"),tickWidth=tickSize?tickSize[0]:0,crispCorr=tickSize?tickSize[1]/2:0;if(gridOptions.enabled===true){let bottom,top,left,right;if(side==="top"){bottom=axis.top+axis.offset;top=bottom-tickWidth}else if(side==="bottom"){top=chart.chartHeight-axis.bottom+axis.offset;bottom=top+tickWidth}else{bottom=axis.top+axis.len-(axis.translate(reversed?nextTickPos:tickPos)||0);top=axis.top+axis.len-(axis.translate(reversed?tickPos:nextTickPos)||0)}if(side==="right"){left=chart.chartWidth-axis.right+axis.offset;right=left+tickWidth}else if(side==="left"){right=axis.left+axis.offset;left=right-tickWidth}else{left=Math.round(axis.left+(axis.translate(reversed?nextTickPos:tickPos)||0))-crispCorr;right=Math.min(Math.round(axis.left+(axis.translate(reversed?tickPos:nextTickPos)||0))-crispCorr,axis.left+axis.len)}tick.slotWidth=right-left;e.pos.x=align==="left"?left:align==="right"?right:left+(right-left)/2;e.pos.y=verticalAlign==="top"?top:verticalAlign==="bottom"?bottom:top+(bottom-top)/2;if(label){const lblMetrics=chart.renderer.fontMetrics(label),labelHeight=label.getBBox().height;if(!labelOpts.useHTML){const lines=Math.round(labelHeight/lblMetrics.h);e.pos.y+=(lblMetrics.b-(lblMetrics.h-lblMetrics.f))/2+-((lines-1)*lblMetrics.h/2)}else{e.pos.y+=lblMetrics.b+-(labelHeight/2)}}e.pos.x+=axis.horiz&&labelOpts.x||0}}function onTickLabelFormat(ctx){const{axis,value}=ctx;if(axis.options.grid&&axis.options.grid.enabled){const tickPos=axis.tickPositions;const series=(axis.linkedParent||axis).series[0];const isFirst=value===tickPos[0];const isLast=value===tickPos[tickPos.length-1];const point=series&&GridAxis_find(series.options.data,function(p){return p[axis.isXAxis?"x":"y"]===value});let pointCopy;if(point&&series.is("gantt")){pointCopy=merge(point);highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(pointCopy,axis.chart)}ctx.isFirst=isFirst;ctx.isLast=isLast;ctx.point=pointCopy}}function onTrimTicks(){const axis=this,options=axis.options,gridOptions=options.grid||{},categoryAxis=axis.categories,tickPositions=axis.tickPositions,firstPos=tickPositions[0],secondPos=tickPositions[1],lastPos=tickPositions[tickPositions.length-1],beforeLastPos=tickPositions[tickPositions.length-2],linkedMin=axis.linkedParent&&axis.linkedParent.min,linkedMax=axis.linkedParent&&axis.linkedParent.max,min=linkedMin||axis.min,max=linkedMax||axis.max,tickInterval=axis.tickInterval,startLessThanMin=GridAxis_isNumber(min)&&min>=firstPos+tickInterval&&min<secondPos,endMoreThanMin=GridAxis_isNumber(min)&&firstPos<min&&firstPos+tickInterval>min,startLessThanMax=GridAxis_isNumber(max)&&lastPos>max&&lastPos-tickInterval<max,endMoreThanMax=GridAxis_isNumber(max)&&max<=lastPos-tickInterval&&max>beforeLastPos;if(gridOptions.enabled===true&&!categoryAxis&&(axis.isXAxis||axis.isLinked)){if((endMoreThanMin||startLessThanMin)&&!options.startOnTick){tickPositions[0]=min}if((startLessThanMax||endMoreThanMax)&&!options.endOnTick){tickPositions[tickPositions.length-1]=max}}}function wrapUnsquish(proceed){const axis=this;const{options:{grid:gridOptions={}}}=axis;if(gridOptions.enabled===true&&axis.categories){return axis.tickInterval}return proceed.apply(axis,argsToArray(arguments))}class GridAxisAdditions{constructor(axis){this.axis=axis}isOuterAxis(){const axis=this.axis;const chart=axis.chart;const columnIndex=axis.grid.columnIndex;const columns=axis.linkedParent?.grid.columns||axis.grid.columns||[];const parentAxis=columnIndex?axis.linkedParent:axis;let thisIndex=-1,lastIndex=0;if(axis.side===3&&!chart.inverted&&columns.length){return!axis.linkedParent}(chart[axis.coll]||[]).forEach((otherAxis,index)=>{if(otherAxis.side===axis.side&&!otherAxis.options.isInternal){lastIndex=index;if(otherAxis===parentAxis){thisIndex=index}}});return lastIndex===thisIndex&&(GridAxis_isNumber(columnIndex)?columns.length===columnIndex:true)}renderBorder(path){const axis=this.axis,renderer=axis.chart.renderer,options=axis.options,extraBorderLine=renderer.path(path).addClass("highcharts-axis-line").add(axis.axisGroup);if(!renderer.styledMode){extraBorderLine.attr({stroke:options.lineColor,"stroke-width":options.lineWidth,zIndex:7})}return extraBorderLine}}dateFormats.E=function(timestamp){return this.dateFormat("%a",timestamp,true).charAt(0)};dateFormats.W=function(timestamp){const d=this.toParts(timestamp),firstDay=(d[7]+6)%7,thursday=d.slice(0);thursday[2]=d[2]-firstDay+3;const firstThursday=this.toParts(this.makeTime(thursday[0],0,1));if(firstThursday[7]!==4){d[1]=0;d[2]=1+(11-firstThursday[7])%7}const thursdayTS=this.makeTime(thursday[0],thursday[1],thursday[2]),firstThursdayTS=this.makeTime(firstThursday[0],firstThursday[1],firstThursday[2]);return(1+Math.floor((thursdayTS-firstThursdayTS)/6048e5)).toString()};const GridAxis={compose:compose};const Axis_GridAxis=GridAxis;"";const{extend,isNumber:Tree_isNumber,pick:Tree_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function getListOfParents(data){const root="",ids=[],listOfParents=data.reduce((prev,curr)=>{const{parent="",id}=curr;if(typeof prev[parent]==="undefined"){prev[parent]=[]}prev[parent].push(curr);if(id){ids.push(id)}return prev},{});Object.keys(listOfParents).forEach(node=>{if(node!==root&&ids.indexOf(node)===-1){const adoptedByRoot=listOfParents[node].map(function(orphan){const{...parentExcluded}=orphan;return parentExcluded});listOfParents[root].push(...adoptedByRoot);delete listOfParents[node]}});return listOfParents}function getNode(id,parent,level,data,mapOfIdToChildren,options){const after=options&&options.after,before=options&&options.before,node={data:data,depth:level-1,id:id,level:level,parent:parent||""};let descendants=0,height=0,start,end;if(typeof before==="function"){before(node,options)}const children=(mapOfIdToChildren[id]||[]).map(child=>{const node=getNode(child.id,id,level+1,child,mapOfIdToChildren,options),childStart=child.start||NaN,childEnd=child.milestone===true?childStart:child.end||NaN;start=!Tree_isNumber(start)||childStart<start?childStart:start;end=!Tree_isNumber(end)||childEnd>end?childEnd:end;descendants=descendants+1+node.descendants;height=Math.max(node.height+1,height);return node});if(data){data.start=Tree_pick(data.start,start);data.end=Tree_pick(data.end,end)}extend(node,{children:children,descendants:descendants,height:height});if(typeof after==="function"){after(node,options)}return node}function getTree(data,options){return getNode("",null,1,null,getListOfParents(data),options)}const Tree={getNode:getNode,getTree:getTree};const Gantt_Tree=Tree;const{addEvent:TreeGridTick_addEvent,removeEvent,isObject:TreeGridTick_isObject,isNumber:TreeGridTick_isNumber,pick:TreeGridTick_pick,wrap:TreeGridTick_wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function onTickInit(){const tick=this;if(!tick.treeGrid){tick.treeGrid=new TreeGridTickAdditions(tick)}}function onTickHover(label){label.addClass("highcharts-treegrid-node-active");if(!label.renderer.styledMode){label.css({textDecoration:"underline"})}}function onTickHoverExit(label,options){const css=TreeGridTick_isObject(options.style)?options.style:{};label.removeClass("highcharts-treegrid-node-active");if(!label.renderer.styledMode){label.css({textDecoration:css.textDecoration||"none"})}}function renderLabelIcon(tick,params){const treeGrid=tick.treeGrid,isNew=!treeGrid.labelIcon,renderer=params.renderer,labelBox=params.xy,options=params.options,width=options.width||0,height=options.height||0,padding=options.padding??tick.axis.linkedParent?0:5,iconCenter={x:labelBox.x-width/2-padding,y:labelBox.y-height/2},rotation=params.collapsed?90:180,shouldRender=params.show&&TreeGridTick_isNumber(iconCenter.y);let icon=treeGrid.labelIcon;if(!icon){treeGrid.labelIcon=icon=renderer.path(renderer.symbols[options.type](options.x||0,options.y||0,width,height)).addClass("highcharts-label-icon").add(params.group)}icon[shouldRender?"show":"hide"]();if(!renderer.styledMode){icon.attr({cursor:"pointer",fill:TreeGridTick_pick(params.color,"#666666"),"stroke-width":1,stroke:options.lineColor,strokeWidth:options.lineWidth||0})}icon[isNew?"attr":"animate"]({translateX:iconCenter.x,translateY:iconCenter.y,rotation:rotation})}function wrapGetLabelPosition(proceed,x,y,label,horiz,labelOptions,tickmarkOffset,index,step){const tick=this,lbOptions=TreeGridTick_pick(tick.options&&tick.options.labels,labelOptions),pos=tick.pos,axis=tick.axis,isTreeGrid=axis.type==="treegrid",result=proceed.apply(tick,[x,y,label,horiz,lbOptions,tickmarkOffset,index,step]);let mapOfPosToGridNode,node,level;if(isTreeGrid){const{width=0,padding=axis.linkedParent?0:5}=lbOptions&&TreeGridTick_isObject(lbOptions.symbol,true)?lbOptions.symbol:{},indentation=lbOptions&&TreeGridTick_isNumber(lbOptions.indentation)?lbOptions.indentation:0;mapOfPosToGridNode=axis.treeGrid.mapOfPosToGridNode;node=mapOfPosToGridNode&&mapOfPosToGridNode[pos];level=node&&node.depth||1;result.x+=width+padding*2+(level-1)*indentation}return result}function wrapRenderLabel(proceed){const tick=this,{pos,axis,label,treeGrid:tickGrid,options:tickOptions}=tick,icon=tickGrid?.labelIcon,labelElement=label?.element,{treeGrid:axisGrid,options:axisOptions,chart,tickPositions}=axis,mapOfPosToGridNode=axisGrid.mapOfPosToGridNode,labelOptions=TreeGridTick_pick(tickOptions?.labels,axisOptions?.labels),symbolOptions=labelOptions&&TreeGridTick_isObject(labelOptions.symbol,true)?labelOptions.symbol:{},node=mapOfPosToGridNode&&mapOfPosToGridNode[pos],{descendants,depth}=node||{},hasDescendants=node&&descendants&&descendants>0,level=depth,isTreeGridElement=axis.type==="treegrid"&&labelElement,shouldRender=tickPositions.indexOf(pos)>-1,prefixClassName="highcharts-treegrid-node-",prefixLevelClass=prefixClassName+"level-",styledMode=chart.styledMode;let collapsed,addClassName,removeClassName;if(isTreeGridElement&&node){label.removeClass(new RegExp(prefixLevelClass+".*")).addClass(prefixLevelClass+level)}proceed.apply(tick,Array.prototype.slice.call(arguments,1));if(isTreeGridElement&&hasDescendants){collapsed=axisGrid.isCollapsed(node);renderLabelIcon(tick,{color:!styledMode&&label.styles.color||"",collapsed:collapsed,group:label.parentGroup,options:symbolOptions,renderer:label.renderer,show:shouldRender,xy:label.xy});addClassName=prefixClassName+(collapsed?"collapsed":"expanded");removeClassName=prefixClassName+(collapsed?"expanded":"collapsed");label.addClass(addClassName).removeClass(removeClassName);if(!styledMode){label.css({cursor:"pointer"})}[label,icon].forEach(object=>{if(object&&!object.attachedTreeGridEvents){TreeGridTick_addEvent(object.element,"mouseover",function(){onTickHover(label)});TreeGridTick_addEvent(object.element,"mouseout",function(){onTickHoverExit(label,labelOptions)});TreeGridTick_addEvent(object.element,"click",function(){tickGrid.toggleCollapse()});object.attachedTreeGridEvents=true}})}else if(icon){removeEvent(labelElement);label?.css({cursor:"default"});icon.destroy()}}class TreeGridTickAdditions{static compose(TickClass){const tickProto=TickClass.prototype;if(!tickProto.toggleCollapse){TreeGridTick_addEvent(TickClass,"init",onTickInit);TreeGridTick_wrap(tickProto,"getLabelPosition",wrapGetLabelPosition);TreeGridTick_wrap(tickProto,"renderLabel",wrapRenderLabel);tickProto.collapse=function(redraw){this.treeGrid.collapse(redraw)};tickProto.expand=function(redraw){this.treeGrid.expand(redraw)};tickProto.toggleCollapse=function(redraw){this.treeGrid.toggleCollapse(redraw)}}}constructor(tick){this.tick=tick}collapse(redraw){const tick=this.tick,axis=tick.axis,brokenAxis=axis.brokenAxis;if(brokenAxis&&axis.treeGrid.mapOfPosToGridNode){const pos=tick.pos,node=axis.treeGrid.mapOfPosToGridNode[pos],breaks=axis.treeGrid.collapse(node);brokenAxis.setBreaks(breaks,TreeGridTick_pick(redraw,true))}}destroy(){if(this.labelIcon){this.labelIcon.destroy()}}expand(redraw){const{pos,axis}=this.tick,{treeGrid,brokenAxis}=axis,posMappedNodes=treeGrid.mapOfPosToGridNode;if(brokenAxis&&posMappedNodes){const node=posMappedNodes[pos],breaks=treeGrid.expand(node);brokenAxis.setBreaks(breaks,TreeGridTick_pick(redraw,true))}}toggleCollapse(redraw){const tick=this.tick,axis=tick.axis,brokenAxis=axis.brokenAxis;if(brokenAxis&&axis.treeGrid.mapOfPosToGridNode){const pos=tick.pos,node=axis.treeGrid.mapOfPosToGridNode[pos],breaks=axis.treeGrid.toggleCollapse(node);brokenAxis.setBreaks(breaks,TreeGridTick_pick(redraw,true))}}}const TreeGridTick=TreeGridTickAdditions;var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_=__webpack_require__(620);var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default=__webpack_require__.n(highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_);const{extend:TreeUtilities_extend,isArray:TreeUtilities_isArray,isNumber:TreeUtilities_isNumber,isObject:TreeUtilities_isObject,merge:TreeUtilities_merge,pick:TreeUtilities_pick,relativeLength}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function getColor(node,options){const index=options.index,mapOptionsToLevel=options.mapOptionsToLevel,parentColor=options.parentColor,parentColorIndex=options.parentColorIndex,series=options.series,colors=options.colors,siblings=options.siblings,points=series.points,chartOptionsChart=series.chart.options.chart;let getColorByPoint,point,level,colorByPoint,colorIndexByPoint,color,colorIndex;const variateColor=color=>{const colorVariation=level&&level.colorVariation;if(colorVariation&&colorVariation.key==="brightness"&&index&&siblings){return highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default().parse(color).brighten(colorVariation.to*(index/siblings)).get()}return color};if(node){point=points[node.i];level=mapOptionsToLevel[node.level]||{};getColorByPoint=point&&level.colorByPoint;if(getColorByPoint){colorIndexByPoint=point.index%(colors?colors.length:chartOptionsChart.colorCount);colorByPoint=colors&&colors[colorIndexByPoint]}if(!series.chart.styledMode){color=TreeUtilities_pick(point&&point.options.color,level&&level.color,colorByPoint,parentColor&&variateColor(parentColor),series.color)}colorIndex=TreeUtilities_pick(point&&point.options.colorIndex,level&&level.colorIndex,colorIndexByPoint,parentColorIndex,options.colorIndex)}return{color:color,colorIndex:colorIndex}}function getLevelOptions(params){const result={};let defaults,converted,i,from,to,levels;if(TreeUtilities_isObject(params)){from=TreeUtilities_isNumber(params.from)?params.from:1;levels=params.levels;converted={};defaults=TreeUtilities_isObject(params.defaults)?params.defaults:{};if(TreeUtilities_isArray(levels)){converted=levels.reduce((obj,item)=>{let level,levelIsConstant,options;if(TreeUtilities_isObject(item)&&TreeUtilities_isNumber(item.level)){options=TreeUtilities_merge({},item);levelIsConstant=TreeUtilities_pick(options.levelIsConstant,defaults.levelIsConstant);delete options.levelIsConstant;delete options.level;level=item.level+(levelIsConstant?0:from-1);if(TreeUtilities_isObject(obj[level])){TreeUtilities_merge(true,obj[level],options)}else{obj[level]=options}}return obj},{})}to=TreeUtilities_isNumber(params.to)?params.to:1;for(i=0;i<=to;i++){result[i]=TreeUtilities_merge({},defaults,TreeUtilities_isObject(converted[i])?converted[i]:{})}}return result}function setTreeValues(tree,options){const before=options.before,idRoot=options.idRoot,mapIdToNode=options.mapIdToNode,nodeRoot=mapIdToNode[idRoot],levelIsConstant=options.levelIsConstant!==false,points=options.points,point=points[tree.i],optionsPoint=point&&point.options||{},children=[];let childrenTotal=0;tree.levelDynamic=tree.level-(levelIsConstant?0:nodeRoot.level);tree.name=TreeUtilities_pick(point&&point.name,"");tree.visible=idRoot===tree.id||options.visible===true;if(typeof before==="function"){tree=before(tree,options)}tree.children.forEach((child,i)=>{const newOptions=TreeUtilities_extend({},options);TreeUtilities_extend(newOptions,{index:i,siblings:tree.children.length,visible:tree.visible});child=setTreeValues(child,newOptions);children.push(child);if(child.visible){childrenTotal+=child.val}});const value=TreeUtilities_pick(optionsPoint.value,childrenTotal);tree.visible=value>=0&&(childrenTotal>0||tree.visible);tree.children=children;tree.childrenTotal=childrenTotal;tree.isLeaf=tree.visible&&!childrenTotal;tree.val=value;return tree}function updateRootId(series){let rootId,options;if(TreeUtilities_isObject(series)){options=TreeUtilities_isObject(series.options)?series.options:{};rootId=TreeUtilities_pick(series.rootNode,options.rootId,"");if(TreeUtilities_isObject(series.userOptions)){series.userOptions.rootId=rootId}series.rootNode=rootId}return rootId}function getNodeWidth(series,columnCount){const{chart,options}=series,{nodeDistance=0,nodeWidth=0}=options,{plotSizeX=1}=chart;if(nodeWidth==="auto"){if(typeof nodeDistance==="string"&&/%$/.test(nodeDistance)){const fraction=parseFloat(nodeDistance)/100,total=columnCount+fraction*(columnCount-1);return plotSizeX/total}const nDistance=Number(nodeDistance);return(plotSizeX+nDistance)/(columnCount||1)-nDistance}return relativeLength(nodeWidth,plotSizeX)}const TreeUtilities={getColor:getColor,getLevelOptions:getLevelOptions,getNodeWidth:getNodeWidth,setTreeValues:setTreeValues,updateRootId:updateRootId};const Series_TreeUtilities=TreeUtilities;const{getLevelOptions:TreeGridAxis_getLevelOptions}=Series_TreeUtilities;const{addEvent:TreeGridAxis_addEvent,isArray:TreeGridAxis_isArray,splat,find:TreeGridAxis_find,fireEvent:TreeGridAxis_fireEvent,isObject:TreeGridAxis_isObject,isString,merge:TreeGridAxis_merge,pick:TreeGridAxis_pick,removeEvent:TreeGridAxis_removeEvent,wrap:TreeGridAxis_wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();let TickConstructor;function getBreakFromNode(node,max){const to=node.collapseEnd||0;let from=node.collapseStart||0;if(to>=max){from-=.5}return{from:from,to:to,showPoints:false}}function getTreeGridFromData(data,uniqueNames,numberOfSeries){const categories=[],collapsedNodes=[],mapOfIdToNode={},uniqueNamesEnabled=uniqueNames||false;let mapOfPosToGridNode={},posIterator=-1;const treeParams={after:function(node){const gridNode=mapOfPosToGridNode[node.pos];let height=0,descendants=0;gridNode.children.forEach(function(child){descendants+=(child.descendants||0)+1;height=Math.max((child.height||0)+1,height)});gridNode.descendants=descendants;gridNode.height=height;if(gridNode.collapsed){collapsedNodes.push(gridNode)}},before:function(node){const data=TreeGridAxis_isObject(node.data,true)?node.data:{},name=isString(data.name)?data.name:"",parentNode=mapOfIdToNode[node.parent],parentGridNode=TreeGridAxis_isObject(parentNode,true)?mapOfPosToGridNode[parentNode.pos]:null,hasSameName=function(x){return x.name===name};let gridNode,pos;if(uniqueNamesEnabled&&TreeGridAxis_isObject(parentGridNode,true)&&!!(gridNode=TreeGridAxis_find(parentGridNode.children,hasSameName))){pos=gridNode.pos;gridNode.nodes.push(node)}else{pos=posIterator++}if(!mapOfPosToGridNode[pos]){mapOfPosToGridNode[pos]=gridNode={depth:parentGridNode?parentGridNode.depth+1:0,name:name,id:data.id,nodes:[node],children:[],pos:pos};if(pos!==-1){categories.push(name)}if(TreeGridAxis_isObject(parentGridNode,true)){parentGridNode.children.push(gridNode)}}if(isString(node.id)){mapOfIdToNode[node.id]=node}if(gridNode&&data.collapsed===true){gridNode.collapsed=true}node.pos=pos}};const updateYValuesAndTickPos=function(map,numberOfSeries){const setValues=function(gridNode,start,result){const nodes=gridNode.nodes,padding=.5;let end=start+(start===-1?0:numberOfSeries-1);const diff=(end-start)/2,pos=start+diff;nodes.forEach(function(node){const data=node.data;if(TreeGridAxis_isObject(data,true)){data.y=start+(data.seriesIndex||0);delete data.seriesIndex}node.pos=pos});result[pos]=gridNode;gridNode.pos=pos;gridNode.tickmarkOffset=diff+padding;gridNode.collapseStart=end+padding;gridNode.children.forEach(function(child){setValues(child,end+1,result);end=(child.collapseEnd||0)-padding});gridNode.collapseEnd=end+padding;return result};return setValues(map["-1"],-1,{})};const tree=Gantt_Tree.getTree(data,treeParams);mapOfPosToGridNode=updateYValuesAndTickPos(mapOfPosToGridNode,numberOfSeries);return{categories:categories,mapOfIdToNode:mapOfIdToNode,mapOfPosToGridNode:mapOfPosToGridNode,collapsedNodes:collapsedNodes,tree:tree}}function onBeforeRender(e){const chart=e.target,axes=chart.axes;axes.filter(axis=>axis.type==="treegrid").forEach(function(axis){const options=axis.options||{},labelOptions=options.labels,uniqueNames=axis.uniqueNames,max=chart.time.parse(options.max),isDirty=!axis.treeGrid.mapOfPosToGridNode||axis.series.some(function(series){return!series.hasRendered||series.isDirtyData||series.isDirty});let numberOfSeries=0,data,treeGrid;if(isDirty){const seriesHasPrimitivePoints=[];data=axis.series.reduce(function(arr,s){const seriesData=s.options.data||[],firstPoint=seriesData[0],foundPrimitivePoint=Array.isArray(firstPoint)&&!firstPoint.find(value=>typeof value==="object");seriesHasPrimitivePoints.push(foundPrimitivePoint);if(s.visible){seriesData.forEach(function(pointOptions){if(foundPrimitivePoint||s.options.keys&&s.options.keys.length){pointOptions=s.pointClass.prototype.optionsToObject.call({series:s},pointOptions);s.pointClass.setGanttPointAliases(pointOptions,chart)}if(TreeGridAxis_isObject(pointOptions,true)){pointOptions.seriesIndex=numberOfSeries;arr.push(pointOptions)}});if(uniqueNames===true){numberOfSeries++}}return arr},[]);if(max&&data.length<max){for(let i=data.length;i<=max;i++){data.push({name:i+"​"})}}treeGrid=getTreeGridFromData(data,uniqueNames||false,uniqueNames===true?numberOfSeries:1);axis.categories=treeGrid.categories;axis.treeGrid.mapOfPosToGridNode=treeGrid.mapOfPosToGridNode;axis.hasNames=true;axis.treeGrid.tree=treeGrid.tree;axis.series.forEach(function(series,index){const axisData=(series.options.data||[]).map(function(d){if(seriesHasPrimitivePoints[index]||TreeGridAxis_isArray(d)&&series.options.keys&&series.options.keys.length){data.forEach(function(point){const toArray=splat(d);if(toArray.indexOf(point.x||0)>=0&&toArray.indexOf(point.x2||0)>=0){d=point}})}return TreeGridAxis_isObject(d,true)?TreeGridAxis_merge(d):d});if(series.visible){series.setData(axisData,false)}});axis.treeGrid.mapOptionsToLevel=TreeGridAxis_getLevelOptions({defaults:labelOptions,from:1,levels:labelOptions&&labelOptions.levels,to:axis.treeGrid.tree&&axis.treeGrid.tree.height});if(e.type==="beforeRender"){axis.treeGrid.collapsedNodes=treeGrid.collapsedNodes}}})}function wrapGenerateTick(proceed,pos){const axis=this,mapOptionsToLevel=axis.treeGrid.mapOptionsToLevel||{},isTreeGrid=axis.type==="treegrid",ticks=axis.ticks;let tick=ticks[pos],levelOptions,options,gridNode;if(isTreeGrid&&axis.treeGrid.mapOfPosToGridNode){gridNode=axis.treeGrid.mapOfPosToGridNode[pos];levelOptions=mapOptionsToLevel[gridNode.depth];if(levelOptions){options={labels:levelOptions}}if(!tick&&TickConstructor){ticks[pos]=tick=new TickConstructor(axis,pos,void 0,void 0,{category:gridNode.name,tickmarkOffset:gridNode.tickmarkOffset,options:options})}else{tick.parameters.category=gridNode.name;tick.options=options;tick.addLabel()}}else{proceed.apply(axis,Array.prototype.slice.call(arguments,1))}}function wrapInit(proceed,chart,userOptions,coll){const axis=this,isTreeGrid=userOptions.type==="treegrid";if(!axis.treeGrid){axis.treeGrid=new TreeGridAxisAdditions(axis)}if(isTreeGrid){TreeGridAxis_addEvent(chart,"beforeRender",onBeforeRender);TreeGridAxis_addEvent(chart,"beforeRedraw",onBeforeRender);TreeGridAxis_addEvent(chart,"addSeries",function(e){if(e.options.data){const treeGrid=getTreeGridFromData(e.options.data,userOptions.uniqueNames||false,1);axis.treeGrid.collapsedNodes=(axis.treeGrid.collapsedNodes||[]).concat(treeGrid.collapsedNodes)}});TreeGridAxis_addEvent(axis,"foundExtremes",function(){if(axis.treeGrid.collapsedNodes){axis.treeGrid.collapsedNodes.forEach(function(node){const breaks=axis.treeGrid.collapse(node);if(axis.brokenAxis){axis.brokenAxis.setBreaks(breaks,false);if(axis.treeGrid.collapsedNodes){axis.treeGrid.collapsedNodes=axis.treeGrid.collapsedNodes.filter(n=>node.collapseStart!==n.collapseStart||node.collapseEnd!==n.collapseEnd)}}})}});TreeGridAxis_addEvent(axis,"afterBreaks",function(){if(axis.coll==="yAxis"&&!axis.staticScale&&axis.chart.options.chart.height){axis.isDirty=true}});userOptions=TreeGridAxis_merge({grid:{enabled:true},labels:{align:"left",levels:[{level:void 0},{level:1,style:{fontWeight:"bold"}}],symbol:{type:"triangle",x:-5,y:-5,height:10,width:10}},uniqueNames:false},userOptions,{reversed:true})}proceed.apply(axis,[chart,userOptions,coll]);if(isTreeGrid){axis.hasNames=true;axis.options.showLastLabel=true}}function wrapSetTickInterval(proceed){const axis=this,options=axis.options,time=axis.chart.time,linkedParent=typeof options.linkedTo==="number"?this.chart[axis.coll]?.[options.linkedTo]:void 0,isTreeGrid=axis.type==="treegrid";if(isTreeGrid){axis.min=axis.userMin??time.parse(options.min)??axis.dataMin;axis.max=axis.userMax??time.parse(options.max)??axis.dataMax;TreeGridAxis_fireEvent(axis,"foundExtremes");axis.setAxisTranslation();axis.tickInterval=1;axis.tickmarkOffset=.5;axis.tickPositions=axis.treeGrid.mapOfPosToGridNode?axis.treeGrid.getTickPositions():[];if(linkedParent){const linkedParentExtremes=linkedParent.getExtremes();axis.min=TreeGridAxis_pick(linkedParentExtremes.min,linkedParentExtremes.dataMin);axis.max=TreeGridAxis_pick(linkedParentExtremes.max,linkedParentExtremes.dataMax);axis.tickPositions=linkedParent.tickPositions}axis.linkedParent=linkedParent}else{proceed.apply(axis,Array.prototype.slice.call(arguments,1))}}function wrapRedraw(proceed){const axis=this,isTreeGrid=this.type==="treegrid";if(isTreeGrid&&axis.visible){axis.tickPositions.forEach(function(pos){const tick=axis.ticks[pos];if(tick.label&&tick.label.attachedTreeGridEvents){TreeGridAxis_removeEvent(tick.label.element);tick.label.attachedTreeGridEvents=false}})}proceed.apply(axis,Array.prototype.slice.call(arguments,1))}class TreeGridAxisAdditions{static compose(AxisClass,ChartClass,SeriesClass,TickClass){if(!AxisClass.keepProps.includes("treeGrid")){const axisProps=AxisClass.prototype;AxisClass.keepProps.push("treeGrid");TreeGridAxis_wrap(axisProps,"generateTick",wrapGenerateTick);TreeGridAxis_wrap(axisProps,"init",wrapInit);TreeGridAxis_wrap(axisProps,"setTickInterval",wrapSetTickInterval);TreeGridAxis_wrap(axisProps,"redraw",wrapRedraw);axisProps.utils={getNode:Gantt_Tree.getNode};if(!TickConstructor){TickConstructor=TickClass}}Axis_GridAxis.compose(AxisClass,ChartClass,TickClass);Axis_BrokenAxis.compose(AxisClass,SeriesClass);TreeGridTick.compose(TickClass);return AxisClass}constructor(axis){this.axis=axis}setCollapsedStatus(node){const axis=this.axis,chart=axis.chart;axis.series.forEach(function(series){const data=series.options.data;if(node.id&&data){const point=chart.get(node.id),dataPoint=data[series.data.indexOf(point)];if(point&&dataPoint){point.collapsed=node.collapsed;dataPoint.collapsed=node.collapsed}}})}collapse(node){const axis=this.axis,breaks=axis.options.breaks||[],obj=getBreakFromNode(node,axis.max);breaks.push(obj);node.collapsed=true;axis.treeGrid.setCollapsedStatus(node);return breaks}expand(node){const axis=this.axis,breaks=axis.options.breaks||[],obj=getBreakFromNode(node,axis.max);node.collapsed=false;axis.treeGrid.setCollapsedStatus(node);return breaks.reduce(function(arr,b){if(b.to!==obj.to||b.from!==obj.from){arr.push(b)}return arr},[])}getTickPositions(){const axis=this.axis,roundedMin=Math.floor(axis.min/axis.tickInterval)*axis.tickInterval,roundedMax=Math.ceil(axis.max/axis.tickInterval)*axis.tickInterval;return Object.keys(axis.treeGrid.mapOfPosToGridNode||{}).reduce(function(arr,key){const pos=+key;if(pos>=roundedMin&&pos<=roundedMax&&!(axis.brokenAxis&&axis.brokenAxis.isInAnyBreak(pos))){arr.push(pos)}return arr},[])}isCollapsed(node){const axis=this.axis,breaks=axis.options.breaks||[],obj=getBreakFromNode(node,axis.max);return breaks.some(function(b){return b.from===obj.from&&b.to===obj.to})}toggleCollapse(node){return this.isCollapsed(node)?this.expand(node):this.collapse(node)}}const TreeGridAxis=TreeGridAxisAdditions;const G=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();TreeGridAxis.compose(G.Axis,G.Chart,G.Series,G.Tick);const treegrid_src=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});