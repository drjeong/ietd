(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory(root["_Highcharts"],root["_Highcharts"]["Point"]);else if(typeof define==="function"&&define.amd)define("highcharts/modules/pathfinder",["highcharts/highcharts"],function(amd1){return factory(amd1,amd1["Point"])});else if(typeof exports==="object")exports["highcharts/modules/pathfinder"]=factory(root["_Highcharts"],root["_Highcharts"]["Point"]);else root["Highcharts"]=factory(root["Highcharts"],root["Highcharts"]["Point"])})(typeof window==="undefined"?this:window,(__WEBPACK_EXTERNAL_MODULE__944__,__WEBPACK_EXTERNAL_MODULE__260__)=>{return(()=>{"use strict";var __webpack_modules__={260:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__260__},944:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__944__}};var __webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(cachedModule!==undefined){return cachedModule.exports}var module=__webpack_module_cache__[moduleId]={exports:{}};__webpack_modules__[moduleId](module,module.exports,__webpack_require__);return module.exports}(()=>{__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module["default"]:()=>module;__webpack_require__.d(getter,{a:getter});return getter}})();(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>pathfinder_src});var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_=__webpack_require__(944);var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default=__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);const{defined,error,merge,objectEach}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const deg2rad=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().deg2rad,max=Math.max,min=Math.min;class Connection{constructor(from,to,options){this.init(from,to,options)}init(from,to,options){this.fromPoint=from;this.toPoint=to;this.options=options;this.chart=from.series.chart;this.pathfinder=this.chart.pathfinder}renderPath(path,attribs){const connection=this,chart=this.chart,styledMode=chart.styledMode,pathfinder=this.pathfinder,anim={};let pathGraphic=connection.graphics&&connection.graphics.path;if(!pathfinder.group){pathfinder.group=chart.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(chart.seriesGroup)}pathfinder.group.translate(chart.plotLeft,chart.plotTop);if(!(pathGraphic&&pathGraphic.renderer)){pathGraphic=chart.renderer.path().add(pathfinder.group);if(!styledMode){pathGraphic.attr({opacity:0})}}pathGraphic.attr(attribs);anim.d=path;if(!styledMode){anim.opacity=1}pathGraphic.animate(anim);this.graphics=this.graphics||{};this.graphics.path=pathGraphic}addMarker(type,options,path){const connection=this,chart=connection.fromPoint.series.chart,pathfinder=chart.pathfinder,renderer=chart.renderer,point=type==="start"?connection.fromPoint:connection.toPoint,anchor=point.getPathfinderAnchorPoint(options);let markerVector,radians,rotation,box,width,height,pathVector,segment;if(!options.enabled){return}if(type==="start"){segment=path[1]}else{segment=path[path.length-2]}if(segment&&segment[0]==="M"||segment[0]==="L"){pathVector={x:segment[1],y:segment[2]};radians=point.getRadiansToVector(pathVector,anchor);markerVector=point.getMarkerVector(radians,options.radius,anchor);rotation=-radians/deg2rad;if(options.width&&options.height){width=options.width;height=options.height}else{width=height=options.radius*2}connection.graphics=connection.graphics||{};box={x:markerVector.x-width/2,y:markerVector.y-height/2,width:width,height:height,rotation:rotation,rotationOriginX:markerVector.x,rotationOriginY:markerVector.y};if(!connection.graphics[type]){connection.graphics[type]=renderer.symbol(options.symbol).addClass("highcharts-point-connecting-path-"+type+"-marker"+" highcharts-color-"+this.fromPoint.colorIndex).attr(box).add(pathfinder.group);if(!renderer.styledMode){connection.graphics[type].attr({fill:options.color||connection.fromPoint.color,stroke:options.lineColor,"stroke-width":options.lineWidth,opacity:0}).animate({opacity:1},point.series.options.animation)}}else{connection.graphics[type].animate(box)}}}getPath(options){const pathfinder=this.pathfinder,chart=this.chart,algorithm=pathfinder.algorithms[options.type];let chartObstacles=pathfinder.chartObstacles;if(typeof algorithm!=="function"){error('"'+options.type+'" is not a Pathfinder algorithm.');return{path:[],obstacles:[]}}if(algorithm.requiresObstacles&&!chartObstacles){chartObstacles=pathfinder.chartObstacles=pathfinder.getChartObstacles(options);chart.options.connectors.algorithmMargin=options.algorithmMargin;pathfinder.chartObstacleMetrics=pathfinder.getObstacleMetrics(chartObstacles)}return algorithm(this.fromPoint.getPathfinderAnchorPoint(options.startMarker),this.toPoint.getPathfinderAnchorPoint(options.endMarker),merge({chartObstacles:chartObstacles,lineObstacles:pathfinder.lineObstacles||[],obstacleMetrics:pathfinder.chartObstacleMetrics,hardBounds:{xMin:0,xMax:chart.plotWidth,yMin:0,yMax:chart.plotHeight},obstacleOptions:{margin:options.algorithmMargin},startDirectionX:pathfinder.getAlgorithmStartDirection(options.startMarker)},options))}render(){const connection=this,fromPoint=connection.fromPoint,series=fromPoint.series,chart=series.chart,pathfinder=chart.pathfinder,attribs={};let options=merge(chart.options.connectors,series.options.connectors,fromPoint.options.connectors,connection.options);if(!chart.styledMode){attribs.stroke=options.lineColor||fromPoint.color;attribs["stroke-width"]=options.lineWidth;if(options.dashStyle){attribs.dashstyle=options.dashStyle}}attribs["class"]="highcharts-point-connecting-path "+"highcharts-color-"+fromPoint.colorIndex;options=merge(attribs,options);if(!defined(options.marker.radius)){options.marker.radius=min(max(Math.ceil((options.algorithmMargin||8)/2)-1,1),5)}const pathResult=connection.getPath(options),path=pathResult.path;if(pathResult.obstacles){pathfinder.lineObstacles=pathfinder.lineObstacles||[];pathfinder.lineObstacles=pathfinder.lineObstacles.concat(pathResult.obstacles)}connection.renderPath(path,attribs);connection.addMarker("start",merge(options.marker,options.startMarker),path);connection.addMarker("end",merge(options.marker,options.endMarker),path)}destroy(){if(this.graphics){objectEach(this.graphics,function(val){val.destroy()});delete this.graphics}}}const Gantt_Connection=Connection;"";const getLinkPath={default:getDefaultPath,straight:getStraightPath,curved:getCurvedPath};function getDefaultPath(pathParams){const{x1,y1,x2,y2,width=0,inverted=false,radius,parentVisible}=pathParams;const path=[["M",x1,y1],["L",x1,y1],["C",x1,y1,x1,y2,x1,y2],["L",x1,y2],["C",x1,y1,x1,y2,x1,y2],["L",x1,y2]];return parentVisible?applyRadius([["M",x1,y1],["L",x1+width*(inverted?-.5:.5),y1],["L",x1+width*(inverted?-.5:.5),y2],["L",x2,y2]],radius):path}function getStraightPath(pathParams){const{x1,y1,x2,y2,width=0,inverted=false,parentVisible}=pathParams;return parentVisible?[["M",x1,y1],["L",x1+width*(inverted?-1:1),y2],["L",x2,y2]]:[["M",x1,y1],["L",x1,y2],["L",x1,y2]]}function getCurvedPath(pathParams){const{x1,y1,x2,y2,offset=0,width=0,inverted=false,parentVisible}=pathParams;return parentVisible?[["M",x1,y1],["C",x1+offset,y1,x1-offset+width*(inverted?-1:1),y2,x1+width*(inverted?-1:1),y2],["L",x2,y2]]:[["M",x1,y1],["C",x1,y1,x1,y2,x1,y2],["L",x2,y2]]}function applyRadius(path,r){const d=[];for(let i=0;i<path.length;i++){const x=path[i][1];const y=path[i][2];if(typeof x==="number"&&typeof y==="number"){if(i===0){d.push(["M",x,y])}else if(i===path.length-1){d.push(["L",x,y])}else if(r){const prevSeg=path[i-1];const nextSeg=path[i+1];if(prevSeg&&nextSeg){const x1=prevSeg[1],y1=prevSeg[2],x2=nextSeg[1],y2=nextSeg[2];if(typeof x1==="number"&&typeof x2==="number"&&typeof y1==="number"&&typeof y2==="number"&&x1!==x2&&y1!==y2){const directionX=x1<x2?1:-1,directionY=y1<y2?1:-1;d.push(["L",x-directionX*Math.min(Math.abs(x-x1),r),y-directionY*Math.min(Math.abs(y-y1),r)],["C",x,y,x,y,x+directionX*Math.min(Math.abs(x-x2),r),y+directionY*Math.min(Math.abs(y-y2),r)])}}}else{d.push(["L",x,y])}}}return d}const PathUtilities={applyRadius:applyRadius,getLinkPath:getLinkPath};const Series_PathUtilities=PathUtilities;const{pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{min:PathfinderAlgorithms_min,max:PathfinderAlgorithms_max,abs}=Math;function findLastObstacleBefore(obstacles,xMin,startIx){const min=xMin-1e-7;let left=startIx||0,right=obstacles.length-1,cursor,cmp;while(left<=right){cursor=right+left>>1;cmp=min-obstacles[cursor].xMin;if(cmp>0){left=cursor+1}else if(cmp<0){right=cursor-1}else{return cursor}}return left>0?left-1:0}function pointWithinObstacle(obstacle,point){return point.x<=obstacle.xMax&&point.x>=obstacle.xMin&&point.y<=obstacle.yMax&&point.y>=obstacle.yMin}function findObstacleFromPoint(obstacles,point){let i=findLastObstacleBefore(obstacles,point.x+1)+1;while(i--){if(obstacles[i].xMax>=point.x&&pointWithinObstacle(obstacles[i],point)){return i}}return-1}function pathFromSegments(segments){const path=[];if(segments.length){path.push(["M",segments[0].start.x,segments[0].start.y]);for(let i=0;i<segments.length;++i){path.push(["L",segments[i].end.x,segments[i].end.y])}}return path}function limitObstacleToBounds(obstacle,bounds){obstacle.yMin=PathfinderAlgorithms_max(obstacle.yMin,bounds.yMin);obstacle.yMax=PathfinderAlgorithms_min(obstacle.yMax,bounds.yMax);obstacle.xMin=PathfinderAlgorithms_max(obstacle.xMin,bounds.xMin);obstacle.xMax=PathfinderAlgorithms_min(obstacle.xMax,bounds.xMax)}function straight(start,end){return{path:[["M",start.x,start.y],["L",end.x,end.y]],obstacles:[{start:start,end:end}]}}const simpleConnect=function(start,end,options){const segments=[],chartObstacles=options.chartObstacles,startObstacleIx=findObstacleFromPoint(chartObstacles,start),endObstacleIx=findObstacleFromPoint(chartObstacles,end);let endSegment,dir=pick(options.startDirectionX,abs(end.x-start.x)>abs(end.y-start.y))?"x":"y",startObstacle,endObstacle,waypoint,useMax,endPoint;function copyFromPoint(from,fromKey,to,toKey,offset){const point={x:from.x,y:from.y};point[fromKey]=to[toKey||fromKey]+(offset||0);return point}function getMeOut(obstacle,point,direction){const useMax=abs(point[direction]-obstacle[direction+"Min"])>abs(point[direction]-obstacle[direction+"Max"]);return copyFromPoint(point,direction,obstacle,direction+(useMax?"Max":"Min"),useMax?1:-1)}if(endObstacleIx>-1){endObstacle=chartObstacles[endObstacleIx];waypoint=getMeOut(endObstacle,end,dir);endSegment={start:waypoint,end:end};endPoint=waypoint}else{endPoint=end}if(startObstacleIx>-1){startObstacle=chartObstacles[startObstacleIx];waypoint=getMeOut(startObstacle,start,dir);segments.push({start:start,end:waypoint});if(waypoint[dir]>=start[dir]===waypoint[dir]>=endPoint[dir]){dir=dir==="y"?"x":"y";useMax=start[dir]<end[dir];segments.push({start:waypoint,end:copyFromPoint(waypoint,dir,startObstacle,dir+(useMax?"Max":"Min"),useMax?1:-1)});dir=dir==="y"?"x":"y"}}const prevWaypoint=segments.length?segments[segments.length-1].end:start;waypoint=copyFromPoint(prevWaypoint,dir,endPoint);segments.push({start:prevWaypoint,end:waypoint});dir=dir==="y"?"x":"y";const waypoint2=copyFromPoint(waypoint,dir,endPoint);segments.push({start:waypoint,end:waypoint2});segments.push(endSegment);const path=Series_PathUtilities.applyRadius(pathFromSegments(segments),options.radius);return{path:path,obstacles:segments}};simpleConnect.requiresObstacles=true;function fastAvoid(start,end,options){const dirIsX=pick(options.startDirectionX,abs(end.x-start.x)>abs(end.y-start.y)),dir=dirIsX?"x":"y",endSegments=[],metrics=options.obstacleMetrics,softMinX=PathfinderAlgorithms_min(start.x,end.x)-metrics.maxWidth-10,softMaxX=PathfinderAlgorithms_max(start.x,end.x)+metrics.maxWidth+10,softMinY=PathfinderAlgorithms_min(start.y,end.y)-metrics.maxHeight-10,softMaxY=PathfinderAlgorithms_max(start.y,end.y)+metrics.maxHeight+10;let segments,useMax,extractedEndPoint,forceObstacleBreak=false,chartObstacles=options.chartObstacles,endObstacleIx=findLastObstacleBefore(chartObstacles,softMaxX);const startObstacleIx=findLastObstacleBefore(chartObstacles,softMinX);function pivotPoint(fromPoint,toPoint,directionIsX){const searchDirection=fromPoint.x<toPoint.x?1:-1;let firstPoint,lastPoint,highestPoint,lowestPoint;if(fromPoint.x<toPoint.x){firstPoint=fromPoint;lastPoint=toPoint}else{firstPoint=toPoint;lastPoint=fromPoint}if(fromPoint.y<toPoint.y){lowestPoint=fromPoint;highestPoint=toPoint}else{lowestPoint=toPoint;highestPoint=fromPoint}let i=searchDirection<0?PathfinderAlgorithms_min(findLastObstacleBefore(chartObstacles,lastPoint.x),chartObstacles.length-1):0;while(chartObstacles[i]&&(searchDirection>0&&chartObstacles[i].xMin<=lastPoint.x||searchDirection<0&&chartObstacles[i].xMax>=firstPoint.x)){if(chartObstacles[i].xMin<=lastPoint.x&&chartObstacles[i].xMax>=firstPoint.x&&chartObstacles[i].yMin<=highestPoint.y&&chartObstacles[i].yMax>=lowestPoint.y){if(directionIsX){return{y:fromPoint.y,x:fromPoint.x<toPoint.x?chartObstacles[i].xMin-1:chartObstacles[i].xMax+1,obstacle:chartObstacles[i]}}return{x:fromPoint.x,y:fromPoint.y<toPoint.y?chartObstacles[i].yMin-1:chartObstacles[i].yMax+1,obstacle:chartObstacles[i]}}i+=searchDirection}return toPoint}function getDodgeDirection(obstacle,fromPoint,toPoint,dirIsX,bounds){const softBounds=bounds.soft,hardBounds=bounds.hard,dir=dirIsX?"x":"y",toPointMax={x:fromPoint.x,y:fromPoint.y},toPointMin={x:fromPoint.x,y:fromPoint.y},maxOutOfSoftBounds=obstacle[dir+"Max"]>=softBounds[dir+"Max"],minOutOfSoftBounds=obstacle[dir+"Min"]<=softBounds[dir+"Min"],maxOutOfHardBounds=obstacle[dir+"Max"]>=hardBounds[dir+"Max"],minOutOfHardBounds=obstacle[dir+"Min"]<=hardBounds[dir+"Min"],minDistance=abs(obstacle[dir+"Min"]-fromPoint[dir]),maxDistance=abs(obstacle[dir+"Max"]-fromPoint[dir]);let useMax=abs(minDistance-maxDistance)<10?fromPoint[dir]<toPoint[dir]:maxDistance<minDistance;toPointMin[dir]=obstacle[dir+"Min"];toPointMax[dir]=obstacle[dir+"Max"];const minPivot=pivotPoint(fromPoint,toPointMin,dirIsX)[dir]!==toPointMin[dir],maxPivot=pivotPoint(fromPoint,toPointMax,dirIsX)[dir]!==toPointMax[dir];useMax=minPivot?maxPivot?useMax:true:maxPivot?false:useMax;useMax=minOutOfSoftBounds?maxOutOfSoftBounds?useMax:true:maxOutOfSoftBounds?false:useMax;useMax=minOutOfHardBounds?maxOutOfHardBounds?useMax:true:maxOutOfHardBounds?false:useMax;return useMax}function clearPathTo(fromPoint,toPoint,dirIsX){if(fromPoint.x===toPoint.x&&fromPoint.y===toPoint.y){return[]}const dir=dirIsX?"x":"y",obstacleMargin=options.obstacleOptions.margin,bounds={soft:{xMin:softMinX,xMax:softMaxX,yMin:softMinY,yMax:softMaxY},hard:options.hardBounds};let pivot,segments,waypoint,waypointUseMax,envelopingObstacle,secondEnvelopingObstacle,envelopWaypoint;envelopingObstacle=findObstacleFromPoint(chartObstacles,fromPoint);if(envelopingObstacle>-1){envelopingObstacle=chartObstacles[envelopingObstacle];waypointUseMax=getDodgeDirection(envelopingObstacle,fromPoint,toPoint,dirIsX,bounds);limitObstacleToBounds(envelopingObstacle,options.hardBounds);envelopWaypoint=dirIsX?{y:fromPoint.y,x:envelopingObstacle[waypointUseMax?"xMax":"xMin"]+(waypointUseMax?1:-1)}:{x:fromPoint.x,y:envelopingObstacle[waypointUseMax?"yMax":"yMin"]+(waypointUseMax?1:-1)};secondEnvelopingObstacle=findObstacleFromPoint(chartObstacles,envelopWaypoint);if(secondEnvelopingObstacle>-1){secondEnvelopingObstacle=chartObstacles[secondEnvelopingObstacle];limitObstacleToBounds(secondEnvelopingObstacle,options.hardBounds);envelopWaypoint[dir]=waypointUseMax?PathfinderAlgorithms_max(envelopingObstacle[dir+"Max"]-obstacleMargin+1,(secondEnvelopingObstacle[dir+"Min"]+envelopingObstacle[dir+"Max"])/2):PathfinderAlgorithms_min(envelopingObstacle[dir+"Min"]+obstacleMargin-1,(secondEnvelopingObstacle[dir+"Max"]+envelopingObstacle[dir+"Min"])/2);if(fromPoint.x===envelopWaypoint.x&&fromPoint.y===envelopWaypoint.y){if(forceObstacleBreak){envelopWaypoint[dir]=waypointUseMax?PathfinderAlgorithms_max(envelopingObstacle[dir+"Max"],secondEnvelopingObstacle[dir+"Max"])+1:PathfinderAlgorithms_min(envelopingObstacle[dir+"Min"],secondEnvelopingObstacle[dir+"Min"])-1}forceObstacleBreak=!forceObstacleBreak}else{forceObstacleBreak=false}}segments=[{start:fromPoint,end:envelopWaypoint}]}else{pivot=pivotPoint(fromPoint,{x:dirIsX?toPoint.x:fromPoint.x,y:dirIsX?fromPoint.y:toPoint.y},dirIsX);segments=[{start:fromPoint,end:{x:pivot.x,y:pivot.y}}];if(pivot[dirIsX?"x":"y"]!==toPoint[dirIsX?"x":"y"]){waypointUseMax=getDodgeDirection(pivot.obstacle,pivot,toPoint,!dirIsX,bounds);limitObstacleToBounds(pivot.obstacle,options.hardBounds);waypoint={x:dirIsX?pivot.x:pivot.obstacle[waypointUseMax?"xMax":"xMin"]+(waypointUseMax?1:-1),y:dirIsX?pivot.obstacle[waypointUseMax?"yMax":"yMin"]+(waypointUseMax?1:-1):pivot.y};dirIsX=!dirIsX;segments=segments.concat(clearPathTo({x:pivot.x,y:pivot.y},waypoint,dirIsX))}}segments=segments.concat(clearPathTo(segments[segments.length-1].end,toPoint,!dirIsX));return segments}function extractFromObstacle(obstacle,point,goalPoint){const dirIsX=PathfinderAlgorithms_min(obstacle.xMax-point.x,point.x-obstacle.xMin)<PathfinderAlgorithms_min(obstacle.yMax-point.y,point.y-obstacle.yMin),bounds={soft:options.hardBounds,hard:options.hardBounds},useMax=getDodgeDirection(obstacle,point,goalPoint,dirIsX,bounds);return dirIsX?{y:point.y,x:obstacle[useMax?"xMax":"xMin"]+(useMax?1:-1)}:{x:point.x,y:obstacle[useMax?"yMax":"yMin"]+(useMax?1:-1)}}chartObstacles=chartObstacles.slice(startObstacleIx,endObstacleIx+1);if((endObstacleIx=findObstacleFromPoint(chartObstacles,end))>-1){extractedEndPoint=extractFromObstacle(chartObstacles[endObstacleIx],end,start);endSegments.push({end:end,start:extractedEndPoint});end=extractedEndPoint}while((endObstacleIx=findObstacleFromPoint(chartObstacles,end))>-1){useMax=end[dir]-start[dir]<0;extractedEndPoint={x:end.x,y:end.y};extractedEndPoint[dir]=chartObstacles[endObstacleIx][useMax?dir+"Max":dir+"Min"]+(useMax?1:-1);endSegments.push({end:end,start:extractedEndPoint});end=extractedEndPoint}segments=clearPathTo(start,end,dirIsX);segments=segments.concat(endSegments.reverse());return{path:pathFromSegments(segments),obstacles:segments}}fastAvoid.requiresObstacles=true;const algorithms={fastAvoid:fastAvoid,straight:straight,simpleConnect:simpleConnect};const PathfinderAlgorithms=algorithms;const connectorsDefaults={connectors:{type:"straight",radius:0,lineWidth:1,marker:{enabled:false,align:"center",verticalAlign:"middle",inside:false,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}};const ConnectorsDefaults=connectorsDefaults;"";const{setOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{defined:PathfinderComposition_defined,error:PathfinderComposition_error,merge:PathfinderComposition_merge}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function getPointBB(point){const shapeArgs=point.shapeArgs;if(shapeArgs){return{xMin:shapeArgs.x||0,xMax:(shapeArgs.x||0)+(shapeArgs.width||0),yMin:shapeArgs.y||0,yMax:(shapeArgs.y||0)+(shapeArgs.height||0)}}const bb=point.graphic&&point.graphic.getBBox();return bb?{xMin:point.plotX-bb.width/2,xMax:point.plotX+bb.width/2,yMin:point.plotY-bb.height/2,yMax:point.plotY+bb.height/2}:null}function warnLegacy(chart){if(chart.options.pathfinder||chart.series.reduce(function(acc,series){if(series.options){PathfinderComposition_merge(true,series.options.connectors=series.options.connectors||{},series.options.pathfinder)}return acc||series.options&&series.options.pathfinder},false)){PathfinderComposition_merge(true,chart.options.connectors=chart.options.connectors||{},chart.options.pathfinder);PathfinderComposition_error("WARNING: Pathfinder options have been renamed. "+'Use "chart.connectors" or "series.connectors" instead.')}}var ConnectionComposition;(function(ConnectionComposition){function compose(ChartClass,PathfinderClass,PointClass){const pointProto=PointClass.prototype;if(!pointProto.getPathfinderAnchorPoint){ChartClass.prototype.callbacks.push(function(chart){const options=chart.options;if(options.connectors.enabled!==false){warnLegacy(chart);this.pathfinder=new PathfinderClass(this);this.pathfinder.update(true)}});pointProto.getMarkerVector=pointGetMarkerVector;pointProto.getPathfinderAnchorPoint=pointGetPathfinderAnchorPoint;pointProto.getRadiansToVector=pointGetRadiansToVector;setOptions(ConnectorsDefaults)}}ConnectionComposition.compose=compose;function pointGetPathfinderAnchorPoint(markerOptions){const bb=getPointBB(this);let x,y;switch(markerOptions.align){case"right":x="xMax";break;case"left":x="xMin"}switch(markerOptions.verticalAlign){case"top":y="yMin";break;case"bottom":y="yMax"}return{x:x?bb[x]:(bb.xMin+bb.xMax)/2,y:y?bb[y]:(bb.yMin+bb.yMax)/2}}function pointGetRadiansToVector(v1,v2){let box;if(!PathfinderComposition_defined(v2)){box=getPointBB(this);if(box){v2={x:(box.xMin+box.xMax)/2,y:(box.yMin+box.yMax)/2}}}return Math.atan2(v2.y-v1.y,v1.x-v2.x)}function pointGetMarkerVector(radians,markerRadius,anchor){const twoPI=Math.PI*2,bb=getPointBB(this),rectWidth=bb.xMax-bb.xMin,rectHeight=bb.yMax-bb.yMin,rAtan=Math.atan2(rectHeight,rectWidth),rectHalfWidth=rectWidth/2,rectHalfHeight=rectHeight/2,rectHorizontalCenter=bb.xMin+rectHalfWidth,rectVerticalCenter=bb.yMin+rectHalfHeight,edgePoint={x:rectHorizontalCenter,y:rectVerticalCenter};let theta=radians,tanTheta=1,leftOrRightRegion=false,xFactor=1,yFactor=1;while(theta<-Math.PI){theta+=twoPI}while(theta>Math.PI){theta-=twoPI}tanTheta=Math.tan(theta);if(theta>-rAtan&&theta<=rAtan){yFactor=-1;leftOrRightRegion=true}else if(theta>rAtan&&theta<=Math.PI-rAtan){yFactor=-1}else if(theta>Math.PI-rAtan||theta<=-(Math.PI-rAtan)){xFactor=-1;leftOrRightRegion=true}else{xFactor=-1}if(leftOrRightRegion){edgePoint.x+=xFactor*rectHalfWidth;edgePoint.y+=yFactor*rectHalfWidth*tanTheta}else{edgePoint.x+=xFactor*(rectHeight/(2*tanTheta));edgePoint.y+=yFactor*rectHalfHeight}if(anchor.x!==rectHorizontalCenter){edgePoint.x=anchor.x}if(anchor.y!==rectVerticalCenter){edgePoint.y=anchor.y}return{x:edgePoint.x+markerRadius*Math.cos(theta),y:edgePoint.y-markerRadius*Math.sin(theta)}}})(ConnectionComposition||(ConnectionComposition={}));const PathfinderComposition=ConnectionComposition;var highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_=__webpack_require__(260);var highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_default=__webpack_require__.n(highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_);const{addEvent,defined:Pathfinder_defined,pick:Pathfinder_pick,splat}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const Pathfinder_max=Math.max,Pathfinder_min=Math.min;function Pathfinder_getPointBB(point){const shapeArgs=point.shapeArgs;if(shapeArgs){return{xMin:shapeArgs.x||0,xMax:(shapeArgs.x||0)+(shapeArgs.width||0),yMin:shapeArgs.y||0,yMax:(shapeArgs.y||0)+(shapeArgs.height||0)}}const bb=point.graphic&&point.graphic.getBBox();return bb?{xMin:point.plotX-bb.width/2,xMax:point.plotX+bb.width/2,yMin:point.plotY-bb.height/2,yMax:point.plotY+bb.height/2}:null}function calculateObstacleDistance(a,b,bbMargin){const margin=Pathfinder_pick(bbMargin,10),yOverlap=a.yMax+margin>b.yMin-margin&&a.yMin-margin<b.yMax+margin,xOverlap=a.xMax+margin>b.xMin-margin&&a.xMin-margin<b.xMax+margin,xDistance=yOverlap?a.xMin>b.xMax?a.xMin-b.xMax:b.xMin-a.xMax:Infinity,yDistance=xOverlap?a.yMin>b.yMax?a.yMin-b.yMax:b.yMin-a.yMax:Infinity;if(xOverlap&&yOverlap){return margin?calculateObstacleDistance(a,b,Math.floor(margin/2)):Infinity}return Pathfinder_min(xDistance,yDistance)}function calculateObstacleMargin(obstacles){const len=obstacles.length,distances=[];let onstacleDistance;for(let i=0;i<len;++i){for(let j=i+1;j<len;++j){onstacleDistance=calculateObstacleDistance(obstacles[i],obstacles[j]);if(onstacleDistance<80){distances.push(onstacleDistance)}}}distances.push(80);return Pathfinder_max(Math.floor(distances.sort(function(a,b){return a-b})[Math.floor(distances.length/10)]/2-1),1)}class Pathfinder{static compose(ChartClass,PointClass){PathfinderComposition.compose(ChartClass,Pathfinder,PointClass)}constructor(chart){this.init(chart)}init(chart){this.chart=chart;this.connections=[];addEvent(chart,"redraw",function(){this.pathfinder.update()})}update(deferRender){const chart=this.chart,pathfinder=this,oldConnections=pathfinder.connections;pathfinder.connections=[];chart.series.forEach(function(series){if(series.visible&&!series.options.isInternal){series.points.forEach(function(point){const ganttPointOptions=point.options;if(ganttPointOptions&&ganttPointOptions.dependency){ganttPointOptions.connect=ganttPointOptions.dependency}const connects=point.options?.connect?splat(point.options.connect):[];let to;if(point.visible&&point.isInside!==false){connects.forEach(connect=>{const toId=typeof connect==="string"?connect:connect.to;if(toId){to=chart.get(toId)}if(to instanceof highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_default()&&to.series.visible&&to.visible&&to.isInside!==false){pathfinder.connections.push(new Gantt_Connection(point,to,typeof connect==="string"?{}:connect))}})}})}});for(let j=0,k,found,lenOld=oldConnections.length,lenNew=pathfinder.connections.length;j<lenOld;++j){found=false;const oldCon=oldConnections[j];for(k=0;k<lenNew;++k){const newCon=pathfinder.connections[k];if((oldCon.options&&oldCon.options.type)===(newCon.options&&newCon.options.type)&&oldCon.fromPoint===newCon.fromPoint&&oldCon.toPoint===newCon.toPoint){newCon.graphics=oldCon.graphics;found=true;break}}if(!found){oldCon.destroy()}}delete this.chartObstacles;delete this.lineObstacles;pathfinder.renderConnections(deferRender)}renderConnections(deferRender){if(deferRender){this.chart.series.forEach(function(series){const render=function(){const pathfinder=series.chart.pathfinder,conns=pathfinder&&pathfinder.connections||[];conns.forEach(function(connection){if(connection.fromPoint&&connection.fromPoint.series===series){connection.render()}});if(series.pathfinderRemoveRenderEvent){series.pathfinderRemoveRenderEvent();delete series.pathfinderRemoveRenderEvent}};if(series.options.animation===false){render()}else{series.pathfinderRemoveRenderEvent=addEvent(series,"afterAnimate",render)}})}else{this.connections.forEach(function(connection){connection.render()})}}getChartObstacles(options){const series=this.chart.series,margin=Pathfinder_pick(options.algorithmMargin,0);let obstacles=[],calculatedMargin;for(let i=0,sLen=series.length;i<sLen;++i){if(series[i].visible&&!series[i].options.isInternal){for(let j=0,pLen=series[i].points.length,bb,point;j<pLen;++j){point=series[i].points[j];if(point.visible){bb=Pathfinder_getPointBB(point);if(bb){obstacles.push({xMin:bb.xMin-margin,xMax:bb.xMax+margin,yMin:bb.yMin-margin,yMax:bb.yMax+margin})}}}}}obstacles=obstacles.sort(function(a,b){return a.xMin-b.xMin});if(!Pathfinder_defined(options.algorithmMargin)){calculatedMargin=options.algorithmMargin=calculateObstacleMargin(obstacles);obstacles.forEach(function(obstacle){obstacle.xMin-=calculatedMargin;obstacle.xMax+=calculatedMargin;obstacle.yMin-=calculatedMargin;obstacle.yMax+=calculatedMargin})}return obstacles}getObstacleMetrics(obstacles){let maxWidth=0,maxHeight=0,width,height,i=obstacles.length;while(i--){width=obstacles[i].xMax-obstacles[i].xMin;height=obstacles[i].yMax-obstacles[i].yMin;if(maxWidth<width){maxWidth=width}if(maxHeight<height){maxHeight=height}}return{maxHeight:maxHeight,maxWidth:maxWidth}}getAlgorithmStartDirection(markerOptions){const xCenter=markerOptions.align!=="left"&&markerOptions.align!=="right",yCenter=markerOptions.verticalAlign!=="top"&&markerOptions.verticalAlign!=="bottom";return xCenter?yCenter?void 0:false:yCenter?true:void 0}}Pathfinder.prototype.algorithms=PathfinderAlgorithms;const Gantt_Pathfinder=Pathfinder;"";function arrow(x,y,w,h){return[["M",x,y+h/2],["L",x+w,y],["L",x,y+h/2],["L",x+w,y+h]]}function arrowHalf(x,y,w,h){return arrow(x,y,w/2,h)}function compose(SVGRendererClass){const symbols=SVGRendererClass.prototype.symbols;symbols.arrow=arrow;symbols["arrow-filled"]=triangleLeft;symbols["arrow-filled-half"]=triangleLeftHalf;symbols["arrow-half"]=arrowHalf;symbols["triangle-left"]=triangleLeft;symbols["triangle-left-half"]=triangleLeftHalf}function triangleLeft(x,y,w,h){return[["M",x+w,y],["L",x,y+h/2],["L",x+w,y+h],["Z"]]}function triangleLeftHalf(x,y,w,h){return triangleLeft(x,y,w/2,h)}const ArrowSymbols={compose:compose};const Extensions_ArrowSymbols=ArrowSymbols;const G=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();G.Pathfinder=G.Pathfinder||Gantt_Pathfinder;Extensions_ArrowSymbols.compose(G.SVGRenderer);G.Pathfinder.compose(G.Chart,G.Point);const pathfinder_src=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});