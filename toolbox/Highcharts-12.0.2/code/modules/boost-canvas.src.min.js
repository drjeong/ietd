(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory(root["_Highcharts"],root["_Highcharts"]["Color"]);else if(typeof define==="function"&&define.amd)define("highcharts/modules/boost-canvas",["highcharts/highcharts"],function(amd1){return factory(amd1,amd1["Color"])});else if(typeof exports==="object")exports["highcharts/modules/boost-canvas"]=factory(root["_Highcharts"],root["_Highcharts"]["Color"]);else root["Highcharts"]=factory(root["Highcharts"],root["Highcharts"]["Color"])})(typeof window==="undefined"?this:window,(__WEBPACK_EXTERNAL_MODULE__944__,__WEBPACK_EXTERNAL_MODULE__620__)=>{return(()=>{"use strict";var __webpack_modules__={620:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__620__},944:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__944__}};var __webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(cachedModule!==undefined){return cachedModule.exports}var module=__webpack_module_cache__[moduleId]={exports:{}};__webpack_modules__[moduleId](module,module.exports,__webpack_require__);return module.exports}(()=>{__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module["default"]:()=>module;__webpack_require__.d(getter,{a:getter});return getter}})();(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>boost_canvas_src});var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_=__webpack_require__(944);var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default=__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);const Boostables=["area","areaspline","arearange","column","columnrange","bar","line","scatter","heatmap","bubble","treemap"];const Boost_Boostables=Boostables;const BoostableMap={};Boost_Boostables.forEach(item=>{BoostableMap[item]=true});const Boost_BoostableMap=BoostableMap;const{composed}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent,pick,pushUnique}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function compose(ChartClass,wglMode){if(wglMode&&pushUnique(composed,"Boost.Chart")){ChartClass.prototype.callbacks.push(onChartCallback)}return ChartClass}function getBoostClipRect(chart,target){const navigator=chart.navigator;let clipBox={x:chart.plotLeft,y:chart.plotTop,width:chart.plotWidth,height:chart.plotHeight};if(navigator&&chart.inverted){clipBox.width+=navigator.top+navigator.height;if(!navigator.opposite){clipBox.x=navigator.left}}else if(navigator&&!chart.inverted){clipBox.height=navigator.top+navigator.height-chart.plotTop}if(target.getClipBox){const{xAxis,yAxis}=target;clipBox=target.getClipBox();if(chart.inverted){const lateral=clipBox.width;clipBox.width=clipBox.height;clipBox.height=lateral;clipBox.x=yAxis.pos;clipBox.y=xAxis.pos}else{clipBox.x=xAxis.pos;clipBox.y=yAxis.pos}}if(target===chart){const verticalAxes=chart.inverted?chart.xAxis:chart.yAxis;if(verticalAxes.length<=1){clipBox.y=Math.min(verticalAxes[0].pos,clipBox.y);clipBox.height=verticalAxes[0].pos-chart.plotTop+verticalAxes[0].len}}return clipBox}function isChartSeriesBoosting(chart){const allSeries=chart.series,boost=chart.boost=chart.boost||{},boostOptions=chart.options.boost||{},threshold=pick(boostOptions.seriesThreshold,50);if(allSeries.length>=threshold){return true}if(allSeries.length===1){return false}let allowBoostForce=boostOptions.allowForce;if(typeof allowBoostForce==="undefined"){allowBoostForce=true;for(const axis of chart.xAxis){if(pick(axis.min,-Infinity)>pick(axis.dataMin,-Infinity)||pick(axis.max,Infinity)<pick(axis.dataMax,Infinity)){allowBoostForce=false;break}}}if(typeof boost.forceChartBoost!=="undefined"){if(allowBoostForce){return boost.forceChartBoost}boost.forceChartBoost=void 0}let canBoostCount=0,needBoostCount=0,seriesOptions;for(const series of allSeries){seriesOptions=series.options;if(seriesOptions.boostThreshold===0||series.visible===false){continue}if(series.type==="heatmap"){continue}if(Boost_BoostableMap[series.type]){++canBoostCount}if(patientMax(series.getColumn("x",true),seriesOptions.data,series.points)>=(seriesOptions.boostThreshold||Number.MAX_VALUE)){++needBoostCount}}boost.forceChartBoost=allowBoostForce&&(canBoostCount===allSeries.length&&needBoostCount===canBoostCount||needBoostCount>5);return boost.forceChartBoost}function onChartCallback(chart){function canvasToSVG(){if(chart.boost&&chart.boost.wgl&&isChartSeriesBoosting(chart)){chart.boost.wgl.render(chart)}}function preRender(){chart.boost=chart.boost||{};chart.boost.forceChartBoost=void 0;chart.boosted=false;if(!chart.axes.some(axis=>axis.isPanning)){chart.boost.clear?.()}if(chart.boost.canvas&&chart.boost.wgl&&isChartSeriesBoosting(chart)){chart.boost.wgl.allocateBuffer(chart)}if(chart.boost.markerGroup&&chart.xAxis&&chart.xAxis.length>0&&chart.yAxis&&chart.yAxis.length>0){chart.boost.markerGroup.translate(chart.xAxis[0].pos,chart.yAxis[0].pos)}}addEvent(chart,"predraw",preRender);addEvent(chart,"load",canvasToSVG,{order:-1});addEvent(chart,"redraw",canvasToSVG);let prevX=-1;let prevY=-1;addEvent(chart.pointer,"afterGetHoverData",e=>{const series=e.hoverPoint?.series;chart.boost=chart.boost||{};if(chart.boost.markerGroup&&series){const xAxis=chart.inverted?series.yAxis:series.xAxis;const yAxis=chart.inverted?series.xAxis:series.yAxis;if(xAxis&&xAxis.pos!==prevX||yAxis&&yAxis.pos!==prevY){chart.series.forEach(s=>{s.halo?.hide()});chart.boost.markerGroup.translate(xAxis.pos,yAxis.pos);prevX=xAxis.pos;prevY=yAxis.pos}}})}function patientMax(...args){let r=-Number.MAX_VALUE;args.forEach(t=>{if(typeof t!=="undefined"&&t!==null&&typeof t.length!=="undefined"){if(t.length>0){r=t.length;return true}}});return r}const BoostChart={compose:compose,getBoostClipRect:getBoostClipRect,isChartSeriesBoosting:isChartSeriesBoosting};const Boost_BoostChart=BoostChart;var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_=__webpack_require__(620);var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default=__webpack_require__.n(highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_);const WGLDrawMode={area:"LINES",arearange:"LINES",areaspline:"LINES",column:"LINES",columnrange:"LINES",bar:"LINES",line:"LINE_STRIP",scatter:"POINTS",heatmap:"TRIANGLES",treemap:"TRIANGLES",bubble:"POINTS"};const Boost_WGLDrawMode=WGLDrawMode;const{clamp,error,pick:WGLShader_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const fragmentShader=["precision highp float;","uniform vec4 fillColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform sampler2D uSampler;","uniform bool isCircle;","uniform bool hasColor;","void main(void) {","vec4 col = fillColor;","vec4 tcol = texture2D(uSampler, gl_PointCoord.st);","if (hasColor) {","col = vColor;","}","if (isCircle) {","col *= tcol;","if (tcol.r < 0.0) {","discard;","} else {","gl_FragColor = col;","}","} else {","gl_FragColor = col;","}","}"].join("\n");const vertexShader=["#version 100","#define LN10 2.302585092994046","precision highp float;","attribute vec4 aVertexPosition;","attribute vec4 aColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform mat4 uPMatrix;","uniform float pSize;","uniform float translatedThreshold;","uniform bool hasThreshold;","uniform bool skipTranslation;","uniform float xAxisTrans;","uniform float xAxisMin;","uniform float xAxisMinPad;","uniform float xAxisPointRange;","uniform float xAxisLen;","uniform bool  xAxisPostTranslate;","uniform float xAxisOrdinalSlope;","uniform float xAxisOrdinalOffset;","uniform float xAxisPos;","uniform bool  xAxisCVSCoord;","uniform bool  xAxisIsLog;","uniform bool  xAxisReversed;","uniform float yAxisTrans;","uniform float yAxisMin;","uniform float yAxisMinPad;","uniform float yAxisPointRange;","uniform float yAxisLen;","uniform bool  yAxisPostTranslate;","uniform float yAxisOrdinalSlope;","uniform float yAxisOrdinalOffset;","uniform float yAxisPos;","uniform bool  yAxisCVSCoord;","uniform bool  yAxisIsLog;","uniform bool  yAxisReversed;","uniform bool  isBubble;","uniform bool  bubbleSizeByArea;","uniform float bubbleZMin;","uniform float bubbleZMax;","uniform float bubbleZThreshold;","uniform float bubbleMinSize;","uniform float bubbleMaxSize;","uniform bool  bubbleSizeAbs;","uniform bool  isInverted;","float bubbleRadius(){","float value = aVertexPosition.w;","float zMax = bubbleZMax;","float zMin = bubbleZMin;","float radius = 0.0;","float pos = 0.0;","float zRange = zMax - zMin;","if (bubbleSizeAbs){","value = value - bubbleZThreshold;","zMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);","zMin = 0.0;","}","if (value < zMin){","radius = bubbleZMin / 2.0 - 1.0;","} else {","pos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;","if (bubbleSizeByArea && pos > 0.0){","pos = sqrt(pos);","}","radius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;","}","return radius * 2.0;","}","float translate(float val,","float pointPlacement,","float localA,","float localMin,","float minPixelPadding,","float pointRange,","float len,","bool  cvsCoord,","bool  isLog,","bool  reversed","){","float sign = 1.0;","float cvsOffset = 0.0;","if (cvsCoord) {","sign *= -1.0;","cvsOffset = len;","}","if (isLog) {","val = log(val) / LN10;","}","if (reversed) {","sign *= -1.0;","cvsOffset -= sign * len;","}","return sign * (val - localMin) * localA + cvsOffset + ","(sign * minPixelPadding);","}","float xToPixels(float value) {","if (skipTranslation){","return value;// + xAxisPos;","}","return translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord, xAxisIsLog, xAxisReversed);// + xAxisPos;","}","float yToPixels(float value, float checkTreshold) {","float v;","if (skipTranslation){","v = value;// + yAxisPos;","} else {","v = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord, yAxisIsLog, yAxisReversed);// + yAxisPos;","if (v > yAxisLen) {","v = yAxisLen;","}","}","if (checkTreshold > 0.0 && hasThreshold) {","v = min(v, translatedThreshold);","}","return v;","}","void main(void) {","if (isBubble){","gl_PointSize = bubbleRadius();","} else {","gl_PointSize = pSize;","}","vColor = aColor;","if (skipTranslation && isInverted) {","gl_Position = uPMatrix * vec4(aVertexPosition.y + yAxisPos, aVertexPosition.x + xAxisPos, 0.0, 1.0);","} else if (isInverted) {","gl_Position = uPMatrix * vec4(yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, xToPixels(aVertexPosition.x) + xAxisPos, 0.0, 1.0);","} else {","gl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);","}","}"].join("\n");class WGLShader{constructor(gl){this.errors=[];this.uLocations={};this.gl=gl;if(gl&&!this.createShader()){return void 0}}bind(){if(this.gl&&this.shaderProgram){this.gl.useProgram(this.shaderProgram)}}createShader(){const v=this.stringToProgram(vertexShader,"vertex"),f=this.stringToProgram(fragmentShader,"fragment"),uloc=n=>this.gl.getUniformLocation(this.shaderProgram,n);if(!v||!f){this.shaderProgram=false;this.handleErrors();return false}this.shaderProgram=this.gl.createProgram();this.gl.attachShader(this.shaderProgram,v);this.gl.attachShader(this.shaderProgram,f);this.gl.linkProgram(this.shaderProgram);if(!this.gl.getProgramParameter(this.shaderProgram,this.gl.LINK_STATUS)){this.errors.push(this.gl.getProgramInfoLog(this.shaderProgram));this.handleErrors();this.shaderProgram=false;return false}this.gl.useProgram(this.shaderProgram);this.gl.bindAttribLocation(this.shaderProgram,0,"aVertexPosition");this.pUniform=uloc("uPMatrix");this.psUniform=uloc("pSize");this.fcUniform=uloc("fillColor");this.isBubbleUniform=uloc("isBubble");this.bubbleSizeAbsUniform=uloc("bubbleSizeAbs");this.bubbleSizeAreaUniform=uloc("bubbleSizeByArea");this.uSamplerUniform=uloc("uSampler");this.skipTranslationUniform=uloc("skipTranslation");this.isCircleUniform=uloc("isCircle");this.isInverted=uloc("isInverted");return true}handleErrors(){if(this.errors.length){error("[highcharts boost] shader error - "+this.errors.join("\n"))}}stringToProgram(str,type){const shader=this.gl.createShader(type==="vertex"?this.gl.VERTEX_SHADER:this.gl.FRAGMENT_SHADER);this.gl.shaderSource(shader,str);this.gl.compileShader(shader);if(!this.gl.getShaderParameter(shader,this.gl.COMPILE_STATUS)){this.errors.push("when compiling "+type+" shader:\n"+this.gl.getShaderInfoLog(shader));return false}return shader}destroy(){if(this.gl&&this.shaderProgram){this.gl.deleteProgram(this.shaderProgram);this.shaderProgram=false}}fillColorUniform(){return this.fcUniform}getProgram(){return this.shaderProgram}pointSizeUniform(){return this.psUniform}perspectiveUniform(){return this.pUniform}reset(){if(this.gl&&this.shaderProgram){this.gl.uniform1i(this.isBubbleUniform,0);this.gl.uniform1i(this.isCircleUniform,0)}}setBubbleUniforms(series,zCalcMin,zCalcMax,pixelRatio=1){const seriesOptions=series.options;let zMin=Number.MAX_VALUE,zMax=-Number.MAX_VALUE;if(this.gl&&this.shaderProgram&&series.is("bubble")){const pxSizes=series.getPxExtremes();zMin=WGLShader_pick(seriesOptions.zMin,clamp(zCalcMin,seriesOptions.displayNegative===false?seriesOptions.zThreshold:-Number.MAX_VALUE,zMin));zMax=WGLShader_pick(seriesOptions.zMax,Math.max(zMax,zCalcMax));this.gl.uniform1i(this.isBubbleUniform,1);this.gl.uniform1i(this.isCircleUniform,1);this.gl.uniform1i(this.bubbleSizeAreaUniform,series.options.sizeBy!=="width");this.gl.uniform1i(this.bubbleSizeAbsUniform,series.options.sizeByAbsoluteValue);this.setUniform("bubbleMinSize",pxSizes.minPxSize*pixelRatio);this.setUniform("bubbleMaxSize",pxSizes.maxPxSize*pixelRatio);this.setUniform("bubbleZMin",zMin);this.setUniform("bubbleZMax",zMax);this.setUniform("bubbleZThreshold",series.options.zThreshold)}}setColor(color){if(this.gl&&this.shaderProgram){this.gl.uniform4f(this.fcUniform,color[0]/255,color[1]/255,color[2]/255,color[3])}}setDrawAsCircle(flag){if(this.gl&&this.shaderProgram){this.gl.uniform1i(this.isCircleUniform,flag?1:0)}}setInverted(flag){if(this.gl&&this.shaderProgram){this.gl.uniform1i(this.isInverted,flag)}}setPMatrix(m){if(this.gl&&this.shaderProgram){this.gl.uniformMatrix4fv(this.pUniform,false,m)}}setPointSize(p){if(this.gl&&this.shaderProgram){this.gl.uniform1f(this.psUniform,p)}}setSkipTranslation(flag){if(this.gl&&this.shaderProgram){this.gl.uniform1i(this.skipTranslationUniform,flag===true?1:0)}}setTexture(texture){if(this.gl&&this.shaderProgram){this.gl.uniform1i(this.uSamplerUniform,texture)}}setUniform(name,val){if(this.gl&&this.shaderProgram){const u=this.uLocations[name]=this.uLocations[name]||this.gl.getUniformLocation(this.shaderProgram,name);this.gl.uniform1f(u,val)}}}const Boost_WGLShader=WGLShader;class WGLVertexBuffer{constructor(gl,shader,dataComponents){this.buffer=false;this.iterator=0;this.preAllocated=false;this.vertAttribute=false;this.components=dataComponents||2;this.dataComponents=dataComponents;this.gl=gl;this.shader=shader}allocate(size){this.iterator=-1;this.preAllocated=new Float32Array(size*4)}bind(){if(!this.buffer){return false}this.gl.vertexAttribPointer(this.vertAttribute,this.components,this.gl.FLOAT,false,0,0)}build(dataIn,attrib,dataComponents){let farray;this.data=dataIn||[];if((!this.data||this.data.length===0)&&!this.preAllocated){this.destroy();return false}this.components=dataComponents||this.components;if(this.buffer){this.gl.deleteBuffer(this.buffer)}if(!this.preAllocated){farray=new Float32Array(this.data)}this.buffer=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.buffer);this.gl.bufferData(this.gl.ARRAY_BUFFER,this.preAllocated||farray,this.gl.STATIC_DRAW);this.vertAttribute=this.gl.getAttribLocation(this.shader.getProgram(),attrib);this.gl.enableVertexAttribArray(this.vertAttribute);farray=false;return true}destroy(){if(this.buffer){this.gl.deleteBuffer(this.buffer);this.buffer=false;this.vertAttribute=false}this.iterator=0;this.components=this.dataComponents||2;this.data=[]}push(x,y,a,b){if(this.preAllocated){this.preAllocated[++this.iterator]=x;this.preAllocated[++this.iterator]=y;this.preAllocated[++this.iterator]=a;this.preAllocated[++this.iterator]=b}}render(from,to,drawMode){const length=this.preAllocated?this.preAllocated.length:this.data.length;if(!this.buffer){return false}if(!length){return false}if(!from||from>length||from<0){from=0}if(!to||to>length){to=length}if(from>=to){return false}drawMode=drawMode||"POINTS";this.gl.drawArrays(this.gl[drawMode],from/this.components,(to-from)/this.components);return true}}const Boost_WGLVertexBuffer=WGLVertexBuffer;const{parse:color}=highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default();const{doc,win}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{isNumber,isObject,merge,objectEach,pick:WGLRenderer_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const asBar={column:true,columnrange:true,bar:true,area:true,areaspline:true,arearange:true};const asCircle={scatter:true,bubble:true};const contexts=["webgl","experimental-webgl","moz-webgl","webkit-3d"];class WGLRenderer{static orthoMatrix(width,height){const near=0,far=1;return[2/width,0,0,0,0,-(2/height),0,0,0,0,-2/(far-near),0,-1,1,-(far+near)/(far-near),1]}static seriesPointCount(series){let isStacked,xData,s;if(series.boosted){isStacked=!!series.options.stacking;xData=(series.getColumn("x").length?series.getColumn("x"):void 0)||series.options.xData||series.getColumn("x",true);s=(isStacked?series.data:xData||series.options.data).length;if(series.type==="treemap"){s*=12}else if(series.type==="heatmap"){s*=6}else if(asBar[series.type]){s*=2}return s}return 0}constructor(postRenderCallback){this.data=[];this.height=0;this.isInited=false;this.markerData=[];this.series=[];this.textureHandles={};this.width=0;this.postRenderCallback=postRenderCallback;this.settings={pointSize:1,lineWidth:1,fillColor:"#AA00AA",useAlpha:true,usePreallocated:false,useGPUTranslations:false,debug:{timeRendering:false,timeSeriesProcessing:false,timeSetup:false,timeBufferCopy:false,timeKDTree:false,showSkipSummary:false}}}getPixelRatio(){return this.settings.pixelRatio||win.devicePixelRatio||1}setOptions(options){if(!("pixelRatio"in options)){options.pixelRatio=1}merge(true,this.settings,options)}allocateBuffer(chart){const vbuffer=this.vbuffer;let s=0;if(!this.settings.usePreallocated){return}chart.series.forEach(series=>{if(series.boosted){s+=WGLRenderer.seriesPointCount(series)}});vbuffer&&vbuffer.allocate(s)}allocateBufferForSingleSeries(series){const vbuffer=this.vbuffer;let s=0;if(!this.settings.usePreallocated){return}if(series.boosted){s=WGLRenderer.seriesPointCount(series)}vbuffer&&vbuffer.allocate(s)}clear(){const gl=this.gl;gl&&gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)}pushSeriesData(series,inst){const data=this.data,settings=this.settings,vbuffer=this.vbuffer,isRange=series.pointArrayMap&&series.pointArrayMap.join(",")==="low,high",{chart,options,sorted,xAxis,yAxis}=series,isStacked=!!options.stacking,rawData=options.data,xExtremes=series.xAxis.getExtremes(),xMin=xExtremes.min-(series.xAxis.minPointOffset||0),xMax=xExtremes.max+(series.xAxis.minPointOffset||0),yExtremes=series.yAxis.getExtremes(),yMin=yExtremes.min-(series.yAxis.minPointOffset||0),yMax=yExtremes.max+(series.yAxis.minPointOffset||0),xData=(series.getColumn("x").length?series.getColumn("x"):void 0)||options.xData||series.getColumn("x",true),yData=(series.getColumn("y").length?series.getColumn("y"):void 0)||options.yData||series.getColumn("y",true),zData=(series.getColumn("z").length?series.getColumn("z"):void 0)||options.zData||series.getColumn("z",true),useRaw=!xData||xData.length===0,connectNulls=options.connectNulls,points=series.points||false,sdata=isStacked?series.data:xData||rawData,closestLeft={x:Number.MAX_VALUE,y:0},closestRight={x:-Number.MAX_VALUE,y:0},cullXThreshold=1,cullYThreshold=1,chartDestroyed=typeof chart.index==="undefined",drawAsBar=asBar[series.type],zoneAxis=options.zoneAxis||"y",zones=options.zones||false,threshold=options.threshold,pixelRatio=this.getPixelRatio();let plotWidth=series.chart.plotWidth,lastX=false,lastY=false,minVal,scolor,skipped=0,hadPoints=false,x,y,d,z,i=-1,px=false,nx=false,low,nextInside=false,prevInside=false,pcolor=false,isXInside=false,isYInside=true,firstPoint=true,zoneColors,zoneDefColor=false,gapSize=false,vlen=0;if(options.boostData&&options.boostData.length>0){return}if(options.gapSize){gapSize=options.gapUnit!=="value"?options.gapSize*series.closestPointRange:options.gapSize}if(zones){zoneColors=[];zones.forEach((zone,i)=>{if(zone.color){const zoneColor=color(zone.color).rgba;zoneColor[0]/=255;zoneColor[1]/=255;zoneColor[2]/=255;zoneColors[i]=zoneColor;if(!zoneDefColor&&typeof zone.value==="undefined"){zoneDefColor=zoneColor}}});if(!zoneDefColor){const seriesColor=series.pointAttribs&&series.pointAttribs().fill||series.color;zoneDefColor=color(seriesColor).rgba;zoneDefColor[0]/=255;zoneDefColor[1]/=255;zoneDefColor[2]/=255}}if(chart.inverted){plotWidth=series.chart.plotHeight}series.closestPointRangePx=Number.MAX_VALUE;const pushColor=color=>{if(color){inst.colorData.push(color[0]);inst.colorData.push(color[1]);inst.colorData.push(color[2]);inst.colorData.push(color[3])}};const vertice=(x,y,checkTreshold,pointSize=1,color)=>{pushColor(color);if(pixelRatio!==1&&(!settings.useGPUTranslations||inst.skipTranslation)){x*=pixelRatio;y*=pixelRatio;pointSize*=pixelRatio}if(settings.usePreallocated&&vbuffer){vbuffer.push(x,y,checkTreshold?1:0,pointSize);vlen+=4}else{data.push(x);data.push(y);data.push(checkTreshold?pixelRatio:0);data.push(pointSize)}};const closeSegment=()=>{if(inst.segments.length){inst.segments[inst.segments.length-1].to=data.length||vlen}};const beginSegment=()=>{if(inst.segments.length&&inst.segments[inst.segments.length-1].from===(data.length||vlen)){return}closeSegment();inst.segments.push({from:data.length||vlen})};const pushRect=(x,y,w,h,color)=>{pushColor(color);vertice(x+w,y);pushColor(color);vertice(x,y);pushColor(color);vertice(x,y+h);pushColor(color);vertice(x,y+h);pushColor(color);vertice(x+w,y+h);pushColor(color);vertice(x+w,y)};beginSegment();if(points&&points.length>0){inst.skipTranslation=true;inst.drawMode="TRIANGLES";if(points[0].node&&points[0].node.levelDynamic){points.sort((a,b)=>{if(a.node){if(a.node.levelDynamic>b.node.levelDynamic){return 1}if(a.node.levelDynamic<b.node.levelDynamic){return-1}}return 0})}points.forEach(point=>{const plotY=point.plotY;let swidth,pointAttr;if(typeof plotY!=="undefined"&&!isNaN(plotY)&&point.y!==null&&point.shapeArgs){let{x=0,y=0,width=0,height=0}=point.shapeArgs;pointAttr=chart.styledMode?point.series.colorAttribs(point):pointAttr=point.series.pointAttribs(point);swidth=pointAttr["stroke-width"]||0;pcolor=color(pointAttr.fill).rgba;pcolor[0]/=255;pcolor[1]/=255;pcolor[2]/=255;if(series.is("treemap")){swidth=swidth||1;scolor=color(pointAttr.stroke).rgba;scolor[0]/=255;scolor[1]/=255;scolor[2]/=255;pushRect(x,y,width,height,scolor);swidth/=2}if(series.is("heatmap")&&chart.inverted){x=xAxis.len-x;y=yAxis.len-y;width=-width;height=-height}pushRect(x+swidth,y+swidth,width-swidth*2,height-swidth*2,pcolor)}});closeSegment();return}while(i<sdata.length-1){d=sdata[++i];if(typeof d==="undefined"){continue}if(chartDestroyed){break}const pointOptions=rawData&&rawData[i];if(!useRaw&&isObject(pointOptions,true)){if(pointOptions.color){pcolor=color(pointOptions.color).rgba;pcolor[0]/=255;pcolor[1]/=255;pcolor[2]/=255}}if(useRaw){x=d[0];y=d[1];if(sdata[i+1]){nx=sdata[i+1][0]}if(sdata[i-1]){px=sdata[i-1][0]}if(d.length>=3){z=d[2];if(d[2]>inst.zMax){inst.zMax=d[2]}if(d[2]<inst.zMin){inst.zMin=d[2]}}}else{x=d;y=yData?.[i];if(sdata[i+1]){nx=sdata[i+1]}if(sdata[i-1]){px=sdata[i-1]}if(zData&&zData.length){z=zData[i];if(zData[i]>inst.zMax){inst.zMax=zData[i]}if(zData[i]<inst.zMin){inst.zMin=zData[i]}}}if(!connectNulls&&(x===null||y===null)){beginSegment();continue}if(nx&&nx>=xMin&&nx<=xMax){nextInside=true}if(px&&px>=xMin&&px<=xMax){prevInside=true}if(isRange){if(useRaw){y=d.slice(1,3)}low=series.getColumn("low",true)?.[i];y=series.getColumn("high",true)?.[i]||0}else if(isStacked){x=d.x;y=d.stackY;low=y-d.y}if(yMin!==null&&typeof yMin!=="undefined"&&yMax!==null&&typeof yMax!=="undefined"){isYInside=y>=yMin&&y<=yMax}if(!sorted&&!isYInside){continue}if(x>xMax&&closestRight.x<xMax){closestRight.x=x;closestRight.y=y}if(x<xMin&&closestLeft.x>xMin){closestLeft.x=x;closestLeft.y=y}if(y===null&&connectNulls){continue}if(y===null||!isYInside&&!nextInside&&!prevInside){beginSegment();continue}if(sorted&&((nx>=xMin||x>=xMin)&&(px<=xMax||x<=xMax))||!sorted&&(x>=xMin&&x<=xMax)){isXInside=true}if(!isXInside&&!nextInside&&!prevInside){continue}if(gapSize&&x-px>gapSize){beginSegment()}if(zones){let zoneColor;zones.some((zone,i)=>{const last=zones[i-1];if(zoneAxis==="x"){if(typeof zone.value!=="undefined"&&x<=zone.value){if(zoneColors[i]&&(!last||x>=last.value)){zoneColor=zoneColors[i]}return true}return false}if(typeof zone.value!=="undefined"&&y<=zone.value){if(zoneColors[i]&&(!last||y>=last.value)){zoneColor=zoneColors[i]}return true}return false});pcolor=zoneColor||zoneDefColor||pcolor}if(!settings.useGPUTranslations){inst.skipTranslation=true;x=xAxis.toPixels(x,true);y=yAxis.toPixels(y,true);if(x>plotWidth){if(inst.drawMode==="POINTS"){continue}}}if(inst.hasMarkers&&isXInside){if(lastX!==false){series.closestPointRangePx=Math.min(series.closestPointRangePx,Math.abs(x-lastX))}}if(!settings.useGPUTranslations&&!settings.usePreallocated&&(lastX&&Math.abs(x-lastX)<cullXThreshold)&&(lastY&&Math.abs(y-lastY)<cullYThreshold)){if(settings.debug.showSkipSummary){++skipped}continue}if(drawAsBar){minVal=low||0;if(low===false||typeof low==="undefined"){if(y<0){minVal=y}else{minVal=0}}if(!isRange&&!isStacked||yAxis.logarithmic){minVal=Math.max(threshold===null?yMin:threshold,yMin)}if(!settings.useGPUTranslations){minVal=yAxis.toPixels(minVal,true)}vertice(x,minVal,0,0,pcolor)}if(options.step&&!firstPoint){vertice(x,lastY,0,2,pcolor)}vertice(x,y,0,series.type==="bubble"?z||1:2,pcolor);lastX=x;lastY=y;hadPoints=true;firstPoint=false}if(settings.debug.showSkipSummary){console.log("skipped points:",skipped)}const pushSupplementPoint=(point,atStart)=>{if(!settings.useGPUTranslations){inst.skipTranslation=true;point.x=xAxis.toPixels(point.x,true);point.y=yAxis.toPixels(point.y,true)}if(atStart){this.data=[point.x,point.y,0,2].concat(this.data);return}vertice(point.x,point.y,0,2)};if(!hadPoints&&connectNulls!==false&&series.drawMode==="line_strip"){if(closestLeft.x<Number.MAX_VALUE){pushSupplementPoint(closestLeft,true)}if(closestRight.x>-Number.MAX_VALUE){pushSupplementPoint(closestRight)}}closeSegment()}pushSeries(s){const markerData=this.markerData,series=this.series,settings=this.settings;if(series.length>0){if(series[series.length-1].hasMarkers){series[series.length-1].markerTo=markerData.length}}if(settings.debug.timeSeriesProcessing){console.time("building "+s.type+" series")}const obj={segments:[],markerFrom:markerData.length,colorData:[],series:s,zMin:Number.MAX_VALUE,zMax:-Number.MAX_VALUE,hasMarkers:s.options.marker?s.options.marker.enabled!==false:false,showMarkers:true,drawMode:Boost_WGLDrawMode[s.type]||"LINE_STRIP"};if(s.index>=series.length){series.push(obj)}else{series[s.index]=obj}this.pushSeriesData(s,obj);if(settings.debug.timeSeriesProcessing){console.timeEnd("building "+s.type+" series")}}flush(){const vbuffer=this.vbuffer;this.data=[];this.markerData=[];this.series=[];if(vbuffer){vbuffer.destroy()}}setXAxis(axis){const shader=this.shader;if(!shader){return}const pixelRatio=this.getPixelRatio();shader.setUniform("xAxisTrans",axis.transA*pixelRatio);shader.setUniform("xAxisMin",axis.min);shader.setUniform("xAxisMinPad",axis.minPixelPadding*pixelRatio);shader.setUniform("xAxisPointRange",axis.pointRange);shader.setUniform("xAxisLen",axis.len*pixelRatio);shader.setUniform("xAxisPos",axis.pos*pixelRatio);shader.setUniform("xAxisCVSCoord",!axis.horiz);shader.setUniform("xAxisIsLog",!!axis.logarithmic);shader.setUniform("xAxisReversed",!!axis.reversed)}setYAxis(axis){const shader=this.shader;if(!shader){return}const pixelRatio=this.getPixelRatio();shader.setUniform("yAxisTrans",axis.transA*pixelRatio);shader.setUniform("yAxisMin",axis.min);shader.setUniform("yAxisMinPad",axis.minPixelPadding*pixelRatio);shader.setUniform("yAxisPointRange",axis.pointRange);shader.setUniform("yAxisLen",axis.len*pixelRatio);shader.setUniform("yAxisPos",axis.pos*pixelRatio);shader.setUniform("yAxisCVSCoord",!axis.horiz);shader.setUniform("yAxisIsLog",!!axis.logarithmic);shader.setUniform("yAxisReversed",!!axis.reversed)}setThreshold(has,translation){const shader=this.shader;if(!shader){return}shader.setUniform("hasThreshold",has);shader.setUniform("translatedThreshold",translation)}renderChart(chart){const gl=this.gl,settings=this.settings,shader=this.shader,vbuffer=this.vbuffer;const pixelRatio=this.getPixelRatio();if(chart){this.width=chart.chartWidth*pixelRatio;this.height=chart.chartHeight*pixelRatio}else{return false}const height=this.height,width=this.width;if(!gl||!shader||!width||!height){return false}if(settings.debug.timeRendering){console.time("gl rendering")}gl.canvas.width=width;gl.canvas.height=height;shader.bind();gl.viewport(0,0,width,height);shader.setPMatrix(WGLRenderer.orthoMatrix(width,height));if(settings.lineWidth>1&&!highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().isMS){gl.lineWidth(settings.lineWidth)}if(vbuffer){vbuffer.build(this.data,"aVertexPosition",4);vbuffer.bind()}shader.setInverted(chart.inverted);this.series.forEach((s,si)=>{const options=s.series.options,shapeOptions=options.marker,lineWidth=typeof options.lineWidth!=="undefined"?options.lineWidth:1,threshold=options.threshold,hasThreshold=isNumber(threshold),yBottom=s.series.yAxis.getThreshold(threshold),translatedThreshold=yBottom,showMarkers=WGLRenderer_pick(options.marker?options.marker.enabled:null,s.series.xAxis.isRadial?true:null,s.series.closestPointRangePx>2*((options.marker?options.marker.radius:10)||10)),shapeTexture=this.textureHandles[shapeOptions&&shapeOptions.symbol||s.series.symbol]||this.textureHandles.circle;let sindex,cbuffer,fillColor,scolor=[];if(s.segments.length===0||s.segments[0].from===s.segments[0].to){return}if(shapeTexture.isReady){gl.bindTexture(gl.TEXTURE_2D,shapeTexture.handle);shader.setTexture(shapeTexture.handle)}if(chart.styledMode){if(s.series.markerGroup===s.series.chart.boost?.markerGroup){delete s.series.markerGroup;s.series.markerGroup=s.series.plotGroup("markerGroup","markers","visible",1,chart.seriesGroup).addClass("highcharts-tracker");fillColor=s.series.markerGroup.getStyle("fill");s.series.markerGroup.destroy();s.series.markerGroup=s.series.chart.boost?.markerGroup}else{fillColor=s.series.markerGroup?.getStyle("fill")}}else{fillColor=s.drawMode==="POINTS"&&s.series.pointAttribs&&s.series.pointAttribs().fill||s.series.color;if(options.colorByPoint){fillColor=s.series.chart.options.colors[si]}}if(s.series.fillOpacity&&options.fillOpacity){fillColor=new(highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default())(fillColor).setOpacity(WGLRenderer_pick(options.fillOpacity,1)).get()}scolor=color(fillColor).rgba;if(!settings.useAlpha){scolor[3]=1}if(options.boostBlending==="add"){gl.blendFunc(gl.SRC_ALPHA,gl.ONE);gl.blendEquation(gl.FUNC_ADD)}else if(options.boostBlending==="mult"||options.boostBlending==="multiply"){gl.blendFunc(gl.DST_COLOR,gl.ZERO)}else if(options.boostBlending==="darken"){gl.blendFunc(gl.ONE,gl.ONE);gl.blendEquation(gl.FUNC_MIN)}else{gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA)}shader.reset();if(s.colorData.length>0){shader.setUniform("hasColor",1);cbuffer=new Boost_WGLVertexBuffer(gl,shader);cbuffer.build(Array(s.segments[0].from).concat(s.colorData),"aColor",4);cbuffer.bind()}else{shader.setUniform("hasColor",0);gl.disableVertexAttribArray(gl.getAttribLocation(shader.getProgram(),"aColor"))}shader.setColor(scolor);this.setXAxis(s.series.xAxis);this.setYAxis(s.series.yAxis);this.setThreshold(hasThreshold,translatedThreshold);if(s.drawMode==="POINTS"){shader.setPointSize(WGLRenderer_pick(options.marker&&options.marker.radius,.5)*2*pixelRatio)}shader.setSkipTranslation(s.skipTranslation);if(s.series.type==="bubble"){shader.setBubbleUniforms(s.series,s.zMin,s.zMax,pixelRatio)}shader.setDrawAsCircle(asCircle[s.series.type]||false);if(!vbuffer){return}if(lineWidth>0||s.drawMode!=="LINE_STRIP"){for(sindex=0;sindex<s.segments.length;sindex++){vbuffer.render(s.segments[sindex].from,s.segments[sindex].to,s.drawMode)}}if(s.hasMarkers&&showMarkers){shader.setPointSize(WGLRenderer_pick(options.marker&&options.marker.radius,5)*2*pixelRatio);shader.setDrawAsCircle(true);for(sindex=0;sindex<s.segments.length;sindex++){vbuffer.render(s.segments[sindex].from,s.segments[sindex].to,"POINTS")}}});if(settings.debug.timeRendering){console.timeEnd("gl rendering")}if(this.postRenderCallback){this.postRenderCallback(this)}this.flush()}render(chart){this.clear();if(chart.renderer.forExport){return this.renderChart(chart)}if(this.isInited){this.renderChart(chart)}else{setTimeout(()=>{this.render(chart)},1)}}setSize(width,height){const shader=this.shader;if(!shader||this.width===width&&this.height===height){return}this.width=width;this.height=height;shader.bind();shader.setPMatrix(WGLRenderer.orthoMatrix(width,height))}init(canvas,noFlush){const settings=this.settings;this.isInited=false;if(!canvas){return false}if(settings.debug.timeSetup){console.time("gl setup")}for(let i=0;i<contexts.length;++i){this.gl=canvas.getContext(contexts[i],{});if(this.gl){break}}const gl=this.gl;if(gl){if(!noFlush){this.flush()}}else{return false}gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);gl.disable(gl.DEPTH_TEST);gl.depthFunc(gl.LESS);const shader=this.shader=new Boost_WGLShader(gl);if(!shader){return false}this.vbuffer=new Boost_WGLVertexBuffer(gl,shader);const createTexture=(name,fn)=>{const props={isReady:false,texture:doc.createElement("canvas"),handle:gl.createTexture()},ctx=props.texture.getContext("2d");this.textureHandles[name]=props;props.texture.width=512;props.texture.height=512;ctx.mozImageSmoothingEnabled=false;ctx.webkitImageSmoothingEnabled=false;ctx.msImageSmoothingEnabled=false;ctx.imageSmoothingEnabled=false;ctx.strokeStyle="rgba(255, 255, 255, 0)";ctx.fillStyle="#FFF";fn(ctx);try{gl.activeTexture(gl.TEXTURE0);gl.bindTexture(gl.TEXTURE_2D,props.handle);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,props.texture);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);gl.bindTexture(gl.TEXTURE_2D,null);props.isReady=true}catch(e){}};createTexture("circle",ctx=>{ctx.beginPath();ctx.arc(256,256,256,0,2*Math.PI);ctx.stroke();ctx.fill()});createTexture("square",ctx=>{ctx.fillRect(0,0,512,512)});createTexture("diamond",ctx=>{ctx.beginPath();ctx.moveTo(256,0);ctx.lineTo(512,256);ctx.lineTo(256,512);ctx.lineTo(0,256);ctx.lineTo(256,0);ctx.fill()});createTexture("triangle",ctx=>{ctx.beginPath();ctx.moveTo(0,512);ctx.lineTo(256,0);ctx.lineTo(512,512);ctx.lineTo(0,512);ctx.fill()});createTexture("triangle-down",ctx=>{ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(256,512);ctx.lineTo(512,0);ctx.lineTo(0,0);ctx.fill()});this.isInited=true;if(settings.debug.timeSetup){console.timeEnd("gl setup")}return true}destroy(){const gl=this.gl,shader=this.shader,vbuffer=this.vbuffer;this.flush();if(vbuffer){vbuffer.destroy()}if(shader){shader.destroy()}if(gl){objectEach(this.textureHandles,texture=>{if(texture.handle){gl.deleteTexture(texture.handle)}});gl.canvas.width=1;gl.canvas.height=1}}}const Boost_WGLRenderer=WGLRenderer;const{getBoostClipRect:BoostSeries_getBoostClipRect,isChartSeriesBoosting:BoostSeries_isChartSeriesBoosting}=Boost_BoostChart;const{getOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{composed:BoostSeries_composed,doc:BoostSeries_doc,noop,win:BoostSeries_win}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:BoostSeries_addEvent,destroyObjectProperties,error:BoostSeries_error,extend,fireEvent,isArray,isNumber:BoostSeries_isNumber,pick:BoostSeries_pick,pushUnique:BoostSeries_pushUnique,wrap,defined}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const CHUNK_SIZE=3e3;let index,mainCanvas;function allocateIfNotSeriesBoosting(renderer,series){const boost=series.boost;if(renderer&&boost&&boost.target&&boost.canvas&&!BoostSeries_isChartSeriesBoosting(series.chart)){renderer.allocateBufferForSingleSeries(series)}}function boostEnabled(chart){return BoostSeries_pick(chart&&chart.options&&chart.options.boost&&chart.options.boost.enabled,true)}function BoostSeries_compose(SeriesClass,seriesTypes,wglMode){if(BoostSeries_pushUnique(BoostSeries_composed,"Boost.Series")){const plotOptions=getOptions().plotOptions,seriesProto=SeriesClass.prototype;BoostSeries_addEvent(SeriesClass,"destroy",onSeriesDestroy);BoostSeries_addEvent(SeriesClass,"hide",onSeriesHide);if(wglMode){seriesProto.renderCanvas=seriesRenderCanvas}wrap(seriesProto,"getExtremes",wrapSeriesGetExtremes);wrap(seriesProto,"processData",wrapSeriesProcessData);wrap(seriesProto,"searchPoint",wrapSeriesSearchPoint);["translate","generatePoints","drawTracker","drawPoints","render"].forEach(method=>wrapSeriesFunctions(seriesProto,seriesTypes,method));Boost_Boostables.forEach(type=>{const typePlotOptions=plotOptions[type];if(typePlotOptions){typePlotOptions.boostThreshold=5e3;typePlotOptions.boostData=[];seriesTypes[type].prototype.fillOpacity=true}});if(wglMode){const{area:AreaSeries,areaspline:AreaSplineSeries,bubble:BubbleSeries,column:ColumnSeries,heatmap:HeatmapSeries,scatter:ScatterSeries,treemap:TreemapSeries}=seriesTypes;if(AreaSeries){extend(AreaSeries.prototype,{fill:true,fillOpacity:true,sampling:true})}if(AreaSplineSeries){extend(AreaSplineSeries.prototype,{fill:true,fillOpacity:true,sampling:true})}if(BubbleSeries){const bubbleProto=BubbleSeries.prototype;delete bubbleProto.buildKDTree;wrap(bubbleProto,"markerAttribs",function(proceed){if(this.boosted){return false}return proceed.apply(this,[].slice.call(arguments,1))})}if(ColumnSeries){extend(ColumnSeries.prototype,{fill:true,sampling:true})}if(ScatterSeries){ScatterSeries.prototype.fill=true}[HeatmapSeries,TreemapSeries].forEach(SC=>{if(SC){wrap(SC.prototype,"drawPoints",wrapSeriesDrawPoints)}})}}return SeriesClass}function createAndAttachRenderer(chart,series){const ChartClass=chart.constructor,targetGroup=chart.seriesGroup||series.group,alpha=1;let width=chart.chartWidth,height=chart.chartHeight,target=chart,foSupported=typeof SVGForeignObjectElement!=="undefined",hasClickHandler=false;if(BoostSeries_isChartSeriesBoosting(chart)){target=chart}else{target=series;hasClickHandler=Boolean(series.options.events?.click||series.options.point?.events?.click)}const boost=target.boost=target.boost||{};foSupported=false;if(!mainCanvas){mainCanvas=BoostSeries_doc.createElement("canvas")}if(!boost.target){boost.canvas=mainCanvas;if(chart.renderer.forExport||!foSupported){target.renderTarget=boost.target=chart.renderer.image("",0,0,width,height).addClass("highcharts-boost-canvas").add(targetGroup);boost.clear=function(){boost.target.attr({href:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="})};boost.copy=function(){boost.resize();boost.target.attr({href:boost.canvas.toDataURL("image/png")})}}else{boost.targetFo=chart.renderer.createElement("foreignObject").add(targetGroup);target.renderTarget=boost.target=BoostSeries_doc.createElement("canvas");boost.targetCtx=boost.target.getContext("2d");boost.targetFo.element.appendChild(boost.target);boost.clear=function(){boost.target.width=boost.canvas.width;boost.target.height=boost.canvas.height};boost.copy=function(){boost.target.width=boost.canvas.width;boost.target.height=boost.canvas.height;boost.targetCtx.drawImage(boost.canvas,0,0)}}boost.resize=function(){width=chart.chartWidth;height=chart.chartHeight;(boost.targetFo||boost.target).attr({x:0,y:0,width:width,height:height}).css({pointerEvents:hasClickHandler?void 0:"none",mixedBlendMode:"normal",opacity:alpha}).addClass(hasClickHandler?"highcharts-tracker":"");if(target instanceof ChartClass){target.boost?.markerGroup?.translate(chart.plotLeft,chart.plotTop)}};boost.clipRect=chart.renderer.clipRect();(boost.targetFo||boost.target).attr({zIndex:series.options.zIndex});if(target instanceof ChartClass){target.boost.markerGroup=target.renderer.g().add(targetGroup).translate(series.xAxis.pos,series.yAxis.pos)}}boost.canvas.width=width;boost.canvas.height=height;if(boost.clipRect){const box=BoostSeries_getBoostClipRect(chart,target),clippedElement=box.width===chart.clipBox.width&&box.height===chart.clipBox.height?targetGroup:boost.targetFo||boost.target;boost.clipRect.attr(box);clippedElement?.clip(boost.clipRect)}boost.resize();boost.clear();if(!boost.wgl){boost.wgl=new Boost_WGLRenderer(wgl=>{if(wgl.settings.debug.timeBufferCopy){console.time("buffer copy")}boost.copy();if(wgl.settings.debug.timeBufferCopy){console.timeEnd("buffer copy")}});if(!boost.wgl.init(boost.canvas)){BoostSeries_error("[highcharts boost] - unable to init WebGL renderer")}boost.wgl.setOptions(chart.options.boost||{});if(target instanceof ChartClass){boost.wgl.allocateBuffer(chart)}}boost.wgl.setSize(width,height);return boost.wgl}function destroyGraphics(series){const points=series.points;if(points){let point,i;for(i=0;i<points.length;i=i+1){point=points[i];if(point&&point.destroyElements){point.destroyElements()}}}["graph","area","tracker"].forEach(prop=>{const seriesProp=series[prop];if(seriesProp){series[prop]=seriesProp.destroy()}});for(const zone of series.zones){destroyObjectProperties(zone,void 0,true)}}function eachAsync(arr,fn,finalFunc,chunkSize,i,noTimeout){i=i||0;chunkSize=chunkSize||CHUNK_SIZE;const threshold=i+chunkSize;let proceed=true;while(proceed&&i<threshold&&i<arr.length){proceed=fn(arr[i],i);++i}if(proceed){if(i<arr.length){if(noTimeout){eachAsync(arr,fn,finalFunc,chunkSize,i,noTimeout)}else if(BoostSeries_win.requestAnimationFrame){BoostSeries_win.requestAnimationFrame(function(){eachAsync(arr,fn,finalFunc,chunkSize,i)})}else{setTimeout(eachAsync,0,arr,fn,finalFunc,chunkSize,i)}}else if(finalFunc){finalFunc()}}}function enterBoost(series){series.boost=series.boost||{getPoint:bp=>getPoint(series,bp)};const alteredByBoost=series.boost.altered=[];["allowDG","directTouch","stickyTracking"].forEach(prop=>{alteredByBoost.push({prop:prop,val:series[prop],own:Object.hasOwnProperty.call(series,prop)})});series.allowDG=false;series.directTouch=false;series.stickyTracking=true;series.finishedAnimating=true;if(series.labelBySeries){series.labelBySeries=series.labelBySeries.destroy()}if(series.is("scatter")&&!series.is("treemap")&&series.data.length){for(const point of series.data){point?.destroy?.()}series.data.length=0;series.points.length=0;delete series.processedData}}function exitBoost(series){const boost=series.boost,chart=series.chart,chartBoost=chart.boost;if(chartBoost?.markerGroup){chartBoost.markerGroup.destroy();chartBoost.markerGroup=void 0;for(const s of chart.series){s.markerGroup=void 0;s.markerGroup=s.plotGroup("markerGroup","markers","visible",1,chart.seriesGroup).addClass("highcharts-tracker")}}if(boost){(boost.altered||[]).forEach(setting=>{if(setting.own){series[setting.prop]=setting.val}else{delete series[setting.prop]}});if(boost.clear){boost.clear()}}(chart.seriesGroup||series.group)?.clip()}function hasExtremes(series,checkX){const options=series.options,dataLength=series.dataTable.modified.rowCount,xAxis=series.xAxis&&series.xAxis.options,yAxis=series.yAxis&&series.yAxis.options,colorAxis=series.colorAxis&&series.colorAxis.options;return dataLength>(options.boostThreshold||Number.MAX_VALUE)&&BoostSeries_isNumber(yAxis.min)&&BoostSeries_isNumber(yAxis.max)&&(!checkX||BoostSeries_isNumber(xAxis.min)&&BoostSeries_isNumber(xAxis.max))&&(!colorAxis||BoostSeries_isNumber(colorAxis.min)&&BoostSeries_isNumber(colorAxis.max))}const getSeriesBoosting=(series,data)=>{if(series.forceCrop){return false}return BoostSeries_isChartSeriesBoosting(series.chart)||(data?data.length:0)>=(series.options.boostThreshold||Number.MAX_VALUE)};function onSeriesDestroy(){const series=this,chart=series.chart;if(chart.boost&&chart.boost.markerGroup===series.markerGroup){series.markerGroup=null}if(chart.hoverPoints){chart.hoverPoints=chart.hoverPoints.filter(function(point){return point.series===series})}if(chart.hoverPoint&&chart.hoverPoint.series===series){chart.hoverPoint=null}}function onSeriesHide(){const boost=this.boost;if(boost&&boost.canvas&&boost.target){if(boost.wgl){boost.wgl.clear()}if(boost.clear){boost.clear()}}}function renderIfNotSeriesBoosting(series){const boost=series.boost;if(boost&&boost.canvas&&boost.target&&boost.wgl&&!BoostSeries_isChartSeriesBoosting(series.chart)){boost.wgl.render(series.chart)}}function getPoint(series,boostPoint){const seriesOptions=series.options,xAxis=series.xAxis,PointClass=series.pointClass;if(boostPoint instanceof PointClass){return boostPoint}const xData=(series.getColumn("x").length?series.getColumn("x"):void 0)||seriesOptions.xData||series.getColumn("x",true)||false,point=new PointClass(series,(isArray(series.options.data)?series.options.data:[])[boostPoint.i],xData?xData[boostPoint.i]:void 0);point.category=BoostSeries_pick(xAxis.categories?xAxis.categories[point.x]:point.x,point.x);point.key=point.name??point.category;point.dist=boostPoint.dist;point.distX=boostPoint.distX;point.plotX=boostPoint.plotX;point.plotY=boostPoint.plotY;point.index=boostPoint.i;point.percentage=boostPoint.percentage;point.isInside=series.isPointInside(point);return point}function scatterProcessData(force){var _a,_b,_c,_d;const series=this,{options,xAxis,yAxis}=series;if(!series.isDirty&&!xAxis.isDirty&&!yAxis.isDirty&&!force){return false}series.yAxis.setTickInterval();const boostThreshold=options.boostThreshold||0,cropThreshold=options.cropThreshold,xData=series.getColumn("x"),xExtremes=xAxis.getExtremes(),xMax=xExtremes.max??Number.MAX_VALUE,xMin=xExtremes.min??-Number.MAX_VALUE,yData=series.getColumn("y"),yExtremes=yAxis.getExtremes(),yMax=yExtremes.max??Number.MAX_VALUE,yMin=yExtremes.min??-Number.MAX_VALUE;if(!series.boosted&&xAxis.old&&yAxis.old&&xMin>=(xAxis.old.min??-Number.MAX_VALUE)&&xMax<=(xAxis.old.max??Number.MAX_VALUE)&&yMin>=(yAxis.old.min??-Number.MAX_VALUE)&&yMax<=(yAxis.old.max??Number.MAX_VALUE)){series.dataTable.modified.setColumns({x:xData,y:yData});return true}const dataLength=series.dataTable.rowCount;if(!boostThreshold||dataLength<boostThreshold||cropThreshold&&!series.forceCrop&&!series.getExtremesFromAll&&!options.getExtremesFromAll&&dataLength<cropThreshold){series.dataTable.modified.setColumns({x:xData,y:yData});return true}const processedData=[],processedXData=[],processedYData=[],xRangeNeeded=!(BoostSeries_isNumber(xExtremes.max)||BoostSeries_isNumber(xExtremes.min)),yRangeNeeded=!(BoostSeries_isNumber(yExtremes.max)||BoostSeries_isNumber(yExtremes.min));let cropped=false,x,xDataMax=xData[0],xDataMin=xData[0],y,yDataMax=yData?.[0],yDataMin=yData?.[0];for(let i=0,iEnd=xData.length;i<iEnd;++i){x=xData[i];y=yData?.[i];if(x>=xMin&&x<=xMax&&y>=yMin&&y<=yMax){processedData.push({x:x,y:y});processedXData.push(x);processedYData.push(y);if(xRangeNeeded){xDataMax=Math.max(xDataMax,x);xDataMin=Math.min(xDataMin,x)}if(yRangeNeeded){yDataMax=Math.max(yDataMax,y);yDataMin=Math.min(yDataMin,y)}}else{cropped=true}}if(xRangeNeeded){(_a=xAxis.options).max??(_a.max=xDataMax);(_b=xAxis.options).min??(_b.min=xDataMin)}if(yRangeNeeded){(_c=yAxis.options).max??(_c.max=yDataMax);(_d=yAxis.options).min??(_d.min=yDataMin)}series.cropped=cropped;series.cropStart=0;series.dataTable.modified.setColumns({x:processedXData,y:processedYData});if(!getSeriesBoosting(series,processedXData)){series.processedData=processedData}return true}function seriesRenderCanvas(){const options=this.options||{},chart=this.chart,chartBoost=chart.boost,seriesBoost=this.boost,xAxis=this.xAxis,yAxis=this.yAxis,xData=options.xData||this.getColumn("x",true),yData=options.yData||this.getColumn("y",true),lowData=this.getColumn("low",true),highData=this.getColumn("high",true),rawData=this.processedData||options.data,xExtremes=xAxis.getExtremes(),xMin=xExtremes.min-(xAxis.minPointOffset||0),xMax=xExtremes.max+(xAxis.minPointOffset||0),yExtremes=yAxis.getExtremes(),yMin=yExtremes.min-(yAxis.minPointOffset||0),yMax=yExtremes.max+(yAxis.minPointOffset||0),pointTaken={},sampling=!!this.sampling,enableMouseTracking=options.enableMouseTracking,threshold=options.threshold,isRange=this.pointArrayMap&&this.pointArrayMap.join(",")==="low,high",isStacked=!!options.stacking,cropStart=this.cropStart||0,requireSorting=this.requireSorting,useRaw=!xData,compareX=options.findNearestPointBy==="x",xDataFull=(this.getColumn("x",true).length?this.getColumn("x",true):void 0)||this.options.xData||this.getColumn("x",true),lineWidth=BoostSeries_pick(options.lineWidth,1);let renderer=false,lastClientX,yBottom=yAxis.getThreshold(threshold),minVal,maxVal,minI,maxI;if(xAxis.isPanning||yAxis.isPanning){return}renderer=createAndAttachRenderer(chart,this);chart.boosted=true;if(!this.visible){return}if(this.points||this.graph){destroyGraphics(this)}if(!BoostSeries_isChartSeriesBoosting(chart)){if(this.markerGroup===chartBoost?.markerGroup){this.markerGroup=void 0}this.markerGroup=this.plotGroup("markerGroup","markers","visible",1,chart.seriesGroup).addClass("highcharts-tracker")}else{if(this.markerGroup&&this.markerGroup!==chartBoost?.markerGroup){this.markerGroup.destroy()}this.markerGroup=chartBoost?.markerGroup;if(seriesBoost&&seriesBoost.target){this.renderTarget=seriesBoost.target=seriesBoost.target.destroy()}}const points=this.points=[],addKDPoint=(clientX,plotY,i,percentage)=>{const x=xDataFull?xDataFull[cropStart+i]:false,pushPoint=plotX=>{if(chart.inverted){plotX=xAxis.len-plotX;plotY=yAxis.len-plotY}points.push({destroy:noop,x:x,clientX:plotX,plotX:plotX,plotY:plotY,i:cropStart+i,percentage:percentage})};clientX=Math.ceil(clientX);index=compareX?clientX:clientX+","+plotY;if(enableMouseTracking){if(!pointTaken[index]){pointTaken[index]=true;pushPoint(clientX)}else if(x===xDataFull[xDataFull.length-1]){points.length--;pushPoint(clientX)}}};this.buildKDTree=noop;fireEvent(this,"renderCanvas");if(this.is("line")&&lineWidth>1&&seriesBoost?.target&&chartBoost&&!chartBoost.lineWidthFilter){chartBoost.lineWidthFilter=chart.renderer.definition({tagName:"filter",children:[{tagName:"feMorphology",attributes:{operator:"dilate",radius:.25*lineWidth}}],attributes:{id:"linewidth"}});seriesBoost.target.attr({filter:"url(#linewidth)"})}if(renderer){allocateIfNotSeriesBoosting(renderer,this);renderer.pushSeries(this);renderIfNotSeriesBoosting(this)}function processPoint(d,i){const chartDestroyed=typeof chart.index==="undefined";let x,y,clientX,plotY,percentage,low=false,isYInside=true;if(!defined(d)){return true}if(!chartDestroyed){if(useRaw){x=d[0];y=d[1]}else{x=d;y=yData?.[i]}if(isRange){if(useRaw){y=d.slice(1,3)}low=lowData[i];y=highData[i]}else if(isStacked){x=d.x;y=d.stackY;low=y-d.y;percentage=d.percentage}if(!requireSorting){isYInside=(y||0)>=yMin&&y<=yMax}if(y!==null&&x>=xMin&&x<=xMax&&isYInside){clientX=xAxis.toPixels(x,true);if(sampling){if(typeof minI==="undefined"||clientX===lastClientX){if(!isRange){low=y}if(typeof maxI==="undefined"||y>maxVal){maxVal=y;maxI=i}if(typeof minI==="undefined"||low<minVal){minVal=low;minI=i}}if(!compareX||clientX!==lastClientX){if(typeof minI!=="undefined"){plotY=yAxis.toPixels(maxVal,true);yBottom=yAxis.toPixels(minVal,true);addKDPoint(clientX,plotY,maxI,percentage);if(yBottom!==plotY){addKDPoint(clientX,yBottom,minI,percentage)}}minI=maxI=void 0;lastClientX=clientX}}else{plotY=Math.ceil(yAxis.toPixels(y,true));addKDPoint(clientX,plotY,i,percentage)}}}return!chartDestroyed}const boostOptions=renderer.settings,doneProcessing=()=>{fireEvent(this,"renderedCanvas");delete this.buildKDTree;if(this.options){this.buildKDTree()}if(boostOptions.debug.timeKDTree){console.timeEnd("kd tree building")}};if(!chart.renderer.forExport){if(boostOptions.debug.timeKDTree){console.time("kd tree building")}eachAsync(isStacked?this.data.slice(cropStart):xData||rawData,processPoint,doneProcessing)}}function wrapSeriesDrawPoints(proceed){let enabled=true;if(this.chart.options&&this.chart.options.boost){enabled=typeof this.chart.options.boost.enabled==="undefined"?true:this.chart.options.boost.enabled}if(!enabled||!this.boosted){return proceed.call(this)}this.chart.boosted=true;const renderer=createAndAttachRenderer(this.chart,this);if(renderer){allocateIfNotSeriesBoosting(renderer,this);renderer.pushSeries(this)}renderIfNotSeriesBoosting(this)}function wrapSeriesFunctions(seriesProto,seriesTypes,method){function branch(proceed){const letItPass=this.options.stacking&&(method==="translate"||method==="generatePoints");if(!this.boosted||letItPass||!boostEnabled(this.chart)||this.type==="heatmap"||this.type==="treemap"||!Boost_BoostableMap[this.type]||this.options.boostThreshold===0){proceed.call(this)}else if(method==="render"&&this.renderCanvas){this.renderCanvas()}}wrap(seriesProto,method,branch);if(method==="translate"){for(const type of["column","arearange","columnrange","heatmap","treemap"]){if(seriesTypes[type]){wrap(seriesTypes[type].prototype,method,branch)}}}}function wrapSeriesGetExtremes(proceed){if(this.boosted){if(hasExtremes(this)){return{}}if(this.xAxis.isPanning||this.yAxis.isPanning){return this}}return proceed.apply(this,[].slice.call(arguments,1))}function wrapSeriesProcessData(proceed){let dataToMeasure=this.options.data;if(boostEnabled(this.chart)&&Boost_BoostableMap[this.type]){const series=this,isScatter=series.is("scatter")&&!series.is("bubble")&&!series.is("treemap")&&!series.is("heatmap");if(!getSeriesBoosting(series,dataToMeasure)||isScatter||series.is("treemap")||series.options.stacking||!hasExtremes(series,true)){if(series.boosted&&(series.xAxis?.isPanning||series.yAxis?.isPanning)){return}if(isScatter&&!series.yAxis.treeGrid){scatterProcessData.call(series,arguments[1])}else{proceed.apply(series,[].slice.call(arguments,1))}dataToMeasure=series.getColumn("x",true)}series.boosted=getSeriesBoosting(series,dataToMeasure);if(series.boosted){let firstPoint;if(series.options.data?.length){firstPoint=series.getFirstValidPoint(series.options.data);if(!BoostSeries_isNumber(firstPoint)&&!isArray(firstPoint)&&!series.is("treemap")){BoostSeries_error(12,false,series.chart)}}enterBoost(series)}else{exitBoost(series)}}else{proceed.apply(this,[].slice.call(arguments,1))}}function wrapSeriesSearchPoint(proceed){const result=proceed.apply(this,[].slice.call(arguments,1));if(this.boost&&result){return this.boost.getPoint(result)}return result}const BoostSeries={compose:BoostSeries_compose,destroyGraphics:destroyGraphics,eachAsync:eachAsync,getPoint:getPoint};const Boost_BoostSeries=BoostSeries;const{getBoostClipRect:BoostCanvas_getBoostClipRect,isChartSeriesBoosting:BoostCanvas_isChartSeriesBoosting}=Boost_BoostChart;const{destroyGraphics:BoostCanvas_destroyGraphics}=Boost_BoostSeries;const{parse:BoostCanvas_color}=highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default();const{doc:BoostCanvas_doc,noop:BoostCanvas_noop}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:BoostCanvas_addEvent,fireEvent:BoostCanvas_fireEvent,isNumber:BoostCanvas_isNumber,merge:BoostCanvas_merge,pick:BoostCanvas_pick,wrap:BoostCanvas_wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var BoostCanvas;(function(BoostCanvas){const b64BlankPixel="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAw"+"CAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";const CHUNK_SIZE=5e4;let ChartConstructor;let destroyLoadingDiv;function areaCvsDrawPoint(ctx,clientX,plotY,yBottom,lastPoint){if(lastPoint&&clientX!==lastPoint.clientX){ctx.moveTo(lastPoint.clientX,lastPoint.yBottom);ctx.lineTo(lastPoint.clientX,lastPoint.plotY);ctx.lineTo(clientX,plotY);ctx.lineTo(clientX,yBottom)}}function bubbleCvsMarkerCircle(ctx,clientX,plotY,r,i){ctx.moveTo(clientX,plotY);ctx.arc(clientX,plotY,this.radii&&this.radii[i],0,2*Math.PI,false)}function columnCvsDrawPoint(ctx,clientX,plotY,yBottom){ctx.rect(clientX-1,plotY,1,yBottom-plotY)}function compose(ChartClass,SeriesClass,seriesTypes){const seriesProto=SeriesClass.prototype;if(!seriesProto.renderCanvas){const{area:AreaSeries,bubble:BubbleSeries,column:ColumnSeries,heatmap:HeatmapSeries,scatter:ScatterSeries}=seriesTypes;ChartConstructor=ChartClass;ChartClass.prototype.callbacks.push(chart=>{BoostCanvas_addEvent(chart,"predraw",onChartClear);BoostCanvas_addEvent(chart,"render",onChartCanvasToSVG)});seriesProto.canvasToSVG=seriesCanvasToSVG;seriesProto.cvsLineTo=seriesCvsLineTo;seriesProto.getContext=seriesGetContext;seriesProto.renderCanvas=seriesRenderCanvas;if(AreaSeries){const areaProto=AreaSeries.prototype;areaProto.cvsDrawPoint=areaCvsDrawPoint;areaProto.fill=true;areaProto.fillOpacity=true;areaProto.sampling=true}if(BubbleSeries){const bubbleProto=BubbleSeries.prototype;bubbleProto.cvsMarkerCircle=bubbleCvsMarkerCircle;bubbleProto.cvsStrokeBatch=1}if(ColumnSeries){const columnProto=ColumnSeries.prototype;columnProto.cvsDrawPoint=columnCvsDrawPoint;columnProto.fill=true;columnProto.sampling=true}if(HeatmapSeries){const heatmapProto=HeatmapSeries.prototype;BoostCanvas_wrap(heatmapProto,"drawPoints",wrapHeatmapDrawPoints)}if(ScatterSeries){const scatterProto=ScatterSeries.prototype;scatterProto.cvsMarkerCircle=scatterCvsMarkerCircle;scatterProto.cvsMarkerSquare=scatterCvsMarkerSquare;scatterProto.fill=true}}}BoostCanvas.compose=compose;function onChartCanvasToSVG(){if(this.boost&&this.boost.copy){this.boost.copy()}}function onChartClear(){const boost=this.boost||{};if(boost.target){boost.target.attr({href:b64BlankPixel})}if(boost.canvas){boost.canvas.getContext("2d").clearRect(0,0,boost.canvas.width,boost.canvas.height)}}function seriesCanvasToSVG(){if(!BoostCanvas_isChartSeriesBoosting(this.chart)){if(this.boost&&this.boost.copy){this.boost.copy()}else if(this.chart.boost&&this.chart.boost.copy){this.chart.boost.copy()}}else if(this.boost&&this.boost.clear){this.boost.clear()}}function seriesCvsLineTo(ctx,clientX,plotY){ctx.lineTo(clientX,plotY)}function seriesGetContext(){const chart=this.chart,target=BoostCanvas_isChartSeriesBoosting(chart)?chart:this,targetGroup=target===chart?chart.seriesGroup:chart.seriesGroup||this.group,width=chart.chartWidth,height=chart.chartHeight,swapXY=function(proceed,x,y,a,b,c,d){proceed.call(this,y,x,a,b,c,d)};let ctx;const boost=target.boost=target.boost||{};ctx=boost.targetCtx;if(!boost.canvas){boost.canvas=BoostCanvas_doc.createElement("canvas");boost.target=chart.renderer.image("",0,0,width,height).addClass("highcharts-boost-canvas").add(targetGroup);ctx=boost.targetCtx=boost.canvas.getContext("2d");if(chart.inverted){["moveTo","lineTo","rect","arc"].forEach(fn=>{BoostCanvas_wrap(ctx,fn,swapXY)})}boost.copy=function(){boost.target.attr({href:boost.canvas.toDataURL("image/png")})};boost.clear=function(){ctx.clearRect(0,0,boost.canvas.width,boost.canvas.height);if(target===boost.target){boost.target.attr({href:b64BlankPixel})}};boost.clipRect=chart.renderer.clipRect();boost.target.clip(boost.clipRect)}else if(!(target instanceof ChartConstructor)){}if(boost.canvas.width!==width){boost.canvas.width=width}if(boost.canvas.height!==height){boost.canvas.height=height}boost.target.attr({x:0,y:0,width:width,height:height,style:"pointer-events: none",href:b64BlankPixel});if(boost.clipRect){boost.clipRect.attr(BoostCanvas_getBoostClipRect(chart,target))}return ctx}function seriesRenderCanvas(){const series=this,options=series.options,chart=series.chart,xAxis=series.xAxis,yAxis=series.yAxis,activeBoostSettings=chart.options.boost||{},boostSettings={timeRendering:activeBoostSettings.timeRendering||false,timeSeriesProcessing:activeBoostSettings.timeSeriesProcessing||false,timeSetup:activeBoostSettings.timeSetup||false},xData=series.getColumn("x",true),yData=series.getColumn("y",true),rawData=options.data,xExtremes=xAxis.getExtremes(),xMin=xExtremes.min,xMax=xExtremes.max,yExtremes=yAxis.getExtremes(),yMin=yExtremes.min,yMax=yExtremes.max,pointTaken={},sampling=!!series.sampling,r=options.marker&&options.marker.radius,strokeBatch=series.cvsStrokeBatch||1e3,enableMouseTracking=options.enableMouseTracking,threshold=options.threshold,hasThreshold=BoostCanvas_isNumber(threshold),translatedThreshold=yAxis.getThreshold(threshold),doFill=series.fill,isRange=series.pointArrayMap&&series.pointArrayMap.join(",")==="low,high",isStacked=!!options.stacking,cropStart=series.cropStart||0,loadingOptions=chart.options.loading,requireSorting=series.requireSorting,connectNulls=options.connectNulls,useRaw=!xData,sdata=isStacked?series.data:xData||rawData,fillColor=series.fillOpacity?highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default().parse(series.color).setOpacity(BoostCanvas_pick(options.fillOpacity,.75)).get():series.color,compareX=options.findNearestPointBy==="x",boost=this.boost||{},cvsDrawPoint=series.cvsDrawPoint,cvsLineTo=options.lineWidth?series.cvsLineTo:void 0,cvsMarker=r&&r<=1?series.cvsMarkerSquare:series.cvsMarkerCircle;if(boost.target){boost.target.attr({href:b64BlankPixel})}if(series.points||series.graph){BoostCanvas_destroyGraphics(series)}series.plotGroup("group","series",series.visible?"visible":"hidden",options.zIndex,chart.seriesGroup);series.markerGroup=series.group;BoostCanvas_addEvent(series,"destroy",function(){series.markerGroup=null});const points=this.points=[],ctx=this.getContext();series.buildKDTree=BoostCanvas_noop;if(boost.clear){boost.clear()}if(!series.visible){return}if(rawData.length>99999){chart.options.loading=BoostCanvas_merge(loadingOptions,{labelStyle:{backgroundColor:BoostCanvas_color("#ffffff").setOpacity(.75).get(),padding:"1em",borderRadius:"0.5em"},style:{backgroundColor:"none",opacity:1}});highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().clearTimeout(destroyLoadingDiv);chart.showLoading("Drawing...");chart.options.loading=loadingOptions}if(boostSettings.timeRendering){console.time("canvas rendering")}let c=0,lastClientX,lastPoint,yBottom=translatedThreshold,wasNull,minVal,maxVal,minI,maxI,index;const stroke=function(){if(doFill){ctx.fillStyle=fillColor;ctx.fill()}else{ctx.strokeStyle=series.color;ctx.lineWidth=options.lineWidth;ctx.stroke()}},drawPoint=function(clientX,plotY,yBottom,i){if(c===0){ctx.beginPath();if(cvsLineTo){ctx.lineJoin="round"}}if(chart.scroller&&series.options.className==="highcharts-navigator-series"){plotY+=chart.scroller.top;if(yBottom){yBottom+=chart.scroller.top}}else{plotY+=chart.plotTop}clientX+=chart.plotLeft;if(wasNull){ctx.moveTo(clientX,plotY)}else{if(cvsDrawPoint){cvsDrawPoint(ctx,clientX,plotY,yBottom,lastPoint)}else if(cvsLineTo){cvsLineTo(ctx,clientX,plotY)}else if(cvsMarker){cvsMarker.call(series,ctx,clientX,plotY,r,i)}}c=c+1;if(c===strokeBatch){stroke();c=0}lastPoint={clientX:clientX,plotY:plotY,yBottom:yBottom}},xDataFull=(this.getColumn("x").length?this.getColumn("x"):void 0)||this.options.xData||(this.getColumn("x",true).length?this.getColumn("x",true):false),addKDPoint=function(clientX,plotY,i){index=compareX?clientX:clientX+","+plotY;if(enableMouseTracking&&!pointTaken[index]){pointTaken[index]=true;if(chart.inverted){clientX=xAxis.len-clientX;plotY=yAxis.len-plotY}points.push({x:xDataFull?xDataFull[cropStart+i]:false,clientX:clientX,plotX:clientX,plotY:plotY,i:cropStart+i})}};Boost_BoostSeries.eachAsync(sdata,(d,i)=>{const chartDestroyed=typeof chart.index==="undefined";let x,y,clientX,plotY,isNull,low,isNextInside=false,isPrevInside=false,nx=NaN,px=NaN,isYInside=true;if(!chartDestroyed){if(useRaw){x=d[0];y=d[1];if(sdata[i+1]){nx=sdata[i+1][0]}if(sdata[i-1]){px=sdata[i-1][0]}}else{x=d;y=yData[i];if(sdata[i+1]){nx=sdata[i+1]}if(sdata[i-1]){px=sdata[i-1]}}if(nx&&nx>=xMin&&nx<=xMax){isNextInside=true}if(px&&px>=xMin&&px<=xMax){isPrevInside=true}if(isRange){if(useRaw){y=d.slice(1,3)}low=y[0];y=y[1]}else if(isStacked){x=d.x;y=d.stackY;low=y-d.y}isNull=y===null;if(!requireSorting){isYInside=y>=yMin&&y<=yMax}if(!isNull&&(x>=xMin&&x<=xMax&&isYInside||(isNextInside||isPrevInside))){clientX=Math.round(xAxis.toPixels(x,true));if(sampling){if(typeof minI==="undefined"||clientX===lastClientX){if(!isRange){low=y}if(typeof maxI==="undefined"||y>maxVal){maxVal=y;maxI=i}if(typeof minI==="undefined"||low<minVal){minVal=low;minI=i}}if(clientX!==lastClientX){if(typeof minI!=="undefined"){plotY=yAxis.toPixels(maxVal,true);yBottom=yAxis.toPixels(minVal,true);drawPoint(clientX,hasThreshold?Math.min(plotY,translatedThreshold):plotY,hasThreshold?Math.max(yBottom,translatedThreshold):yBottom,i);addKDPoint(clientX,plotY,maxI);if(yBottom!==plotY){addKDPoint(clientX,yBottom,minI)}}minI=maxI=void 0;lastClientX=clientX}}else{plotY=Math.round(yAxis.toPixels(y,true));drawPoint(clientX,plotY,yBottom,i);addKDPoint(clientX,plotY,i)}}wasNull=isNull&&!connectNulls;if(i%CHUNK_SIZE===0){if(series.boost&&series.boost.copy){series.boost.copy()}else if(series.chart.boost&&series.chart.boost.copy){series.chart.boost.copy()}}}return!chartDestroyed},function(){const loadingDiv=chart.loadingDiv,loadingShown=chart.loadingShown;stroke();series.canvasToSVG();if(boostSettings.timeRendering){console.timeEnd("canvas rendering")}BoostCanvas_fireEvent(series,"renderedCanvas");if(loadingShown){loadingDiv.style.transition="opacity 250ms";loadingDiv.opacity=0;chart.loadingShown=false;destroyLoadingDiv=setTimeout(function(){if(loadingDiv.parentNode){loadingDiv.parentNode.removeChild(loadingDiv)}chart.loadingDiv=chart.loadingSpan=null},250)}delete series.buildKDTree;series.buildKDTree()},chart.renderer.forExport?Number.MAX_VALUE:void 0)}function scatterCvsMarkerCircle(ctx,clientX,plotY,r){ctx.moveTo(clientX,plotY);ctx.arc(clientX,plotY,r,0,2*Math.PI,false)}function scatterCvsMarkerSquare(ctx,clientX,plotY,r){ctx.rect(clientX-r,plotY-r,r*2,r*2)}function wrapHeatmapDrawPoints(){const chart=this.chart,ctx=this.getContext(),inverted=this.chart.inverted,xAxis=this.xAxis,yAxis=this.yAxis;if(ctx){this.points.forEach(point=>{const plotY=point.plotY;let pointAttr;if(typeof plotY!=="undefined"&&!isNaN(plotY)&&point.y!==null&&ctx){const{x=0,y=0,width=0,height=0}=point.shapeArgs||{};if(!chart.styledMode){pointAttr=point.series.pointAttribs(point)}else{pointAttr=point.series.colorAttribs(point)}ctx.fillStyle=pointAttr.fill;if(inverted){ctx.fillRect(yAxis.len-y+xAxis.left,xAxis.len-x+yAxis.top,-height,-width)}else{ctx.fillRect(x+xAxis.left,y+yAxis.top,width,height)}}});this.canvasToSVG()}else{this.chart.showLoading("Your browser doesn't support HTML5 canvas, <br>"+"please use a modern browser")}}})(BoostCanvas||(BoostCanvas={}));const Extensions_BoostCanvas=BoostCanvas;const G=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();G.initCanvasBoost=function(){Extensions_BoostCanvas.compose(G.Chart,G.Series,G.seriesTypes)};const boost_canvas_src=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});