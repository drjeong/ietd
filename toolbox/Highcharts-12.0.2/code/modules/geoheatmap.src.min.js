(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory(root["_Highcharts"],root["_Highcharts"]["SeriesRegistry"]);else if(typeof define==="function"&&define.amd)define("highcharts/modules/geoheatmap",["highcharts/highcharts"],function(amd1){return factory(amd1,amd1["SeriesRegistry"])});else if(typeof exports==="object")exports["highcharts/modules/geoheatmap"]=factory(root["_Highcharts"],root["_Highcharts"]["SeriesRegistry"]);else root["Highcharts"]=factory(root["Highcharts"],root["Highcharts"]["SeriesRegistry"])})(typeof window==="undefined"?this:window,(__WEBPACK_EXTERNAL_MODULE__944__,__WEBPACK_EXTERNAL_MODULE__512__)=>{return(()=>{"use strict";var __webpack_modules__={512:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__512__},944:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__944__}};var __webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(cachedModule!==undefined){return cachedModule.exports}var module=__webpack_module_cache__[moduleId]={exports:{}};__webpack_modules__[moduleId](module,module.exports,__webpack_require__);return module.exports}(()=>{__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module["default"]:()=>module;__webpack_require__.d(getter,{a:getter});return getter}})();(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>geoheatmap_src});var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_=__webpack_require__(944);var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default=__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_=__webpack_require__(512);var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default=__webpack_require__.n(highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_);const{map:{prototype:{pointClass:MapPoint}}}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().seriesTypes;const{isNumber}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class GeoHeatmapPoint extends MapPoint{applyOptions(options,x){const point=super.applyOptions.call(this,options,x),{lat,lon}=point.options;if(isNumber(lon)&&isNumber(lat)){const{colsize=1,rowsize=1}=this.series.options,x1=lon-colsize/2,y1=lat-rowsize/2;point.geometry=point.options.geometry={type:"Polygon",coordinates:[[[x1,y1],[x1+colsize,y1],[x1+colsize,y1+rowsize],[x1,y1+rowsize],[x1,y1]]]}}return point}}const GeoHeatmap_GeoHeatmapPoint=GeoHeatmapPoint;const{doc}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{defined,pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function colorFromPoint(value,point){const colorAxis=point.series.colorAxis;if(colorAxis){const rgba=colorAxis.toColor(value||0,point).split(")")[0].split("(")[1].split(",").map(s=>pick(parseFloat(s),parseInt(s,10)));rgba[3]=pick(rgba[3],1)*255;if(!defined(value)||!point.visible){rgba[3]=0}return rgba}return[0,0,0,0]}function getContext(series){const{canvas,context}=series;if(canvas&&context){context.clearRect(0,0,canvas.width,canvas.height)}else{series.canvas=doc.createElement("canvas");series.context=series.canvas.getContext("2d",{willReadFrequently:true})||void 0;return series.context}return context}const InterpolationUtilities={colorFromPoint:colorFromPoint,getContext:getContext};const Series_InterpolationUtilities=InterpolationUtilities;const{animObject,stop}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{noop}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{colorFromPoint:GeoHeatmapSeries_colorFromPoint,getContext:GeoHeatmapSeries_getContext}=Series_InterpolationUtilities;const{seriesTypes:{map:MapSeries}}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default();const{addEvent,extend,isNumber:GeoHeatmapSeries_isNumber,isObject,merge,pick:GeoHeatmapSeries_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function normalizeLonValue(lon){return lon-Math.floor((lon+180)/360)*360}function scaledPointPos(lon,lat,canvasWidth,canvasHeight,colsize,rowsize){return Math.ceil(canvasWidth*(canvasHeight-1-(lat+90)/rowsize)+(lon+180)/colsize)}class GeoHeatmapSeries extends MapSeries{constructor(){super(...arguments);this.isDirtyCanvas=true}update(){const series=this;series.options=merge(series.options,arguments[0]);if(series.getInterpolation().enabled){series.isDirtyCanvas=true;series.points.forEach(point=>{if(point.graphic){point.graphic.destroy();delete point.graphic}})}super.update.apply(series,arguments)}translate(){if(this.getInterpolation().enabled&&this.image&&!this.isDirty&&!this.isDirtyData){return}super.translate.apply(this,arguments)}getInterpolation(){if(!isObject(this.options.interpolation)){return{blur:1,enabled:this.options.interpolation}}return this.options.interpolation}drawPoints(){const series=this,chart=series.chart,mapView=chart.mapView,seriesOptions=series.options;if(series.getInterpolation().enabled&&mapView&&series.bounds){const ctx=series.context||GeoHeatmapSeries_getContext(series),{canvas,colorAxis,image,chart,points}=series,[colsize,rowsize]=[GeoHeatmapSeries_pick(seriesOptions.colsize,1),GeoHeatmapSeries_pick(seriesOptions.rowsize,1)],topLeft=mapView.projectedUnitsToPixels({x:series.bounds.x1,y:series.bounds.y2}),bottomRight=mapView.projectedUnitsToPixels({x:series.bounds.x2,y:series.bounds.y1});if(canvas&&ctx&&colorAxis&&topLeft&&bottomRight){const dimensions={x:topLeft.x,y:topLeft.y,width:bottomRight.x-topLeft.x,height:bottomRight.y-topLeft.y};if(series.isDirtyCanvas||series.isDirtyData||mapView.projection.options.name==="Orthographic"){series.isDirtyCanvas=true;const canvasWidth=canvas.width=~~(360/colsize)+1,canvasHeight=canvas.height=~~(180/rowsize)+1,canvasArea=canvasWidth*canvasHeight,pixelData=new Uint8ClampedArray(canvasArea*4);series.directTouch=false;for(let i=0;i<points.length;i++){const p=points[i],sourceArr=new Uint8ClampedArray(GeoHeatmapSeries_colorFromPoint(p.value,p)),{lon,lat}=p.options;if(GeoHeatmapSeries_isNumber(lon)&&GeoHeatmapSeries_isNumber(lat)){pixelData.set(sourceArr,scaledPointPos(lon,lat,canvasWidth,canvasHeight,colsize,rowsize)*4)}}const blur=series.getInterpolation().blur,blurFactor=blur===0?1:blur*11,upscaledWidth=~~(canvasWidth*blurFactor),upscaledHeight=~~(canvasHeight*blurFactor),projectedWidth=~~dimensions.width,projectedHeight=~~dimensions.height,img=new ImageData(pixelData,canvasWidth,canvasHeight);canvas.width=upscaledWidth;canvas.height=upscaledHeight;ctx.putImageData(img,0,0);ctx.globalCompositeOperation="copy";ctx.drawImage(canvas,0,0,img.width,img.height,0,0,canvas.width,canvas.height);const cartesianImageData=ctx.getImageData(0,0,canvas.width,canvas.height),projectedPixelData=this.getProjectedImageData(mapView,projectedWidth,projectedHeight,cartesianImageData,canvas,dimensions.x,dimensions.y),projectedImg=new ImageData(projectedPixelData,projectedWidth,projectedHeight);ctx.globalCompositeOperation="copy";canvas.width=projectedWidth;canvas.height=projectedHeight;ctx.putImageData(projectedImg,0,0)}if(image){if(chart.renderer.globalAnimation&&chart.hasRendered){const startX=Number(image.attr("x")),startY=Number(image.attr("y")),startWidth=Number(image.attr("width")),startHeight=Number(image.attr("height"));const step=(now,fx)=>{image.attr({x:startX+(dimensions.x-startX)*fx.pos,y:startY+(dimensions.y-startY)*fx.pos,width:startWidth+(dimensions.width-startWidth)*fx.pos,height:startHeight+(dimensions.height-startHeight)*fx.pos})};const animOptions=merge(animObject(chart.renderer.globalAnimation)),userStep=animOptions.step;animOptions.step=function(){if(userStep){userStep.apply(this,arguments)}step.apply(this,arguments)};image.attr(merge({animator:0},series.isDirtyCanvas?{href:canvas.toDataURL("image/png",1)}:void 0)).animate({animator:1},animOptions)}else{stop(image);image.attr(merge(dimensions,series.isDirtyCanvas?{href:canvas.toDataURL("image/png",1)}:void 0))}}else{series.image=chart.renderer.image(canvas.toDataURL("image/png",1)).attr(dimensions).add(series.group)}series.isDirtyCanvas=false}}else{super.drawPoints.apply(series,arguments)}}getProjectedImageData(mapView,projectedWidth,projectedHeight,cartesianImageData,canvas,horizontalShift,verticalShift){const projectedPixelData=new Uint8ClampedArray(projectedWidth*projectedHeight*4),lambda=GeoHeatmapSeries_pick(mapView.projection.options.rotation?.[0],0),widthFactor=canvas.width/360,heightFactor=-1*canvas.height/180;let y=-1;for(let i=0;i<projectedPixelData.length;i+=4){const x=i/4%projectedWidth;if(x===0){y++}const projectedCoords=mapView.pixelsToLonLat({x:horizontalShift+x,y:verticalShift+y});if(projectedCoords){if(projectedCoords.lon>-180-lambda&&projectedCoords.lon<180-lambda){projectedCoords.lon=normalizeLonValue(projectedCoords.lon)}const projected=[projectedCoords.lon,projectedCoords.lat],cvs2PixelX=projected[0]*widthFactor+canvas.width/2,cvs2PixelY=projected[1]*heightFactor+canvas.height/2;if(cvs2PixelX>=0&&cvs2PixelX<=canvas.width&&cvs2PixelY>=0&&cvs2PixelY<=canvas.height){const redPos=Math.floor(cvs2PixelY)*canvas.width*4+Math.round(cvs2PixelX)*4;projectedPixelData[i]=cartesianImageData.data[redPos];projectedPixelData[i+1]=cartesianImageData.data[redPos+1];projectedPixelData[i+2]=cartesianImageData.data[redPos+2];projectedPixelData[i+3]=cartesianImageData.data[redPos+3]}}}return projectedPixelData}searchPoint(e,compareX){const series=this,chart=this.chart,mapView=chart.mapView;if(mapView&&series.bounds&&series.image&&chart.tooltip&&chart.tooltip.options.enabled){if(!chart.pointer.hasDragged&&(+series.image.attr("animator")<=.01||+series.image.attr("animator")>=.99)){const topLeft=mapView.projectedUnitsToPixels({x:series.bounds.x1,y:series.bounds.y2}),bottomRight=mapView.projectedUnitsToPixels({x:series.bounds.x2,y:series.bounds.y1});chart.pointer.normalize(e);if(e.lon&&e.lat&&topLeft&&bottomRight&&e.chartX-chart.plotLeft>topLeft.x&&e.chartX-chart.plotLeft<bottomRight.x&&e.chartY-chart.plotTop>topLeft.y&&e.chartY-chart.plotTop<bottomRight.y){return this.searchKDTree({clientX:e.chartX,lon:normalizeLonValue(e.lon),lat:e.lat},compareX,e)}}else{chart.tooltip.destroy()}}}}GeoHeatmapSeries.defaultOptions=merge(MapSeries.defaultOptions,{nullColor:"transparent",tooltip:{pointFormat:"Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>"},borderWidth:0,colsize:1,rowsize:1,stickyTracking:true,interpolation:{enabled:false,blur:1}});addEvent(GeoHeatmapSeries,"afterDataClassLegendClick",function(){this.isDirtyCanvas=true;this.drawPoints()});extend(GeoHeatmapSeries.prototype,{type:"geoheatmap",applyJitter:noop,pointClass:GeoHeatmap_GeoHeatmapPoint,pointArrayMap:["lon","lat","value"],kdAxisArray:["lon","lat"]});highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().registerSeriesType("geoheatmap",GeoHeatmapSeries);const GeoHeatmap_GeoHeatmapSeries=null&&GeoHeatmapSeries;"";const geoheatmap_src=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});